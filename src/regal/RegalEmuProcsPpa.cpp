/* NOTE: Do not edit this file, it is generated by a script:
   E.py --api gl 4.4 --api wgl 4.4 --api glx 4.4 --api cgl 1.4 --api egl 1.0 --outdir .
*/

/*
  Copyright (c) 2011-2013 NVIDIA Corporation
  Copyright (c) 2011-2013 Cass Everitt
  Copyright (c) 2012-2013 Scott Nations
  Copyright (c) 2012 Mathias Schott
  Copyright (c) 2012-2013 Nigel Stewart
  Copyright (c) 2012-2013 Google Inc.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
  Intended formatting conventions:
  $ astyle --style=allman --indent=spaces=2 --indent-switches
*/

#include "RegalUtil.h"

#if REGAL_EMULATION

REGAL_GLOBAL_BEGIN

#include "RegalPrivate.h"
#include "RegalContext.h"
#include "RegalDispatch.h"
#include "RegalPpa.h"
#include "RegalEmuProcsPpa.h"

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

static void REGAL_CALL emuProcInterceptPpa_glActiveTexture(RegalContext *_context, GLenum texture)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glActiveTexture( texture );

  orig.glActiveTexture( _context, texture );

}

static void REGAL_CALL emuProcInterceptPpa_glActiveTextureARB(RegalContext *_context, GLenum texture)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glActiveTexture( texture );

  orig.glActiveTextureARB( _context, texture );

}

static void REGAL_CALL emuProcInterceptPpa_glAlphaFunc(RegalContext *_context, GLenum func, GLclampf ref)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glAlphaFunc( func, ref );

  orig.glAlphaFunc( _context, func, ref );

}

static void REGAL_CALL emuProcInterceptPpa_glBlendColor(RegalContext *_context, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glBlendColor( red, green, blue, alpha );

  orig.glBlendColor( _context, red, green, blue, alpha );

}

static void REGAL_CALL emuProcInterceptPpa_glBlendEquation(RegalContext *_context, GLenum mode)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glBlendEquation( mode );

  orig.glBlendEquation( _context, mode );

}

static void REGAL_CALL emuProcInterceptPpa_glBlendEquationSeparate(RegalContext *_context, GLenum modeRGB, GLenum modeAlpha)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glBlendEquationSeparate( modeRGB, modeAlpha );

  orig.glBlendEquationSeparate( _context, modeRGB, modeAlpha );

}

static void REGAL_CALL emuProcInterceptPpa_glBlendEquationSeparatei(RegalContext *_context, GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glBlendEquationSeparatei( buf, modeRGB, modeAlpha );

  orig.glBlendEquationSeparatei( _context, buf, modeRGB, modeAlpha );

}

static void REGAL_CALL emuProcInterceptPpa_glBlendEquationi(RegalContext *_context, GLuint buf, GLenum mode)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glBlendEquationi( buf, mode );

  orig.glBlendEquationi( _context, buf, mode );

}

static void REGAL_CALL emuProcInterceptPpa_glBlendFunc(RegalContext *_context, GLenum sfactor, GLenum dfactor)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glBlendFunc( sfactor, dfactor );

  orig.glBlendFunc( _context, sfactor, dfactor );

}

static void REGAL_CALL emuProcInterceptPpa_glBlendFuncSeparate(RegalContext *_context, GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glBlendFuncSeparate( sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha );

  orig.glBlendFuncSeparate( _context, sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha );

}

static void REGAL_CALL emuProcInterceptPpa_glBlendFuncSeparatei(RegalContext *_context, GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glBlendFuncSeparatei( buf, srcRGB, dstRGB, srcAlpha, dstAlpha );

  orig.glBlendFuncSeparatei( _context, buf, srcRGB, dstRGB, srcAlpha, dstAlpha );

}

static void REGAL_CALL emuProcInterceptPpa_glBlendFunci(RegalContext *_context, GLuint buf, GLenum src, GLenum dst)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glBlendFunci( buf, src, dst );

  orig.glBlendFunci( _context, buf, src, dst );

}

static void REGAL_CALL emuProcInterceptPpa_glClampColor(RegalContext *_context, GLenum target, GLenum clamp)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glClampColor( target, clamp );

  orig.glClampColor( _context, target, clamp );

}

static void REGAL_CALL emuProcInterceptPpa_glClearAccum(RegalContext *_context, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glClearAccum( red, green, blue, alpha );

  orig.glClearAccum( _context, red, green, blue, alpha );

}

static void REGAL_CALL emuProcInterceptPpa_glClearColor(RegalContext *_context, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glClearColor( red, green, blue, alpha );

  orig.glClearColor( _context, red, green, blue, alpha );

}

static void REGAL_CALL emuProcInterceptPpa_glClearDepth(RegalContext *_context, GLclampd depth)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glClearDepth( depth );

  orig.glClearDepth( _context, depth );

}

static void REGAL_CALL emuProcInterceptPpa_glClearDepthf(RegalContext *_context, GLclampf d)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glClearDepth( d );

  orig.glClearDepthf( _context, d );

}

static void REGAL_CALL emuProcInterceptPpa_glClearIndex(RegalContext *_context, GLfloat c)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glClearIndex( c );

  orig.glClearIndex( _context, c );

}

static void REGAL_CALL emuProcInterceptPpa_glClearStencil(RegalContext *_context, GLint s)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glClearStencil( s );

  orig.glClearStencil( _context, s );

}

static void REGAL_CALL emuProcInterceptPpa_glClipPlane(RegalContext *_context, GLenum plane, const GLdouble *equation)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glClipPlane( plane, equation );

  orig.glClipPlane( _context, plane, equation );

}

static void REGAL_CALL emuProcInterceptPpa_glColorMask(RegalContext *_context, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glColorMask( red, green, blue, alpha );

  orig.glColorMask( _context, red, green, blue, alpha );

}

static void REGAL_CALL emuProcInterceptPpa_glColorMaski(RegalContext *_context, GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glColorMaski( index, r, g, b, a );

  orig.glColorMaski( _context, index, r, g, b, a );

}

static void REGAL_CALL emuProcInterceptPpa_glColorMaterial(RegalContext *_context, GLenum face, GLenum mode)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glColorMaterial( face, mode );

  orig.glColorMaterial( _context, face, mode );

}

static void REGAL_CALL emuProcInterceptPpa_glColorTableParameterfv(RegalContext *_context, GLenum target, GLenum pname, const GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glColorTableParameterv( target, pname, params );

  orig.glColorTableParameterfv( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glColorTableParameteriv(RegalContext *_context, GLenum target, GLenum pname, const GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glColorTableParameterv( target, pname, params );

  orig.glColorTableParameteriv( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glConvolutionParameterf(RegalContext *_context, GLenum target, GLenum pname, GLfloat params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glConvolutionParameter( target, pname, params );

  orig.glConvolutionParameterf( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glConvolutionParameterfv(RegalContext *_context, GLenum target, GLenum pname, const GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glConvolutionParameterv( target, pname, params );

  orig.glConvolutionParameterfv( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glConvolutionParameteri(RegalContext *_context, GLenum target, GLenum pname, GLint params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glConvolutionParameter( target, pname, params );

  orig.glConvolutionParameteri( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glConvolutionParameteriv(RegalContext *_context, GLenum target, GLenum pname, const GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glConvolutionParameterv( target, pname, params );

  orig.glConvolutionParameteriv( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glCullFace(RegalContext *_context, GLenum mode)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glCullFace( mode );

  orig.glCullFace( _context, mode );

}

static void REGAL_CALL emuProcInterceptPpa_glDepthFunc(RegalContext *_context, GLenum func)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glDepthFunc( func );

  orig.glDepthFunc( _context, func );

}

static void REGAL_CALL emuProcInterceptPpa_glDepthMask(RegalContext *_context, GLboolean flag)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glDepthMask( flag );

  orig.glDepthMask( _context, flag );

}

static void REGAL_CALL emuProcInterceptPpa_glDepthRange(RegalContext *_context, GLclampd zNear, GLclampd zFar)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glDepthRange( zNear, zFar );

  orig.glDepthRange( _context, zNear, zFar );

}

static void REGAL_CALL emuProcInterceptPpa_glDepthRangeArrayv(RegalContext *_context, GLuint first, GLsizei count, const GLclampd *v)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glDepthRangeArrayv( first, count, v );

  orig.glDepthRangeArrayv( _context, first, count, v );

}

static void REGAL_CALL emuProcInterceptPpa_glDepthRangeIndexed(RegalContext *_context, GLuint index, GLclampd n, GLclampd f)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glDepthRangeIndexed( index, n, f );

  orig.glDepthRangeIndexed( _context, index, n, f );

}

static void REGAL_CALL emuProcInterceptPpa_glDepthRangef(RegalContext *_context, GLclampf n, GLclampf f)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glDepthRange( n, f );

  orig.glDepthRangef( _context, n, f );

}

static void REGAL_CALL emuProcInterceptPpa_glDisable(RegalContext *_context, GLenum cap)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->Disable( _context, cap ) ) {
    return;
  }

  orig.glDisable( _context, cap );

}

static void REGAL_CALL emuProcInterceptPpa_glDisablei(RegalContext *_context, GLenum cap, GLuint index)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->Disablei( _context, cap, index ) ) {
    return;
  }

  orig.glDisablei( _context, cap, index );

}

static void REGAL_CALL emuProcInterceptPpa_glDrawBuffer(RegalContext *_context, GLenum mode)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
    _context->ppa->glDrawBuffer( mode );

  orig.glDrawBuffer( _context, mode );

}

static void REGAL_CALL emuProcInterceptPpa_glDrawBuffers(RegalContext *_context, GLsizei n, const GLenum *bufs)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
    _context->ppa->glDrawBuffers( n, bufs );

  orig.glDrawBuffers( _context, n, bufs );

}

static void REGAL_CALL emuProcInterceptPpa_glDrawBuffersARB(RegalContext *_context, GLsizei n, const GLenum *bufs)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
    _context->ppa->glDrawBuffers( n, bufs );

  orig.glDrawBuffersARB( _context, n, bufs );

}

static void REGAL_CALL emuProcInterceptPpa_glDrawBuffersNV(RegalContext *_context, GLsizei n, const GLenum *bufs)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
    _context->ppa->glDrawBuffers( n, bufs );

  orig.glDrawBuffersNV( _context, n, bufs );

}

static void REGAL_CALL emuProcInterceptPpa_glEnable(RegalContext *_context, GLenum cap)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->Enable( _context, cap ) ) {
    return;
  }

  orig.glEnable( _context, cap );

}

static void REGAL_CALL emuProcInterceptPpa_glEnablei(RegalContext *_context, GLenum cap, GLuint index)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->Enablei( _context, cap, index ) ) {
    return;
  }

  orig.glEnablei( _context, cap, index );

}

static void REGAL_CALL emuProcInterceptPpa_glFrontFace(RegalContext *_context, GLenum mode)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glFrontFace( mode );

  orig.glFrontFace( _context, mode );

}

static void REGAL_CALL emuProcInterceptPpa_glGetBooleani_v(RegalContext *_context, GLenum target, GLuint index, GLboolean *data)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGeti_v( _context, target, index, data ) ) {
    return;
  }

  orig.glGetBooleani_v( _context, target, index, data );

}

static void REGAL_CALL emuProcInterceptPpa_glGetBooleanv(RegalContext *_context, GLenum pname, GLboolean *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetv( _context, pname, params ) ) {
    return;
  }

  orig.glGetBooleanv( _context, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetColorTableParameterfv(RegalContext *_context, GLenum target, GLenum pname, GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetColorTableParameterv( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetColorTableParameterfv( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetColorTableParameteriv(RegalContext *_context, GLenum target, GLenum pname, GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetColorTableParameterv( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetColorTableParameteriv( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetConvolutionParameterfv(RegalContext *_context, GLenum target, GLenum pname, GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetConvolutionParameterv( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetConvolutionParameterfv( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetConvolutionParameteriv(RegalContext *_context, GLenum target, GLenum pname, GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetConvolutionParameterv( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetConvolutionParameteriv( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetDoublei_v(RegalContext *_context, GLenum target, GLuint index, GLdouble *v)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGeti_v( _context, target, index, v ) ) {
    return;
  }

  orig.glGetDoublei_v( _context, target, index, v );

}

static void REGAL_CALL emuProcInterceptPpa_glGetDoublei_vEXT(RegalContext *_context, GLenum target, GLuint index, GLdouble *data)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGeti_v( _context, target, index, data ) ) {
    return;
  }

  orig.glGetDoublei_vEXT( _context, target, index, data );

}

static void REGAL_CALL emuProcInterceptPpa_glGetDoublev(RegalContext *_context, GLenum pname, GLdouble *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetv( _context, pname, params ) ) {
    return;
  }

  orig.glGetDoublev( _context, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetFloati_v(RegalContext *_context, GLenum target, GLuint index, GLfloat *v)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGeti_v( _context, target, index, v ) ) {
    return;
  }

  orig.glGetFloati_v( _context, target, index, v );

}

static void REGAL_CALL emuProcInterceptPpa_glGetFloati_vEXT(RegalContext *_context, GLenum target, GLuint index, GLfloat *data)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGeti_v( _context, target, index, data ) ) {
    return;
  }

  orig.glGetFloati_vEXT( _context, target, index, data );

}

static void REGAL_CALL emuProcInterceptPpa_glGetFloatv(RegalContext *_context, GLenum pname, GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetv( _context, pname, params ) ) {
    return;
  }

  orig.glGetFloatv( _context, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetIntegeri_v(RegalContext *_context, GLenum target, GLuint index, GLint *data)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGeti_v( _context, target, index, data ) ) {
    return;
  }

  orig.glGetIntegeri_v( _context, target, index, data );

}

static void REGAL_CALL emuProcInterceptPpa_glGetIntegeri_vEXT(RegalContext *_context, GLenum target, GLuint index, GLint *data)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGeti_v( _context, target, index, data ) ) {
    return;
  }

  orig.glGetIntegeri_vEXT( _context, target, index, data );

}

static void REGAL_CALL emuProcInterceptPpa_glGetIntegerv(RegalContext *_context, GLenum pname, GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetv( _context, pname, params ) ) {
    return;
  }

  orig.glGetIntegerv( _context, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetLightfv(RegalContext *_context, GLenum light, GLenum pname, GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetLightv( _context, light, pname, params ) ) {
    return;
  }

  orig.glGetLightfv( _context, light, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetLightiv(RegalContext *_context, GLenum light, GLenum pname, GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetLightv( _context, light, pname, params ) ) {
    return;
  }

  orig.glGetLightiv( _context, light, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetLightxv(RegalContext *_context, GLenum light, GLenum pname, GLfixed *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetLightv( _context, light, pname, params ) ) {
    return;
  }

  orig.glGetLightxv( _context, light, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetMaterialfv(RegalContext *_context, GLenum face, GLenum pname, GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetMaterialv( _context, face, pname, params ) ) {
    return;
  }

  orig.glGetMaterialfv( _context, face, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetMaterialiv(RegalContext *_context, GLenum face, GLenum pname, GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetMaterialv( _context, face, pname, params ) ) {
    return;
  }

  orig.glGetMaterialiv( _context, face, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetMaterialxv(RegalContext *_context, GLenum face, GLenum pname, GLfixed *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetMaterialv( _context, face, pname, params ) ) {
    return;
  }

  orig.glGetMaterialxv( _context, face, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetMultiTexEnvfvEXT(RegalContext *_context, GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetMultiTexEnvv( _context, texunit, target, pname, params ) ) {
    return;
  }

  orig.glGetMultiTexEnvfvEXT( _context, texunit, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetMultiTexEnvivEXT(RegalContext *_context, GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetMultiTexEnvv( _context, texunit, target, pname, params ) ) {
    return;
  }

  orig.glGetMultiTexEnvivEXT( _context, texunit, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetPolygonStipple(RegalContext *_context, GLubyte *mask)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetPolygonStipple( _context, mask ) ) {
    return;
  }

  orig.glGetPolygonStipple( _context, mask );

}

static void REGAL_CALL emuProcInterceptPpa_glGetTexEnvfv(RegalContext *_context, GLenum target, GLenum pname, GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetTexEnvv( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetTexEnvfv( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetTexEnviv(RegalContext *_context, GLenum target, GLenum pname, GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetTexEnvv( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetTexEnviv( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetTexLevelParameterfv(RegalContext *_context, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetTexLevelParameter( _context, target, level, pname, params ) ) {
    return;
  }

  orig.glGetTexLevelParameterfv( _context, target, level, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetTexLevelParameteriv(RegalContext *_context, GLenum target, GLint level, GLenum pname, GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetTexLevelParameter( _context, target, level, pname, params ) ) {
    return;
  }

  orig.glGetTexLevelParameteriv( _context, target, level, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetTexParameterfv(RegalContext *_context, GLenum target, GLenum pname, GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetTexParameter( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetTexParameterfv( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetTexParameteriv(RegalContext *_context, GLenum target, GLenum pname, GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetTexParameter( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetTexParameteriv( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetTextureLevelParameterfvEXT(RegalContext *_context, GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetTextureLevelParameter( _context, texture, target, level, pname, params ) ) {
    return;
  }

  orig.glGetTextureLevelParameterfvEXT( _context, texture, target, level, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetTextureLevelParameterivEXT(RegalContext *_context, GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetTextureLevelParameter( _context, texture, target, level, pname, params ) ) {
    return;
  }

  orig.glGetTextureLevelParameterivEXT( _context, texture, target, level, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetTextureParameterfvEXT(RegalContext *_context, GLuint texture, GLenum target, GLenum pname, GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetTextureParameter( _context, texture, target, pname, params ) ) {
    return;
  }

  orig.glGetTextureParameterfvEXT( _context, texture, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glGetTextureParameterivEXT(RegalContext *_context, GLuint texture, GLenum target, GLenum pname, GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  if( _context->ppa->glGetTextureParameter( _context, texture, target, pname, params ) ) {
    return;
  }

  orig.glGetTextureParameterivEXT( _context, texture, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glHint(RegalContext *_context, GLenum target, GLenum mode)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glHint( target, mode );

  orig.glHint( _context, target, mode );

}

static void REGAL_CALL emuProcInterceptPpa_glIndexMask(RegalContext *_context, GLuint mask)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glIndexMask( mask );

  orig.glIndexMask( _context, mask );

}

static GLboolean REGAL_CALL emuProcInterceptPpa_glIsEnabled(RegalContext *_context, GLenum cap)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  GLboolean enabled;
  if( _context->ppa->glIsEnabled( _context, enabled, cap ) ) {
    return enabled;
  }

  return orig.glIsEnabled( _context, cap );

}

static GLboolean REGAL_CALL emuProcInterceptPpa_glIsEnabledi(RegalContext *_context, GLenum target, GLuint index)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  GLboolean enabled;
  if( _context->ppa->glIsEnabledi( _context, enabled, target, index ) ) {
    return enabled;
  }

  return orig.glIsEnabledi( _context, target, index );

}

static void REGAL_CALL emuProcInterceptPpa_glLightModelf(RegalContext *_context, GLenum pname, GLfloat param)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glLightModel( pname, param );

  orig.glLightModelf( _context, pname, param );

}

static void REGAL_CALL emuProcInterceptPpa_glLightModelfv(RegalContext *_context, GLenum pname, const GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glLightModelv( pname, params );

  orig.glLightModelfv( _context, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glLightModeli(RegalContext *_context, GLenum pname, GLint param)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glLightModel( pname, param );

  orig.glLightModeli( _context, pname, param );

}

static void REGAL_CALL emuProcInterceptPpa_glLightModeliv(RegalContext *_context, GLenum pname, const GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glLightModelv( pname, params );

  orig.glLightModeliv( _context, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glLightf(RegalContext *_context, GLenum light, GLenum pname, GLfloat param)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glLight( light, pname, param );

  orig.glLightf( _context, light, pname, param );

}

static void REGAL_CALL emuProcInterceptPpa_glLightfv(RegalContext *_context, GLenum light, GLenum pname, const GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glLightv( light, pname, params );

  orig.glLightfv( _context, light, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glLighti(RegalContext *_context, GLenum light, GLenum pname, GLint param)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glLight( light, pname, param );

  orig.glLighti( _context, light, pname, param );

}

static void REGAL_CALL emuProcInterceptPpa_glLightiv(RegalContext *_context, GLenum light, GLenum pname, const GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glLightv( light, pname, params );

  orig.glLightiv( _context, light, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glLineStipple(RegalContext *_context, GLint factor, GLushort pattern)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glLineStipple( factor, pattern );

  orig.glLineStipple( _context, factor, pattern );

}

static void REGAL_CALL emuProcInterceptPpa_glLineWidth(RegalContext *_context, GLfloat width)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glLineWidth( width );

  orig.glLineWidth( _context, width );

}

static void REGAL_CALL emuProcInterceptPpa_glListBase(RegalContext *_context, GLuint base)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glListBase( base );

  orig.glListBase( _context, base );

}

static void REGAL_CALL emuProcInterceptPpa_glLogicOp(RegalContext *_context, GLenum opcode)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glLogicOp( opcode );

  orig.glLogicOp( _context, opcode );

}

static void REGAL_CALL emuProcInterceptPpa_glMapGrid1d(RegalContext *_context, GLint un, GLdouble u1, GLdouble u2)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glMapGrid1( un, u1, u2 );

  orig.glMapGrid1d( _context, un, u1, u2 );

}

static void REGAL_CALL emuProcInterceptPpa_glMapGrid1f(RegalContext *_context, GLint un, GLfloat u1, GLfloat u2)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glMapGrid1( un, u1, u2 );

  orig.glMapGrid1f( _context, un, u1, u2 );

}

static void REGAL_CALL emuProcInterceptPpa_glMapGrid2d(RegalContext *_context, GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glMapGrid2( un, u1, u2, vn, v1, v2 );

  orig.glMapGrid2d( _context, un, u1, u2, vn, v1, v2 );

}

static void REGAL_CALL emuProcInterceptPpa_glMapGrid2f(RegalContext *_context, GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glMapGrid2( un, u1, u2, vn, v1, v2 );

  orig.glMapGrid2f( _context, un, u1, u2, vn, v1, v2 );

}

static void REGAL_CALL emuProcInterceptPpa_glMaterialf(RegalContext *_context, GLenum face, GLenum pname, GLfloat param)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glMaterial( face, pname, param );

  orig.glMaterialf( _context, face, pname, param );

}

static void REGAL_CALL emuProcInterceptPpa_glMaterialfv(RegalContext *_context, GLenum face, GLenum pname, const GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glMaterialv( face, pname, params );

  orig.glMaterialfv( _context, face, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glMateriali(RegalContext *_context, GLenum face, GLenum pname, GLint param)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glMaterial( face, pname, param );

  orig.glMateriali( _context, face, pname, param );

}

static void REGAL_CALL emuProcInterceptPpa_glMaterialiv(RegalContext *_context, GLenum face, GLenum pname, const GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glMaterialv( face, pname, params );

  orig.glMaterialiv( _context, face, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glMatrixMode(RegalContext *_context, GLenum mode)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glMatrixMode( mode );

  orig.glMatrixMode( _context, mode );

}

static void REGAL_CALL emuProcInterceptPpa_glMinSampleShading(RegalContext *_context, GLclampf value)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glMinSampleShading( value );

  orig.glMinSampleShading( _context, value );

}

static void REGAL_CALL emuProcInterceptPpa_glMultiTexEnvfEXT(RegalContext *_context, GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glMultiTexEnv( texunit, target, pname, param );

  orig.glMultiTexEnvfEXT( _context, texunit, target, pname, param );

}

static void REGAL_CALL emuProcInterceptPpa_glMultiTexEnvfvEXT(RegalContext *_context, GLenum texunit, GLenum target, GLenum pname, const GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glMultiTexEnvv( texunit, target, pname, params );

  orig.glMultiTexEnvfvEXT( _context, texunit, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glMultiTexEnviEXT(RegalContext *_context, GLenum texunit, GLenum target, GLenum pname, GLint param)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glMultiTexEnv( texunit, target, pname, param );

  orig.glMultiTexEnviEXT( _context, texunit, target, pname, param );

}

static void REGAL_CALL emuProcInterceptPpa_glMultiTexEnvivEXT(RegalContext *_context, GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glMultiTexEnvv( texunit, target, pname, params );

  orig.glMultiTexEnvivEXT( _context, texunit, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glPixelTransferf(RegalContext *_context, GLenum pname, GLfloat param)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glPixelTransfer( pname, param );

  orig.glPixelTransferf( _context, pname, param );

}

static void REGAL_CALL emuProcInterceptPpa_glPixelTransferi(RegalContext *_context, GLenum pname, GLint param)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glPixelTransfer( pname, param );

  orig.glPixelTransferi( _context, pname, param );

}

static void REGAL_CALL emuProcInterceptPpa_glPixelZoom(RegalContext *_context, GLfloat xfactor, GLfloat yfactor)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glPixelZoom( xfactor, yfactor );

  orig.glPixelZoom( _context, xfactor, yfactor );

}

static void REGAL_CALL emuProcInterceptPpa_glPointParameterf(RegalContext *_context, GLenum pname, GLfloat param)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glPointParameter( pname, param );

  orig.glPointParameterf( _context, pname, param );

}

static void REGAL_CALL emuProcInterceptPpa_glPointParameterfv(RegalContext *_context, GLenum pname, const GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glPointParameterv( pname, params );

  orig.glPointParameterfv( _context, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glPointParameteri(RegalContext *_context, GLenum pname, GLint param)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glPointParameter( pname, param );

  orig.glPointParameteri( _context, pname, param );

}

static void REGAL_CALL emuProcInterceptPpa_glPointParameteriv(RegalContext *_context, GLenum pname, const GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glPointParameterv( pname, params );

  orig.glPointParameteriv( _context, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glPointSize(RegalContext *_context, GLfloat size)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glPointSize( size );

  orig.glPointSize( _context, size );

}

static void REGAL_CALL emuProcInterceptPpa_glPolygonMode(RegalContext *_context, GLenum face, GLenum mode)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glPolygonMode( face, mode );

  orig.glPolygonMode( _context, face, mode );

}

static void REGAL_CALL emuProcInterceptPpa_glPolygonOffset(RegalContext *_context, GLfloat factor, GLfloat units)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glPolygonOffset( factor, units );

  orig.glPolygonOffset( _context, factor, units );

}

static void REGAL_CALL emuProcInterceptPpa_glPolygonStipple(RegalContext *_context, const GLubyte *mask)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glPolygonStipple( mask );

  orig.glPolygonStipple( _context, mask );

}

static void REGAL_CALL emuProcInterceptPpa_glPopAttrib(RegalContext *_context)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  _context->ppa->PopAttrib( _context ); return;

  orig.glPopAttrib( _context );

}

static void REGAL_CALL emuProcInterceptPpa_glProvokingVertex(RegalContext *_context, GLenum mode)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glProvokingVertex( mode );

  orig.glProvokingVertex( _context, mode );

}

static void REGAL_CALL emuProcInterceptPpa_glPushAttrib(RegalContext *_context, GLbitfield mask)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // impl
  _context->ppa->PushAttrib( _context, mask ); return;

  orig.glPushAttrib( _context, mask );

}

static void REGAL_CALL emuProcInterceptPpa_glReadBuffer(RegalContext *_context, GLenum mode)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glReadBuffer( mode );

  orig.glReadBuffer( _context, mode );

}

static void REGAL_CALL emuProcInterceptPpa_glSampleCoverage(RegalContext *_context, GLclampf value, GLboolean invert)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glSampleCoverage( value, invert );

  orig.glSampleCoverage( _context, value, invert );

}

static void REGAL_CALL emuProcInterceptPpa_glScissor(RegalContext *_context, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glScissor( x, y, width, height );

  orig.glScissor( _context, x, y, width, height );

}

static void REGAL_CALL emuProcInterceptPpa_glScissorArrayv(RegalContext *_context, GLuint first, GLsizei count, const GLint *v)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glScissorArrayv( first, count, v );

  orig.glScissorArrayv( _context, first, count, v );

}

static void REGAL_CALL emuProcInterceptPpa_glScissorIndexed(RegalContext *_context, GLuint index, GLint left, GLint bottom, GLint width, GLint height)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glScissorIndexed( index, left, bottom, width, height );

  orig.glScissorIndexed( _context, index, left, bottom, width, height );

}

static void REGAL_CALL emuProcInterceptPpa_glScissorIndexedv(RegalContext *_context, GLuint index, const GLint *v)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glScissorIndexedv( index, v );

  orig.glScissorIndexedv( _context, index, v );

}

static void REGAL_CALL emuProcInterceptPpa_glShadeModel(RegalContext *_context, GLenum mode)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glShadeModel( mode );

  orig.glShadeModel( _context, mode );

}

static void REGAL_CALL emuProcInterceptPpa_glStencilFunc(RegalContext *_context, GLenum func, GLint ref, GLuint mask)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glStencilFunc( func, ref, mask );

  orig.glStencilFunc( _context, func, ref, mask );

}

static void REGAL_CALL emuProcInterceptPpa_glStencilFuncSeparate(RegalContext *_context, GLenum face, GLenum func, GLint ref, GLuint mask)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glStencilFuncSeparate( face, func, ref, mask );

  orig.glStencilFuncSeparate( _context, face, func, ref, mask );

}

static void REGAL_CALL emuProcInterceptPpa_glStencilMask(RegalContext *_context, GLuint mask)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glStencilMask( mask );

  orig.glStencilMask( _context, mask );

}

static void REGAL_CALL emuProcInterceptPpa_glStencilMaskSeparate(RegalContext *_context, GLenum face, GLuint mask)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glStencilMaskSeparate( face, mask );

  orig.glStencilMaskSeparate( _context, face, mask );

}

static void REGAL_CALL emuProcInterceptPpa_glStencilOp(RegalContext *_context, GLenum fail, GLenum zfail, GLenum zpass)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glStencilOp( fail, zfail, zpass );

  orig.glStencilOp( _context, fail, zfail, zpass );

}

static void REGAL_CALL emuProcInterceptPpa_glStencilOpSeparate(RegalContext *_context, GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glStencilOpSeparate( face, fail, zfail, zpass );

  orig.glStencilOpSeparate( _context, face, fail, zfail, zpass );

}

static void REGAL_CALL emuProcInterceptPpa_glTexEnvf(RegalContext *_context, GLenum target, GLenum pname, GLfloat param)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glTexEnv( target, pname, param );

  orig.glTexEnvf( _context, target, pname, param );

}

static void REGAL_CALL emuProcInterceptPpa_glTexEnvfv(RegalContext *_context, GLenum target, GLenum pname, const GLfloat *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glTexEnvv( target, pname, params );

  orig.glTexEnvfv( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glTexEnvi(RegalContext *_context, GLenum target, GLenum pname, GLint param)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glTexEnv( target, pname, param );

  orig.glTexEnvi( _context, target, pname, param );

}

static void REGAL_CALL emuProcInterceptPpa_glTexEnviv(RegalContext *_context, GLenum target, GLenum pname, const GLint *params)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glTexEnvv( target, pname, params );

  orig.glTexEnviv( _context, target, pname, params );

}

static void REGAL_CALL emuProcInterceptPpa_glViewport(RegalContext *_context, GLint x, GLint y, GLsizei width, GLsizei height)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glViewport( x, y, width, height );

  orig.glViewport( _context, x, y, width, height );

}

static void REGAL_CALL emuProcInterceptPpa_glViewportArrayv(RegalContext *_context, GLuint first, GLsizei count, const GLfloat *v)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glViewportArrayv( first, count, v );

  orig.glViewportArrayv( _context, first, count, v );

}

static void REGAL_CALL emuProcInterceptPpa_glViewportIndexedf(RegalContext *_context, GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glViewportIndexedf( index, x, y, w, h );

  orig.glViewportIndexedf( _context, index, x, y, w, h );

}

static void REGAL_CALL emuProcInterceptPpa_glViewportIndexedfv(RegalContext *_context, GLuint index, const GLfloat *v)
{
  RegalAssert(_context);
  EmuProcsOriginatePpa & orig = _context->ppa->orig;

  // prefix
  _context->ppa->glViewportIndexedfv( index, v );

  orig.glViewportIndexedfv( _context, index, v );

}

void EmuProcsInterceptPpa( Dispatch::GL & dt ) {
  dt.glActiveTexture                 = emuProcInterceptPpa_glActiveTexture;
  dt.glActiveTextureARB              = emuProcInterceptPpa_glActiveTextureARB;
  dt.glAlphaFunc                     = emuProcInterceptPpa_glAlphaFunc;
  dt.glBlendColor                    = emuProcInterceptPpa_glBlendColor;
  dt.glBlendEquation                 = emuProcInterceptPpa_glBlendEquation;
  dt.glBlendEquationSeparate         = emuProcInterceptPpa_glBlendEquationSeparate;
  dt.glBlendEquationSeparatei        = emuProcInterceptPpa_glBlendEquationSeparatei;
  dt.glBlendEquationi                = emuProcInterceptPpa_glBlendEquationi;
  dt.glBlendFunc                     = emuProcInterceptPpa_glBlendFunc;
  dt.glBlendFuncSeparate             = emuProcInterceptPpa_glBlendFuncSeparate;
  dt.glBlendFuncSeparatei            = emuProcInterceptPpa_glBlendFuncSeparatei;
  dt.glBlendFunci                    = emuProcInterceptPpa_glBlendFunci;
  dt.glClampColor                    = emuProcInterceptPpa_glClampColor;
  dt.glClearAccum                    = emuProcInterceptPpa_glClearAccum;
  dt.glClearColor                    = emuProcInterceptPpa_glClearColor;
  dt.glClearDepth                    = emuProcInterceptPpa_glClearDepth;
  dt.glClearDepthf                   = emuProcInterceptPpa_glClearDepthf;
  dt.glClearIndex                    = emuProcInterceptPpa_glClearIndex;
  dt.glClearStencil                  = emuProcInterceptPpa_glClearStencil;
  dt.glClipPlane                     = emuProcInterceptPpa_glClipPlane;
  dt.glColorMask                     = emuProcInterceptPpa_glColorMask;
  dt.glColorMaski                    = emuProcInterceptPpa_glColorMaski;
  dt.glColorMaterial                 = emuProcInterceptPpa_glColorMaterial;
  dt.glColorTableParameterfv         = emuProcInterceptPpa_glColorTableParameterfv;
  dt.glColorTableParameteriv         = emuProcInterceptPpa_glColorTableParameteriv;
  dt.glConvolutionParameterf         = emuProcInterceptPpa_glConvolutionParameterf;
  dt.glConvolutionParameterfv        = emuProcInterceptPpa_glConvolutionParameterfv;
  dt.glConvolutionParameteri         = emuProcInterceptPpa_glConvolutionParameteri;
  dt.glConvolutionParameteriv        = emuProcInterceptPpa_glConvolutionParameteriv;
  dt.glCullFace                      = emuProcInterceptPpa_glCullFace;
  dt.glDepthFunc                     = emuProcInterceptPpa_glDepthFunc;
  dt.glDepthMask                     = emuProcInterceptPpa_glDepthMask;
  dt.glDepthRange                    = emuProcInterceptPpa_glDepthRange;
  dt.glDepthRangeArrayv              = emuProcInterceptPpa_glDepthRangeArrayv;
  dt.glDepthRangeIndexed             = emuProcInterceptPpa_glDepthRangeIndexed;
  dt.glDepthRangef                   = emuProcInterceptPpa_glDepthRangef;
  dt.glDisable                       = emuProcInterceptPpa_glDisable;
  dt.glDisablei                      = emuProcInterceptPpa_glDisablei;
  dt.glDrawBuffer                    = emuProcInterceptPpa_glDrawBuffer;
  dt.glDrawBuffers                   = emuProcInterceptPpa_glDrawBuffers;
  dt.glDrawBuffersARB                = emuProcInterceptPpa_glDrawBuffersARB;
  dt.glDrawBuffersNV                 = emuProcInterceptPpa_glDrawBuffersNV;
  dt.glEnable                        = emuProcInterceptPpa_glEnable;
  dt.glEnablei                       = emuProcInterceptPpa_glEnablei;
  dt.glFrontFace                     = emuProcInterceptPpa_glFrontFace;
  dt.glGetBooleani_v                 = emuProcInterceptPpa_glGetBooleani_v;
  dt.glGetBooleanv                   = emuProcInterceptPpa_glGetBooleanv;
  dt.glGetColorTableParameterfv      = emuProcInterceptPpa_glGetColorTableParameterfv;
  dt.glGetColorTableParameteriv      = emuProcInterceptPpa_glGetColorTableParameteriv;
  dt.glGetConvolutionParameterfv     = emuProcInterceptPpa_glGetConvolutionParameterfv;
  dt.glGetConvolutionParameteriv     = emuProcInterceptPpa_glGetConvolutionParameteriv;
  dt.glGetDoublei_v                  = emuProcInterceptPpa_glGetDoublei_v;
  dt.glGetDoublei_vEXT               = emuProcInterceptPpa_glGetDoublei_vEXT;
  dt.glGetDoublev                    = emuProcInterceptPpa_glGetDoublev;
  dt.glGetFloati_v                   = emuProcInterceptPpa_glGetFloati_v;
  dt.glGetFloati_vEXT                = emuProcInterceptPpa_glGetFloati_vEXT;
  dt.glGetFloatv                     = emuProcInterceptPpa_glGetFloatv;
  dt.glGetIntegeri_v                 = emuProcInterceptPpa_glGetIntegeri_v;
  dt.glGetIntegeri_vEXT              = emuProcInterceptPpa_glGetIntegeri_vEXT;
  dt.glGetIntegerv                   = emuProcInterceptPpa_glGetIntegerv;
  dt.glGetLightfv                    = emuProcInterceptPpa_glGetLightfv;
  dt.glGetLightiv                    = emuProcInterceptPpa_glGetLightiv;
  dt.glGetLightxv                    = emuProcInterceptPpa_glGetLightxv;
  dt.glGetMaterialfv                 = emuProcInterceptPpa_glGetMaterialfv;
  dt.glGetMaterialiv                 = emuProcInterceptPpa_glGetMaterialiv;
  dt.glGetMaterialxv                 = emuProcInterceptPpa_glGetMaterialxv;
  dt.glGetMultiTexEnvfvEXT           = emuProcInterceptPpa_glGetMultiTexEnvfvEXT;
  dt.glGetMultiTexEnvivEXT           = emuProcInterceptPpa_glGetMultiTexEnvivEXT;
  dt.glGetPolygonStipple             = emuProcInterceptPpa_glGetPolygonStipple;
  dt.glGetTexEnvfv                   = emuProcInterceptPpa_glGetTexEnvfv;
  dt.glGetTexEnviv                   = emuProcInterceptPpa_glGetTexEnviv;
  dt.glGetTexLevelParameterfv        = emuProcInterceptPpa_glGetTexLevelParameterfv;
  dt.glGetTexLevelParameteriv        = emuProcInterceptPpa_glGetTexLevelParameteriv;
  dt.glGetTexParameterfv             = emuProcInterceptPpa_glGetTexParameterfv;
  dt.glGetTexParameteriv             = emuProcInterceptPpa_glGetTexParameteriv;
  dt.glGetTextureLevelParameterfvEXT = emuProcInterceptPpa_glGetTextureLevelParameterfvEXT;
  dt.glGetTextureLevelParameterivEXT = emuProcInterceptPpa_glGetTextureLevelParameterivEXT;
  dt.glGetTextureParameterfvEXT      = emuProcInterceptPpa_glGetTextureParameterfvEXT;
  dt.glGetTextureParameterivEXT      = emuProcInterceptPpa_glGetTextureParameterivEXT;
  dt.glHint                          = emuProcInterceptPpa_glHint;
  dt.glIndexMask                     = emuProcInterceptPpa_glIndexMask;
  dt.glIsEnabled                     = emuProcInterceptPpa_glIsEnabled;
  dt.glIsEnabledi                    = emuProcInterceptPpa_glIsEnabledi;
  dt.glLightModelf                   = emuProcInterceptPpa_glLightModelf;
  dt.glLightModelfv                  = emuProcInterceptPpa_glLightModelfv;
  dt.glLightModeli                   = emuProcInterceptPpa_glLightModeli;
  dt.glLightModeliv                  = emuProcInterceptPpa_glLightModeliv;
  dt.glLightf                        = emuProcInterceptPpa_glLightf;
  dt.glLightfv                       = emuProcInterceptPpa_glLightfv;
  dt.glLighti                        = emuProcInterceptPpa_glLighti;
  dt.glLightiv                       = emuProcInterceptPpa_glLightiv;
  dt.glLineStipple                   = emuProcInterceptPpa_glLineStipple;
  dt.glLineWidth                     = emuProcInterceptPpa_glLineWidth;
  dt.glListBase                      = emuProcInterceptPpa_glListBase;
  dt.glLogicOp                       = emuProcInterceptPpa_glLogicOp;
  dt.glMapGrid1d                     = emuProcInterceptPpa_glMapGrid1d;
  dt.glMapGrid1f                     = emuProcInterceptPpa_glMapGrid1f;
  dt.glMapGrid2d                     = emuProcInterceptPpa_glMapGrid2d;
  dt.glMapGrid2f                     = emuProcInterceptPpa_glMapGrid2f;
  dt.glMaterialf                     = emuProcInterceptPpa_glMaterialf;
  dt.glMaterialfv                    = emuProcInterceptPpa_glMaterialfv;
  dt.glMateriali                     = emuProcInterceptPpa_glMateriali;
  dt.glMaterialiv                    = emuProcInterceptPpa_glMaterialiv;
  dt.glMatrixMode                    = emuProcInterceptPpa_glMatrixMode;
  dt.glMinSampleShading              = emuProcInterceptPpa_glMinSampleShading;
  dt.glMultiTexEnvfEXT               = emuProcInterceptPpa_glMultiTexEnvfEXT;
  dt.glMultiTexEnvfvEXT              = emuProcInterceptPpa_glMultiTexEnvfvEXT;
  dt.glMultiTexEnviEXT               = emuProcInterceptPpa_glMultiTexEnviEXT;
  dt.glMultiTexEnvivEXT              = emuProcInterceptPpa_glMultiTexEnvivEXT;
  dt.glPixelTransferf                = emuProcInterceptPpa_glPixelTransferf;
  dt.glPixelTransferi                = emuProcInterceptPpa_glPixelTransferi;
  dt.glPixelZoom                     = emuProcInterceptPpa_glPixelZoom;
  dt.glPointParameterf               = emuProcInterceptPpa_glPointParameterf;
  dt.glPointParameterfv              = emuProcInterceptPpa_glPointParameterfv;
  dt.glPointParameteri               = emuProcInterceptPpa_glPointParameteri;
  dt.glPointParameteriv              = emuProcInterceptPpa_glPointParameteriv;
  dt.glPointSize                     = emuProcInterceptPpa_glPointSize;
  dt.glPolygonMode                   = emuProcInterceptPpa_glPolygonMode;
  dt.glPolygonOffset                 = emuProcInterceptPpa_glPolygonOffset;
  dt.glPolygonStipple                = emuProcInterceptPpa_glPolygonStipple;
  dt.glPopAttrib                     = emuProcInterceptPpa_glPopAttrib;
  dt.glProvokingVertex               = emuProcInterceptPpa_glProvokingVertex;
  dt.glPushAttrib                    = emuProcInterceptPpa_glPushAttrib;
  dt.glReadBuffer                    = emuProcInterceptPpa_glReadBuffer;
  dt.glSampleCoverage                = emuProcInterceptPpa_glSampleCoverage;
  dt.glScissor                       = emuProcInterceptPpa_glScissor;
  dt.glScissorArrayv                 = emuProcInterceptPpa_glScissorArrayv;
  dt.glScissorIndexed                = emuProcInterceptPpa_glScissorIndexed;
  dt.glScissorIndexedv               = emuProcInterceptPpa_glScissorIndexedv;
  dt.glShadeModel                    = emuProcInterceptPpa_glShadeModel;
  dt.glStencilFunc                   = emuProcInterceptPpa_glStencilFunc;
  dt.glStencilFuncSeparate           = emuProcInterceptPpa_glStencilFuncSeparate;
  dt.glStencilMask                   = emuProcInterceptPpa_glStencilMask;
  dt.glStencilMaskSeparate           = emuProcInterceptPpa_glStencilMaskSeparate;
  dt.glStencilOp                     = emuProcInterceptPpa_glStencilOp;
  dt.glStencilOpSeparate             = emuProcInterceptPpa_glStencilOpSeparate;
  dt.glTexEnvf                       = emuProcInterceptPpa_glTexEnvf;
  dt.glTexEnvfv                      = emuProcInterceptPpa_glTexEnvfv;
  dt.glTexEnvi                       = emuProcInterceptPpa_glTexEnvi;
  dt.glTexEnviv                      = emuProcInterceptPpa_glTexEnviv;
  dt.glViewport                      = emuProcInterceptPpa_glViewport;
  dt.glViewportArrayv                = emuProcInterceptPpa_glViewportArrayv;
  dt.glViewportIndexedf              = emuProcInterceptPpa_glViewportIndexedf;
  dt.glViewportIndexedfv             = emuProcInterceptPpa_glViewportIndexedfv;
}

REGAL_NAMESPACE_END

#endif // REGAL_EMULATION
