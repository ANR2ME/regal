/* NOTE: Do not edit this file, it is generated by a script:
   Export.py --api gl 4.4 --api wgl 4.4 --api glx 4.4 --api cgl 1.4 --api egl 1.0 --outdir .
*/

/*
  Copyright (c) 2011-2013 NVIDIA Corporation
  Copyright (c) 2011-2013 Cass Everitt
  Copyright (c) 2012-2013 Scott Nations
  Copyright (c) 2012 Mathias Schott
  Copyright (c) 2012-2013 Nigel Stewart
  Copyright (c) 2012-2013 Google Inc.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
  Intended formatting conventions:
  $ astyle --style=allman --indent=spaces=2 --indent-switches
*/

#include "RegalUtil.h"

#if REGAL_EMULATION

REGAL_GLOBAL_BEGIN

#include "RegalPrivate.h"
#include "RegalContext.h"
#include "RegalDispatch.h"
#include "RegalPpa.h"
#include "RegalEmuProcsPpa.h"

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

static void REGAL_CALL Ppa_glActiveTexture(Layer *_layer, GLenum texture)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glActiveTexture( texture );

  orig.glActiveTexture( orig.glActiveTexture_layer, texture );

}

static void REGAL_CALL Ppa_glActiveTextureARB(Layer *_layer, GLenum texture)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glActiveTexture( texture );

  orig.glActiveTextureARB( orig.glActiveTextureARB_layer, texture );

}

static void REGAL_CALL Ppa_glAlphaFunc(Layer *_layer, GLenum func, GLclampf ref)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glAlphaFunc( func, ref );

  orig.glAlphaFunc( orig.glAlphaFunc_layer, func, ref );

}

static void REGAL_CALL Ppa_glBlendColor(Layer *_layer, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glBlendColor( red, green, blue, alpha );

  orig.glBlendColor( orig.glBlendColor_layer, red, green, blue, alpha );

}

static void REGAL_CALL Ppa_glBlendEquation(Layer *_layer, GLenum mode)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glBlendEquation( mode );

  orig.glBlendEquation( orig.glBlendEquation_layer, mode );

}

static void REGAL_CALL Ppa_glBlendEquationSeparate(Layer *_layer, GLenum modeRGB, GLenum modeAlpha)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glBlendEquationSeparate( modeRGB, modeAlpha );

  orig.glBlendEquationSeparate( orig.glBlendEquationSeparate_layer, modeRGB, modeAlpha );

}

static void REGAL_CALL Ppa_glBlendEquationSeparatei(Layer *_layer, GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glBlendEquationSeparatei( buf, modeRGB, modeAlpha );

  orig.glBlendEquationSeparatei( orig.glBlendEquationSeparatei_layer, buf, modeRGB, modeAlpha );

}

static void REGAL_CALL Ppa_glBlendEquationi(Layer *_layer, GLuint buf, GLenum mode)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glBlendEquationi( buf, mode );

  orig.glBlendEquationi( orig.glBlendEquationi_layer, buf, mode );

}

static void REGAL_CALL Ppa_glBlendFunc(Layer *_layer, GLenum sfactor, GLenum dfactor)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glBlendFunc( sfactor, dfactor );

  orig.glBlendFunc( orig.glBlendFunc_layer, sfactor, dfactor );

}

static void REGAL_CALL Ppa_glBlendFuncSeparate(Layer *_layer, GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glBlendFuncSeparate( sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha );

  orig.glBlendFuncSeparate( orig.glBlendFuncSeparate_layer, sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha );

}

static void REGAL_CALL Ppa_glBlendFuncSeparatei(Layer *_layer, GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glBlendFuncSeparatei( buf, srcRGB, dstRGB, srcAlpha, dstAlpha );

  orig.glBlendFuncSeparatei( orig.glBlendFuncSeparatei_layer, buf, srcRGB, dstRGB, srcAlpha, dstAlpha );

}

static void REGAL_CALL Ppa_glBlendFunci(Layer *_layer, GLuint buf, GLenum src, GLenum dst)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glBlendFunci( buf, src, dst );

  orig.glBlendFunci( orig.glBlendFunci_layer, buf, src, dst );

}

static void REGAL_CALL Ppa_glClampColor(Layer *_layer, GLenum target, GLenum clamp)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glClampColor( target, clamp );

  orig.glClampColor( orig.glClampColor_layer, target, clamp );

}

static void REGAL_CALL Ppa_glClearAccum(Layer *_layer, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glClearAccum( red, green, blue, alpha );

  orig.glClearAccum( orig.glClearAccum_layer, red, green, blue, alpha );

}

static void REGAL_CALL Ppa_glClearColor(Layer *_layer, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glClearColor( red, green, blue, alpha );

  orig.glClearColor( orig.glClearColor_layer, red, green, blue, alpha );

}

static void REGAL_CALL Ppa_glClearDepth(Layer *_layer, GLclampd depth)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glClearDepth( depth );

  orig.glClearDepth( orig.glClearDepth_layer, depth );

}

static void REGAL_CALL Ppa_glClearDepthf(Layer *_layer, GLclampf d)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glClearDepth( d );

  orig.glClearDepthf( orig.glClearDepthf_layer, d );

}

static void REGAL_CALL Ppa_glClearIndex(Layer *_layer, GLfloat c)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glClearIndex( c );

  orig.glClearIndex( orig.glClearIndex_layer, c );

}

static void REGAL_CALL Ppa_glClearStencil(Layer *_layer, GLint s)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glClearStencil( s );

  orig.glClearStencil( orig.glClearStencil_layer, s );

}

static void REGAL_CALL Ppa_glClipPlane(Layer *_layer, GLenum plane, const GLdouble *equation)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glClipPlane( plane, equation );

  orig.glClipPlane( orig.glClipPlane_layer, plane, equation );

}

static void REGAL_CALL Ppa_glColorMask(Layer *_layer, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glColorMask( red, green, blue, alpha );

  orig.glColorMask( orig.glColorMask_layer, red, green, blue, alpha );

}

static void REGAL_CALL Ppa_glColorMaski(Layer *_layer, GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glColorMaski( index, r, g, b, a );

  orig.glColorMaski( orig.glColorMaski_layer, index, r, g, b, a );

}

static void REGAL_CALL Ppa_glColorMaterial(Layer *_layer, GLenum face, GLenum mode)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glColorMaterial( face, mode );

  orig.glColorMaterial( orig.glColorMaterial_layer, face, mode );

}

static void REGAL_CALL Ppa_glColorTableParameterfv(Layer *_layer, GLenum target, GLenum pname, const GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glColorTableParameterv( target, pname, params );

  orig.glColorTableParameterfv( orig.glColorTableParameterfv_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glColorTableParameteriv(Layer *_layer, GLenum target, GLenum pname, const GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glColorTableParameterv( target, pname, params );

  orig.glColorTableParameteriv( orig.glColorTableParameteriv_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glConvolutionParameterf(Layer *_layer, GLenum target, GLenum pname, GLfloat params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glConvolutionParameter( target, pname, params );

  orig.glConvolutionParameterf( orig.glConvolutionParameterf_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glConvolutionParameterfv(Layer *_layer, GLenum target, GLenum pname, const GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glConvolutionParameterv( target, pname, params );

  orig.glConvolutionParameterfv( orig.glConvolutionParameterfv_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glConvolutionParameteri(Layer *_layer, GLenum target, GLenum pname, GLint params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glConvolutionParameter( target, pname, params );

  orig.glConvolutionParameteri( orig.glConvolutionParameteri_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glConvolutionParameteriv(Layer *_layer, GLenum target, GLenum pname, const GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glConvolutionParameterv( target, pname, params );

  orig.glConvolutionParameteriv( orig.glConvolutionParameteriv_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glCullFace(Layer *_layer, GLenum mode)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glCullFace( mode );

  orig.glCullFace( orig.glCullFace_layer, mode );

}

static void REGAL_CALL Ppa_glDepthFunc(Layer *_layer, GLenum func)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glDepthFunc( func );

  orig.glDepthFunc( orig.glDepthFunc_layer, func );

}

static void REGAL_CALL Ppa_glDepthMask(Layer *_layer, GLboolean flag)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glDepthMask( flag );

  orig.glDepthMask( orig.glDepthMask_layer, flag );

}

static void REGAL_CALL Ppa_glDepthRange(Layer *_layer, GLclampd zNear, GLclampd zFar)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glDepthRange( zNear, zFar );

  orig.glDepthRange( orig.glDepthRange_layer, zNear, zFar );

}

static void REGAL_CALL Ppa_glDepthRangeArrayv(Layer *_layer, GLuint first, GLsizei count, const GLclampd *v)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glDepthRangeArrayv( first, count, v );

  orig.glDepthRangeArrayv( orig.glDepthRangeArrayv_layer, first, count, v );

}

static void REGAL_CALL Ppa_glDepthRangeIndexed(Layer *_layer, GLuint index, GLclampd n, GLclampd f)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glDepthRangeIndexed( index, n, f );

  orig.glDepthRangeIndexed( orig.glDepthRangeIndexed_layer, index, n, f );

}

static void REGAL_CALL Ppa_glDepthRangef(Layer *_layer, GLclampf n, GLclampf f)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glDepthRange( n, f );

  orig.glDepthRangef( orig.glDepthRangef_layer, n, f );

}

static void REGAL_CALL Ppa_glDisable(Layer *_layer, GLenum cap)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->Disable( _context, cap ) ) {
    return;
  }

  orig.glDisable( orig.glDisable_layer, cap );

}

static void REGAL_CALL Ppa_glDisablei(Layer *_layer, GLenum cap, GLuint index)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->Disablei( _context, cap, index ) ) {
    return;
  }

  orig.glDisablei( orig.glDisablei_layer, cap, index );

}

static void REGAL_CALL Ppa_glDrawBuffer(Layer *_layer, GLenum mode)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
    _context->ppa->glDrawBuffer( mode );

  orig.glDrawBuffer( orig.glDrawBuffer_layer, mode );

}

static void REGAL_CALL Ppa_glDrawBuffers(Layer *_layer, GLsizei n, const GLenum *bufs)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
    _context->ppa->glDrawBuffers( n, bufs );

  orig.glDrawBuffers( orig.glDrawBuffers_layer, n, bufs );

}

static void REGAL_CALL Ppa_glDrawBuffersARB(Layer *_layer, GLsizei n, const GLenum *bufs)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
    _context->ppa->glDrawBuffers( n, bufs );

  orig.glDrawBuffersARB( orig.glDrawBuffersARB_layer, n, bufs );

}

static void REGAL_CALL Ppa_glDrawBuffersNV(Layer *_layer, GLsizei n, const GLenum *bufs)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
    _context->ppa->glDrawBuffers( n, bufs );

  orig.glDrawBuffersNV( orig.glDrawBuffersNV_layer, n, bufs );

}

static void REGAL_CALL Ppa_glEnable(Layer *_layer, GLenum cap)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->Enable( _context, cap ) ) {
    return;
  }

  orig.glEnable( orig.glEnable_layer, cap );

}

static void REGAL_CALL Ppa_glEnablei(Layer *_layer, GLenum cap, GLuint index)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->Enablei( _context, cap, index ) ) {
    return;
  }

  orig.glEnablei( orig.glEnablei_layer, cap, index );

}

static void REGAL_CALL Ppa_glFrontFace(Layer *_layer, GLenum mode)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glFrontFace( mode );

  orig.glFrontFace( orig.glFrontFace_layer, mode );

}

static void REGAL_CALL Ppa_glGetBooleani_v(Layer *_layer, GLenum target, GLuint index, GLboolean *data)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGeti_v( _context, target, index, data ) ) {
    return;
  }

  orig.glGetBooleani_v( orig.glGetBooleani_v_layer, target, index, data );

}

static void REGAL_CALL Ppa_glGetBooleanv(Layer *_layer, GLenum pname, GLboolean *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetv( _context, pname, params ) ) {
    return;
  }

  orig.glGetBooleanv( orig.glGetBooleanv_layer, pname, params );

}

static void REGAL_CALL Ppa_glGetColorTableParameterfv(Layer *_layer, GLenum target, GLenum pname, GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetColorTableParameterv( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetColorTableParameterfv( orig.glGetColorTableParameterfv_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glGetColorTableParameteriv(Layer *_layer, GLenum target, GLenum pname, GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetColorTableParameterv( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetColorTableParameteriv( orig.glGetColorTableParameteriv_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glGetConvolutionParameterfv(Layer *_layer, GLenum target, GLenum pname, GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetConvolutionParameterv( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetConvolutionParameterfv( orig.glGetConvolutionParameterfv_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glGetConvolutionParameteriv(Layer *_layer, GLenum target, GLenum pname, GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetConvolutionParameterv( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetConvolutionParameteriv( orig.glGetConvolutionParameteriv_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glGetDoublei_v(Layer *_layer, GLenum target, GLuint index, GLdouble *v)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGeti_v( _context, target, index, v ) ) {
    return;
  }

  orig.glGetDoublei_v( orig.glGetDoublei_v_layer, target, index, v );

}

static void REGAL_CALL Ppa_glGetDoublei_vEXT(Layer *_layer, GLenum target, GLuint index, GLdouble *data)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGeti_v( _context, target, index, data ) ) {
    return;
  }

  orig.glGetDoublei_vEXT( orig.glGetDoublei_vEXT_layer, target, index, data );

}

static void REGAL_CALL Ppa_glGetDoublev(Layer *_layer, GLenum pname, GLdouble *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetv( _context, pname, params ) ) {
    return;
  }

  orig.glGetDoublev( orig.glGetDoublev_layer, pname, params );

}

static void REGAL_CALL Ppa_glGetFloati_v(Layer *_layer, GLenum target, GLuint index, GLfloat *v)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGeti_v( _context, target, index, v ) ) {
    return;
  }

  orig.glGetFloati_v( orig.glGetFloati_v_layer, target, index, v );

}

static void REGAL_CALL Ppa_glGetFloati_vEXT(Layer *_layer, GLenum target, GLuint index, GLfloat *data)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGeti_v( _context, target, index, data ) ) {
    return;
  }

  orig.glGetFloati_vEXT( orig.glGetFloati_vEXT_layer, target, index, data );

}

static void REGAL_CALL Ppa_glGetFloatv(Layer *_layer, GLenum pname, GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetv( _context, pname, params ) ) {
    return;
  }

  orig.glGetFloatv( orig.glGetFloatv_layer, pname, params );

}

static void REGAL_CALL Ppa_glGetIntegeri_v(Layer *_layer, GLenum target, GLuint index, GLint *data)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGeti_v( _context, target, index, data ) ) {
    return;
  }

  orig.glGetIntegeri_v( orig.glGetIntegeri_v_layer, target, index, data );

}

static void REGAL_CALL Ppa_glGetIntegeri_vEXT(Layer *_layer, GLenum target, GLuint index, GLint *data)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGeti_v( _context, target, index, data ) ) {
    return;
  }

  orig.glGetIntegeri_vEXT( orig.glGetIntegeri_vEXT_layer, target, index, data );

}

static void REGAL_CALL Ppa_glGetIntegerv(Layer *_layer, GLenum pname, GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetv( _context, pname, params ) ) {
    return;
  }

  orig.glGetIntegerv( orig.glGetIntegerv_layer, pname, params );

}

static void REGAL_CALL Ppa_glGetLightfv(Layer *_layer, GLenum light, GLenum pname, GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetLightv( _context, light, pname, params ) ) {
    return;
  }

  orig.glGetLightfv( orig.glGetLightfv_layer, light, pname, params );

}

static void REGAL_CALL Ppa_glGetLightiv(Layer *_layer, GLenum light, GLenum pname, GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetLightv( _context, light, pname, params ) ) {
    return;
  }

  orig.glGetLightiv( orig.glGetLightiv_layer, light, pname, params );

}

static void REGAL_CALL Ppa_glGetLightxv(Layer *_layer, GLenum light, GLenum pname, GLfixed *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetLightv( _context, light, pname, params ) ) {
    return;
  }

  orig.glGetLightxv( orig.glGetLightxv_layer, light, pname, params );

}

static void REGAL_CALL Ppa_glGetMaterialfv(Layer *_layer, GLenum face, GLenum pname, GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetMaterialv( _context, face, pname, params ) ) {
    return;
  }

  orig.glGetMaterialfv( orig.glGetMaterialfv_layer, face, pname, params );

}

static void REGAL_CALL Ppa_glGetMaterialiv(Layer *_layer, GLenum face, GLenum pname, GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetMaterialv( _context, face, pname, params ) ) {
    return;
  }

  orig.glGetMaterialiv( orig.glGetMaterialiv_layer, face, pname, params );

}

static void REGAL_CALL Ppa_glGetMaterialxv(Layer *_layer, GLenum face, GLenum pname, GLfixed *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetMaterialv( _context, face, pname, params ) ) {
    return;
  }

  orig.glGetMaterialxv( orig.glGetMaterialxv_layer, face, pname, params );

}

static void REGAL_CALL Ppa_glGetMultiTexEnvfvEXT(Layer *_layer, GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetMultiTexEnvv( _context, texunit, target, pname, params ) ) {
    return;
  }

  orig.glGetMultiTexEnvfvEXT( orig.glGetMultiTexEnvfvEXT_layer, texunit, target, pname, params );

}

static void REGAL_CALL Ppa_glGetMultiTexEnvivEXT(Layer *_layer, GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetMultiTexEnvv( _context, texunit, target, pname, params ) ) {
    return;
  }

  orig.glGetMultiTexEnvivEXT( orig.glGetMultiTexEnvivEXT_layer, texunit, target, pname, params );

}

static void REGAL_CALL Ppa_glGetPolygonStipple(Layer *_layer, GLubyte *mask)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetPolygonStipple( _context, mask ) ) {
    return;
  }

  orig.glGetPolygonStipple( orig.glGetPolygonStipple_layer, mask );

}

static void REGAL_CALL Ppa_glGetTexEnvfv(Layer *_layer, GLenum target, GLenum pname, GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetTexEnvv( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetTexEnvfv( orig.glGetTexEnvfv_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glGetTexEnviv(Layer *_layer, GLenum target, GLenum pname, GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetTexEnvv( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetTexEnviv( orig.glGetTexEnviv_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glGetTexLevelParameterfv(Layer *_layer, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetTexLevelParameter( _context, target, level, pname, params ) ) {
    return;
  }

  orig.glGetTexLevelParameterfv( orig.glGetTexLevelParameterfv_layer, target, level, pname, params );

}

static void REGAL_CALL Ppa_glGetTexLevelParameteriv(Layer *_layer, GLenum target, GLint level, GLenum pname, GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetTexLevelParameter( _context, target, level, pname, params ) ) {
    return;
  }

  orig.glGetTexLevelParameteriv( orig.glGetTexLevelParameteriv_layer, target, level, pname, params );

}

static void REGAL_CALL Ppa_glGetTexParameterfv(Layer *_layer, GLenum target, GLenum pname, GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetTexParameter( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetTexParameterfv( orig.glGetTexParameterfv_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glGetTexParameteriv(Layer *_layer, GLenum target, GLenum pname, GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetTexParameter( _context, target, pname, params ) ) {
    return;
  }

  orig.glGetTexParameteriv( orig.glGetTexParameteriv_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glGetTextureLevelParameterfvEXT(Layer *_layer, GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetTextureLevelParameter( _context, texture, target, level, pname, params ) ) {
    return;
  }

  orig.glGetTextureLevelParameterfvEXT( orig.glGetTextureLevelParameterfvEXT_layer, texture, target, level, pname, params );

}

static void REGAL_CALL Ppa_glGetTextureLevelParameterivEXT(Layer *_layer, GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetTextureLevelParameter( _context, texture, target, level, pname, params ) ) {
    return;
  }

  orig.glGetTextureLevelParameterivEXT( orig.glGetTextureLevelParameterivEXT_layer, texture, target, level, pname, params );

}

static void REGAL_CALL Ppa_glGetTextureParameterfvEXT(Layer *_layer, GLuint texture, GLenum target, GLenum pname, GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetTextureParameter( _context, texture, target, pname, params ) ) {
    return;
  }

  orig.glGetTextureParameterfvEXT( orig.glGetTextureParameterfvEXT_layer, texture, target, pname, params );

}

static void REGAL_CALL Ppa_glGetTextureParameterivEXT(Layer *_layer, GLuint texture, GLenum target, GLenum pname, GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  if( _context->ppa->glGetTextureParameter( _context, texture, target, pname, params ) ) {
    return;
  }

  orig.glGetTextureParameterivEXT( orig.glGetTextureParameterivEXT_layer, texture, target, pname, params );

}

static void REGAL_CALL Ppa_glHint(Layer *_layer, GLenum target, GLenum mode)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glHint( target, mode );

  orig.glHint( orig.glHint_layer, target, mode );

}

static void REGAL_CALL Ppa_glIndexMask(Layer *_layer, GLuint mask)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glIndexMask( mask );

  orig.glIndexMask( orig.glIndexMask_layer, mask );

}

static GLboolean REGAL_CALL Ppa_glIsEnabled(Layer *_layer, GLenum cap)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  GLboolean enabled;
  if( _context->ppa->glIsEnabled( _context, enabled, cap ) ) {
    return enabled;
  }

  return orig.glIsEnabled( orig.glIsEnabled_layer, cap );

}

static GLboolean REGAL_CALL Ppa_glIsEnabledi(Layer *_layer, GLenum target, GLuint index)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  GLboolean enabled;
  if( _context->ppa->glIsEnabledi( _context, enabled, target, index ) ) {
    return enabled;
  }

  return orig.glIsEnabledi( orig.glIsEnabledi_layer, target, index );

}

static void REGAL_CALL Ppa_glLightModelf(Layer *_layer, GLenum pname, GLfloat param)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glLightModel( pname, param );

  orig.glLightModelf( orig.glLightModelf_layer, pname, param );

}

static void REGAL_CALL Ppa_glLightModelfv(Layer *_layer, GLenum pname, const GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glLightModelv( pname, params );

  orig.glLightModelfv( orig.glLightModelfv_layer, pname, params );

}

static void REGAL_CALL Ppa_glLightModeli(Layer *_layer, GLenum pname, GLint param)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glLightModel( pname, param );

  orig.glLightModeli( orig.glLightModeli_layer, pname, param );

}

static void REGAL_CALL Ppa_glLightModeliv(Layer *_layer, GLenum pname, const GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glLightModelv( pname, params );

  orig.glLightModeliv( orig.glLightModeliv_layer, pname, params );

}

static void REGAL_CALL Ppa_glLightf(Layer *_layer, GLenum light, GLenum pname, GLfloat param)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glLight( light, pname, param );

  orig.glLightf( orig.glLightf_layer, light, pname, param );

}

static void REGAL_CALL Ppa_glLightfv(Layer *_layer, GLenum light, GLenum pname, const GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glLightv( light, pname, params );

  orig.glLightfv( orig.glLightfv_layer, light, pname, params );

}

static void REGAL_CALL Ppa_glLighti(Layer *_layer, GLenum light, GLenum pname, GLint param)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glLight( light, pname, param );

  orig.glLighti( orig.glLighti_layer, light, pname, param );

}

static void REGAL_CALL Ppa_glLightiv(Layer *_layer, GLenum light, GLenum pname, const GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glLightv( light, pname, params );

  orig.glLightiv( orig.glLightiv_layer, light, pname, params );

}

static void REGAL_CALL Ppa_glLineStipple(Layer *_layer, GLint factor, GLushort pattern)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glLineStipple( factor, pattern );

  orig.glLineStipple( orig.glLineStipple_layer, factor, pattern );

}

static void REGAL_CALL Ppa_glLineWidth(Layer *_layer, GLfloat width)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glLineWidth( width );

  orig.glLineWidth( orig.glLineWidth_layer, width );

}

static void REGAL_CALL Ppa_glListBase(Layer *_layer, GLuint base)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glListBase( base );

  orig.glListBase( orig.glListBase_layer, base );

}

static void REGAL_CALL Ppa_glLogicOp(Layer *_layer, GLenum opcode)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glLogicOp( opcode );

  orig.glLogicOp( orig.glLogicOp_layer, opcode );

}

static void REGAL_CALL Ppa_glMapGrid1d(Layer *_layer, GLint un, GLdouble u1, GLdouble u2)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glMapGrid1( un, u1, u2 );

  orig.glMapGrid1d( orig.glMapGrid1d_layer, un, u1, u2 );

}

static void REGAL_CALL Ppa_glMapGrid1f(Layer *_layer, GLint un, GLfloat u1, GLfloat u2)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glMapGrid1( un, u1, u2 );

  orig.glMapGrid1f( orig.glMapGrid1f_layer, un, u1, u2 );

}

static void REGAL_CALL Ppa_glMapGrid2d(Layer *_layer, GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glMapGrid2( un, u1, u2, vn, v1, v2 );

  orig.glMapGrid2d( orig.glMapGrid2d_layer, un, u1, u2, vn, v1, v2 );

}

static void REGAL_CALL Ppa_glMapGrid2f(Layer *_layer, GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glMapGrid2( un, u1, u2, vn, v1, v2 );

  orig.glMapGrid2f( orig.glMapGrid2f_layer, un, u1, u2, vn, v1, v2 );

}

static void REGAL_CALL Ppa_glMaterialf(Layer *_layer, GLenum face, GLenum pname, GLfloat param)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glMaterial( face, pname, param );

  orig.glMaterialf( orig.glMaterialf_layer, face, pname, param );

}

static void REGAL_CALL Ppa_glMaterialfv(Layer *_layer, GLenum face, GLenum pname, const GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glMaterialv( face, pname, params );

  orig.glMaterialfv( orig.glMaterialfv_layer, face, pname, params );

}

static void REGAL_CALL Ppa_glMateriali(Layer *_layer, GLenum face, GLenum pname, GLint param)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glMaterial( face, pname, param );

  orig.glMateriali( orig.glMateriali_layer, face, pname, param );

}

static void REGAL_CALL Ppa_glMaterialiv(Layer *_layer, GLenum face, GLenum pname, const GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glMaterialv( face, pname, params );

  orig.glMaterialiv( orig.glMaterialiv_layer, face, pname, params );

}

static void REGAL_CALL Ppa_glMatrixMode(Layer *_layer, GLenum mode)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glMatrixMode( mode );

  orig.glMatrixMode( orig.glMatrixMode_layer, mode );

}

static void REGAL_CALL Ppa_glMinSampleShading(Layer *_layer, GLclampf value)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glMinSampleShading( value );

  orig.glMinSampleShading( orig.glMinSampleShading_layer, value );

}

static void REGAL_CALL Ppa_glMultiTexEnvfEXT(Layer *_layer, GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glMultiTexEnv( texunit, target, pname, param );

  orig.glMultiTexEnvfEXT( orig.glMultiTexEnvfEXT_layer, texunit, target, pname, param );

}

static void REGAL_CALL Ppa_glMultiTexEnvfvEXT(Layer *_layer, GLenum texunit, GLenum target, GLenum pname, const GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glMultiTexEnvv( texunit, target, pname, params );

  orig.glMultiTexEnvfvEXT( orig.glMultiTexEnvfvEXT_layer, texunit, target, pname, params );

}

static void REGAL_CALL Ppa_glMultiTexEnviEXT(Layer *_layer, GLenum texunit, GLenum target, GLenum pname, GLint param)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glMultiTexEnv( texunit, target, pname, param );

  orig.glMultiTexEnviEXT( orig.glMultiTexEnviEXT_layer, texunit, target, pname, param );

}

static void REGAL_CALL Ppa_glMultiTexEnvivEXT(Layer *_layer, GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glMultiTexEnvv( texunit, target, pname, params );

  orig.glMultiTexEnvivEXT( orig.glMultiTexEnvivEXT_layer, texunit, target, pname, params );

}

static void REGAL_CALL Ppa_glPixelTransferf(Layer *_layer, GLenum pname, GLfloat param)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glPixelTransfer( pname, param );

  orig.glPixelTransferf( orig.glPixelTransferf_layer, pname, param );

}

static void REGAL_CALL Ppa_glPixelTransferi(Layer *_layer, GLenum pname, GLint param)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glPixelTransfer( pname, param );

  orig.glPixelTransferi( orig.glPixelTransferi_layer, pname, param );

}

static void REGAL_CALL Ppa_glPixelZoom(Layer *_layer, GLfloat xfactor, GLfloat yfactor)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glPixelZoom( xfactor, yfactor );

  orig.glPixelZoom( orig.glPixelZoom_layer, xfactor, yfactor );

}

static void REGAL_CALL Ppa_glPointParameterf(Layer *_layer, GLenum pname, GLfloat param)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glPointParameter( pname, param );

  orig.glPointParameterf( orig.glPointParameterf_layer, pname, param );

}

static void REGAL_CALL Ppa_glPointParameterfv(Layer *_layer, GLenum pname, const GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glPointParameterv( pname, params );

  orig.glPointParameterfv( orig.glPointParameterfv_layer, pname, params );

}

static void REGAL_CALL Ppa_glPointParameteri(Layer *_layer, GLenum pname, GLint param)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glPointParameter( pname, param );

  orig.glPointParameteri( orig.glPointParameteri_layer, pname, param );

}

static void REGAL_CALL Ppa_glPointParameteriv(Layer *_layer, GLenum pname, const GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glPointParameterv( pname, params );

  orig.glPointParameteriv( orig.glPointParameteriv_layer, pname, params );

}

static void REGAL_CALL Ppa_glPointSize(Layer *_layer, GLfloat size)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glPointSize( size );

  orig.glPointSize( orig.glPointSize_layer, size );

}

static void REGAL_CALL Ppa_glPolygonMode(Layer *_layer, GLenum face, GLenum mode)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glPolygonMode( face, mode );

  orig.glPolygonMode( orig.glPolygonMode_layer, face, mode );

}

static void REGAL_CALL Ppa_glPolygonOffset(Layer *_layer, GLfloat factor, GLfloat units)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glPolygonOffset( factor, units );

  orig.glPolygonOffset( orig.glPolygonOffset_layer, factor, units );

}

static void REGAL_CALL Ppa_glPolygonStipple(Layer *_layer, const GLubyte *mask)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glPolygonStipple( mask );

  orig.glPolygonStipple( orig.glPolygonStipple_layer, mask );

}

static void REGAL_CALL Ppa_glPopAttrib(Layer *_layer)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  _context->ppa->PopAttrib( _context ); return;

  orig.glPopAttrib( orig.glPopAttrib_layer );

}

static void REGAL_CALL Ppa_glProvokingVertex(Layer *_layer, GLenum mode)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glProvokingVertex( mode );

  orig.glProvokingVertex( orig.glProvokingVertex_layer, mode );

}

static void REGAL_CALL Ppa_glPushAttrib(Layer *_layer, GLbitfield mask)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // impl
  _context->ppa->PushAttrib( _context, mask ); return;

  orig.glPushAttrib( orig.glPushAttrib_layer, mask );

}

static void REGAL_CALL Ppa_glReadBuffer(Layer *_layer, GLenum mode)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glReadBuffer( mode );

  orig.glReadBuffer( orig.glReadBuffer_layer, mode );

}

static void REGAL_CALL Ppa_glSampleCoverage(Layer *_layer, GLclampf value, GLboolean invert)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glSampleCoverage( value, invert );

  orig.glSampleCoverage( orig.glSampleCoverage_layer, value, invert );

}

static void REGAL_CALL Ppa_glScissor(Layer *_layer, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glScissor( x, y, width, height );

  orig.glScissor( orig.glScissor_layer, x, y, width, height );

}

static void REGAL_CALL Ppa_glScissorArrayv(Layer *_layer, GLuint first, GLsizei count, const GLint *v)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glScissorArrayv( first, count, v );

  orig.glScissorArrayv( orig.glScissorArrayv_layer, first, count, v );

}

static void REGAL_CALL Ppa_glScissorIndexed(Layer *_layer, GLuint index, GLint left, GLint bottom, GLint width, GLint height)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glScissorIndexed( index, left, bottom, width, height );

  orig.glScissorIndexed( orig.glScissorIndexed_layer, index, left, bottom, width, height );

}

static void REGAL_CALL Ppa_glScissorIndexedv(Layer *_layer, GLuint index, const GLint *v)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glScissorIndexedv( index, v );

  orig.glScissorIndexedv( orig.glScissorIndexedv_layer, index, v );

}

static void REGAL_CALL Ppa_glShadeModel(Layer *_layer, GLenum mode)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glShadeModel( mode );

  orig.glShadeModel( orig.glShadeModel_layer, mode );

}

static void REGAL_CALL Ppa_glStencilFunc(Layer *_layer, GLenum func, GLint ref, GLuint mask)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glStencilFunc( func, ref, mask );

  orig.glStencilFunc( orig.glStencilFunc_layer, func, ref, mask );

}

static void REGAL_CALL Ppa_glStencilFuncSeparate(Layer *_layer, GLenum face, GLenum func, GLint ref, GLuint mask)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glStencilFuncSeparate( face, func, ref, mask );

  orig.glStencilFuncSeparate( orig.glStencilFuncSeparate_layer, face, func, ref, mask );

}

static void REGAL_CALL Ppa_glStencilMask(Layer *_layer, GLuint mask)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glStencilMask( mask );

  orig.glStencilMask( orig.glStencilMask_layer, mask );

}

static void REGAL_CALL Ppa_glStencilMaskSeparate(Layer *_layer, GLenum face, GLuint mask)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glStencilMaskSeparate( face, mask );

  orig.glStencilMaskSeparate( orig.glStencilMaskSeparate_layer, face, mask );

}

static void REGAL_CALL Ppa_glStencilOp(Layer *_layer, GLenum fail, GLenum zfail, GLenum zpass)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glStencilOp( fail, zfail, zpass );

  orig.glStencilOp( orig.glStencilOp_layer, fail, zfail, zpass );

}

static void REGAL_CALL Ppa_glStencilOpSeparate(Layer *_layer, GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glStencilOpSeparate( face, fail, zfail, zpass );

  orig.glStencilOpSeparate( orig.glStencilOpSeparate_layer, face, fail, zfail, zpass );

}

static void REGAL_CALL Ppa_glTexEnvf(Layer *_layer, GLenum target, GLenum pname, GLfloat param)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glTexEnv( target, pname, param );

  orig.glTexEnvf( orig.glTexEnvf_layer, target, pname, param );

}

static void REGAL_CALL Ppa_glTexEnvfv(Layer *_layer, GLenum target, GLenum pname, const GLfloat *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glTexEnvv( target, pname, params );

  orig.glTexEnvfv( orig.glTexEnvfv_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glTexEnvi(Layer *_layer, GLenum target, GLenum pname, GLint param)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glTexEnv( target, pname, param );

  orig.glTexEnvi( orig.glTexEnvi_layer, target, pname, param );

}

static void REGAL_CALL Ppa_glTexEnviv(Layer *_layer, GLenum target, GLenum pname, const GLint *params)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glTexEnvv( target, pname, params );

  orig.glTexEnviv( orig.glTexEnviv_layer, target, pname, params );

}

static void REGAL_CALL Ppa_glViewport(Layer *_layer, GLint x, GLint y, GLsizei width, GLsizei height)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glViewport( x, y, width, height );

  orig.glViewport( orig.glViewport_layer, x, y, width, height );

}

static void REGAL_CALL Ppa_glViewportArrayv(Layer *_layer, GLuint first, GLsizei count, const GLfloat *v)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glViewportArrayv( first, count, v );

  orig.glViewportArrayv( orig.glViewportArrayv_layer, first, count, v );

}

static void REGAL_CALL Ppa_glViewportIndexedf(Layer *_layer, GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glViewportIndexedf( index, x, y, w, h );

  orig.glViewportIndexedf( orig.glViewportIndexedf_layer, index, x, y, w, h );

}

static void REGAL_CALL Ppa_glViewportIndexedfv(Layer *_layer, GLuint index, const GLfloat *v)
{
  Ppa * self = static_cast<Ppa *>(_layer);

  PpaOriginate & orig = self->orig;

  // prefix
  _context->ppa->glViewportIndexedfv( index, v );

  orig.glViewportIndexedfv( orig.glViewportIndexedfv_layer, index, v );

}

void PpaIntercept( Dispatch::GL & dt ) {
  dt.glActiveTexture                 = RPpa_glActiveTexture;
  dt.glActiveTextureARB              = RPpa_glActiveTextureARB;
  dt.glAlphaFunc                     = RPpa_glAlphaFunc;
  dt.glBlendColor                    = RPpa_glBlendColor;
  dt.glBlendEquation                 = RPpa_glBlendEquation;
  dt.glBlendEquationSeparate         = RPpa_glBlendEquationSeparate;
  dt.glBlendEquationSeparatei        = RPpa_glBlendEquationSeparatei;
  dt.glBlendEquationi                = RPpa_glBlendEquationi;
  dt.glBlendFunc                     = RPpa_glBlendFunc;
  dt.glBlendFuncSeparate             = RPpa_glBlendFuncSeparate;
  dt.glBlendFuncSeparatei            = RPpa_glBlendFuncSeparatei;
  dt.glBlendFunci                    = RPpa_glBlendFunci;
  dt.glClampColor                    = RPpa_glClampColor;
  dt.glClearAccum                    = RPpa_glClearAccum;
  dt.glClearColor                    = RPpa_glClearColor;
  dt.glClearDepth                    = RPpa_glClearDepth;
  dt.glClearDepthf                   = RPpa_glClearDepthf;
  dt.glClearIndex                    = RPpa_glClearIndex;
  dt.glClearStencil                  = RPpa_glClearStencil;
  dt.glClipPlane                     = RPpa_glClipPlane;
  dt.glColorMask                     = RPpa_glColorMask;
  dt.glColorMaski                    = RPpa_glColorMaski;
  dt.glColorMaterial                 = RPpa_glColorMaterial;
  dt.glColorTableParameterfv         = RPpa_glColorTableParameterfv;
  dt.glColorTableParameteriv         = RPpa_glColorTableParameteriv;
  dt.glConvolutionParameterf         = RPpa_glConvolutionParameterf;
  dt.glConvolutionParameterfv        = RPpa_glConvolutionParameterfv;
  dt.glConvolutionParameteri         = RPpa_glConvolutionParameteri;
  dt.glConvolutionParameteriv        = RPpa_glConvolutionParameteriv;
  dt.glCullFace                      = RPpa_glCullFace;
  dt.glDepthFunc                     = RPpa_glDepthFunc;
  dt.glDepthMask                     = RPpa_glDepthMask;
  dt.glDepthRange                    = RPpa_glDepthRange;
  dt.glDepthRangeArrayv              = RPpa_glDepthRangeArrayv;
  dt.glDepthRangeIndexed             = RPpa_glDepthRangeIndexed;
  dt.glDepthRangef                   = RPpa_glDepthRangef;
  dt.glDisable                       = RPpa_glDisable;
  dt.glDisablei                      = RPpa_glDisablei;
  dt.glDrawBuffer                    = RPpa_glDrawBuffer;
  dt.glDrawBuffers                   = RPpa_glDrawBuffers;
  dt.glDrawBuffersARB                = RPpa_glDrawBuffersARB;
  dt.glDrawBuffersNV                 = RPpa_glDrawBuffersNV;
  dt.glEnable                        = RPpa_glEnable;
  dt.glEnablei                       = RPpa_glEnablei;
  dt.glFrontFace                     = RPpa_glFrontFace;
  dt.glGetBooleani_v                 = RPpa_glGetBooleani_v;
  dt.glGetBooleanv                   = RPpa_glGetBooleanv;
  dt.glGetColorTableParameterfv      = RPpa_glGetColorTableParameterfv;
  dt.glGetColorTableParameteriv      = RPpa_glGetColorTableParameteriv;
  dt.glGetConvolutionParameterfv     = RPpa_glGetConvolutionParameterfv;
  dt.glGetConvolutionParameteriv     = RPpa_glGetConvolutionParameteriv;
  dt.glGetDoublei_v                  = RPpa_glGetDoublei_v;
  dt.glGetDoublei_vEXT               = RPpa_glGetDoublei_vEXT;
  dt.glGetDoublev                    = RPpa_glGetDoublev;
  dt.glGetFloati_v                   = RPpa_glGetFloati_v;
  dt.glGetFloati_vEXT                = RPpa_glGetFloati_vEXT;
  dt.glGetFloatv                     = RPpa_glGetFloatv;
  dt.glGetIntegeri_v                 = RPpa_glGetIntegeri_v;
  dt.glGetIntegeri_vEXT              = RPpa_glGetIntegeri_vEXT;
  dt.glGetIntegerv                   = RPpa_glGetIntegerv;
  dt.glGetLightfv                    = RPpa_glGetLightfv;
  dt.glGetLightiv                    = RPpa_glGetLightiv;
  dt.glGetLightxv                    = RPpa_glGetLightxv;
  dt.glGetMaterialfv                 = RPpa_glGetMaterialfv;
  dt.glGetMaterialiv                 = RPpa_glGetMaterialiv;
  dt.glGetMaterialxv                 = RPpa_glGetMaterialxv;
  dt.glGetMultiTexEnvfvEXT           = RPpa_glGetMultiTexEnvfvEXT;
  dt.glGetMultiTexEnvivEXT           = RPpa_glGetMultiTexEnvivEXT;
  dt.glGetPolygonStipple             = RPpa_glGetPolygonStipple;
  dt.glGetTexEnvfv                   = RPpa_glGetTexEnvfv;
  dt.glGetTexEnviv                   = RPpa_glGetTexEnviv;
  dt.glGetTexLevelParameterfv        = RPpa_glGetTexLevelParameterfv;
  dt.glGetTexLevelParameteriv        = RPpa_glGetTexLevelParameteriv;
  dt.glGetTexParameterfv             = RPpa_glGetTexParameterfv;
  dt.glGetTexParameteriv             = RPpa_glGetTexParameteriv;
  dt.glGetTextureLevelParameterfvEXT = RPpa_glGetTextureLevelParameterfvEXT;
  dt.glGetTextureLevelParameterivEXT = RPpa_glGetTextureLevelParameterivEXT;
  dt.glGetTextureParameterfvEXT      = RPpa_glGetTextureParameterfvEXT;
  dt.glGetTextureParameterivEXT      = RPpa_glGetTextureParameterivEXT;
  dt.glHint                          = RPpa_glHint;
  dt.glIndexMask                     = RPpa_glIndexMask;
  dt.glIsEnabled                     = RPpa_glIsEnabled;
  dt.glIsEnabledi                    = RPpa_glIsEnabledi;
  dt.glLightModelf                   = RPpa_glLightModelf;
  dt.glLightModelfv                  = RPpa_glLightModelfv;
  dt.glLightModeli                   = RPpa_glLightModeli;
  dt.glLightModeliv                  = RPpa_glLightModeliv;
  dt.glLightf                        = RPpa_glLightf;
  dt.glLightfv                       = RPpa_glLightfv;
  dt.glLighti                        = RPpa_glLighti;
  dt.glLightiv                       = RPpa_glLightiv;
  dt.glLineStipple                   = RPpa_glLineStipple;
  dt.glLineWidth                     = RPpa_glLineWidth;
  dt.glListBase                      = RPpa_glListBase;
  dt.glLogicOp                       = RPpa_glLogicOp;
  dt.glMapGrid1d                     = RPpa_glMapGrid1d;
  dt.glMapGrid1f                     = RPpa_glMapGrid1f;
  dt.glMapGrid2d                     = RPpa_glMapGrid2d;
  dt.glMapGrid2f                     = RPpa_glMapGrid2f;
  dt.glMaterialf                     = RPpa_glMaterialf;
  dt.glMaterialfv                    = RPpa_glMaterialfv;
  dt.glMateriali                     = RPpa_glMateriali;
  dt.glMaterialiv                    = RPpa_glMaterialiv;
  dt.glMatrixMode                    = RPpa_glMatrixMode;
  dt.glMinSampleShading              = RPpa_glMinSampleShading;
  dt.glMultiTexEnvfEXT               = RPpa_glMultiTexEnvfEXT;
  dt.glMultiTexEnvfvEXT              = RPpa_glMultiTexEnvfvEXT;
  dt.glMultiTexEnviEXT               = RPpa_glMultiTexEnviEXT;
  dt.glMultiTexEnvivEXT              = RPpa_glMultiTexEnvivEXT;
  dt.glPixelTransferf                = RPpa_glPixelTransferf;
  dt.glPixelTransferi                = RPpa_glPixelTransferi;
  dt.glPixelZoom                     = RPpa_glPixelZoom;
  dt.glPointParameterf               = RPpa_glPointParameterf;
  dt.glPointParameterfv              = RPpa_glPointParameterfv;
  dt.glPointParameteri               = RPpa_glPointParameteri;
  dt.glPointParameteriv              = RPpa_glPointParameteriv;
  dt.glPointSize                     = RPpa_glPointSize;
  dt.glPolygonMode                   = RPpa_glPolygonMode;
  dt.glPolygonOffset                 = RPpa_glPolygonOffset;
  dt.glPolygonStipple                = RPpa_glPolygonStipple;
  dt.glPopAttrib                     = RPpa_glPopAttrib;
  dt.glProvokingVertex               = RPpa_glProvokingVertex;
  dt.glPushAttrib                    = RPpa_glPushAttrib;
  dt.glReadBuffer                    = RPpa_glReadBuffer;
  dt.glSampleCoverage                = RPpa_glSampleCoverage;
  dt.glScissor                       = RPpa_glScissor;
  dt.glScissorArrayv                 = RPpa_glScissorArrayv;
  dt.glScissorIndexed                = RPpa_glScissorIndexed;
  dt.glScissorIndexedv               = RPpa_glScissorIndexedv;
  dt.glShadeModel                    = RPpa_glShadeModel;
  dt.glStencilFunc                   = RPpa_glStencilFunc;
  dt.glStencilFuncSeparate           = RPpa_glStencilFuncSeparate;
  dt.glStencilMask                   = RPpa_glStencilMask;
  dt.glStencilMaskSeparate           = RPpa_glStencilMaskSeparate;
  dt.glStencilOp                     = RPpa_glStencilOp;
  dt.glStencilOpSeparate             = RPpa_glStencilOpSeparate;
  dt.glTexEnvf                       = RPpa_glTexEnvf;
  dt.glTexEnvfv                      = RPpa_glTexEnvfv;
  dt.glTexEnvi                       = RPpa_glTexEnvi;
  dt.glTexEnviv                      = RPpa_glTexEnviv;
  dt.glViewport                      = RPpa_glViewport;
  dt.glViewportArrayv                = RPpa_glViewportArrayv;
  dt.glViewportIndexedf              = RPpa_glViewportIndexedf;
  dt.glViewportIndexedfv             = RPpa_glViewportIndexedfv;
}

REGAL_NAMESPACE_END

#endif // REGAL_EMULATION
