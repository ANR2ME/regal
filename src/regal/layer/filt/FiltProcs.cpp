/* NOTE: Do not edit this file, it is generated by a script:
   Export.py --api gl 4.4 --api wgl 4.4 --api glx 4.4 --api cgl 1.4 --api egl 1.0 --outdir .
*/

/*
  Copyright (c) 2011-2013 NVIDIA Corporation
  Copyright (c) 2011-2013 Cass Everitt
  Copyright (c) 2012-2013 Scott Nations
  Copyright (c) 2012 Mathias Schott
  Copyright (c) 2012-2013 Nigel Stewart
  Copyright (c) 2012-2013 Google Inc.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
  Intended formatting conventions:
  $ astyle --style=allman --indent=spaces=2 --indent-switches
*/

#include "RegalUtil.h"

#if REGAL_EMULATION

REGAL_GLOBAL_BEGIN

#include "RegalPrivate.h"
#include "RegalContext.h"
#include "RegalDispatch.h"
#include "Filt.h"
#include "FiltProcs.h"

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

using namespace Emu;

static void REGAL_CALL filt_glAccum(Layer *_layer, GLenum op, GLfloat value)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glAccum for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglAccum( orig, op, value );

}

static void REGAL_CALL filt_glActiveTextureARB(Layer *_layer, GLenum texture)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_arb_multitexture)
  {
    orig.glActiveTexture( _context,texture);
    return;
  }

  RglActiveTextureARB( orig, texture );

}

static void REGAL_CALL filt_glAttachObjectARB(Layer *_layer, GLhandleARB containerObj, GLhandleARB obj)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    orig.glAttachShader( _context,containerObj, obj);
    return;
  }

  RglAttachObjectARB( orig, containerObj, obj );

}

static void REGAL_CALL filt_glBindAttribLocationARB(Layer *_layer, GLhandleARB programObj, GLuint index, const GLcharARB *name)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    orig.glBindAttribLocation( _context,programObj, index, name);
    return;
  }

  RglBindAttribLocationARB( orig, programObj, index, name );

}

static void REGAL_CALL filt_glBindFramebuffer(Layer *_layer, GLenum target, GLuint framebuffer)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    const bool hasFBBlit = _context->info->gl_ext_framebuffer_blit || _context->info->gl_nv_framebuffer_blit || _context->info->gl_version_major >= 3;
    if (!hasFBBlit && (target==GL_DRAW_FRAMEBUFFER || target==GL_READ_FRAMEBUFFER)) target = GL_FRAMEBUFFER;
  }
  if (_context->filt->BindFramebuffer(*_context, target, framebuffer))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglBindFramebuffer( orig, target, framebuffer );

}

static void REGAL_CALL filt_glBindFramebufferEXT(Layer *_layer, GLenum target, GLuint framebuffer)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    orig.glBindFramebuffer( _context,target, framebuffer);
    return;
  }

  RglBindFramebufferEXT( orig, target, framebuffer );

}

static void REGAL_CALL filt_glBindFramebufferOES(Layer *_layer, GLenum target, GLuint framebuffer)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    const bool hasFBBlit = _context->info->gl_ext_framebuffer_blit || _context->info->gl_nv_framebuffer_blit || _context->info->gl_version_major >= 3;
    if (!hasFBBlit && (target==GL_DRAW_FRAMEBUFFER || target==GL_READ_FRAMEBUFFER)) target = GL_FRAMEBUFFER;
  }
  if (_context->filt->BindFramebuffer(*_context, target, framebuffer))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglBindFramebufferOES( orig, target, framebuffer );

}

static void REGAL_CALL filt_glBindProgramARB(Layer *_layer, GLenum target, GLuint program)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glBindProgramARB (GL_ARB_vertex_program) for ES 2.0 context - skipping.");
    return;
  }

  RglBindProgramARB( orig, target, program );

}

static void REGAL_CALL filt_glBindRenderbufferEXT(Layer *_layer, GLenum target, GLuint renderbuffer)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    orig.glBindRenderbuffer( _context,target, renderbuffer);
    return;
  }

  RglBindRenderbufferEXT( orig, target, renderbuffer );

}

static void REGAL_CALL filt_glBindTexture(Layer *_layer, GLenum target, GLuint texture)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->BindTexture(*_context, target, texture))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglBindTexture( orig, target, texture );

}

static void REGAL_CALL filt_glBitmap(Layer *_layer, GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glBitmap for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglBitmap( orig, width, height, xorig, yorig, xmove, ymove, bitmap );

}

static void REGAL_CALL filt_glBlendColorEXT(Layer *_layer, GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    orig.glBlendColor( _context,red, green, blue, alpha);
    return;
  }

  RglBlendColorEXT( orig, red, green, blue, alpha );

}

static void REGAL_CALL filt_glBlendEquationEXT(Layer *_layer, GLenum mode)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    orig.glBlendEquation( _context,mode);
    return;
  }

  RglBlendEquationEXT( orig, mode );

}

static void REGAL_CALL filt_glBlitFramebuffer(Layer *_layer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    if (_context->info->gl_nv_framebuffer_blit)  return orig.glBlitFramebufferNV( _context, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    if (_context->info->gl_ext_framebuffer_blit) return orig.glBlitFramebufferEXT( _context, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }

  RglBlitFramebuffer( orig, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter );

}

static void REGAL_CALL filt_glBlitFramebufferANGLE(Layer *_layer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glBlitFramebufferANGLE for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglBlitFramebufferANGLE( orig, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter );

}

static void REGAL_CALL filt_glBlitFramebufferEXT(Layer *_layer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_blit)
  {
    _context->emuLevel++;
    orig.glBlitFramebuffer( _context,srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    return;
  }

  RglBlitFramebufferEXT( orig, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter );

}

static void REGAL_CALL filt_glBufferDataARB(Layer *_layer, GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    orig.glBufferData( _context,target, size, data, usage);
    return;
  }

  RglBufferDataARB( orig, target, size, data, usage );

}

static void REGAL_CALL filt_glCallList(Layer *_layer, GLuint list)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glCallList for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglCallList( orig, list );

}

static GLenum REGAL_CALL filt_glCheckFramebufferStatusEXT(Layer *_layer, GLenum target)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    return orig.glCheckFramebufferStatus( _context,target);
  }

  return RglCheckFramebufferStatusEXT( orig, target );

}

static void REGAL_CALL filt_glClearAccum(Layer *_layer, GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glClearAccum for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglClearAccum( orig, red, green, blue, alpha );

}

static void REGAL_CALL filt_glClientActiveTexture(Layer *_layer, GLenum texture)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glClientActiveTexture for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglClientActiveTexture( orig, texture );

}

static void REGAL_CALL filt_glClientActiveTextureARB(Layer *_layer, GLenum texture)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_arb_multitexture)
  {
    _context->emuLevel++;
    orig.glClientActiveTexture( _context,texture);
    return;
  }

  RglClientActiveTextureARB( orig, texture );

}

static void REGAL_CALL filt_glColorMaskIndexedEXT(Layer *_layer, GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2)
  {
    if (!buf)  {
      orig.glColorMask( _context,r, g, b, a);
    }
    return;
  }

  RglColorMaskIndexedEXT( orig, buf, r, g, b, a );

}

static void REGAL_CALL filt_glCompileShaderARB(Layer *_layer, GLhandleARB shaderObj)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    orig.glCompileShader( _context,shaderObj);
    return;
  }

  RglCompileShaderARB( orig, shaderObj );

}

static void REGAL_CALL filt_glCopyPixels(Layer *_layer, GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glCopyPixels for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglCopyPixels( orig, x, y, width, height, type );

}

static GLhandleARB REGAL_CALL filt_glCreateProgramObjectARB(Layer *_layer)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    return orig.glCreateProgram( _context );
  }

  return RglCreateProgramObjectARB( orig );

}

static void REGAL_CALL filt_glDeleteFramebuffersEXT(Layer *_layer, GLsizei n, const GLuint *framebuffers)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    orig.glDeleteFramebuffers( _context,n, framebuffers);
    return;
  }

  RglDeleteFramebuffersEXT( orig, n, framebuffers );

}

static void REGAL_CALL filt_glDeleteLists(Layer *_layer, GLuint list, GLsizei range)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glDeleteLists for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglDeleteLists( orig, list, range );

}

static void REGAL_CALL filt_glDeleteRenderbuffersEXT(Layer *_layer, GLsizei n, const GLuint *renderbuffers)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    orig.glDeleteRenderbuffers( _context,n, renderbuffers);
    return;
  }

  RglDeleteRenderbuffersEXT( orig, n, renderbuffers );

}

static void REGAL_CALL filt_glDisableIndexedEXT(Layer *_layer, GLenum target, GLuint index)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (target==GL_BLEND && (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2))
  {
    if (!index)  {
      orig.glDisable( _context,target);
    }
    return;
  }

  RglDisableIndexedEXT( orig, target, index );

}

static void REGAL_CALL filt_glDrawBuffer(Layer *_layer, GLenum mode)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    if (_context->info->gl_nv_framebuffer_blit || _context->info->gl_ext_framebuffer_blit)
      return orig.glDrawBuffer( _context, mode );
  }

  RglDrawBuffer( orig, mode );

}

static void REGAL_CALL filt_glDrawBuffers(Layer *_layer, GLsizei n, const GLenum *bufs)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->DrawBuffers(*_context, n, bufs))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }
  if (_context->isES2())
  {
    if (_context->info->gl_nv_draw_buffers)
    {
      orig.glDrawBuffersNV( _context, n, bufs );
      return;
    }
  }

  RglDrawBuffers( orig, n, bufs );

}

static void REGAL_CALL filt_glDrawBuffersARB(Layer *_layer, GLsizei n, const GLenum *bufs)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_arb_draw_buffers)
  {
    _context->emuLevel++;
    orig.glDrawBuffers( _context,n, bufs);
    return;
  }

  RglDrawBuffersARB( orig, n, bufs );

}

static void REGAL_CALL filt_glDrawBuffersATI(Layer *_layer, GLsizei n, const GLenum *bufs)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ati_draw_buffers)
  {
    _context->emuLevel++;
    orig.glDrawBuffers( _context,n, bufs);
    return;
  }

  RglDrawBuffersATI( orig, n, bufs );

}

static void REGAL_CALL filt_glDrawPixels(Layer *_layer, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glDrawPixels for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglDrawPixels( orig, width, height, format, type, pixels );

}

static void REGAL_CALL filt_glDrawRangeElements(Layer *_layer, GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    return orig.glDrawElements( _context,mode, count, type, indices);
  }

  RglDrawRangeElements( orig, mode, start, end, count, type, indices );

}

static void REGAL_CALL filt_glDrawRangeElementsBaseVertex(Layer *_layer, GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_arb_draw_elements_base_vertex)
  {
    if (basevertex==0)
    {
      return orig.glDrawElements( _context,mode, count, type, indices);
    }
    else
    {
      Warning("Regal does not support glDrawRangeElementsBaseVertex (GL_ARB_draw_elements_base_vertex extension not available) for basevertex!=0 for ES 2.0 - skipping.");
      return;
    }
  }

  RglDrawRangeElementsBaseVertex( orig, mode, start, end, count, type, indices, basevertex );

}

static void REGAL_CALL filt_glEdgeFlag(Layer *_layer, GLboolean flag)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEdgeFlag for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglEdgeFlag( orig, flag );

}

static void REGAL_CALL filt_glEnableIndexedEXT(Layer *_layer, GLenum target, GLuint index)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (target==GL_BLEND && (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2))
  {
    if (!index)  {
      orig.glEnable( _context,target);
    }
    return;
  }

  RglEnableIndexedEXT( orig, target, index );

}

static void REGAL_CALL filt_glEndList(Layer *_layer)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEndList for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglEndList( orig );

}

static void REGAL_CALL filt_glEvalCoord1d(Layer *_layer, GLdouble u)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord1d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglEvalCoord1d( orig, u );

}

static void REGAL_CALL filt_glEvalCoord1dv(Layer *_layer, const GLdouble *u)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord1dv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglEvalCoord1dv( orig, u );

}

static void REGAL_CALL filt_glEvalCoord1f(Layer *_layer, GLfloat u)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord1f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglEvalCoord1f( orig, u );

}

static void REGAL_CALL filt_glEvalCoord1fv(Layer *_layer, const GLfloat *u)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord1fv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglEvalCoord1fv( orig, u );

}

static void REGAL_CALL filt_glEvalCoord2d(Layer *_layer, GLdouble u, GLdouble v)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord2d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglEvalCoord2d( orig, u, v );

}

static void REGAL_CALL filt_glEvalCoord2dv(Layer *_layer, const GLdouble *u)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord2dv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglEvalCoord2dv( orig, u );

}

static void REGAL_CALL filt_glEvalCoord2f(Layer *_layer, GLfloat u, GLfloat v)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord2f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglEvalCoord2f( orig, u, v );

}

static void REGAL_CALL filt_glEvalCoord2fv(Layer *_layer, const GLfloat *u)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord2fv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglEvalCoord2fv( orig, u );

}

static void REGAL_CALL filt_glEvalMesh1(Layer *_layer, GLenum mode, GLint i1, GLint i2)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalMesh1 for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglEvalMesh1( orig, mode, i1, i2 );

}

static void REGAL_CALL filt_glEvalMesh2(Layer *_layer, GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalMesh2 for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglEvalMesh2( orig, mode, i1, i2, j1, j2 );

}

static void REGAL_CALL filt_glEvalPoint1(Layer *_layer, GLint i)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalPoint1 for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglEvalPoint1( orig, i );

}

static void REGAL_CALL filt_glEvalPoint2(Layer *_layer, GLint i, GLint j)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalPoint2 for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglEvalPoint2( orig, i, j );

}

static void REGAL_CALL filt_glFramebufferRenderbuffer(Layer *_layer, GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->FramebufferAttachmentSupported(*_context, attachment))
    orig.glFramebufferRenderbuffer( _context,target, attachment, renderbuffertarget, renderbuffer);
  return;

  RglFramebufferRenderbuffer( orig, target, attachment, renderbuffertarget, renderbuffer );

}

static void REGAL_CALL filt_glFramebufferRenderbufferEXT(Layer *_layer, GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    orig.glFramebufferRenderbuffer( _context,target, attachment, renderbuffertarget, renderbuffer);
    return;
  }

  RglFramebufferRenderbufferEXT( orig, target, attachment, renderbuffertarget, renderbuffer );

}

static void REGAL_CALL filt_glFramebufferTexture1D(Layer *_layer, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->FramebufferAttachmentSupported(*_context, attachment))
    orig.glFramebufferTexture1D( _context,target, attachment, textarget, texture, level);
  return;

  RglFramebufferTexture1D( orig, target, attachment, textarget, texture, level );

}

static void REGAL_CALL filt_glFramebufferTexture1DEXT(Layer *_layer, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    orig.glFramebufferTexture1D( _context,target, attachment, textarget, texture, level);
    return;
  }

  RglFramebufferTexture1DEXT( orig, target, attachment, textarget, texture, level );

}

static void REGAL_CALL filt_glFramebufferTexture2D(Layer *_layer, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->FramebufferTexture2D(*_context, target, attachment, textarget, texture, level))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglFramebufferTexture2D( orig, target, attachment, textarget, texture, level );

}

static void REGAL_CALL filt_glFramebufferTexture2DEXT(Layer *_layer, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    orig.glFramebufferTexture2D( _context,target, attachment, textarget, texture, level);
    return;
  }

  RglFramebufferTexture2DEXT( orig, target, attachment, textarget, texture, level );

}

static void REGAL_CALL filt_glFramebufferTexture3D(Layer *_layer, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->FramebufferAttachmentSupported(*_context, attachment))
    orig.glFramebufferTexture3D( _context,target, attachment, textarget, texture, level, layer);
  return;

  RglFramebufferTexture3D( orig, target, attachment, textarget, texture, level, layer );

}

static void REGAL_CALL filt_glFramebufferTexture3DEXT(Layer *_layer, GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    orig.glFramebufferTexture3D( _context,target, attachment, textarget, texture, level, zoffset);
    return;
  }

  RglFramebufferTexture3DEXT( orig, target, attachment, textarget, texture, level, zoffset );

}

static void REGAL_CALL filt_glGenFramebuffersEXT(Layer *_layer, GLsizei n, GLuint *framebuffers)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    orig.glGenFramebuffers( _context,n, framebuffers);
    return;
  }

  RglGenFramebuffersEXT( orig, n, framebuffers );

}

static GLuint REGAL_CALL filt_glGenLists(Layer *_layer, GLsizei range)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glGenLists for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return (( GLuint  )0);
  }

  return RglGenLists( orig, range );

}

static void REGAL_CALL filt_glGenProgramsARB(Layer *_layer, GLsizei n, GLuint *programs)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glGenProgramsARB (GL_ARB_vertex_program) for ES 2.0 context - skipping.");
    return;
  }

  RglGenProgramsARB( orig, n, programs );

}

static void REGAL_CALL filt_glGenRenderbuffersEXT(Layer *_layer, GLsizei n, GLuint *renderbuffers)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    orig.glGenRenderbuffers( _context,n, renderbuffers);
    return;
  }

  RglGenRenderbuffersEXT( orig, n, renderbuffers );

}

static void REGAL_CALL filt_glGenSamplers(Layer *_layer, GLsizei count, GLuint *samplers)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glGenSamplers for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglGenSamplers( orig, count, samplers );

}

static void REGAL_CALL filt_glGenerateMipmap(Layer *_layer, GLenum target)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->GenerateMipmap(*_context, target))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglGenerateMipmap( orig, target );

}

static void REGAL_CALL filt_glGenerateMipmapEXT(Layer *_layer, GLenum target)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    orig.glGenerateMipmap( _context,target);
    return;
  }

  RglGenerateMipmapEXT( orig, target );

}

static void REGAL_CALL filt_glGetBooleanIndexedvEXT(Layer *_layer, GLenum value, GLuint index, GLboolean *data)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2)
  {
    if (!index)  {
      orig.glGetBooleanv( _context,value,data);
    }
    return;
  }

  RglGetBooleanIndexedvEXT( orig, value, index, data );

}

static void REGAL_CALL filt_glGetBooleanv(Layer *_layer, GLenum pname, GLboolean *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->Get(*_context, pname, params))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglGetBooleanv( orig, pname, params );

}

static void REGAL_CALL filt_glGetDoublev(Layer *_layer, GLenum pname, GLdouble *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->Get(*_context, pname, params))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglGetDoublev( orig, pname, params );

}

static void REGAL_CALL filt_glGetFloatv(Layer *_layer, GLenum pname, GLfloat *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->Get(*_context, pname, params))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglGetFloatv( orig, pname, params );

}

static void REGAL_CALL filt_glGetFramebufferAttachmentParameteriv(Layer *_layer, GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->filt->FramebufferAttachmentSupported(*_context, attachment))
    *params = 0;
  else
    orig.glGetFramebufferAttachmentParameteriv( _context,target, attachment, pname, params);
  return;

  RglGetFramebufferAttachmentParameteriv( orig, target, attachment, pname, params );

}

static void REGAL_CALL filt_glGetFramebufferAttachmentParameterivEXT(Layer *_layer, GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    orig.glGetFramebufferAttachmentParameteriv( _context,target, attachment, pname, params);
    return;
  }

  RglGetFramebufferAttachmentParameterivEXT( orig, target, attachment, pname, params );

}

static void REGAL_CALL filt_glGetInfoLogARB(Layer *_layer, GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    if (orig.glIsProgram( _context,obj))
      orig.glGetProgramInfoLog( _context,obj, maxLength, length, infoLog);
    else
      orig.glGetShaderInfoLog( _context,obj, maxLength, length, infoLog);
    return;
  }

  RglGetInfoLogARB( orig, obj, maxLength, length, infoLog );

}

static void REGAL_CALL filt_glGetInteger64v(Layer *_layer, GLenum pname, GLint64 *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->Get(*_context, pname, params))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglGetInteger64v( orig, pname, params );

}

static void REGAL_CALL filt_glGetIntegerIndexedvEXT(Layer *_layer, GLenum value, GLuint index, GLint *data)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2)
  {
    if (!index)  {
      orig.glGetIntegerv( _context,value,data);
    }
    return;
  }

  RglGetIntegerIndexedvEXT( orig, value, index, data );

}

static void REGAL_CALL filt_glGetIntegerv(Layer *_layer, GLenum pname, GLint *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->Get(*_context, pname, params))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglGetIntegerv( orig, pname, params );

}

static void REGAL_CALL filt_glGetObjectParameterivARB(Layer *_layer, GLhandleARB obj, GLenum pname, GLint *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    if (orig.glIsProgram( _context,obj))
      orig.glGetProgramiv( _context,obj, pname, params);
    else
      orig.glGetShaderiv( _context,obj, pname, params);
    return;
  }

  RglGetObjectParameterivARB( orig, obj, pname, params );

}

static void REGAL_CALL filt_glGetProgramivARB(Layer *_layer, GLenum target, GLenum pname, GLint *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glGetProgramivARB (GL_ARB_vertex_program) for ES 2.0 context - skipping.");
    return;
  }

  RglGetProgramivARB( orig, target, pname, params );

}

static void REGAL_CALL filt_glGetRenderbufferParameterivEXT(Layer *_layer, GLenum target, GLenum pname, GLint *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    orig.glGetRenderbufferParameteriv( _context,target, pname, params);
    return;
  }

  RglGetRenderbufferParameterivEXT( orig, target, pname, params );

}

static void REGAL_CALL filt_glGetTexImage(Layer *_layer, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glGetTexImage for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglGetTexImage( orig, target, level, format, type, pixels );

}

static void REGAL_CALL filt_glGetTexLevelParameterfv(Layer *_layer, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glGetTexLevelParameterfv for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglGetTexLevelParameterfv( orig, target, level, pname, params );

}

static void REGAL_CALL filt_glGetTexLevelParameteriv(Layer *_layer, GLenum target, GLint level, GLenum pname, GLint *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glGetTexLevelParameteriv for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglGetTexLevelParameteriv( orig, target, level, pname, params );

}

static void REGAL_CALL filt_glGetTexParameteriv(Layer *_layer, GLenum target, GLenum pname, GLint *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->GetTexParameteriv(*_context, target, pname, params))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglGetTexParameteriv( orig, target, pname, params );

}

static GLint REGAL_CALL filt_glGetUniformLocationARB(Layer *_layer, GLhandleARB programObj, const GLcharARB *name)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    return orig.glGetUniformLocation( _context,programObj, name);
  }

  return RglGetUniformLocationARB( orig, programObj, name );

}

static GLboolean REGAL_CALL filt_glIsEnabledIndexedEXT(Layer *_layer, GLenum target, GLuint index)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (target==GL_BLEND && !_context->info->gl_ext_draw_buffers2)
  {
    if (!index)  {
      return orig.glIsEnabled( _context,target);
    }
    return GL_FALSE;
  }

  return RglIsEnabledIndexedEXT( orig, target, index );

}

static GLboolean REGAL_CALL filt_glIsFramebufferEXT(Layer *_layer, GLuint framebuffer)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    return orig.glIsFramebuffer( _context,framebuffer);
  }

  return RglIsFramebufferEXT( orig, framebuffer );

}

static GLboolean REGAL_CALL filt_glIsRenderbufferEXT(Layer *_layer, GLuint renderbuffer)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    return orig.glIsRenderbuffer( _context,renderbuffer);
  }

  return RglIsRenderbufferEXT( orig, renderbuffer );

}

static void REGAL_CALL filt_glLineStipple(Layer *_layer, GLint factor, GLushort pattern)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glLineStipple for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglLineStipple( orig, factor, pattern );

}

static void REGAL_CALL filt_glLineWidth(Layer *_layer, GLfloat width)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isCore())
  {
     Warning("Regal does not support glLineWidth for core profile - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglLineWidth( orig, width );

}

static void REGAL_CALL filt_glMap1d(Layer *_layer, GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMap1d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglMap1d( orig, target, u1, u2, stride, order, points );

}

static void REGAL_CALL filt_glMap1f(Layer *_layer, GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMap1f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglMap1f( orig, target, u1, u2, stride, order, points );

}

static void REGAL_CALL filt_glMap2d(Layer *_layer, GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMap2d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglMap2d( orig, target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points );

}

static void REGAL_CALL filt_glMap2f(Layer *_layer, GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMap2f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglMap2f( orig, target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points );

}

static GLvoid *REGAL_CALL filt_glMapBuffer(Layer *_layer, GLenum target, GLenum access)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    return orig.glMapBufferOES( _context,target, access);
  }

  return RglMapBuffer( orig, target, access );

}

static GLvoid *REGAL_CALL filt_glMapBufferARB(Layer *_layer, GLenum target, GLenum access)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    return orig.glMapBufferOES( _context,target, access);
  }

  return RglMapBufferARB( orig, target, access );

}

static void REGAL_CALL filt_glMapGrid1d(Layer *_layer, GLint un, GLdouble u1, GLdouble u2)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMapGrid1d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglMapGrid1d( orig, un, u1, u2 );

}

static void REGAL_CALL filt_glMapGrid1f(Layer *_layer, GLint un, GLfloat u1, GLfloat u2)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMapGrid1f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglMapGrid1f( orig, un, u1, u2 );

}

static void REGAL_CALL filt_glMapGrid2d(Layer *_layer, GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMapGrid2d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglMapGrid2d( orig, un, u1, u2, vn, v1, v2 );

}

static void REGAL_CALL filt_glMapGrid2f(Layer *_layer, GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMapGrid2f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglMapGrid2f( orig, un, u1, u2, vn, v1, v2 );

}

static void REGAL_CALL filt_glNewList(Layer *_layer, GLuint list, GLenum mode)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glNewList for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglNewList( orig, list, mode );

}

static void REGAL_CALL filt_glPixelStoref(Layer *_layer, GLenum pname, GLfloat param)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glPixelStoref for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglPixelStoref( orig, pname, param );

}

static void REGAL_CALL filt_glPixelStorei(Layer *_layer, GLenum pname, GLint param)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->PixelStorei(*_context, pname, param))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglPixelStorei( orig, pname, param );

}

static void REGAL_CALL filt_glPixelTransferf(Layer *_layer, GLenum pname, GLfloat param)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glPixelTransferf for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglPixelTransferf( orig, pname, param );

}

static void REGAL_CALL filt_glPixelTransferi(Layer *_layer, GLenum pname, GLint param)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glPixelTransferi for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglPixelTransferi( orig, pname, param );

}

static void REGAL_CALL filt_glPixelZoom(Layer *_layer, GLfloat xfactor, GLfloat yfactor)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glPixelZoom for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglPixelZoom( orig, xfactor, yfactor );

}

static void REGAL_CALL filt_glPolygonMode(Layer *_layer, GLenum face, GLenum mode)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->PolygonMode(*_context, face, mode))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglPolygonMode( orig, face, mode );

}

static void REGAL_CALL filt_glPopGroupMarkerEXT(Layer *_layer)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if( ! _context->info->gl_ext_debug_marker ) {
    return;
  }

  RglPopGroupMarkerEXT( orig );

}

static void REGAL_CALL filt_glProgramStringARB(Layer *_layer, GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glProgramStringARB (GL_ARB_vertex_program) for ES 2.0 context - skipping.");
    return;
  }

  RglProgramStringARB( orig, target, format, len, string );

}

static void REGAL_CALL filt_glPushGroupMarkerEXT(Layer *_layer, GLsizei length, const GLchar *marker)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if( ! _context->info->gl_ext_debug_marker ) {
    return;
  }

  RglPushGroupMarkerEXT( orig, length, marker );

}

static void REGAL_CALL filt_glRasterPos2d(Layer *_layer, GLdouble x, GLdouble y)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos2d( orig, x, y );

}

static void REGAL_CALL filt_glRasterPos2dv(Layer *_layer, const GLdouble *v)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2dv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos2dv( orig, v );

}

static void REGAL_CALL filt_glRasterPos2f(Layer *_layer, GLfloat x, GLfloat y)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos2f( orig, x, y );

}

static void REGAL_CALL filt_glRasterPos2fv(Layer *_layer, const GLfloat *v)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2fv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos2fv( orig, v );

}

static void REGAL_CALL filt_glRasterPos2i(Layer *_layer, GLint x, GLint y)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2i for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos2i( orig, x, y );

}

static void REGAL_CALL filt_glRasterPos2iv(Layer *_layer, const GLint *v)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2iv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos2iv( orig, v );

}

static void REGAL_CALL filt_glRasterPos2s(Layer *_layer, GLshort x, GLshort y)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2s for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos2s( orig, x, y );

}

static void REGAL_CALL filt_glRasterPos2sv(Layer *_layer, const GLshort *v)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2sv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos2sv( orig, v );

}

static void REGAL_CALL filt_glRasterPos3d(Layer *_layer, GLdouble x, GLdouble y, GLdouble z)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos3d( orig, x, y, z );

}

static void REGAL_CALL filt_glRasterPos3dv(Layer *_layer, const GLdouble *v)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3dv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos3dv( orig, v );

}

static void REGAL_CALL filt_glRasterPos3f(Layer *_layer, GLfloat x, GLfloat y, GLfloat z)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos3f( orig, x, y, z );

}

static void REGAL_CALL filt_glRasterPos3fv(Layer *_layer, const GLfloat *v)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3fv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos3fv( orig, v );

}

static void REGAL_CALL filt_glRasterPos3i(Layer *_layer, GLint x, GLint y, GLint z)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3i for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos3i( orig, x, y, z );

}

static void REGAL_CALL filt_glRasterPos3iv(Layer *_layer, const GLint *v)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3iv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos3iv( orig, v );

}

static void REGAL_CALL filt_glRasterPos3s(Layer *_layer, GLshort x, GLshort y, GLshort z)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3s for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos3s( orig, x, y, z );

}

static void REGAL_CALL filt_glRasterPos3sv(Layer *_layer, const GLshort *v)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3sv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos3sv( orig, v );

}

static void REGAL_CALL filt_glRasterPos4d(Layer *_layer, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos4d( orig, x, y, z, w );

}

static void REGAL_CALL filt_glRasterPos4dv(Layer *_layer, const GLdouble *v)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4dv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos4dv( orig, v );

}

static void REGAL_CALL filt_glRasterPos4f(Layer *_layer, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos4f( orig, x, y, z, w );

}

static void REGAL_CALL filt_glRasterPos4fv(Layer *_layer, const GLfloat *v)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4fv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos4fv( orig, v );

}

static void REGAL_CALL filt_glRasterPos4i(Layer *_layer, GLint x, GLint y, GLint z, GLint w)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4i for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos4i( orig, x, y, z, w );

}

static void REGAL_CALL filt_glRasterPos4iv(Layer *_layer, const GLint *v)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4iv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos4iv( orig, v );

}

static void REGAL_CALL filt_glRasterPos4s(Layer *_layer, GLshort x, GLshort y, GLshort z, GLshort w)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4s for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos4s( orig, x, y, z, w );

}

static void REGAL_CALL filt_glRasterPos4sv(Layer *_layer, const GLshort *v)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4sv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRasterPos4sv( orig, v );

}

static void REGAL_CALL filt_glReadBuffer(Layer *_layer, GLenum mode)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->ReadBuffer(*_context, mode))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }
  if (_context->isES2() && _context->info->gl_nv_read_buffer)
    orig.glReadBufferNV( _context,mode);
  else
    orig.glReadBuffer( _context,mode);
  return;

  RglReadBuffer( orig, mode );

}

static void REGAL_CALL filt_glRectd(Layer *_layer, GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRectd for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRectd( orig, x1, y1, x2, y2 );

}

static void REGAL_CALL filt_glRectf(Layer *_layer, GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRectf for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRectf( orig, x1, y1, x2, y2 );

}

static void REGAL_CALL filt_glRecti(Layer *_layer, GLint x1, GLint y1, GLint x2, GLint y2)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRecti for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRecti( orig, x1, y1, x2, y2 );

}

static void REGAL_CALL filt_glRects(Layer *_layer, GLshort x1, GLshort y1, GLshort x2, GLshort y2)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRects for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglRects( orig, x1, y1, x2, y2 );

}

static GLint REGAL_CALL filt_glRenderMode(Layer *_layer, GLenum mode)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->RenderMode(*_context, mode))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return (( GLint  )0);
  }

  return RglRenderMode( orig, mode );

}

static void REGAL_CALL filt_glRenderbufferStorageEXT(Layer *_layer, GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    orig.glRenderbufferStorage( _context,target, internalformat, width, height);
    return;
  }

  RglRenderbufferStorageEXT( orig, target, internalformat, width, height );

}

static void REGAL_CALL filt_glShadeModel(Layer *_layer, GLenum mode)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glShadeModel for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglShadeModel( orig, mode );

}

static void REGAL_CALL filt_glTexImage1D(Layer *_layer, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glTexImage1D for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglTexImage1D( orig, target, level, internalformat, width, border, format, type, pixels );

}

static void REGAL_CALL filt_glTexImage2D(Layer *_layer, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->filt->TexImage2D(*_context, target, level, internalformat, width, height, border, format, type, pixels))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglTexImage2D( orig, target, level, internalformat, width, height, border, format, type, pixels );

}

static void REGAL_CALL filt_glTexImage3D(Layer *_layer, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glTexImage3D for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

  RglTexImage3D( orig, target, level, internalformat, width, height, depth, border, format, type, pixels );

}

static void REGAL_CALL filt_glTexParameterf(Layer *_layer, GLenum target, GLenum pname, GLfloat param)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl

  if (_context->filt->TexParameter(*_context, target, pname))
    return;
  GLfloat newparam;
  if (_context->filt->FilterTexParameter(*_context, target, pname, static_cast<GLfloat>(param), newparam))
    orig.glTexParameterf( _context, target, pname, newparam);
  else
    orig.glTexParameterf( _context, target, pname, param);
  return;

  RglTexParameterf( orig, target, pname, param );

}

static void REGAL_CALL filt_glTexParameterfv(Layer *_layer, GLenum target, GLenum pname, const GLfloat *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl

  if (_context->filt->TexParameter(*_context, target, pname))
    return;
  GLfloat newparam;
  if (params && _context->filt->FilterTexParameter(*_context, target, pname, static_cast<GLfloat>(params[0]), newparam))
    orig.glTexParameterf( _context, target, pname, newparam);
  else
    orig.glTexParameterfv( _context, target, pname, params);
  return;

  RglTexParameterfv( orig, target, pname, params );

}

static void REGAL_CALL filt_glTexParameteri(Layer *_layer, GLenum target, GLenum pname, GLint param)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl

  if (_context->filt->TexParameter(*_context, target, pname))
    return;
  GLfloat newparam;
  if (_context->filt->FilterTexParameter(*_context, target, pname, static_cast<GLfloat>(param), newparam))
    orig.glTexParameterf( _context, target, pname, newparam);
  else
    orig.glTexParameteri( _context, target, pname, param);
  return;

  RglTexParameteri( orig, target, pname, param );

}

static void REGAL_CALL filt_glTexParameteriv(Layer *_layer, GLenum target, GLenum pname, const GLint *params)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl

  if (_context->filt->TexParameter(*_context, target, pname))
    return;
  GLfloat newparam;
  if (params && _context->filt->FilterTexParameter(*_context, target, pname, static_cast<GLfloat>(params[0]), newparam))
    orig.glTexParameterf( _context, target, pname, newparam);
  else
    orig.glTexParameteriv( _context, target, pname, params);
  return;

  RglTexParameteriv( orig, target, pname, params );

}

static void REGAL_CALL filt_glUniform1iARB(Layer *_layer, GLint location, GLint v0)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    orig.glUniform1i( _context,location, v0);
    return;
  }

  RglUniform1iARB( orig, location, v0 );

}

static GLboolean REGAL_CALL filt_glUnmapBuffer(Layer *_layer, GLenum target)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    return orig.glUnmapBufferOES( _context,target);
  }

  return RglUnmapBuffer( orig, target );

}

static GLboolean REGAL_CALL filt_glUnmapBufferARB(Layer *_layer, GLenum target)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2())
  {
    return orig.glUnmapBufferOES( _context,target);
  }

  return RglUnmapBufferARB( orig, target );

}

static void REGAL_CALL filt_glWindowPos2d(Layer *_layer, GLdouble x, GLdouble y)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos2d( orig, x, y );

}

static void REGAL_CALL filt_glWindowPos2dv(Layer *_layer, const GLdouble *p)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2dv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos2dv( orig, p );

}

static void REGAL_CALL filt_glWindowPos2f(Layer *_layer, GLfloat x, GLfloat y)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos2f( orig, x, y );

}

static void REGAL_CALL filt_glWindowPos2fv(Layer *_layer, const GLfloat *p)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2fv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos2fv( orig, p );

}

static void REGAL_CALL filt_glWindowPos2i(Layer *_layer, GLint x, GLint y)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2i for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos2i( orig, x, y );

}

static void REGAL_CALL filt_glWindowPos2iv(Layer *_layer, const GLint *p)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2iv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos2iv( orig, p );

}

static void REGAL_CALL filt_glWindowPos2s(Layer *_layer, GLshort x, GLshort y)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2s for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos2s( orig, x, y );

}

static void REGAL_CALL filt_glWindowPos2sv(Layer *_layer, const GLshort *p)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2sv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos2sv( orig, p );

}

static void REGAL_CALL filt_glWindowPos3d(Layer *_layer, GLdouble x, GLdouble y, GLdouble z)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos3d( orig, x, y, z );

}

static void REGAL_CALL filt_glWindowPos3dv(Layer *_layer, const GLdouble *p)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3dv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos3dv( orig, p );

}

static void REGAL_CALL filt_glWindowPos3f(Layer *_layer, GLfloat x, GLfloat y, GLfloat z)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos3f( orig, x, y, z );

}

static void REGAL_CALL filt_glWindowPos3fv(Layer *_layer, const GLfloat *p)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3fv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos3fv( orig, p );

}

static void REGAL_CALL filt_glWindowPos3i(Layer *_layer, GLint x, GLint y, GLint z)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3i for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos3i( orig, x, y, z );

}

static void REGAL_CALL filt_glWindowPos3iv(Layer *_layer, const GLint *p)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3iv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos3iv( orig, p );

}

static void REGAL_CALL filt_glWindowPos3s(Layer *_layer, GLshort x, GLshort y, GLshort z)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3s for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos3s( orig, x, y, z );

}

static void REGAL_CALL filt_glWindowPos3sv(Layer *_layer, const GLshort *p)
{
  Filt * self = static_cast<Filt *>(_layer);

  FiltOriginate & orig = self->orig;

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3sv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

  RglWindowPos3sv( orig, p );

}

void FiltIntercept( Layer *layer, Dispatch::GL & dt ) {
  dt.glAccum                                  = MakeRegalProc(filt_glAccum, layer);
  dt.glActiveTextureARB                       = MakeRegalProc(filt_glActiveTextureARB, layer);
  dt.glAttachObjectARB                        = MakeRegalProc(filt_glAttachObjectARB, layer);
  dt.glBindAttribLocationARB                  = MakeRegalProc(filt_glBindAttribLocationARB, layer);
  dt.glBindFramebuffer                        = MakeRegalProc(filt_glBindFramebuffer, layer);
  dt.glBindFramebufferEXT                     = MakeRegalProc(filt_glBindFramebufferEXT, layer);
  dt.glBindFramebufferOES                     = MakeRegalProc(filt_glBindFramebufferOES, layer);
  dt.glBindProgramARB                         = MakeRegalProc(filt_glBindProgramARB, layer);
  dt.glBindRenderbufferEXT                    = MakeRegalProc(filt_glBindRenderbufferEXT, layer);
  dt.glBindTexture                            = MakeRegalProc(filt_glBindTexture, layer);
  dt.glBitmap                                 = MakeRegalProc(filt_glBitmap, layer);
  dt.glBlendColorEXT                          = MakeRegalProc(filt_glBlendColorEXT, layer);
  dt.glBlendEquationEXT                       = MakeRegalProc(filt_glBlendEquationEXT, layer);
  dt.glBlitFramebuffer                        = MakeRegalProc(filt_glBlitFramebuffer, layer);
  dt.glBlitFramebufferANGLE                   = MakeRegalProc(filt_glBlitFramebufferANGLE, layer);
  dt.glBlitFramebufferEXT                     = MakeRegalProc(filt_glBlitFramebufferEXT, layer);
  dt.glBufferDataARB                          = MakeRegalProc(filt_glBufferDataARB, layer);
  dt.glCallList                               = MakeRegalProc(filt_glCallList, layer);
  dt.glCheckFramebufferStatusEXT              = MakeRegalProc(filt_glCheckFramebufferStatusEXT, layer);
  dt.glClearAccum                             = MakeRegalProc(filt_glClearAccum, layer);
  dt.glClientActiveTexture                    = MakeRegalProc(filt_glClientActiveTexture, layer);
  dt.glClientActiveTextureARB                 = MakeRegalProc(filt_glClientActiveTextureARB, layer);
  dt.glColorMaskIndexedEXT                    = MakeRegalProc(filt_glColorMaskIndexedEXT, layer);
  dt.glCompileShaderARB                       = MakeRegalProc(filt_glCompileShaderARB, layer);
  dt.glCopyPixels                             = MakeRegalProc(filt_glCopyPixels, layer);
  dt.glCreateProgramObjectARB                 = MakeRegalProc(filt_glCreateProgramObjectARB, layer);
  dt.glDeleteFramebuffersEXT                  = MakeRegalProc(filt_glDeleteFramebuffersEXT, layer);
  dt.glDeleteLists                            = MakeRegalProc(filt_glDeleteLists, layer);
  dt.glDeleteRenderbuffersEXT                 = MakeRegalProc(filt_glDeleteRenderbuffersEXT, layer);
  dt.glDisableIndexedEXT                      = MakeRegalProc(filt_glDisableIndexedEXT, layer);
  dt.glDrawBuffer                             = MakeRegalProc(filt_glDrawBuffer, layer);
  dt.glDrawBuffers                            = MakeRegalProc(filt_glDrawBuffers, layer);
  dt.glDrawBuffersARB                         = MakeRegalProc(filt_glDrawBuffersARB, layer);
  dt.glDrawBuffersATI                         = MakeRegalProc(filt_glDrawBuffersATI, layer);
  dt.glDrawPixels                             = MakeRegalProc(filt_glDrawPixels, layer);
  dt.glDrawRangeElements                      = MakeRegalProc(filt_glDrawRangeElements, layer);
  dt.glDrawRangeElementsBaseVertex            = MakeRegalProc(filt_glDrawRangeElementsBaseVertex, layer);
  dt.glEdgeFlag                               = MakeRegalProc(filt_glEdgeFlag, layer);
  dt.glEnableIndexedEXT                       = MakeRegalProc(filt_glEnableIndexedEXT, layer);
  dt.glEndList                                = MakeRegalProc(filt_glEndList, layer);
  dt.glEvalCoord1d                            = MakeRegalProc(filt_glEvalCoord1d, layer);
  dt.glEvalCoord1dv                           = MakeRegalProc(filt_glEvalCoord1dv, layer);
  dt.glEvalCoord1f                            = MakeRegalProc(filt_glEvalCoord1f, layer);
  dt.glEvalCoord1fv                           = MakeRegalProc(filt_glEvalCoord1fv, layer);
  dt.glEvalCoord2d                            = MakeRegalProc(filt_glEvalCoord2d, layer);
  dt.glEvalCoord2dv                           = MakeRegalProc(filt_glEvalCoord2dv, layer);
  dt.glEvalCoord2f                            = MakeRegalProc(filt_glEvalCoord2f, layer);
  dt.glEvalCoord2fv                           = MakeRegalProc(filt_glEvalCoord2fv, layer);
  dt.glEvalMesh1                              = MakeRegalProc(filt_glEvalMesh1, layer);
  dt.glEvalMesh2                              = MakeRegalProc(filt_glEvalMesh2, layer);
  dt.glEvalPoint1                             = MakeRegalProc(filt_glEvalPoint1, layer);
  dt.glEvalPoint2                             = MakeRegalProc(filt_glEvalPoint2, layer);
  dt.glFramebufferRenderbuffer                = MakeRegalProc(filt_glFramebufferRenderbuffer, layer);
  dt.glFramebufferRenderbufferEXT             = MakeRegalProc(filt_glFramebufferRenderbufferEXT, layer);
  dt.glFramebufferTexture1D                   = MakeRegalProc(filt_glFramebufferTexture1D, layer);
  dt.glFramebufferTexture1DEXT                = MakeRegalProc(filt_glFramebufferTexture1DEXT, layer);
  dt.glFramebufferTexture2D                   = MakeRegalProc(filt_glFramebufferTexture2D, layer);
  dt.glFramebufferTexture2DEXT                = MakeRegalProc(filt_glFramebufferTexture2DEXT, layer);
  dt.glFramebufferTexture3D                   = MakeRegalProc(filt_glFramebufferTexture3D, layer);
  dt.glFramebufferTexture3DEXT                = MakeRegalProc(filt_glFramebufferTexture3DEXT, layer);
  dt.glGenFramebuffersEXT                     = MakeRegalProc(filt_glGenFramebuffersEXT, layer);
  dt.glGenLists                               = MakeRegalProc(filt_glGenLists, layer);
  dt.glGenProgramsARB                         = MakeRegalProc(filt_glGenProgramsARB, layer);
  dt.glGenRenderbuffersEXT                    = MakeRegalProc(filt_glGenRenderbuffersEXT, layer);
  dt.glGenSamplers                            = MakeRegalProc(filt_glGenSamplers, layer);
  dt.glGenerateMipmap                         = MakeRegalProc(filt_glGenerateMipmap, layer);
  dt.glGenerateMipmapEXT                      = MakeRegalProc(filt_glGenerateMipmapEXT, layer);
  dt.glGetBooleanIndexedvEXT                  = MakeRegalProc(filt_glGetBooleanIndexedvEXT, layer);
  dt.glGetBooleanv                            = MakeRegalProc(filt_glGetBooleanv, layer);
  dt.glGetDoublev                             = MakeRegalProc(filt_glGetDoublev, layer);
  dt.glGetFloatv                              = MakeRegalProc(filt_glGetFloatv, layer);
  dt.glGetFramebufferAttachmentParameteriv    = MakeRegalProc(filt_glGetFramebufferAttachmentParameteriv, layer);
  dt.glGetFramebufferAttachmentParameterivEXT = MakeRegalProc(filt_glGetFramebufferAttachmentParameterivEXT, layer);
  dt.glGetInfoLogARB                          = MakeRegalProc(filt_glGetInfoLogARB, layer);
  dt.glGetInteger64v                          = MakeRegalProc(filt_glGetInteger64v, layer);
  dt.glGetIntegerIndexedvEXT                  = MakeRegalProc(filt_glGetIntegerIndexedvEXT, layer);
  dt.glGetIntegerv                            = MakeRegalProc(filt_glGetIntegerv, layer);
  dt.glGetObjectParameterivARB                = MakeRegalProc(filt_glGetObjectParameterivARB, layer);
  dt.glGetProgramivARB                        = MakeRegalProc(filt_glGetProgramivARB, layer);
  dt.glGetRenderbufferParameterivEXT          = MakeRegalProc(filt_glGetRenderbufferParameterivEXT, layer);
  dt.glGetTexImage                            = MakeRegalProc(filt_glGetTexImage, layer);
  dt.glGetTexLevelParameterfv                 = MakeRegalProc(filt_glGetTexLevelParameterfv, layer);
  dt.glGetTexLevelParameteriv                 = MakeRegalProc(filt_glGetTexLevelParameteriv, layer);
  dt.glGetTexParameteriv                      = MakeRegalProc(filt_glGetTexParameteriv, layer);
  dt.glGetUniformLocationARB                  = MakeRegalProc(filt_glGetUniformLocationARB, layer);
  dt.glIsEnabledIndexedEXT                    = MakeRegalProc(filt_glIsEnabledIndexedEXT, layer);
  dt.glIsFramebufferEXT                       = MakeRegalProc(filt_glIsFramebufferEXT, layer);
  dt.glIsRenderbufferEXT                      = MakeRegalProc(filt_glIsRenderbufferEXT, layer);
  dt.glLineStipple                            = MakeRegalProc(filt_glLineStipple, layer);
  dt.glLineWidth                              = MakeRegalProc(filt_glLineWidth, layer);
  dt.glMap1d                                  = MakeRegalProc(filt_glMap1d, layer);
  dt.glMap1f                                  = MakeRegalProc(filt_glMap1f, layer);
  dt.glMap2d                                  = MakeRegalProc(filt_glMap2d, layer);
  dt.glMap2f                                  = MakeRegalProc(filt_glMap2f, layer);
  dt.glMapBuffer                              = MakeRegalProc(filt_glMapBuffer, layer);
  dt.glMapBufferARB                           = MakeRegalProc(filt_glMapBufferARB, layer);
  dt.glMapGrid1d                              = MakeRegalProc(filt_glMapGrid1d, layer);
  dt.glMapGrid1f                              = MakeRegalProc(filt_glMapGrid1f, layer);
  dt.glMapGrid2d                              = MakeRegalProc(filt_glMapGrid2d, layer);
  dt.glMapGrid2f                              = MakeRegalProc(filt_glMapGrid2f, layer);
  dt.glNewList                                = MakeRegalProc(filt_glNewList, layer);
  dt.glPixelStoref                            = MakeRegalProc(filt_glPixelStoref, layer);
  dt.glPixelStorei                            = MakeRegalProc(filt_glPixelStorei, layer);
  dt.glPixelTransferf                         = MakeRegalProc(filt_glPixelTransferf, layer);
  dt.glPixelTransferi                         = MakeRegalProc(filt_glPixelTransferi, layer);
  dt.glPixelZoom                              = MakeRegalProc(filt_glPixelZoom, layer);
  dt.glPolygonMode                            = MakeRegalProc(filt_glPolygonMode, layer);
  dt.glPopGroupMarkerEXT                      = MakeRegalProc(filt_glPopGroupMarkerEXT, layer);
  dt.glProgramStringARB                       = MakeRegalProc(filt_glProgramStringARB, layer);
  dt.glPushGroupMarkerEXT                     = MakeRegalProc(filt_glPushGroupMarkerEXT, layer);
  dt.glRasterPos2d                            = MakeRegalProc(filt_glRasterPos2d, layer);
  dt.glRasterPos2dv                           = MakeRegalProc(filt_glRasterPos2dv, layer);
  dt.glRasterPos2f                            = MakeRegalProc(filt_glRasterPos2f, layer);
  dt.glRasterPos2fv                           = MakeRegalProc(filt_glRasterPos2fv, layer);
  dt.glRasterPos2i                            = MakeRegalProc(filt_glRasterPos2i, layer);
  dt.glRasterPos2iv                           = MakeRegalProc(filt_glRasterPos2iv, layer);
  dt.glRasterPos2s                            = MakeRegalProc(filt_glRasterPos2s, layer);
  dt.glRasterPos2sv                           = MakeRegalProc(filt_glRasterPos2sv, layer);
  dt.glRasterPos3d                            = MakeRegalProc(filt_glRasterPos3d, layer);
  dt.glRasterPos3dv                           = MakeRegalProc(filt_glRasterPos3dv, layer);
  dt.glRasterPos3f                            = MakeRegalProc(filt_glRasterPos3f, layer);
  dt.glRasterPos3fv                           = MakeRegalProc(filt_glRasterPos3fv, layer);
  dt.glRasterPos3i                            = MakeRegalProc(filt_glRasterPos3i, layer);
  dt.glRasterPos3iv                           = MakeRegalProc(filt_glRasterPos3iv, layer);
  dt.glRasterPos3s                            = MakeRegalProc(filt_glRasterPos3s, layer);
  dt.glRasterPos3sv                           = MakeRegalProc(filt_glRasterPos3sv, layer);
  dt.glRasterPos4d                            = MakeRegalProc(filt_glRasterPos4d, layer);
  dt.glRasterPos4dv                           = MakeRegalProc(filt_glRasterPos4dv, layer);
  dt.glRasterPos4f                            = MakeRegalProc(filt_glRasterPos4f, layer);
  dt.glRasterPos4fv                           = MakeRegalProc(filt_glRasterPos4fv, layer);
  dt.glRasterPos4i                            = MakeRegalProc(filt_glRasterPos4i, layer);
  dt.glRasterPos4iv                           = MakeRegalProc(filt_glRasterPos4iv, layer);
  dt.glRasterPos4s                            = MakeRegalProc(filt_glRasterPos4s, layer);
  dt.glRasterPos4sv                           = MakeRegalProc(filt_glRasterPos4sv, layer);
  dt.glReadBuffer                             = MakeRegalProc(filt_glReadBuffer, layer);
  dt.glRectd                                  = MakeRegalProc(filt_glRectd, layer);
  dt.glRectf                                  = MakeRegalProc(filt_glRectf, layer);
  dt.glRecti                                  = MakeRegalProc(filt_glRecti, layer);
  dt.glRects                                  = MakeRegalProc(filt_glRects, layer);
  dt.glRenderMode                             = MakeRegalProc(filt_glRenderMode, layer);
  dt.glRenderbufferStorageEXT                 = MakeRegalProc(filt_glRenderbufferStorageEXT, layer);
  dt.glShadeModel                             = MakeRegalProc(filt_glShadeModel, layer);
  dt.glTexImage1D                             = MakeRegalProc(filt_glTexImage1D, layer);
  dt.glTexImage2D                             = MakeRegalProc(filt_glTexImage2D, layer);
  dt.glTexImage3D                             = MakeRegalProc(filt_glTexImage3D, layer);
  dt.glTexParameterf                          = MakeRegalProc(filt_glTexParameterf, layer);
  dt.glTexParameterfv                         = MakeRegalProc(filt_glTexParameterfv, layer);
  dt.glTexParameteri                          = MakeRegalProc(filt_glTexParameteri, layer);
  dt.glTexParameteriv                         = MakeRegalProc(filt_glTexParameteriv, layer);
  dt.glUniform1iARB                           = MakeRegalProc(filt_glUniform1iARB, layer);
  dt.glUnmapBuffer                            = MakeRegalProc(filt_glUnmapBuffer, layer);
  dt.glUnmapBufferARB                         = MakeRegalProc(filt_glUnmapBufferARB, layer);
  dt.glWindowPos2d                            = MakeRegalProc(filt_glWindowPos2d, layer);
  dt.glWindowPos2dv                           = MakeRegalProc(filt_glWindowPos2dv, layer);
  dt.glWindowPos2f                            = MakeRegalProc(filt_glWindowPos2f, layer);
  dt.glWindowPos2fv                           = MakeRegalProc(filt_glWindowPos2fv, layer);
  dt.glWindowPos2i                            = MakeRegalProc(filt_glWindowPos2i, layer);
  dt.glWindowPos2iv                           = MakeRegalProc(filt_glWindowPos2iv, layer);
  dt.glWindowPos2s                            = MakeRegalProc(filt_glWindowPos2s, layer);
  dt.glWindowPos2sv                           = MakeRegalProc(filt_glWindowPos2sv, layer);
  dt.glWindowPos3d                            = MakeRegalProc(filt_glWindowPos3d, layer);
  dt.glWindowPos3dv                           = MakeRegalProc(filt_glWindowPos3dv, layer);
  dt.glWindowPos3f                            = MakeRegalProc(filt_glWindowPos3f, layer);
  dt.glWindowPos3fv                           = MakeRegalProc(filt_glWindowPos3fv, layer);
  dt.glWindowPos3i                            = MakeRegalProc(filt_glWindowPos3i, layer);
  dt.glWindowPos3iv                           = MakeRegalProc(filt_glWindowPos3iv, layer);
  dt.glWindowPos3s                            = MakeRegalProc(filt_glWindowPos3s, layer);
  dt.glWindowPos3sv                           = MakeRegalProc(filt_glWindowPos3sv, layer);
}

REGAL_NAMESPACE_END

#endif // REGAL_EMULATION
