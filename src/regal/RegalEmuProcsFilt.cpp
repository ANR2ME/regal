/* NOTE: Do not edit this file, it is generated by a script:
   Export.py --api gl 4.4 --api wgl 4.4 --api glx 4.4 --api cgl 1.4 --api egl 1.0 --outdir .
*/

/*
  Copyright (c) 2011-2013 NVIDIA Corporation
  Copyright (c) 2011-2013 Cass Everitt
  Copyright (c) 2012-2013 Scott Nations
  Copyright (c) 2012 Mathias Schott
  Copyright (c) 2012-2013 Nigel Stewart
  Copyright (c) 2012-2013 Google Inc.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
  Intended formatting conventions:
  $ astyle --style=allman --indent=spaces=2 --indent-switches
*/

#include "RegalUtil.h"

#if REGAL_EMULATION

REGAL_GLOBAL_BEGIN

#include "RegalPrivate.h"
#include "RegalContext.h"
#include "RegalDispatch.h"
#include "RegalFilt.h"
#include "RegalEmuProcsFilt.h"

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

static void REGAL_CALL emuProcInterceptFilt_glAccum(GLenum op, GLfloat value)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glAccum for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glActiveTextureARB(GLenum texture)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_arb_multitexture)
  {
    _context->filt->orig.glActiveTexture(texture);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    _context->filt->orig.glAttachShader(containerObj, obj);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    _context->filt->orig.glBindAttribLocation(programObj, index, name);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glBindFramebuffer(GLenum target, GLuint framebuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2())
  {
    const bool hasFBBlit = _context->info->gl_ext_framebuffer_blit || _context->info->gl_nv_framebuffer_blit || _context->info->gl_version_major >= 3;
    if (!hasFBBlit && (target==GL_DRAW_FRAMEBUFFER || target==GL_READ_FRAMEBUFFER)) target = GL_FRAMEBUFFER;
  }
  if (_context->filt->BindFramebuffer(*_context, target, framebuffer))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glBindFramebufferEXT(GLenum target, GLuint framebuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    _context->filt->orig.glBindFramebuffer(target, framebuffer);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glBindFramebufferOES(GLenum target, GLuint framebuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2())
  {
    const bool hasFBBlit = _context->info->gl_ext_framebuffer_blit || _context->info->gl_nv_framebuffer_blit || _context->info->gl_version_major >= 3;
    if (!hasFBBlit && (target==GL_DRAW_FRAMEBUFFER || target==GL_READ_FRAMEBUFFER)) target = GL_FRAMEBUFFER;
  }
  if (_context->filt->BindFramebuffer(*_context, target, framebuffer))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glBindProgramARB(GLenum target, GLuint program)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glBindProgramARB (GL_ARB_vertex_program) for ES 2.0 context - skipping.");
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    _context->filt->orig.glBindRenderbuffer(target, renderbuffer);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glBindTexture(GLenum target, GLuint texture)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->filt->BindTexture(*_context, target, texture))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glBitmap for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2())
  {
    _context->filt->orig.glBlendColor(red, green, blue, alpha);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glBlendEquationEXT(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2())
  {
    _context->filt->orig.glBlendEquation(mode);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2())
  {
    if (_context->info->gl_nv_framebuffer_blit)  return _context->filt->orig.glBlitFramebufferNV(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    if (_context->info->gl_ext_framebuffer_blit) return _context->filt->orig.glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
  }

}

static void REGAL_CALL emuProcInterceptFilt_glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glBlitFramebufferANGLE for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_blit)
  {
    _context->emuLevel++;
    _context->filt->orig.glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2())
  {
    _context->filt->orig.glBufferData(target, size, data, usage);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glCallList(GLuint list)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glCallList for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static GLenum REGAL_CALL emuProcInterceptFilt_glCheckFramebufferStatusEXT(GLenum target)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    return _context->filt->orig.glCheckFramebufferStatus(target);
  }

}

static void REGAL_CALL emuProcInterceptFilt_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glClearAccum for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glClientActiveTexture(GLenum texture)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glClientActiveTexture for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glClientActiveTextureARB(GLenum texture)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_arb_multitexture)
  {
    _context->emuLevel++;
    _context->filt->orig.glClientActiveTexture(texture);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glColorMaskIndexedEXT(GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2)
  {
    if (!buf)  {
      _context->filt->orig.glColorMask(r, g, b, a);
    }
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glCompileShaderARB(GLhandleARB shaderObj)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    _context->filt->orig.glCompileShader(shaderObj);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glCopyPixels for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static GLhandleARB REGAL_CALL emuProcInterceptFilt_glCreateProgramObjectARB(void)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    return _context->filt->orig.glCreateProgram();
  }

}

static void REGAL_CALL emuProcInterceptFilt_glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    _context->filt->orig.glDeleteFramebuffers(n, framebuffers);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glDeleteLists(GLuint list, GLsizei range)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glDeleteLists for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    _context->filt->orig.glDeleteRenderbuffers(n, renderbuffers);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glDisableIndexedEXT(GLenum target, GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (target==GL_BLEND && (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2))
  {
    if (!index)  {
      _context->filt->orig.glDisable(target);
    }
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glDrawBuffer(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2())
  {
    if (_context->info->gl_nv_framebuffer_blit || _context->info->gl_ext_framebuffer_blit)
      return _context->filt->orig.glDrawBuffer(mode);
  }

}

static void REGAL_CALL emuProcInterceptFilt_glDrawBuffers(GLsizei n, const GLenum *bufs)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->filt->DrawBuffers(*_context, n, bufs))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }
  if (_context->isES2())
  {
    if (_context->info->gl_nv_draw_buffers)
    {
      _context->filt->orig.glDrawBuffersNV(n, bufs);
      return;
    }
  }

}

static void REGAL_CALL emuProcInterceptFilt_glDrawBuffersARB(GLsizei n, const GLenum *bufs)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_arb_draw_buffers)
  {
    _context->emuLevel++;
    _context->filt->orig.glDrawBuffers(n, bufs);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glDrawBuffersATI(GLsizei n, const GLenum *bufs)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ati_draw_buffers)
  {
    _context->emuLevel++;
    _context->filt->orig.glDrawBuffers(n, bufs);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glDrawPixels for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2())
  {
    return _context->filt->orig.glDrawElements(mode, count, type, indices);
  }

}

static void REGAL_CALL emuProcInterceptFilt_glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_arb_draw_elements_base_vertex)
  {
    if (basevertex==0)
    {
      return _context->filt->orig.glDrawElements(mode, count, type, indices);
    }
    else
    {
      Warning("Regal does not support glDrawRangeElementsBaseVertex (GL_ARB_draw_elements_base_vertex extension not available) for basevertex!=0 for ES 2.0 - skipping.");
      return;
    }
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEdgeFlag(GLboolean flag)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEdgeFlag for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEnableIndexedEXT(GLenum target, GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (target==GL_BLEND && (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2))
  {
    if (!index)  {
      _context->filt->orig.glEnable(target);
    }
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEndList(void)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEndList for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEvalCoord1d(GLdouble u)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord1d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEvalCoord1dv(const GLdouble *u)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord1dv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEvalCoord1f(GLfloat u)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord1f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEvalCoord1fv(const GLfloat *u)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord1fv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEvalCoord2d(GLdouble u, GLdouble v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord2d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEvalCoord2dv(const GLdouble *u)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord2dv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEvalCoord2f(GLfloat u, GLfloat v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord2f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEvalCoord2fv(const GLfloat *u)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalCoord2fv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEvalMesh1(GLenum mode, GLint i1, GLint i2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalMesh1 for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalMesh2 for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEvalPoint1(GLint i)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalPoint1 for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glEvalPoint2(GLint i, GLint j)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glEvalPoint2 for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->filt->FramebufferAttachmentSupported(*_context, attachment))
    _context->filt->orig.glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
  return;

}

static void REGAL_CALL emuProcInterceptFilt_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    _context->filt->orig.glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->filt->FramebufferAttachmentSupported(*_context, attachment))
    _context->filt->orig.glFramebufferTexture1D(target, attachment, textarget, texture, level);
  return;

}

static void REGAL_CALL emuProcInterceptFilt_glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    _context->filt->orig.glFramebufferTexture1D(target, attachment, textarget, texture, level);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->filt->FramebufferTexture2D(*_context, target, attachment, textarget, texture, level))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    _context->filt->orig.glFramebufferTexture2D(target, attachment, textarget, texture, level);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->filt->FramebufferAttachmentSupported(*_context, attachment))
    _context->filt->orig.glFramebufferTexture3D(target, attachment, textarget, texture, level, layer);
  return;

}

static void REGAL_CALL emuProcInterceptFilt_glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    _context->filt->orig.glFramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    _context->filt->orig.glGenFramebuffers(n, framebuffers);
    return;
  }

}

static GLuint REGAL_CALL emuProcInterceptFilt_glGenLists(GLsizei range)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glGenLists for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return (( GLuint  )0);
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGenProgramsARB(GLsizei n, GLuint *programs)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glGenProgramsARB (GL_ARB_vertex_program) for ES 2.0 context - skipping.");
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    _context->filt->orig.glGenRenderbuffers(n, renderbuffers);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGenSamplers(GLsizei count, GLuint *samplers)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glGenSamplers for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGenerateMipmap(GLenum target)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->filt->GenerateMipmap(*_context, target))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGenerateMipmapEXT(GLenum target)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    _context->filt->orig.glGenerateMipmap(target);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetBooleanIndexedvEXT(GLenum value, GLuint index, GLboolean *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2)
  {
    if (!index)  {
      _context->filt->orig.glGetBooleanv(value,data);
    }
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetBooleanv(GLenum pname, GLboolean *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->filt->Get(*_context, pname, params))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetDoublev(GLenum pname, GLdouble *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->filt->Get(*_context, pname, params))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetFloatv(GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->filt->Get(*_context, pname, params))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->filt->FramebufferAttachmentSupported(*_context, attachment))
    *params = 0;
  else
    _context->filt->orig.glGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
  return;

}

static void REGAL_CALL emuProcInterceptFilt_glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    _context->filt->orig.glGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    if (_context->filt->orig.glIsProgram(obj))
      _context->filt->orig.glGetProgramInfoLog(obj, maxLength, length, infoLog);
    else
      _context->filt->orig.glGetShaderInfoLog(obj, maxLength, length, infoLog);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetInteger64v(GLenum pname, GLint64 *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->filt->Get(*_context, pname, params))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetIntegerIndexedvEXT(GLenum value, GLuint index, GLint *data)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (REGAL_FORCE_ES2_PROFILE || !_context->info->gl_ext_draw_buffers2)
  {
    if (!index)  {
      _context->filt->orig.glGetIntegerv(value,data);
    }
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetIntegerv(GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->filt->Get(*_context, pname, params))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    if (_context->filt->orig.glIsProgram(obj))
      _context->filt->orig.glGetProgramiv(obj, pname, params);
    else
      _context->filt->orig.glGetShaderiv(obj, pname, params);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetProgramivARB(GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glGetProgramivARB (GL_ARB_vertex_program) for ES 2.0 context - skipping.");
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    _context->filt->orig.glGetRenderbufferParameteriv(target, pname, params);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glGetTexImage for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glGetTexLevelParameterfv for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glGetTexLevelParameteriv for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->filt->GetTexParameteriv(*_context, target, pname, params))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static GLint REGAL_CALL emuProcInterceptFilt_glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    return _context->filt->orig.glGetUniformLocation(programObj, name);
  }

}

static GLboolean REGAL_CALL emuProcInterceptFilt_glIsEnabledIndexedEXT(GLenum target, GLuint index)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (target==GL_BLEND && !_context->info->gl_ext_draw_buffers2)
  {
    if (!index)  {
      return _context->filt->orig.glIsEnabled(target);
    }
    return GL_FALSE;
  }

}

static GLboolean REGAL_CALL emuProcInterceptFilt_glIsFramebufferEXT(GLuint framebuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    return _context->filt->orig.glIsFramebuffer(framebuffer);
  }

}

static GLboolean REGAL_CALL emuProcInterceptFilt_glIsRenderbufferEXT(GLuint renderbuffer)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    return _context->filt->orig.glIsRenderbuffer(renderbuffer);
  }

}

static void REGAL_CALL emuProcInterceptFilt_glLineStipple(GLint factor, GLushort pattern)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glLineStipple for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glLineWidth(GLfloat width)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isCore())
  {
     Warning("Regal does not support glLineWidth for core profile - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMap1d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMap1f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMap2d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMap2f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static GLvoid *REGAL_CALL emuProcInterceptFilt_glMapBuffer(GLenum target, GLenum access)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2())
  {
    return _context->filt->orig.glMapBufferOES(target, access);
  }

}

static GLvoid *REGAL_CALL emuProcInterceptFilt_glMapBufferARB(GLenum target, GLenum access)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2())
  {
    return _context->filt->orig.glMapBufferOES(target, access);
  }

}

static void REGAL_CALL emuProcInterceptFilt_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMapGrid1d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMapGrid1f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMapGrid2d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glMapGrid2f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glNewList(GLuint list, GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glNewList for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glPixelStoref(GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glPixelStoref for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glPixelStorei(GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->filt->PixelStorei(*_context, pname, param))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glPixelTransferf(GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glPixelTransferf for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glPixelTransferi(GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glPixelTransferi for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glPixelZoom(GLfloat xfactor, GLfloat yfactor)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glPixelZoom for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glPolygonMode(GLenum face, GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->filt->PolygonMode(*_context, face, mode))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glPopGroupMarkerEXT(void)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if( ! _context->info->gl_ext_debug_marker ) {
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glProgramStringARB (GL_ARB_vertex_program) for ES 2.0 context - skipping.");
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glPushGroupMarkerEXT(GLsizei length, const GLchar *marker)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if( ! _context->info->gl_ext_debug_marker ) {
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos2d(GLdouble x, GLdouble y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos2dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2dv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos2f(GLfloat x, GLfloat y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos2fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2fv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos2i(GLint x, GLint y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2i for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos2iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2iv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos2s(GLshort x, GLshort y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2s for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos2sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos2sv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos3dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3dv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos3fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3fv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos3i(GLint x, GLint y, GLint z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3i for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos3iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3iv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos3s(GLshort x, GLshort y, GLshort z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3s for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos3sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos3sv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos4dv(const GLdouble *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4dv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos4fv(const GLfloat *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4fv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4i for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos4iv(const GLint *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4iv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4s for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRasterPos4sv(const GLshort *v)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRasterPos4sv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glReadBuffer(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->filt->ReadBuffer(*_context, mode))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }
  if (_context->isES2() && _context->info->gl_nv_read_buffer)
    _context->filt->orig.glReadBufferNV(mode);
  else
    _context->filt->orig.glReadBuffer(mode);
  return;

}

static void REGAL_CALL emuProcInterceptFilt_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRectd for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRectf for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRecti for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glRects for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static GLint REGAL_CALL emuProcInterceptFilt_glRenderMode(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->filt->RenderMode(*_context, mode))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return (( GLint  )0);
  }

}

static void REGAL_CALL emuProcInterceptFilt_glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (!_context->info->gl_ext_framebuffer_object)
  {
    _context->emuLevel++;
    _context->filt->orig.glRenderbufferStorage(target, internalformat, width, height);
    return;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glShadeModel(GLenum mode)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glShadeModel for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glTexImage1D for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->filt->TexImage2D(*_context, target, level, internalformat, width, height, border, format, type, pixels))
  {
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2())
  {
    Warning("Regal does not support glTexImage3D for ES 2.0 - skipping.");
    #if REGAL_BREAK
    Break::Filter();
    #endif
    return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl

  if (_context->filt->TexParameter(*_context, target, pname))
    return;
  GLfloat newparam;
  if (_context->filt->FilterTexParameter(*_context, target, pname, static_cast<GLfloat>(param), newparam))
    _context->filt->orig.glTexParameterf(target, pname, newparam);
  else
    _context->filt->orig.glTexParameterf(target, pname, param);
  return;

}

static void REGAL_CALL emuProcInterceptFilt_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl

  if (_context->filt->TexParameter(*_context, target, pname))
    return;
  GLfloat newparam;
  if (params && _context->filt->FilterTexParameter(*_context, target, pname, static_cast<GLfloat>(params[0]), newparam))
    _context->filt->orig.glTexParameterf(target, pname, newparam);
  else
    _context->filt->orig.glTexParameterfv(target, pname, params);
  return;

}

static void REGAL_CALL emuProcInterceptFilt_glTexParameteri(GLenum target, GLenum pname, GLint param)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl

  if (_context->filt->TexParameter(*_context, target, pname))
    return;
  GLfloat newparam;
  if (_context->filt->FilterTexParameter(*_context, target, pname, static_cast<GLfloat>(param), newparam))
    _context->filt->orig.glTexParameterf(target, pname, newparam);
  else
    _context->filt->orig.glTexParameteri(target, pname, param);
  return;

}

static void REGAL_CALL emuProcInterceptFilt_glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl

  if (_context->filt->TexParameter(*_context, target, pname))
    return;
  GLfloat newparam;
  if (params && _context->filt->FilterTexParameter(*_context, target, pname, static_cast<GLfloat>(params[0]), newparam))
    _context->filt->orig.glTexParameterf(target, pname, newparam);
  else
    _context->filt->orig.glTexParameteriv(target, pname, params);
  return;

}

static void REGAL_CALL emuProcInterceptFilt_glUniform1iARB(GLint location, GLint v0)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2() || !_context->info->gl_arb_shader_objects)
  {
    _context->filt->orig.glUniform1i(location, v0);
    return;
  }

}

static GLboolean REGAL_CALL emuProcInterceptFilt_glUnmapBuffer(GLenum target)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2())
  {
    return _context->filt->orig.glUnmapBufferOES(target);
  }

}

static GLboolean REGAL_CALL emuProcInterceptFilt_glUnmapBufferARB(GLenum target)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);
  EmuProcsOriginateFilt & orig = _context->filt->orig;

  // impl
  if (_context->isES2())
  {
    return _context->filt->orig.glUnmapBufferOES(target);
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos2d(GLdouble x, GLdouble y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos2dv(const GLdouble *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2dv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos2f(GLfloat x, GLfloat y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos2fv(const GLfloat *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2fv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos2i(GLint x, GLint y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2i for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos2iv(const GLint *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2iv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos2s(GLshort x, GLshort y)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2s for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos2sv(const GLshort *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos2sv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3d for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos3dv(const GLdouble *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3dv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3f for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos3fv(const GLfloat *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3fv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos3i(GLint x, GLint y, GLint z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3i for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos3iv(const GLint *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3iv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos3s(GLshort x, GLshort y, GLshort z)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3s for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

static void REGAL_CALL emuProcInterceptFilt_glWindowPos3sv(const GLshort *p)
{
  RegalContext *_context = REGAL_GET_CONTEXT();
  RegalAssert(_context);

  // impl
  if (_context->isES2() || _context->isCore())
  {
     Warning("Regal does not support glWindowPos3sv for core or ES2 profiles - skipping.");
     #if REGAL_BREAK
     Break::Filter();
     #endif
     return ;
  }

}

void EmuProcsInterceptFilt( Dispatch::GL & dt ) {
  dt.glAccum                                  = emuProcInterceptFilt_glAccum;
  dt.glActiveTextureARB                       = emuProcInterceptFilt_glActiveTextureARB;
  dt.glAttachObjectARB                        = emuProcInterceptFilt_glAttachObjectARB;
  dt.glBindAttribLocationARB                  = emuProcInterceptFilt_glBindAttribLocationARB;
  dt.glBindFramebuffer                        = emuProcInterceptFilt_glBindFramebuffer;
  dt.glBindFramebufferEXT                     = emuProcInterceptFilt_glBindFramebufferEXT;
  dt.glBindFramebufferOES                     = emuProcInterceptFilt_glBindFramebufferOES;
  dt.glBindProgramARB                         = emuProcInterceptFilt_glBindProgramARB;
  dt.glBindRenderbufferEXT                    = emuProcInterceptFilt_glBindRenderbufferEXT;
  dt.glBindTexture                            = emuProcInterceptFilt_glBindTexture;
  dt.glBitmap                                 = emuProcInterceptFilt_glBitmap;
  dt.glBlendColorEXT                          = emuProcInterceptFilt_glBlendColorEXT;
  dt.glBlendEquationEXT                       = emuProcInterceptFilt_glBlendEquationEXT;
  dt.glBlitFramebuffer                        = emuProcInterceptFilt_glBlitFramebuffer;
  dt.glBlitFramebufferANGLE                   = emuProcInterceptFilt_glBlitFramebufferANGLE;
  dt.glBlitFramebufferEXT                     = emuProcInterceptFilt_glBlitFramebufferEXT;
  dt.glBufferDataARB                          = emuProcInterceptFilt_glBufferDataARB;
  dt.glCallList                               = emuProcInterceptFilt_glCallList;
  dt.glCheckFramebufferStatusEXT              = emuProcInterceptFilt_glCheckFramebufferStatusEXT;
  dt.glClearAccum                             = emuProcInterceptFilt_glClearAccum;
  dt.glClientActiveTexture                    = emuProcInterceptFilt_glClientActiveTexture;
  dt.glClientActiveTextureARB                 = emuProcInterceptFilt_glClientActiveTextureARB;
  dt.glColorMaskIndexedEXT                    = emuProcInterceptFilt_glColorMaskIndexedEXT;
  dt.glCompileShaderARB                       = emuProcInterceptFilt_glCompileShaderARB;
  dt.glCopyPixels                             = emuProcInterceptFilt_glCopyPixels;
  dt.glCreateProgramObjectARB                 = emuProcInterceptFilt_glCreateProgramObjectARB;
  dt.glDeleteFramebuffersEXT                  = emuProcInterceptFilt_glDeleteFramebuffersEXT;
  dt.glDeleteLists                            = emuProcInterceptFilt_glDeleteLists;
  dt.glDeleteRenderbuffersEXT                 = emuProcInterceptFilt_glDeleteRenderbuffersEXT;
  dt.glDisableIndexedEXT                      = emuProcInterceptFilt_glDisableIndexedEXT;
  dt.glDrawBuffer                             = emuProcInterceptFilt_glDrawBuffer;
  dt.glDrawBuffers                            = emuProcInterceptFilt_glDrawBuffers;
  dt.glDrawBuffersARB                         = emuProcInterceptFilt_glDrawBuffersARB;
  dt.glDrawBuffersATI                         = emuProcInterceptFilt_glDrawBuffersATI;
  dt.glDrawPixels                             = emuProcInterceptFilt_glDrawPixels;
  dt.glDrawRangeElements                      = emuProcInterceptFilt_glDrawRangeElements;
  dt.glDrawRangeElementsBaseVertex            = emuProcInterceptFilt_glDrawRangeElementsBaseVertex;
  dt.glEdgeFlag                               = emuProcInterceptFilt_glEdgeFlag;
  dt.glEnableIndexedEXT                       = emuProcInterceptFilt_glEnableIndexedEXT;
  dt.glEndList                                = emuProcInterceptFilt_glEndList;
  dt.glEvalCoord1d                            = emuProcInterceptFilt_glEvalCoord1d;
  dt.glEvalCoord1dv                           = emuProcInterceptFilt_glEvalCoord1dv;
  dt.glEvalCoord1f                            = emuProcInterceptFilt_glEvalCoord1f;
  dt.glEvalCoord1fv                           = emuProcInterceptFilt_glEvalCoord1fv;
  dt.glEvalCoord2d                            = emuProcInterceptFilt_glEvalCoord2d;
  dt.glEvalCoord2dv                           = emuProcInterceptFilt_glEvalCoord2dv;
  dt.glEvalCoord2f                            = emuProcInterceptFilt_glEvalCoord2f;
  dt.glEvalCoord2fv                           = emuProcInterceptFilt_glEvalCoord2fv;
  dt.glEvalMesh1                              = emuProcInterceptFilt_glEvalMesh1;
  dt.glEvalMesh2                              = emuProcInterceptFilt_glEvalMesh2;
  dt.glEvalPoint1                             = emuProcInterceptFilt_glEvalPoint1;
  dt.glEvalPoint2                             = emuProcInterceptFilt_glEvalPoint2;
  dt.glFramebufferRenderbuffer                = emuProcInterceptFilt_glFramebufferRenderbuffer;
  dt.glFramebufferRenderbufferEXT             = emuProcInterceptFilt_glFramebufferRenderbufferEXT;
  dt.glFramebufferTexture1D                   = emuProcInterceptFilt_glFramebufferTexture1D;
  dt.glFramebufferTexture1DEXT                = emuProcInterceptFilt_glFramebufferTexture1DEXT;
  dt.glFramebufferTexture2D                   = emuProcInterceptFilt_glFramebufferTexture2D;
  dt.glFramebufferTexture2DEXT                = emuProcInterceptFilt_glFramebufferTexture2DEXT;
  dt.glFramebufferTexture3D                   = emuProcInterceptFilt_glFramebufferTexture3D;
  dt.glFramebufferTexture3DEXT                = emuProcInterceptFilt_glFramebufferTexture3DEXT;
  dt.glGenFramebuffersEXT                     = emuProcInterceptFilt_glGenFramebuffersEXT;
  dt.glGenLists                               = emuProcInterceptFilt_glGenLists;
  dt.glGenProgramsARB                         = emuProcInterceptFilt_glGenProgramsARB;
  dt.glGenRenderbuffersEXT                    = emuProcInterceptFilt_glGenRenderbuffersEXT;
  dt.glGenSamplers                            = emuProcInterceptFilt_glGenSamplers;
  dt.glGenerateMipmap                         = emuProcInterceptFilt_glGenerateMipmap;
  dt.glGenerateMipmapEXT                      = emuProcInterceptFilt_glGenerateMipmapEXT;
  dt.glGetBooleanIndexedvEXT                  = emuProcInterceptFilt_glGetBooleanIndexedvEXT;
  dt.glGetBooleanv                            = emuProcInterceptFilt_glGetBooleanv;
  dt.glGetDoublev                             = emuProcInterceptFilt_glGetDoublev;
  dt.glGetFloatv                              = emuProcInterceptFilt_glGetFloatv;
  dt.glGetFramebufferAttachmentParameteriv    = emuProcInterceptFilt_glGetFramebufferAttachmentParameteriv;
  dt.glGetFramebufferAttachmentParameterivEXT = emuProcInterceptFilt_glGetFramebufferAttachmentParameterivEXT;
  dt.glGetInfoLogARB                          = emuProcInterceptFilt_glGetInfoLogARB;
  dt.glGetInteger64v                          = emuProcInterceptFilt_glGetInteger64v;
  dt.glGetIntegerIndexedvEXT                  = emuProcInterceptFilt_glGetIntegerIndexedvEXT;
  dt.glGetIntegerv                            = emuProcInterceptFilt_glGetIntegerv;
  dt.glGetObjectParameterivARB                = emuProcInterceptFilt_glGetObjectParameterivARB;
  dt.glGetProgramivARB                        = emuProcInterceptFilt_glGetProgramivARB;
  dt.glGetRenderbufferParameterivEXT          = emuProcInterceptFilt_glGetRenderbufferParameterivEXT;
  dt.glGetTexImage                            = emuProcInterceptFilt_glGetTexImage;
  dt.glGetTexLevelParameterfv                 = emuProcInterceptFilt_glGetTexLevelParameterfv;
  dt.glGetTexLevelParameteriv                 = emuProcInterceptFilt_glGetTexLevelParameteriv;
  dt.glGetTexParameteriv                      = emuProcInterceptFilt_glGetTexParameteriv;
  dt.glGetUniformLocationARB                  = emuProcInterceptFilt_glGetUniformLocationARB;
  dt.glIsEnabledIndexedEXT                    = emuProcInterceptFilt_glIsEnabledIndexedEXT;
  dt.glIsFramebufferEXT                       = emuProcInterceptFilt_glIsFramebufferEXT;
  dt.glIsRenderbufferEXT                      = emuProcInterceptFilt_glIsRenderbufferEXT;
  dt.glLineStipple                            = emuProcInterceptFilt_glLineStipple;
  dt.glLineWidth                              = emuProcInterceptFilt_glLineWidth;
  dt.glMap1d                                  = emuProcInterceptFilt_glMap1d;
  dt.glMap1f                                  = emuProcInterceptFilt_glMap1f;
  dt.glMap2d                                  = emuProcInterceptFilt_glMap2d;
  dt.glMap2f                                  = emuProcInterceptFilt_glMap2f;
  dt.glMapBuffer                              = emuProcInterceptFilt_glMapBuffer;
  dt.glMapBufferARB                           = emuProcInterceptFilt_glMapBufferARB;
  dt.glMapGrid1d                              = emuProcInterceptFilt_glMapGrid1d;
  dt.glMapGrid1f                              = emuProcInterceptFilt_glMapGrid1f;
  dt.glMapGrid2d                              = emuProcInterceptFilt_glMapGrid2d;
  dt.glMapGrid2f                              = emuProcInterceptFilt_glMapGrid2f;
  dt.glNewList                                = emuProcInterceptFilt_glNewList;
  dt.glPixelStoref                            = emuProcInterceptFilt_glPixelStoref;
  dt.glPixelStorei                            = emuProcInterceptFilt_glPixelStorei;
  dt.glPixelTransferf                         = emuProcInterceptFilt_glPixelTransferf;
  dt.glPixelTransferi                         = emuProcInterceptFilt_glPixelTransferi;
  dt.glPixelZoom                              = emuProcInterceptFilt_glPixelZoom;
  dt.glPolygonMode                            = emuProcInterceptFilt_glPolygonMode;
  dt.glPopGroupMarkerEXT                      = emuProcInterceptFilt_glPopGroupMarkerEXT;
  dt.glProgramStringARB                       = emuProcInterceptFilt_glProgramStringARB;
  dt.glPushGroupMarkerEXT                     = emuProcInterceptFilt_glPushGroupMarkerEXT;
  dt.glRasterPos2d                            = emuProcInterceptFilt_glRasterPos2d;
  dt.glRasterPos2dv                           = emuProcInterceptFilt_glRasterPos2dv;
  dt.glRasterPos2f                            = emuProcInterceptFilt_glRasterPos2f;
  dt.glRasterPos2fv                           = emuProcInterceptFilt_glRasterPos2fv;
  dt.glRasterPos2i                            = emuProcInterceptFilt_glRasterPos2i;
  dt.glRasterPos2iv                           = emuProcInterceptFilt_glRasterPos2iv;
  dt.glRasterPos2s                            = emuProcInterceptFilt_glRasterPos2s;
  dt.glRasterPos2sv                           = emuProcInterceptFilt_glRasterPos2sv;
  dt.glRasterPos3d                            = emuProcInterceptFilt_glRasterPos3d;
  dt.glRasterPos3dv                           = emuProcInterceptFilt_glRasterPos3dv;
  dt.glRasterPos3f                            = emuProcInterceptFilt_glRasterPos3f;
  dt.glRasterPos3fv                           = emuProcInterceptFilt_glRasterPos3fv;
  dt.glRasterPos3i                            = emuProcInterceptFilt_glRasterPos3i;
  dt.glRasterPos3iv                           = emuProcInterceptFilt_glRasterPos3iv;
  dt.glRasterPos3s                            = emuProcInterceptFilt_glRasterPos3s;
  dt.glRasterPos3sv                           = emuProcInterceptFilt_glRasterPos3sv;
  dt.glRasterPos4d                            = emuProcInterceptFilt_glRasterPos4d;
  dt.glRasterPos4dv                           = emuProcInterceptFilt_glRasterPos4dv;
  dt.glRasterPos4f                            = emuProcInterceptFilt_glRasterPos4f;
  dt.glRasterPos4fv                           = emuProcInterceptFilt_glRasterPos4fv;
  dt.glRasterPos4i                            = emuProcInterceptFilt_glRasterPos4i;
  dt.glRasterPos4iv                           = emuProcInterceptFilt_glRasterPos4iv;
  dt.glRasterPos4s                            = emuProcInterceptFilt_glRasterPos4s;
  dt.glRasterPos4sv                           = emuProcInterceptFilt_glRasterPos4sv;
  dt.glReadBuffer                             = emuProcInterceptFilt_glReadBuffer;
  dt.glRectd                                  = emuProcInterceptFilt_glRectd;
  dt.glRectf                                  = emuProcInterceptFilt_glRectf;
  dt.glRecti                                  = emuProcInterceptFilt_glRecti;
  dt.glRects                                  = emuProcInterceptFilt_glRects;
  dt.glRenderMode                             = emuProcInterceptFilt_glRenderMode;
  dt.glRenderbufferStorageEXT                 = emuProcInterceptFilt_glRenderbufferStorageEXT;
  dt.glShadeModel                             = emuProcInterceptFilt_glShadeModel;
  dt.glTexImage1D                             = emuProcInterceptFilt_glTexImage1D;
  dt.glTexImage2D                             = emuProcInterceptFilt_glTexImage2D;
  dt.glTexImage3D                             = emuProcInterceptFilt_glTexImage3D;
  dt.glTexParameterf                          = emuProcInterceptFilt_glTexParameterf;
  dt.glTexParameterfv                         = emuProcInterceptFilt_glTexParameterfv;
  dt.glTexParameteri                          = emuProcInterceptFilt_glTexParameteri;
  dt.glTexParameteriv                         = emuProcInterceptFilt_glTexParameteriv;
  dt.glUniform1iARB                           = emuProcInterceptFilt_glUniform1iARB;
  dt.glUnmapBuffer                            = emuProcInterceptFilt_glUnmapBuffer;
  dt.glUnmapBufferARB                         = emuProcInterceptFilt_glUnmapBufferARB;
  dt.glWindowPos2d                            = emuProcInterceptFilt_glWindowPos2d;
  dt.glWindowPos2dv                           = emuProcInterceptFilt_glWindowPos2dv;
  dt.glWindowPos2f                            = emuProcInterceptFilt_glWindowPos2f;
  dt.glWindowPos2fv                           = emuProcInterceptFilt_glWindowPos2fv;
  dt.glWindowPos2i                            = emuProcInterceptFilt_glWindowPos2i;
  dt.glWindowPos2iv                           = emuProcInterceptFilt_glWindowPos2iv;
  dt.glWindowPos2s                            = emuProcInterceptFilt_glWindowPos2s;
  dt.glWindowPos2sv                           = emuProcInterceptFilt_glWindowPos2sv;
  dt.glWindowPos3d                            = emuProcInterceptFilt_glWindowPos3d;
  dt.glWindowPos3dv                           = emuProcInterceptFilt_glWindowPos3dv;
  dt.glWindowPos3f                            = emuProcInterceptFilt_glWindowPos3f;
  dt.glWindowPos3fv                           = emuProcInterceptFilt_glWindowPos3fv;
  dt.glWindowPos3i                            = emuProcInterceptFilt_glWindowPos3i;
  dt.glWindowPos3iv                           = emuProcInterceptFilt_glWindowPos3iv;
  dt.glWindowPos3s                            = emuProcInterceptFilt_glWindowPos3s;
  dt.glWindowPos3sv                           = emuProcInterceptFilt_glWindowPos3sv;
}

REGAL_NAMESPACE_END

#endif // REGAL_EMULATION
