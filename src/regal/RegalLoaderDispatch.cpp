/* NOTE: Do not edit this file, it is generated by a script:
   Export.py --api gl 4.2 --api wgl 4.0 --api glx 4.0 --api cgl 1.4 --api egl 1.0 --outdir src/regal
*/

/*
  Copyright (c) 2011 NVIDIA Corporation
  Copyright (c) 2011-2012 Cass Everitt
  Copyright (c) 2012 Scott Nations
  Copyright (c) 2012 Mathias Schott
  Copyright (c) 2012 Nigel Stewart
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "pch.h" /* For MS precompiled header support */

#include "RegalUtil.h"

REGAL_GLOBAL_BEGIN

#include <string>
using namespace std;

#include "RegalLog.h"
#include "RegalToken.h"
#include "RegalHelper.h"
#include "RegalPrivate.h"
#include "RegalContext.h"

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

using namespace Logging;
using Token::toString;

inline bool fileExists(const char *path)
{
  FILE *f = fopen(path,"r");
  if (f)
    fclose(f);
  return f != NULL;
}

inline const char * getEnvironment(const char * const var)
{
  const char *ret = NULL;

  if (var) {
    ret = GetEnv(var);

    /* Treat empty environment variable the same as non-existant */
    if (!ret || *ret=='\0')
      return NULL;
  }

  return ret;
}

static
string libraryLocation(const char *lib)
{
  const char *ret = NULL;

  if (!strcmp(lib, "GL") || !strcmp(lib, "WGL") || !strcmp(lib, "GLX")) {
    // First, try ... variable

    // Second, try default installation location

    if (!ret) {
#if REGAL_SYS_OSX
      ret = "/System/Library/Frameworks/OpenGL.framework/OpenGL";
#endif

#if REGAL_SYS_WGL
      ret = getEnvironment("windir");

      /* XP32, Cygwin */
      if (!ret)
        ret = getEnvironment("WINDIR");

      if (ret) {
        return string(ret) + "\\system32\\opengl32.dll";
      }
#endif

#if REGAL_SYS_GLX

#if defined(__x86_64__) || defined(__x86_64)
      const char * const candidates[] = {
        "/usr/lib/amd64/libGL.so.1",              // Solaris
        "/usr/lib64/nvidia/libGL.so.1",           // RedHat
        "/usr/lib64/libGL.so.1",                  // RedHat
        "/usr/lib/nvidia-current/libGL.so.1",     // Ubuntu NVIDIA
        "/usr/lib/libGL.so.1",                    // Ubuntu
        NULL
      };
#else
      const char * const candidates[] = {
        "/usr/lib32/nvidia-current/libGL.so.1",   // Ubuntu NVIDIA
        "/usr/lib32/libGL.so.1",                  // Ubuntu
        "/usr/lib/libGL.so.1",                    // RedHat & Solaris
        NULL
      };
#endif
      for (const char * const *i = candidates; *i; ++i) {
        if (fileExists(*i))
          return *i;
      }
#endif
    }
  }
  return ret;
}

#if REGAL_SYS_OSX

#include <dlfcn.h>

void * RegalGetProcAddress( const char * entry )
{
    static string lib_OpenGL_filename;
    static void  *lib_OpenGL = NULL;

    static string lib_GL_filename;
    static void  *lib_GL = NULL;

    if( lib_OpenGL == NULL || lib_GL == NULL ) {
        // this chdir business is a hacky solution to avoid recursion
        // when using libRegal as libGL via symlink and DYLD_LIBRARY_PATH=.

        char old_cwd[256];
        getcwd( old_cwd, sizeof( old_cwd ) );
        chdir( "/" );

        // CGL entry point are in OpenGL framework

        if (!lib_OpenGL) {
            lib_OpenGL_filename = "/System/Library/Frameworks/OpenGL.framework/OpenGL";
            lib_OpenGL = dlopen(lib_OpenGL_filename.c_str() , RTLD_LAZY);
            Info("Loading OpenGL from ",lib_OpenGL_filename,lib_OpenGL ? " succeeded." : " failed.");
        }

        // GL entry point are in libGL.dylib

        if (!lib_GL) {
            lib_GL_filename = "/System/Library/Frameworks/OpenGL.framework/Libraries/libGL.dylib";
            lib_GL = dlopen(lib_GL_filename.c_str(), RTLD_LAZY);
            Info("Loading OpenGL from ",lib_GL_filename,lib_GL ? " succeeded." : " failed.");
        }
        chdir( old_cwd );
    }
    if (lib_OpenGL && lib_GL) {
        void * sym;
        sym = dlsym( lib_OpenGL, entry );
        if (sym) {
            return sym;
        }
        sym = dlsym( lib_GL, entry );
        return sym;
    }
    return NULL;
}

#elif REGAL_SYS_IOS

#include <dlfcn.h>

void * RegalGetProcAddress( const char * entry )
{
    static void * lib_OpenGLES = NULL;
    if (lib_OpenGLES == NULL) {
        lib_OpenGLES = dlopen( "/System/Library/Frameworks/OpenGLES.framework/OpenGLES", RTLD_LAZY );
    }
    if (lib_OpenGLES) {
        void * sym;
        sym = dlsym( lib_OpenGLES, entry );
        return sym;
    }
    return NULL;
}

#elif REGAL_SYS_GLX

#include <dlfcn.h>

void * RegalGetProcAddress( const char * entry )
{
    static void * lib_GL = NULL;
    static string lib_GL_filename;
    if (!lib_GL_filename.length()) {
        lib_GL_filename = libraryLocation("GL");
    }
    if (!lib_GL && lib_GL_filename.length()) {
        Info("Loading OpenGL from ",lib_GL_filename);
        lib_GL = dlopen( lib_GL_filename.c_str(), RTLD_LAZY );
    }
    if (lib_GL) {
        void * sym;
        sym = dlsym( lib_GL, entry );
        return sym;
    }
    return NULL;
}

#elif REGAL_SYS_ANDROID

#include <dlfcn.h>

void * RegalGetProcAddress( const char * entry )
{
    static void * lib_EGL = NULL;
    static void * lib_GLESv2 = NULL;
    if (lib_GLESv2 == NULL) {
        lib_GLESv2 = dlopen( "/system/lib/libGLESv2.so", RTLD_LAZY );
    }
    if (lib_EGL == NULL) {
        lib_EGL = dlopen( "/system/lib/libEGL.so", RTLD_LAZY );
    }
    if (lib_GLESv2 && lib_EGL) {
        void * sym;
        sym = dlsym( lib_GLESv2, entry );
        if (!sym) {
            sym = dlsym( lib_EGL, entry );
        }
        return sym;
    }
    return NULL;
}

#elif REGAL_SYS_WGL

typedef void *HMODULE;

extern "C" {
  HMODULE __stdcall LoadLibraryA(const char *filename);
  void *  __stdcall GetProcAddress(HMODULE hModule, const char *proc);
}

void *RegalGetProcAddress( const char * entry )
{
    static HMODULE lib_GL = 0;
    static PROC (__stdcall *wglGetProcAddress)(LPCSTR lpszProc);
    static string lib_GL_filename;
    if (!lib_GL_filename.length()) {
        lib_GL_filename = libraryLocation("GL");
    }
    if (!lib_GL && lib_GL_filename.length()) {
        Info("Loading OpenGL from ",lib_GL_filename);
        lib_GL = LoadLibraryA(lib_GL_filename.c_str());
    }
    if (lib_GL) {
        void * sym;
        sym = GetProcAddress( lib_GL, entry );
        if (sym)
          return sym;
        if (!wglGetProcAddress)
          wglGetProcAddress = (PROC (__stdcall *)(LPCSTR)) GetProcAddress( lib_GL, "wglGetProcAddress");
        if (wglGetProcAddress)
          return wglGetProcAddress(entry);
    }
    return NULL;
}

#endif

// GL_VERSION_1_0

static void REGAL_CALL missing_glNewList(GLuint list, GLenum mode)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glNewList" );
}

static void REGAL_CALL loader_glNewList(GLuint list, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNewList, "glNewList");
   if ( !driverTbl.glNewList ) {
      driverTbl.glNewList = missing_glNewList;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNewList == loader_glNewList) {
      rCtx->dsp.emuTbl.glNewList = driverTbl.glNewList;
   }
   driverTbl.glNewList(list, mode);
}

static void REGAL_CALL missing_glEndList(void)
{
   Warning( "Called missing function glEndList" );
}

static void REGAL_CALL loader_glEndList(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndList, "glEndList");
   if ( !driverTbl.glEndList ) {
      driverTbl.glEndList = missing_glEndList;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndList == loader_glEndList) {
      rCtx->dsp.emuTbl.glEndList = driverTbl.glEndList;
   }
   driverTbl.glEndList();
}

static void REGAL_CALL missing_glCallList(GLuint list)
{
   UNUSED_PARAMETER(list);
   Warning( "Called missing function glCallList" );
}

static void REGAL_CALL loader_glCallList(GLuint list)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCallList, "glCallList");
   if ( !driverTbl.glCallList ) {
      driverTbl.glCallList = missing_glCallList;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCallList == loader_glCallList) {
      rCtx->dsp.emuTbl.glCallList = driverTbl.glCallList;
   }
   driverTbl.glCallList(list);
}

static void REGAL_CALL missing_glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(lists);
   Warning( "Called missing function glCallLists" );
}

static void REGAL_CALL loader_glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCallLists, "glCallLists");
   if ( !driverTbl.glCallLists ) {
      driverTbl.glCallLists = missing_glCallLists;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCallLists == loader_glCallLists) {
      rCtx->dsp.emuTbl.glCallLists = driverTbl.glCallLists;
   }
   driverTbl.glCallLists(n, type, lists);
}

static void REGAL_CALL missing_glDeleteLists(GLuint list, GLsizei range)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(range);
   Warning( "Called missing function glDeleteLists" );
}

static void REGAL_CALL loader_glDeleteLists(GLuint list, GLsizei range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteLists, "glDeleteLists");
   if ( !driverTbl.glDeleteLists ) {
      driverTbl.glDeleteLists = missing_glDeleteLists;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteLists == loader_glDeleteLists) {
      rCtx->dsp.emuTbl.glDeleteLists = driverTbl.glDeleteLists;
   }
   driverTbl.glDeleteLists(list, range);
}

static GLuint REGAL_CALL missing_glGenLists(GLsizei range)
{
   UNUSED_PARAMETER(range);
   Warning( "Called missing function glGenLists" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGenLists(GLsizei range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenLists, "glGenLists");
   if ( !driverTbl.glGenLists ) {
      driverTbl.glGenLists = missing_glGenLists;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenLists == loader_glGenLists) {
      rCtx->dsp.emuTbl.glGenLists = driverTbl.glGenLists;
   }
   return driverTbl.glGenLists(range);
}

static void REGAL_CALL missing_glListBase(GLuint base)
{
   UNUSED_PARAMETER(base);
   Warning( "Called missing function glListBase" );
}

static void REGAL_CALL loader_glListBase(GLuint base)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glListBase, "glListBase");
   if ( !driverTbl.glListBase ) {
      driverTbl.glListBase = missing_glListBase;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glListBase == loader_glListBase) {
      rCtx->dsp.emuTbl.glListBase = driverTbl.glListBase;
   }
   driverTbl.glListBase(base);
}

static void REGAL_CALL missing_glBegin(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glBegin" );
}

static void REGAL_CALL loader_glBegin(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBegin, "glBegin");
   if ( !driverTbl.glBegin ) {
      driverTbl.glBegin = missing_glBegin;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBegin == loader_glBegin) {
      rCtx->dsp.emuTbl.glBegin = driverTbl.glBegin;
   }
   driverTbl.glBegin(mode);
}

static void REGAL_CALL missing_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(xorig);
   UNUSED_PARAMETER(yorig);
   UNUSED_PARAMETER(xmove);
   UNUSED_PARAMETER(ymove);
   UNUSED_PARAMETER(bitmap);
   Warning( "Called missing function glBitmap" );
}

static void REGAL_CALL loader_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBitmap, "glBitmap");
   if ( !driverTbl.glBitmap ) {
      driverTbl.glBitmap = missing_glBitmap;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBitmap == loader_glBitmap) {
      rCtx->dsp.emuTbl.glBitmap = driverTbl.glBitmap;
   }
   driverTbl.glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
}

static void REGAL_CALL missing_glColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glColor3b" );
}

static void REGAL_CALL loader_glColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3b, "glColor3b");
   if ( !driverTbl.glColor3b ) {
      driverTbl.glColor3b = missing_glColor3b;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3b == loader_glColor3b) {
      rCtx->dsp.emuTbl.glColor3b = driverTbl.glColor3b;
   }
   driverTbl.glColor3b(red, green, blue);
}

static void REGAL_CALL missing_glColor3bv(const GLbyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor3bv" );
}

static void REGAL_CALL loader_glColor3bv(const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3bv, "glColor3bv");
   if ( !driverTbl.glColor3bv ) {
      driverTbl.glColor3bv = missing_glColor3bv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3bv == loader_glColor3bv) {
      rCtx->dsp.emuTbl.glColor3bv = driverTbl.glColor3bv;
   }
   driverTbl.glColor3bv(v);
}

static void REGAL_CALL missing_glColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glColor3d" );
}

static void REGAL_CALL loader_glColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3d, "glColor3d");
   if ( !driverTbl.glColor3d ) {
      driverTbl.glColor3d = missing_glColor3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3d == loader_glColor3d) {
      rCtx->dsp.emuTbl.glColor3d = driverTbl.glColor3d;
   }
   driverTbl.glColor3d(red, green, blue);
}

static void REGAL_CALL missing_glColor3dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor3dv" );
}

static void REGAL_CALL loader_glColor3dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3dv, "glColor3dv");
   if ( !driverTbl.glColor3dv ) {
      driverTbl.glColor3dv = missing_glColor3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3dv == loader_glColor3dv) {
      rCtx->dsp.emuTbl.glColor3dv = driverTbl.glColor3dv;
   }
   driverTbl.glColor3dv(v);
}

static void REGAL_CALL missing_glColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glColor3f" );
}

static void REGAL_CALL loader_glColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3f, "glColor3f");
   if ( !driverTbl.glColor3f ) {
      driverTbl.glColor3f = missing_glColor3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3f == loader_glColor3f) {
      rCtx->dsp.emuTbl.glColor3f = driverTbl.glColor3f;
   }
   driverTbl.glColor3f(red, green, blue);
}

static void REGAL_CALL missing_glColor3fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor3fv" );
}

static void REGAL_CALL loader_glColor3fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3fv, "glColor3fv");
   if ( !driverTbl.glColor3fv ) {
      driverTbl.glColor3fv = missing_glColor3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3fv == loader_glColor3fv) {
      rCtx->dsp.emuTbl.glColor3fv = driverTbl.glColor3fv;
   }
   driverTbl.glColor3fv(v);
}

static void REGAL_CALL missing_glColor3i(GLint red, GLint green, GLint blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glColor3i" );
}

static void REGAL_CALL loader_glColor3i(GLint red, GLint green, GLint blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3i, "glColor3i");
   if ( !driverTbl.glColor3i ) {
      driverTbl.glColor3i = missing_glColor3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3i == loader_glColor3i) {
      rCtx->dsp.emuTbl.glColor3i = driverTbl.glColor3i;
   }
   driverTbl.glColor3i(red, green, blue);
}

static void REGAL_CALL missing_glColor3iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor3iv" );
}

static void REGAL_CALL loader_glColor3iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3iv, "glColor3iv");
   if ( !driverTbl.glColor3iv ) {
      driverTbl.glColor3iv = missing_glColor3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3iv == loader_glColor3iv) {
      rCtx->dsp.emuTbl.glColor3iv = driverTbl.glColor3iv;
   }
   driverTbl.glColor3iv(v);
}

static void REGAL_CALL missing_glColor3s(GLshort red, GLshort green, GLshort blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glColor3s" );
}

static void REGAL_CALL loader_glColor3s(GLshort red, GLshort green, GLshort blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3s, "glColor3s");
   if ( !driverTbl.glColor3s ) {
      driverTbl.glColor3s = missing_glColor3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3s == loader_glColor3s) {
      rCtx->dsp.emuTbl.glColor3s = driverTbl.glColor3s;
   }
   driverTbl.glColor3s(red, green, blue);
}

static void REGAL_CALL missing_glColor3sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor3sv" );
}

static void REGAL_CALL loader_glColor3sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3sv, "glColor3sv");
   if ( !driverTbl.glColor3sv ) {
      driverTbl.glColor3sv = missing_glColor3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3sv == loader_glColor3sv) {
      rCtx->dsp.emuTbl.glColor3sv = driverTbl.glColor3sv;
   }
   driverTbl.glColor3sv(v);
}

static void REGAL_CALL missing_glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glColor3ub" );
}

static void REGAL_CALL loader_glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3ub, "glColor3ub");
   if ( !driverTbl.glColor3ub ) {
      driverTbl.glColor3ub = missing_glColor3ub;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3ub == loader_glColor3ub) {
      rCtx->dsp.emuTbl.glColor3ub = driverTbl.glColor3ub;
   }
   driverTbl.glColor3ub(red, green, blue);
}

static void REGAL_CALL missing_glColor3ubv(const GLubyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor3ubv" );
}

static void REGAL_CALL loader_glColor3ubv(const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3ubv, "glColor3ubv");
   if ( !driverTbl.glColor3ubv ) {
      driverTbl.glColor3ubv = missing_glColor3ubv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3ubv == loader_glColor3ubv) {
      rCtx->dsp.emuTbl.glColor3ubv = driverTbl.glColor3ubv;
   }
   driverTbl.glColor3ubv(v);
}

static void REGAL_CALL missing_glColor3ui(GLuint red, GLuint green, GLuint blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glColor3ui" );
}

static void REGAL_CALL loader_glColor3ui(GLuint red, GLuint green, GLuint blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3ui, "glColor3ui");
   if ( !driverTbl.glColor3ui ) {
      driverTbl.glColor3ui = missing_glColor3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3ui == loader_glColor3ui) {
      rCtx->dsp.emuTbl.glColor3ui = driverTbl.glColor3ui;
   }
   driverTbl.glColor3ui(red, green, blue);
}

static void REGAL_CALL missing_glColor3uiv(const GLuint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor3uiv" );
}

static void REGAL_CALL loader_glColor3uiv(const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3uiv, "glColor3uiv");
   if ( !driverTbl.glColor3uiv ) {
      driverTbl.glColor3uiv = missing_glColor3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3uiv == loader_glColor3uiv) {
      rCtx->dsp.emuTbl.glColor3uiv = driverTbl.glColor3uiv;
   }
   driverTbl.glColor3uiv(v);
}

static void REGAL_CALL missing_glColor3us(GLushort red, GLushort green, GLushort blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glColor3us" );
}

static void REGAL_CALL loader_glColor3us(GLushort red, GLushort green, GLushort blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3us, "glColor3us");
   if ( !driverTbl.glColor3us ) {
      driverTbl.glColor3us = missing_glColor3us;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3us == loader_glColor3us) {
      rCtx->dsp.emuTbl.glColor3us = driverTbl.glColor3us;
   }
   driverTbl.glColor3us(red, green, blue);
}

static void REGAL_CALL missing_glColor3usv(const GLushort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor3usv" );
}

static void REGAL_CALL loader_glColor3usv(const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3usv, "glColor3usv");
   if ( !driverTbl.glColor3usv ) {
      driverTbl.glColor3usv = missing_glColor3usv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3usv == loader_glColor3usv) {
      rCtx->dsp.emuTbl.glColor3usv = driverTbl.glColor3usv;
   }
   driverTbl.glColor3usv(v);
}

static void REGAL_CALL missing_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glColor4b" );
}

static void REGAL_CALL loader_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4b, "glColor4b");
   if ( !driverTbl.glColor4b ) {
      driverTbl.glColor4b = missing_glColor4b;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4b == loader_glColor4b) {
      rCtx->dsp.emuTbl.glColor4b = driverTbl.glColor4b;
   }
   driverTbl.glColor4b(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4bv(const GLbyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor4bv" );
}

static void REGAL_CALL loader_glColor4bv(const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4bv, "glColor4bv");
   if ( !driverTbl.glColor4bv ) {
      driverTbl.glColor4bv = missing_glColor4bv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4bv == loader_glColor4bv) {
      rCtx->dsp.emuTbl.glColor4bv = driverTbl.glColor4bv;
   }
   driverTbl.glColor4bv(v);
}

static void REGAL_CALL missing_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glColor4d" );
}

static void REGAL_CALL loader_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4d, "glColor4d");
   if ( !driverTbl.glColor4d ) {
      driverTbl.glColor4d = missing_glColor4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4d == loader_glColor4d) {
      rCtx->dsp.emuTbl.glColor4d = driverTbl.glColor4d;
   }
   driverTbl.glColor4d(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor4dv" );
}

static void REGAL_CALL loader_glColor4dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4dv, "glColor4dv");
   if ( !driverTbl.glColor4dv ) {
      driverTbl.glColor4dv = missing_glColor4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4dv == loader_glColor4dv) {
      rCtx->dsp.emuTbl.glColor4dv = driverTbl.glColor4dv;
   }
   driverTbl.glColor4dv(v);
}

static void REGAL_CALL missing_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glColor4f" );
}

static void REGAL_CALL loader_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4f, "glColor4f");
   if ( !driverTbl.glColor4f ) {
      driverTbl.glColor4f = missing_glColor4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4f == loader_glColor4f) {
      rCtx->dsp.emuTbl.glColor4f = driverTbl.glColor4f;
   }
   driverTbl.glColor4f(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor4fv" );
}

static void REGAL_CALL loader_glColor4fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4fv, "glColor4fv");
   if ( !driverTbl.glColor4fv ) {
      driverTbl.glColor4fv = missing_glColor4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4fv == loader_glColor4fv) {
      rCtx->dsp.emuTbl.glColor4fv = driverTbl.glColor4fv;
   }
   driverTbl.glColor4fv(v);
}

static void REGAL_CALL missing_glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glColor4i" );
}

static void REGAL_CALL loader_glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4i, "glColor4i");
   if ( !driverTbl.glColor4i ) {
      driverTbl.glColor4i = missing_glColor4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4i == loader_glColor4i) {
      rCtx->dsp.emuTbl.glColor4i = driverTbl.glColor4i;
   }
   driverTbl.glColor4i(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor4iv" );
}

static void REGAL_CALL loader_glColor4iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4iv, "glColor4iv");
   if ( !driverTbl.glColor4iv ) {
      driverTbl.glColor4iv = missing_glColor4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4iv == loader_glColor4iv) {
      rCtx->dsp.emuTbl.glColor4iv = driverTbl.glColor4iv;
   }
   driverTbl.glColor4iv(v);
}

static void REGAL_CALL missing_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glColor4s" );
}

static void REGAL_CALL loader_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4s, "glColor4s");
   if ( !driverTbl.glColor4s ) {
      driverTbl.glColor4s = missing_glColor4s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4s == loader_glColor4s) {
      rCtx->dsp.emuTbl.glColor4s = driverTbl.glColor4s;
   }
   driverTbl.glColor4s(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor4sv" );
}

static void REGAL_CALL loader_glColor4sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4sv, "glColor4sv");
   if ( !driverTbl.glColor4sv ) {
      driverTbl.glColor4sv = missing_glColor4sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4sv == loader_glColor4sv) {
      rCtx->dsp.emuTbl.glColor4sv = driverTbl.glColor4sv;
   }
   driverTbl.glColor4sv(v);
}

static void REGAL_CALL missing_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glColor4ub" );
}

static void REGAL_CALL loader_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4ub, "glColor4ub");
   if ( !driverTbl.glColor4ub ) {
      driverTbl.glColor4ub = missing_glColor4ub;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4ub == loader_glColor4ub) {
      rCtx->dsp.emuTbl.glColor4ub = driverTbl.glColor4ub;
   }
   driverTbl.glColor4ub(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4ubv(const GLubyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor4ubv" );
}

static void REGAL_CALL loader_glColor4ubv(const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4ubv, "glColor4ubv");
   if ( !driverTbl.glColor4ubv ) {
      driverTbl.glColor4ubv = missing_glColor4ubv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4ubv == loader_glColor4ubv) {
      rCtx->dsp.emuTbl.glColor4ubv = driverTbl.glColor4ubv;
   }
   driverTbl.glColor4ubv(v);
}

static void REGAL_CALL missing_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glColor4ui" );
}

static void REGAL_CALL loader_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4ui, "glColor4ui");
   if ( !driverTbl.glColor4ui ) {
      driverTbl.glColor4ui = missing_glColor4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4ui == loader_glColor4ui) {
      rCtx->dsp.emuTbl.glColor4ui = driverTbl.glColor4ui;
   }
   driverTbl.glColor4ui(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4uiv(const GLuint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor4uiv" );
}

static void REGAL_CALL loader_glColor4uiv(const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4uiv, "glColor4uiv");
   if ( !driverTbl.glColor4uiv ) {
      driverTbl.glColor4uiv = missing_glColor4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4uiv == loader_glColor4uiv) {
      rCtx->dsp.emuTbl.glColor4uiv = driverTbl.glColor4uiv;
   }
   driverTbl.glColor4uiv(v);
}

static void REGAL_CALL missing_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glColor4us" );
}

static void REGAL_CALL loader_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4us, "glColor4us");
   if ( !driverTbl.glColor4us ) {
      driverTbl.glColor4us = missing_glColor4us;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4us == loader_glColor4us) {
      rCtx->dsp.emuTbl.glColor4us = driverTbl.glColor4us;
   }
   driverTbl.glColor4us(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4usv(const GLushort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor4usv" );
}

static void REGAL_CALL loader_glColor4usv(const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4usv, "glColor4usv");
   if ( !driverTbl.glColor4usv ) {
      driverTbl.glColor4usv = missing_glColor4usv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4usv == loader_glColor4usv) {
      rCtx->dsp.emuTbl.glColor4usv = driverTbl.glColor4usv;
   }
   driverTbl.glColor4usv(v);
}

static void REGAL_CALL missing_glEdgeFlag(GLboolean flag)
{
   UNUSED_PARAMETER(flag);
   Warning( "Called missing function glEdgeFlag" );
}

static void REGAL_CALL loader_glEdgeFlag(GLboolean flag)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEdgeFlag, "glEdgeFlag");
   if ( !driverTbl.glEdgeFlag ) {
      driverTbl.glEdgeFlag = missing_glEdgeFlag;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEdgeFlag == loader_glEdgeFlag) {
      rCtx->dsp.emuTbl.glEdgeFlag = driverTbl.glEdgeFlag;
   }
   driverTbl.glEdgeFlag(flag);
}

static void REGAL_CALL missing_glEdgeFlagv(const GLboolean *flag)
{
   UNUSED_PARAMETER(flag);
   Warning( "Called missing function glEdgeFlagv" );
}

static void REGAL_CALL loader_glEdgeFlagv(const GLboolean *flag)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEdgeFlagv, "glEdgeFlagv");
   if ( !driverTbl.glEdgeFlagv ) {
      driverTbl.glEdgeFlagv = missing_glEdgeFlagv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEdgeFlagv == loader_glEdgeFlagv) {
      rCtx->dsp.emuTbl.glEdgeFlagv = driverTbl.glEdgeFlagv;
   }
   driverTbl.glEdgeFlagv(flag);
}

static void REGAL_CALL missing_glEnd(void)
{
   Warning( "Called missing function glEnd" );
}

static void REGAL_CALL loader_glEnd(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEnd, "glEnd");
   if ( !driverTbl.glEnd ) {
      driverTbl.glEnd = missing_glEnd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEnd == loader_glEnd) {
      rCtx->dsp.emuTbl.glEnd = driverTbl.glEnd;
   }
   driverTbl.glEnd();
}

static void REGAL_CALL missing_glIndexd(GLdouble c)
{
   UNUSED_PARAMETER(c);
   Warning( "Called missing function glIndexd" );
}

static void REGAL_CALL loader_glIndexd(GLdouble c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexd, "glIndexd");
   if ( !driverTbl.glIndexd ) {
      driverTbl.glIndexd = missing_glIndexd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexd == loader_glIndexd) {
      rCtx->dsp.emuTbl.glIndexd = driverTbl.glIndexd;
   }
   driverTbl.glIndexd(c);
}

static void REGAL_CALL missing_glIndexdv(const GLdouble *c)
{
   UNUSED_PARAMETER(c);
   Warning( "Called missing function glIndexdv" );
}

static void REGAL_CALL loader_glIndexdv(const GLdouble *c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexdv, "glIndexdv");
   if ( !driverTbl.glIndexdv ) {
      driverTbl.glIndexdv = missing_glIndexdv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexdv == loader_glIndexdv) {
      rCtx->dsp.emuTbl.glIndexdv = driverTbl.glIndexdv;
   }
   driverTbl.glIndexdv(c);
}

static void REGAL_CALL missing_glIndexf(GLfloat c)
{
   UNUSED_PARAMETER(c);
   Warning( "Called missing function glIndexf" );
}

static void REGAL_CALL loader_glIndexf(GLfloat c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexf, "glIndexf");
   if ( !driverTbl.glIndexf ) {
      driverTbl.glIndexf = missing_glIndexf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexf == loader_glIndexf) {
      rCtx->dsp.emuTbl.glIndexf = driverTbl.glIndexf;
   }
   driverTbl.glIndexf(c);
}

static void REGAL_CALL missing_glIndexfv(const GLfloat *c)
{
   UNUSED_PARAMETER(c);
   Warning( "Called missing function glIndexfv" );
}

static void REGAL_CALL loader_glIndexfv(const GLfloat *c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexfv, "glIndexfv");
   if ( !driverTbl.glIndexfv ) {
      driverTbl.glIndexfv = missing_glIndexfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexfv == loader_glIndexfv) {
      rCtx->dsp.emuTbl.glIndexfv = driverTbl.glIndexfv;
   }
   driverTbl.glIndexfv(c);
}

static void REGAL_CALL missing_glIndexi(GLint c)
{
   UNUSED_PARAMETER(c);
   Warning( "Called missing function glIndexi" );
}

static void REGAL_CALL loader_glIndexi(GLint c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexi, "glIndexi");
   if ( !driverTbl.glIndexi ) {
      driverTbl.glIndexi = missing_glIndexi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexi == loader_glIndexi) {
      rCtx->dsp.emuTbl.glIndexi = driverTbl.glIndexi;
   }
   driverTbl.glIndexi(c);
}

static void REGAL_CALL missing_glIndexiv(const GLint *c)
{
   UNUSED_PARAMETER(c);
   Warning( "Called missing function glIndexiv" );
}

static void REGAL_CALL loader_glIndexiv(const GLint *c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexiv, "glIndexiv");
   if ( !driverTbl.glIndexiv ) {
      driverTbl.glIndexiv = missing_glIndexiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexiv == loader_glIndexiv) {
      rCtx->dsp.emuTbl.glIndexiv = driverTbl.glIndexiv;
   }
   driverTbl.glIndexiv(c);
}

static void REGAL_CALL missing_glIndexs(GLshort c)
{
   UNUSED_PARAMETER(c);
   Warning( "Called missing function glIndexs" );
}

static void REGAL_CALL loader_glIndexs(GLshort c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexs, "glIndexs");
   if ( !driverTbl.glIndexs ) {
      driverTbl.glIndexs = missing_glIndexs;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexs == loader_glIndexs) {
      rCtx->dsp.emuTbl.glIndexs = driverTbl.glIndexs;
   }
   driverTbl.glIndexs(c);
}

static void REGAL_CALL missing_glIndexsv(const GLshort *c)
{
   UNUSED_PARAMETER(c);
   Warning( "Called missing function glIndexsv" );
}

static void REGAL_CALL loader_glIndexsv(const GLshort *c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexsv, "glIndexsv");
   if ( !driverTbl.glIndexsv ) {
      driverTbl.glIndexsv = missing_glIndexsv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexsv == loader_glIndexsv) {
      rCtx->dsp.emuTbl.glIndexsv = driverTbl.glIndexsv;
   }
   driverTbl.glIndexsv(c);
}

static void REGAL_CALL missing_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
{
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   Warning( "Called missing function glNormal3b" );
}

static void REGAL_CALL loader_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormal3b, "glNormal3b");
   if ( !driverTbl.glNormal3b ) {
      driverTbl.glNormal3b = missing_glNormal3b;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormal3b == loader_glNormal3b) {
      rCtx->dsp.emuTbl.glNormal3b = driverTbl.glNormal3b;
   }
   driverTbl.glNormal3b(nx, ny, nz);
}

static void REGAL_CALL missing_glNormal3bv(const GLbyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glNormal3bv" );
}

static void REGAL_CALL loader_glNormal3bv(const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormal3bv, "glNormal3bv");
   if ( !driverTbl.glNormal3bv ) {
      driverTbl.glNormal3bv = missing_glNormal3bv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormal3bv == loader_glNormal3bv) {
      rCtx->dsp.emuTbl.glNormal3bv = driverTbl.glNormal3bv;
   }
   driverTbl.glNormal3bv(v);
}

static void REGAL_CALL missing_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
{
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   Warning( "Called missing function glNormal3d" );
}

static void REGAL_CALL loader_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormal3d, "glNormal3d");
   if ( !driverTbl.glNormal3d ) {
      driverTbl.glNormal3d = missing_glNormal3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormal3d == loader_glNormal3d) {
      rCtx->dsp.emuTbl.glNormal3d = driverTbl.glNormal3d;
   }
   driverTbl.glNormal3d(nx, ny, nz);
}

static void REGAL_CALL missing_glNormal3dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glNormal3dv" );
}

static void REGAL_CALL loader_glNormal3dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormal3dv, "glNormal3dv");
   if ( !driverTbl.glNormal3dv ) {
      driverTbl.glNormal3dv = missing_glNormal3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormal3dv == loader_glNormal3dv) {
      rCtx->dsp.emuTbl.glNormal3dv = driverTbl.glNormal3dv;
   }
   driverTbl.glNormal3dv(v);
}

static void REGAL_CALL missing_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
{
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   Warning( "Called missing function glNormal3f" );
}

static void REGAL_CALL loader_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormal3f, "glNormal3f");
   if ( !driverTbl.glNormal3f ) {
      driverTbl.glNormal3f = missing_glNormal3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormal3f == loader_glNormal3f) {
      rCtx->dsp.emuTbl.glNormal3f = driverTbl.glNormal3f;
   }
   driverTbl.glNormal3f(nx, ny, nz);
}

static void REGAL_CALL missing_glNormal3fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glNormal3fv" );
}

static void REGAL_CALL loader_glNormal3fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormal3fv, "glNormal3fv");
   if ( !driverTbl.glNormal3fv ) {
      driverTbl.glNormal3fv = missing_glNormal3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormal3fv == loader_glNormal3fv) {
      rCtx->dsp.emuTbl.glNormal3fv = driverTbl.glNormal3fv;
   }
   driverTbl.glNormal3fv(v);
}

static void REGAL_CALL missing_glNormal3i(GLint nx, GLint ny, GLint nz)
{
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   Warning( "Called missing function glNormal3i" );
}

static void REGAL_CALL loader_glNormal3i(GLint nx, GLint ny, GLint nz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormal3i, "glNormal3i");
   if ( !driverTbl.glNormal3i ) {
      driverTbl.glNormal3i = missing_glNormal3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormal3i == loader_glNormal3i) {
      rCtx->dsp.emuTbl.glNormal3i = driverTbl.glNormal3i;
   }
   driverTbl.glNormal3i(nx, ny, nz);
}

static void REGAL_CALL missing_glNormal3iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glNormal3iv" );
}

static void REGAL_CALL loader_glNormal3iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormal3iv, "glNormal3iv");
   if ( !driverTbl.glNormal3iv ) {
      driverTbl.glNormal3iv = missing_glNormal3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormal3iv == loader_glNormal3iv) {
      rCtx->dsp.emuTbl.glNormal3iv = driverTbl.glNormal3iv;
   }
   driverTbl.glNormal3iv(v);
}

static void REGAL_CALL missing_glNormal3s(GLshort nx, GLshort ny, GLshort nz)
{
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   Warning( "Called missing function glNormal3s" );
}

static void REGAL_CALL loader_glNormal3s(GLshort nx, GLshort ny, GLshort nz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormal3s, "glNormal3s");
   if ( !driverTbl.glNormal3s ) {
      driverTbl.glNormal3s = missing_glNormal3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormal3s == loader_glNormal3s) {
      rCtx->dsp.emuTbl.glNormal3s = driverTbl.glNormal3s;
   }
   driverTbl.glNormal3s(nx, ny, nz);
}

static void REGAL_CALL missing_glNormal3sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glNormal3sv" );
}

static void REGAL_CALL loader_glNormal3sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormal3sv, "glNormal3sv");
   if ( !driverTbl.glNormal3sv ) {
      driverTbl.glNormal3sv = missing_glNormal3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormal3sv == loader_glNormal3sv) {
      rCtx->dsp.emuTbl.glNormal3sv = driverTbl.glNormal3sv;
   }
   driverTbl.glNormal3sv(v);
}

static void REGAL_CALL missing_glRasterPos2d(GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glRasterPos2d" );
}

static void REGAL_CALL loader_glRasterPos2d(GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos2d, "glRasterPos2d");
   if ( !driverTbl.glRasterPos2d ) {
      driverTbl.glRasterPos2d = missing_glRasterPos2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos2d == loader_glRasterPos2d) {
      rCtx->dsp.emuTbl.glRasterPos2d = driverTbl.glRasterPos2d;
   }
   driverTbl.glRasterPos2d(x, y);
}

static void REGAL_CALL missing_glRasterPos2dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glRasterPos2dv" );
}

static void REGAL_CALL loader_glRasterPos2dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos2dv, "glRasterPos2dv");
   if ( !driverTbl.glRasterPos2dv ) {
      driverTbl.glRasterPos2dv = missing_glRasterPos2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos2dv == loader_glRasterPos2dv) {
      rCtx->dsp.emuTbl.glRasterPos2dv = driverTbl.glRasterPos2dv;
   }
   driverTbl.glRasterPos2dv(v);
}

static void REGAL_CALL missing_glRasterPos2f(GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glRasterPos2f" );
}

static void REGAL_CALL loader_glRasterPos2f(GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos2f, "glRasterPos2f");
   if ( !driverTbl.glRasterPos2f ) {
      driverTbl.glRasterPos2f = missing_glRasterPos2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos2f == loader_glRasterPos2f) {
      rCtx->dsp.emuTbl.glRasterPos2f = driverTbl.glRasterPos2f;
   }
   driverTbl.glRasterPos2f(x, y);
}

static void REGAL_CALL missing_glRasterPos2fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glRasterPos2fv" );
}

static void REGAL_CALL loader_glRasterPos2fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos2fv, "glRasterPos2fv");
   if ( !driverTbl.glRasterPos2fv ) {
      driverTbl.glRasterPos2fv = missing_glRasterPos2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos2fv == loader_glRasterPos2fv) {
      rCtx->dsp.emuTbl.glRasterPos2fv = driverTbl.glRasterPos2fv;
   }
   driverTbl.glRasterPos2fv(v);
}

static void REGAL_CALL missing_glRasterPos2i(GLint x, GLint y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glRasterPos2i" );
}

static void REGAL_CALL loader_glRasterPos2i(GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos2i, "glRasterPos2i");
   if ( !driverTbl.glRasterPos2i ) {
      driverTbl.glRasterPos2i = missing_glRasterPos2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos2i == loader_glRasterPos2i) {
      rCtx->dsp.emuTbl.glRasterPos2i = driverTbl.glRasterPos2i;
   }
   driverTbl.glRasterPos2i(x, y);
}

static void REGAL_CALL missing_glRasterPos2iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glRasterPos2iv" );
}

static void REGAL_CALL loader_glRasterPos2iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos2iv, "glRasterPos2iv");
   if ( !driverTbl.glRasterPos2iv ) {
      driverTbl.glRasterPos2iv = missing_glRasterPos2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos2iv == loader_glRasterPos2iv) {
      rCtx->dsp.emuTbl.glRasterPos2iv = driverTbl.glRasterPos2iv;
   }
   driverTbl.glRasterPos2iv(v);
}

static void REGAL_CALL missing_glRasterPos2s(GLshort x, GLshort y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glRasterPos2s" );
}

static void REGAL_CALL loader_glRasterPos2s(GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos2s, "glRasterPos2s");
   if ( !driverTbl.glRasterPos2s ) {
      driverTbl.glRasterPos2s = missing_glRasterPos2s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos2s == loader_glRasterPos2s) {
      rCtx->dsp.emuTbl.glRasterPos2s = driverTbl.glRasterPos2s;
   }
   driverTbl.glRasterPos2s(x, y);
}

static void REGAL_CALL missing_glRasterPos2sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glRasterPos2sv" );
}

static void REGAL_CALL loader_glRasterPos2sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos2sv, "glRasterPos2sv");
   if ( !driverTbl.glRasterPos2sv ) {
      driverTbl.glRasterPos2sv = missing_glRasterPos2sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos2sv == loader_glRasterPos2sv) {
      rCtx->dsp.emuTbl.glRasterPos2sv = driverTbl.glRasterPos2sv;
   }
   driverTbl.glRasterPos2sv(v);
}

static void REGAL_CALL missing_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glRasterPos3d" );
}

static void REGAL_CALL loader_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos3d, "glRasterPos3d");
   if ( !driverTbl.glRasterPos3d ) {
      driverTbl.glRasterPos3d = missing_glRasterPos3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos3d == loader_glRasterPos3d) {
      rCtx->dsp.emuTbl.glRasterPos3d = driverTbl.glRasterPos3d;
   }
   driverTbl.glRasterPos3d(x, y, z);
}

static void REGAL_CALL missing_glRasterPos3dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glRasterPos3dv" );
}

static void REGAL_CALL loader_glRasterPos3dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos3dv, "glRasterPos3dv");
   if ( !driverTbl.glRasterPos3dv ) {
      driverTbl.glRasterPos3dv = missing_glRasterPos3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos3dv == loader_glRasterPos3dv) {
      rCtx->dsp.emuTbl.glRasterPos3dv = driverTbl.glRasterPos3dv;
   }
   driverTbl.glRasterPos3dv(v);
}

static void REGAL_CALL missing_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glRasterPos3f" );
}

static void REGAL_CALL loader_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos3f, "glRasterPos3f");
   if ( !driverTbl.glRasterPos3f ) {
      driverTbl.glRasterPos3f = missing_glRasterPos3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos3f == loader_glRasterPos3f) {
      rCtx->dsp.emuTbl.glRasterPos3f = driverTbl.glRasterPos3f;
   }
   driverTbl.glRasterPos3f(x, y, z);
}

static void REGAL_CALL missing_glRasterPos3fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glRasterPos3fv" );
}

static void REGAL_CALL loader_glRasterPos3fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos3fv, "glRasterPos3fv");
   if ( !driverTbl.glRasterPos3fv ) {
      driverTbl.glRasterPos3fv = missing_glRasterPos3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos3fv == loader_glRasterPos3fv) {
      rCtx->dsp.emuTbl.glRasterPos3fv = driverTbl.glRasterPos3fv;
   }
   driverTbl.glRasterPos3fv(v);
}

static void REGAL_CALL missing_glRasterPos3i(GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glRasterPos3i" );
}

static void REGAL_CALL loader_glRasterPos3i(GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos3i, "glRasterPos3i");
   if ( !driverTbl.glRasterPos3i ) {
      driverTbl.glRasterPos3i = missing_glRasterPos3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos3i == loader_glRasterPos3i) {
      rCtx->dsp.emuTbl.glRasterPos3i = driverTbl.glRasterPos3i;
   }
   driverTbl.glRasterPos3i(x, y, z);
}

static void REGAL_CALL missing_glRasterPos3iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glRasterPos3iv" );
}

static void REGAL_CALL loader_glRasterPos3iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos3iv, "glRasterPos3iv");
   if ( !driverTbl.glRasterPos3iv ) {
      driverTbl.glRasterPos3iv = missing_glRasterPos3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos3iv == loader_glRasterPos3iv) {
      rCtx->dsp.emuTbl.glRasterPos3iv = driverTbl.glRasterPos3iv;
   }
   driverTbl.glRasterPos3iv(v);
}

static void REGAL_CALL missing_glRasterPos3s(GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glRasterPos3s" );
}

static void REGAL_CALL loader_glRasterPos3s(GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos3s, "glRasterPos3s");
   if ( !driverTbl.glRasterPos3s ) {
      driverTbl.glRasterPos3s = missing_glRasterPos3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos3s == loader_glRasterPos3s) {
      rCtx->dsp.emuTbl.glRasterPos3s = driverTbl.glRasterPos3s;
   }
   driverTbl.glRasterPos3s(x, y, z);
}

static void REGAL_CALL missing_glRasterPos3sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glRasterPos3sv" );
}

static void REGAL_CALL loader_glRasterPos3sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos3sv, "glRasterPos3sv");
   if ( !driverTbl.glRasterPos3sv ) {
      driverTbl.glRasterPos3sv = missing_glRasterPos3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos3sv == loader_glRasterPos3sv) {
      rCtx->dsp.emuTbl.glRasterPos3sv = driverTbl.glRasterPos3sv;
   }
   driverTbl.glRasterPos3sv(v);
}

static void REGAL_CALL missing_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glRasterPos4d" );
}

static void REGAL_CALL loader_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos4d, "glRasterPos4d");
   if ( !driverTbl.glRasterPos4d ) {
      driverTbl.glRasterPos4d = missing_glRasterPos4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos4d == loader_glRasterPos4d) {
      rCtx->dsp.emuTbl.glRasterPos4d = driverTbl.glRasterPos4d;
   }
   driverTbl.glRasterPos4d(x, y, z, w);
}

static void REGAL_CALL missing_glRasterPos4dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glRasterPos4dv" );
}

static void REGAL_CALL loader_glRasterPos4dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos4dv, "glRasterPos4dv");
   if ( !driverTbl.glRasterPos4dv ) {
      driverTbl.glRasterPos4dv = missing_glRasterPos4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos4dv == loader_glRasterPos4dv) {
      rCtx->dsp.emuTbl.glRasterPos4dv = driverTbl.glRasterPos4dv;
   }
   driverTbl.glRasterPos4dv(v);
}

static void REGAL_CALL missing_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glRasterPos4f" );
}

static void REGAL_CALL loader_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos4f, "glRasterPos4f");
   if ( !driverTbl.glRasterPos4f ) {
      driverTbl.glRasterPos4f = missing_glRasterPos4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos4f == loader_glRasterPos4f) {
      rCtx->dsp.emuTbl.glRasterPos4f = driverTbl.glRasterPos4f;
   }
   driverTbl.glRasterPos4f(x, y, z, w);
}

static void REGAL_CALL missing_glRasterPos4fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glRasterPos4fv" );
}

static void REGAL_CALL loader_glRasterPos4fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos4fv, "glRasterPos4fv");
   if ( !driverTbl.glRasterPos4fv ) {
      driverTbl.glRasterPos4fv = missing_glRasterPos4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos4fv == loader_glRasterPos4fv) {
      rCtx->dsp.emuTbl.glRasterPos4fv = driverTbl.glRasterPos4fv;
   }
   driverTbl.glRasterPos4fv(v);
}

static void REGAL_CALL missing_glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glRasterPos4i" );
}

static void REGAL_CALL loader_glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos4i, "glRasterPos4i");
   if ( !driverTbl.glRasterPos4i ) {
      driverTbl.glRasterPos4i = missing_glRasterPos4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos4i == loader_glRasterPos4i) {
      rCtx->dsp.emuTbl.glRasterPos4i = driverTbl.glRasterPos4i;
   }
   driverTbl.glRasterPos4i(x, y, z, w);
}

static void REGAL_CALL missing_glRasterPos4iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glRasterPos4iv" );
}

static void REGAL_CALL loader_glRasterPos4iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos4iv, "glRasterPos4iv");
   if ( !driverTbl.glRasterPos4iv ) {
      driverTbl.glRasterPos4iv = missing_glRasterPos4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos4iv == loader_glRasterPos4iv) {
      rCtx->dsp.emuTbl.glRasterPos4iv = driverTbl.glRasterPos4iv;
   }
   driverTbl.glRasterPos4iv(v);
}

static void REGAL_CALL missing_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glRasterPos4s" );
}

static void REGAL_CALL loader_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos4s, "glRasterPos4s");
   if ( !driverTbl.glRasterPos4s ) {
      driverTbl.glRasterPos4s = missing_glRasterPos4s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos4s == loader_glRasterPos4s) {
      rCtx->dsp.emuTbl.glRasterPos4s = driverTbl.glRasterPos4s;
   }
   driverTbl.glRasterPos4s(x, y, z, w);
}

static void REGAL_CALL missing_glRasterPos4sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glRasterPos4sv" );
}

static void REGAL_CALL loader_glRasterPos4sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRasterPos4sv, "glRasterPos4sv");
   if ( !driverTbl.glRasterPos4sv ) {
      driverTbl.glRasterPos4sv = missing_glRasterPos4sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRasterPos4sv == loader_glRasterPos4sv) {
      rCtx->dsp.emuTbl.glRasterPos4sv = driverTbl.glRasterPos4sv;
   }
   driverTbl.glRasterPos4sv(v);
}

static void REGAL_CALL missing_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{
   UNUSED_PARAMETER(x1);
   UNUSED_PARAMETER(y1);
   UNUSED_PARAMETER(x2);
   UNUSED_PARAMETER(y2);
   Warning( "Called missing function glRectd" );
}

static void REGAL_CALL loader_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRectd, "glRectd");
   if ( !driverTbl.glRectd ) {
      driverTbl.glRectd = missing_glRectd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRectd == loader_glRectd) {
      rCtx->dsp.emuTbl.glRectd = driverTbl.glRectd;
   }
   driverTbl.glRectd(x1, y1, x2, y2);
}

static void REGAL_CALL missing_glRectdv(const GLdouble *v1, const GLdouble *v2)
{
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glRectdv" );
}

static void REGAL_CALL loader_glRectdv(const GLdouble *v1, const GLdouble *v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRectdv, "glRectdv");
   if ( !driverTbl.glRectdv ) {
      driverTbl.glRectdv = missing_glRectdv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRectdv == loader_glRectdv) {
      rCtx->dsp.emuTbl.glRectdv = driverTbl.glRectdv;
   }
   driverTbl.glRectdv(v1, v2);
}

static void REGAL_CALL missing_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
   UNUSED_PARAMETER(x1);
   UNUSED_PARAMETER(y1);
   UNUSED_PARAMETER(x2);
   UNUSED_PARAMETER(y2);
   Warning( "Called missing function glRectf" );
}

static void REGAL_CALL loader_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRectf, "glRectf");
   if ( !driverTbl.glRectf ) {
      driverTbl.glRectf = missing_glRectf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRectf == loader_glRectf) {
      rCtx->dsp.emuTbl.glRectf = driverTbl.glRectf;
   }
   driverTbl.glRectf(x1, y1, x2, y2);
}

static void REGAL_CALL missing_glRectfv(const GLfloat *v1, const GLfloat *v2)
{
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glRectfv" );
}

static void REGAL_CALL loader_glRectfv(const GLfloat *v1, const GLfloat *v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRectfv, "glRectfv");
   if ( !driverTbl.glRectfv ) {
      driverTbl.glRectfv = missing_glRectfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRectfv == loader_glRectfv) {
      rCtx->dsp.emuTbl.glRectfv = driverTbl.glRectfv;
   }
   driverTbl.glRectfv(v1, v2);
}

static void REGAL_CALL missing_glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
{
   UNUSED_PARAMETER(x1);
   UNUSED_PARAMETER(y1);
   UNUSED_PARAMETER(x2);
   UNUSED_PARAMETER(y2);
   Warning( "Called missing function glRecti" );
}

static void REGAL_CALL loader_glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRecti, "glRecti");
   if ( !driverTbl.glRecti ) {
      driverTbl.glRecti = missing_glRecti;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRecti == loader_glRecti) {
      rCtx->dsp.emuTbl.glRecti = driverTbl.glRecti;
   }
   driverTbl.glRecti(x1, y1, x2, y2);
}

static void REGAL_CALL missing_glRectiv(const GLint *v1, const GLint *v2)
{
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glRectiv" );
}

static void REGAL_CALL loader_glRectiv(const GLint *v1, const GLint *v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRectiv, "glRectiv");
   if ( !driverTbl.glRectiv ) {
      driverTbl.glRectiv = missing_glRectiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRectiv == loader_glRectiv) {
      rCtx->dsp.emuTbl.glRectiv = driverTbl.glRectiv;
   }
   driverTbl.glRectiv(v1, v2);
}

static void REGAL_CALL missing_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
{
   UNUSED_PARAMETER(x1);
   UNUSED_PARAMETER(y1);
   UNUSED_PARAMETER(x2);
   UNUSED_PARAMETER(y2);
   Warning( "Called missing function glRects" );
}

static void REGAL_CALL loader_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRects, "glRects");
   if ( !driverTbl.glRects ) {
      driverTbl.glRects = missing_glRects;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRects == loader_glRects) {
      rCtx->dsp.emuTbl.glRects = driverTbl.glRects;
   }
   driverTbl.glRects(x1, y1, x2, y2);
}

static void REGAL_CALL missing_glRectsv(const GLshort *v1, const GLshort *v2)
{
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glRectsv" );
}

static void REGAL_CALL loader_glRectsv(const GLshort *v1, const GLshort *v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRectsv, "glRectsv");
   if ( !driverTbl.glRectsv ) {
      driverTbl.glRectsv = missing_glRectsv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRectsv == loader_glRectsv) {
      rCtx->dsp.emuTbl.glRectsv = driverTbl.glRectsv;
   }
   driverTbl.glRectsv(v1, v2);
}

static void REGAL_CALL missing_glTexCoord1d(GLdouble s)
{
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glTexCoord1d" );
}

static void REGAL_CALL loader_glTexCoord1d(GLdouble s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord1d, "glTexCoord1d");
   if ( !driverTbl.glTexCoord1d ) {
      driverTbl.glTexCoord1d = missing_glTexCoord1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord1d == loader_glTexCoord1d) {
      rCtx->dsp.emuTbl.glTexCoord1d = driverTbl.glTexCoord1d;
   }
   driverTbl.glTexCoord1d(s);
}

static void REGAL_CALL missing_glTexCoord1dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord1dv" );
}

static void REGAL_CALL loader_glTexCoord1dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord1dv, "glTexCoord1dv");
   if ( !driverTbl.glTexCoord1dv ) {
      driverTbl.glTexCoord1dv = missing_glTexCoord1dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord1dv == loader_glTexCoord1dv) {
      rCtx->dsp.emuTbl.glTexCoord1dv = driverTbl.glTexCoord1dv;
   }
   driverTbl.glTexCoord1dv(v);
}

static void REGAL_CALL missing_glTexCoord1f(GLfloat s)
{
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glTexCoord1f" );
}

static void REGAL_CALL loader_glTexCoord1f(GLfloat s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord1f, "glTexCoord1f");
   if ( !driverTbl.glTexCoord1f ) {
      driverTbl.glTexCoord1f = missing_glTexCoord1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord1f == loader_glTexCoord1f) {
      rCtx->dsp.emuTbl.glTexCoord1f = driverTbl.glTexCoord1f;
   }
   driverTbl.glTexCoord1f(s);
}

static void REGAL_CALL missing_glTexCoord1fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord1fv" );
}

static void REGAL_CALL loader_glTexCoord1fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord1fv, "glTexCoord1fv");
   if ( !driverTbl.glTexCoord1fv ) {
      driverTbl.glTexCoord1fv = missing_glTexCoord1fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord1fv == loader_glTexCoord1fv) {
      rCtx->dsp.emuTbl.glTexCoord1fv = driverTbl.glTexCoord1fv;
   }
   driverTbl.glTexCoord1fv(v);
}

static void REGAL_CALL missing_glTexCoord1i(GLint s)
{
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glTexCoord1i" );
}

static void REGAL_CALL loader_glTexCoord1i(GLint s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord1i, "glTexCoord1i");
   if ( !driverTbl.glTexCoord1i ) {
      driverTbl.glTexCoord1i = missing_glTexCoord1i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord1i == loader_glTexCoord1i) {
      rCtx->dsp.emuTbl.glTexCoord1i = driverTbl.glTexCoord1i;
   }
   driverTbl.glTexCoord1i(s);
}

static void REGAL_CALL missing_glTexCoord1iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord1iv" );
}

static void REGAL_CALL loader_glTexCoord1iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord1iv, "glTexCoord1iv");
   if ( !driverTbl.glTexCoord1iv ) {
      driverTbl.glTexCoord1iv = missing_glTexCoord1iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord1iv == loader_glTexCoord1iv) {
      rCtx->dsp.emuTbl.glTexCoord1iv = driverTbl.glTexCoord1iv;
   }
   driverTbl.glTexCoord1iv(v);
}

static void REGAL_CALL missing_glTexCoord1s(GLshort s)
{
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glTexCoord1s" );
}

static void REGAL_CALL loader_glTexCoord1s(GLshort s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord1s, "glTexCoord1s");
   if ( !driverTbl.glTexCoord1s ) {
      driverTbl.glTexCoord1s = missing_glTexCoord1s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord1s == loader_glTexCoord1s) {
      rCtx->dsp.emuTbl.glTexCoord1s = driverTbl.glTexCoord1s;
   }
   driverTbl.glTexCoord1s(s);
}

static void REGAL_CALL missing_glTexCoord1sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord1sv" );
}

static void REGAL_CALL loader_glTexCoord1sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord1sv, "glTexCoord1sv");
   if ( !driverTbl.glTexCoord1sv ) {
      driverTbl.glTexCoord1sv = missing_glTexCoord1sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord1sv == loader_glTexCoord1sv) {
      rCtx->dsp.emuTbl.glTexCoord1sv = driverTbl.glTexCoord1sv;
   }
   driverTbl.glTexCoord1sv(v);
}

static void REGAL_CALL missing_glTexCoord2d(GLdouble s, GLdouble t)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "Called missing function glTexCoord2d" );
}

static void REGAL_CALL loader_glTexCoord2d(GLdouble s, GLdouble t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2d, "glTexCoord2d");
   if ( !driverTbl.glTexCoord2d ) {
      driverTbl.glTexCoord2d = missing_glTexCoord2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2d == loader_glTexCoord2d) {
      rCtx->dsp.emuTbl.glTexCoord2d = driverTbl.glTexCoord2d;
   }
   driverTbl.glTexCoord2d(s, t);
}

static void REGAL_CALL missing_glTexCoord2dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord2dv" );
}

static void REGAL_CALL loader_glTexCoord2dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2dv, "glTexCoord2dv");
   if ( !driverTbl.glTexCoord2dv ) {
      driverTbl.glTexCoord2dv = missing_glTexCoord2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2dv == loader_glTexCoord2dv) {
      rCtx->dsp.emuTbl.glTexCoord2dv = driverTbl.glTexCoord2dv;
   }
   driverTbl.glTexCoord2dv(v);
}

static void REGAL_CALL missing_glTexCoord2f(GLfloat s, GLfloat t)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "Called missing function glTexCoord2f" );
}

static void REGAL_CALL loader_glTexCoord2f(GLfloat s, GLfloat t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2f, "glTexCoord2f");
   if ( !driverTbl.glTexCoord2f ) {
      driverTbl.glTexCoord2f = missing_glTexCoord2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2f == loader_glTexCoord2f) {
      rCtx->dsp.emuTbl.glTexCoord2f = driverTbl.glTexCoord2f;
   }
   driverTbl.glTexCoord2f(s, t);
}

static void REGAL_CALL missing_glTexCoord2fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord2fv" );
}

static void REGAL_CALL loader_glTexCoord2fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2fv, "glTexCoord2fv");
   if ( !driverTbl.glTexCoord2fv ) {
      driverTbl.glTexCoord2fv = missing_glTexCoord2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2fv == loader_glTexCoord2fv) {
      rCtx->dsp.emuTbl.glTexCoord2fv = driverTbl.glTexCoord2fv;
   }
   driverTbl.glTexCoord2fv(v);
}

static void REGAL_CALL missing_glTexCoord2i(GLint s, GLint t)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "Called missing function glTexCoord2i" );
}

static void REGAL_CALL loader_glTexCoord2i(GLint s, GLint t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2i, "glTexCoord2i");
   if ( !driverTbl.glTexCoord2i ) {
      driverTbl.glTexCoord2i = missing_glTexCoord2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2i == loader_glTexCoord2i) {
      rCtx->dsp.emuTbl.glTexCoord2i = driverTbl.glTexCoord2i;
   }
   driverTbl.glTexCoord2i(s, t);
}

static void REGAL_CALL missing_glTexCoord2iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord2iv" );
}

static void REGAL_CALL loader_glTexCoord2iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2iv, "glTexCoord2iv");
   if ( !driverTbl.glTexCoord2iv ) {
      driverTbl.glTexCoord2iv = missing_glTexCoord2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2iv == loader_glTexCoord2iv) {
      rCtx->dsp.emuTbl.glTexCoord2iv = driverTbl.glTexCoord2iv;
   }
   driverTbl.glTexCoord2iv(v);
}

static void REGAL_CALL missing_glTexCoord2s(GLshort s, GLshort t)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "Called missing function glTexCoord2s" );
}

static void REGAL_CALL loader_glTexCoord2s(GLshort s, GLshort t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2s, "glTexCoord2s");
   if ( !driverTbl.glTexCoord2s ) {
      driverTbl.glTexCoord2s = missing_glTexCoord2s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2s == loader_glTexCoord2s) {
      rCtx->dsp.emuTbl.glTexCoord2s = driverTbl.glTexCoord2s;
   }
   driverTbl.glTexCoord2s(s, t);
}

static void REGAL_CALL missing_glTexCoord2sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord2sv" );
}

static void REGAL_CALL loader_glTexCoord2sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2sv, "glTexCoord2sv");
   if ( !driverTbl.glTexCoord2sv ) {
      driverTbl.glTexCoord2sv = missing_glTexCoord2sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2sv == loader_glTexCoord2sv) {
      rCtx->dsp.emuTbl.glTexCoord2sv = driverTbl.glTexCoord2sv;
   }
   driverTbl.glTexCoord2sv(v);
}

static void REGAL_CALL missing_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "Called missing function glTexCoord3d" );
}

static void REGAL_CALL loader_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord3d, "glTexCoord3d");
   if ( !driverTbl.glTexCoord3d ) {
      driverTbl.glTexCoord3d = missing_glTexCoord3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord3d == loader_glTexCoord3d) {
      rCtx->dsp.emuTbl.glTexCoord3d = driverTbl.glTexCoord3d;
   }
   driverTbl.glTexCoord3d(s, t, r);
}

static void REGAL_CALL missing_glTexCoord3dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord3dv" );
}

static void REGAL_CALL loader_glTexCoord3dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord3dv, "glTexCoord3dv");
   if ( !driverTbl.glTexCoord3dv ) {
      driverTbl.glTexCoord3dv = missing_glTexCoord3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord3dv == loader_glTexCoord3dv) {
      rCtx->dsp.emuTbl.glTexCoord3dv = driverTbl.glTexCoord3dv;
   }
   driverTbl.glTexCoord3dv(v);
}

static void REGAL_CALL missing_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "Called missing function glTexCoord3f" );
}

static void REGAL_CALL loader_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord3f, "glTexCoord3f");
   if ( !driverTbl.glTexCoord3f ) {
      driverTbl.glTexCoord3f = missing_glTexCoord3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord3f == loader_glTexCoord3f) {
      rCtx->dsp.emuTbl.glTexCoord3f = driverTbl.glTexCoord3f;
   }
   driverTbl.glTexCoord3f(s, t, r);
}

static void REGAL_CALL missing_glTexCoord3fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord3fv" );
}

static void REGAL_CALL loader_glTexCoord3fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord3fv, "glTexCoord3fv");
   if ( !driverTbl.glTexCoord3fv ) {
      driverTbl.glTexCoord3fv = missing_glTexCoord3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord3fv == loader_glTexCoord3fv) {
      rCtx->dsp.emuTbl.glTexCoord3fv = driverTbl.glTexCoord3fv;
   }
   driverTbl.glTexCoord3fv(v);
}

static void REGAL_CALL missing_glTexCoord3i(GLint s, GLint t, GLint r)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "Called missing function glTexCoord3i" );
}

static void REGAL_CALL loader_glTexCoord3i(GLint s, GLint t, GLint r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord3i, "glTexCoord3i");
   if ( !driverTbl.glTexCoord3i ) {
      driverTbl.glTexCoord3i = missing_glTexCoord3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord3i == loader_glTexCoord3i) {
      rCtx->dsp.emuTbl.glTexCoord3i = driverTbl.glTexCoord3i;
   }
   driverTbl.glTexCoord3i(s, t, r);
}

static void REGAL_CALL missing_glTexCoord3iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord3iv" );
}

static void REGAL_CALL loader_glTexCoord3iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord3iv, "glTexCoord3iv");
   if ( !driverTbl.glTexCoord3iv ) {
      driverTbl.glTexCoord3iv = missing_glTexCoord3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord3iv == loader_glTexCoord3iv) {
      rCtx->dsp.emuTbl.glTexCoord3iv = driverTbl.glTexCoord3iv;
   }
   driverTbl.glTexCoord3iv(v);
}

static void REGAL_CALL missing_glTexCoord3s(GLshort s, GLshort t, GLshort r)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "Called missing function glTexCoord3s" );
}

static void REGAL_CALL loader_glTexCoord3s(GLshort s, GLshort t, GLshort r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord3s, "glTexCoord3s");
   if ( !driverTbl.glTexCoord3s ) {
      driverTbl.glTexCoord3s = missing_glTexCoord3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord3s == loader_glTexCoord3s) {
      rCtx->dsp.emuTbl.glTexCoord3s = driverTbl.glTexCoord3s;
   }
   driverTbl.glTexCoord3s(s, t, r);
}

static void REGAL_CALL missing_glTexCoord3sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord3sv" );
}

static void REGAL_CALL loader_glTexCoord3sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord3sv, "glTexCoord3sv");
   if ( !driverTbl.glTexCoord3sv ) {
      driverTbl.glTexCoord3sv = missing_glTexCoord3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord3sv == loader_glTexCoord3sv) {
      rCtx->dsp.emuTbl.glTexCoord3sv = driverTbl.glTexCoord3sv;
   }
   driverTbl.glTexCoord3sv(v);
}

static void REGAL_CALL missing_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "Called missing function glTexCoord4d" );
}

static void REGAL_CALL loader_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord4d, "glTexCoord4d");
   if ( !driverTbl.glTexCoord4d ) {
      driverTbl.glTexCoord4d = missing_glTexCoord4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord4d == loader_glTexCoord4d) {
      rCtx->dsp.emuTbl.glTexCoord4d = driverTbl.glTexCoord4d;
   }
   driverTbl.glTexCoord4d(s, t, r, q);
}

static void REGAL_CALL missing_glTexCoord4dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord4dv" );
}

static void REGAL_CALL loader_glTexCoord4dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord4dv, "glTexCoord4dv");
   if ( !driverTbl.glTexCoord4dv ) {
      driverTbl.glTexCoord4dv = missing_glTexCoord4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord4dv == loader_glTexCoord4dv) {
      rCtx->dsp.emuTbl.glTexCoord4dv = driverTbl.glTexCoord4dv;
   }
   driverTbl.glTexCoord4dv(v);
}

static void REGAL_CALL missing_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "Called missing function glTexCoord4f" );
}

static void REGAL_CALL loader_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord4f, "glTexCoord4f");
   if ( !driverTbl.glTexCoord4f ) {
      driverTbl.glTexCoord4f = missing_glTexCoord4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord4f == loader_glTexCoord4f) {
      rCtx->dsp.emuTbl.glTexCoord4f = driverTbl.glTexCoord4f;
   }
   driverTbl.glTexCoord4f(s, t, r, q);
}

static void REGAL_CALL missing_glTexCoord4fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord4fv" );
}

static void REGAL_CALL loader_glTexCoord4fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord4fv, "glTexCoord4fv");
   if ( !driverTbl.glTexCoord4fv ) {
      driverTbl.glTexCoord4fv = missing_glTexCoord4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord4fv == loader_glTexCoord4fv) {
      rCtx->dsp.emuTbl.glTexCoord4fv = driverTbl.glTexCoord4fv;
   }
   driverTbl.glTexCoord4fv(v);
}

static void REGAL_CALL missing_glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "Called missing function glTexCoord4i" );
}

static void REGAL_CALL loader_glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord4i, "glTexCoord4i");
   if ( !driverTbl.glTexCoord4i ) {
      driverTbl.glTexCoord4i = missing_glTexCoord4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord4i == loader_glTexCoord4i) {
      rCtx->dsp.emuTbl.glTexCoord4i = driverTbl.glTexCoord4i;
   }
   driverTbl.glTexCoord4i(s, t, r, q);
}

static void REGAL_CALL missing_glTexCoord4iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord4iv" );
}

static void REGAL_CALL loader_glTexCoord4iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord4iv, "glTexCoord4iv");
   if ( !driverTbl.glTexCoord4iv ) {
      driverTbl.glTexCoord4iv = missing_glTexCoord4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord4iv == loader_glTexCoord4iv) {
      rCtx->dsp.emuTbl.glTexCoord4iv = driverTbl.glTexCoord4iv;
   }
   driverTbl.glTexCoord4iv(v);
}

static void REGAL_CALL missing_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "Called missing function glTexCoord4s" );
}

static void REGAL_CALL loader_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord4s, "glTexCoord4s");
   if ( !driverTbl.glTexCoord4s ) {
      driverTbl.glTexCoord4s = missing_glTexCoord4s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord4s == loader_glTexCoord4s) {
      rCtx->dsp.emuTbl.glTexCoord4s = driverTbl.glTexCoord4s;
   }
   driverTbl.glTexCoord4s(s, t, r, q);
}

static void REGAL_CALL missing_glTexCoord4sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord4sv" );
}

static void REGAL_CALL loader_glTexCoord4sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord4sv, "glTexCoord4sv");
   if ( !driverTbl.glTexCoord4sv ) {
      driverTbl.glTexCoord4sv = missing_glTexCoord4sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord4sv == loader_glTexCoord4sv) {
      rCtx->dsp.emuTbl.glTexCoord4sv = driverTbl.glTexCoord4sv;
   }
   driverTbl.glTexCoord4sv(v);
}

static void REGAL_CALL missing_glVertex2d(GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertex2d" );
}

static void REGAL_CALL loader_glVertex2d(GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex2d, "glVertex2d");
   if ( !driverTbl.glVertex2d ) {
      driverTbl.glVertex2d = missing_glVertex2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex2d == loader_glVertex2d) {
      rCtx->dsp.emuTbl.glVertex2d = driverTbl.glVertex2d;
   }
   driverTbl.glVertex2d(x, y);
}

static void REGAL_CALL missing_glVertex2dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex2dv" );
}

static void REGAL_CALL loader_glVertex2dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex2dv, "glVertex2dv");
   if ( !driverTbl.glVertex2dv ) {
      driverTbl.glVertex2dv = missing_glVertex2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex2dv == loader_glVertex2dv) {
      rCtx->dsp.emuTbl.glVertex2dv = driverTbl.glVertex2dv;
   }
   driverTbl.glVertex2dv(v);
}

static void REGAL_CALL missing_glVertex2f(GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertex2f" );
}

static void REGAL_CALL loader_glVertex2f(GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex2f, "glVertex2f");
   if ( !driverTbl.glVertex2f ) {
      driverTbl.glVertex2f = missing_glVertex2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex2f == loader_glVertex2f) {
      rCtx->dsp.emuTbl.glVertex2f = driverTbl.glVertex2f;
   }
   driverTbl.glVertex2f(x, y);
}

static void REGAL_CALL missing_glVertex2fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex2fv" );
}

static void REGAL_CALL loader_glVertex2fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex2fv, "glVertex2fv");
   if ( !driverTbl.glVertex2fv ) {
      driverTbl.glVertex2fv = missing_glVertex2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex2fv == loader_glVertex2fv) {
      rCtx->dsp.emuTbl.glVertex2fv = driverTbl.glVertex2fv;
   }
   driverTbl.glVertex2fv(v);
}

static void REGAL_CALL missing_glVertex2i(GLint x, GLint y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertex2i" );
}

static void REGAL_CALL loader_glVertex2i(GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex2i, "glVertex2i");
   if ( !driverTbl.glVertex2i ) {
      driverTbl.glVertex2i = missing_glVertex2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex2i == loader_glVertex2i) {
      rCtx->dsp.emuTbl.glVertex2i = driverTbl.glVertex2i;
   }
   driverTbl.glVertex2i(x, y);
}

static void REGAL_CALL missing_glVertex2iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex2iv" );
}

static void REGAL_CALL loader_glVertex2iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex2iv, "glVertex2iv");
   if ( !driverTbl.glVertex2iv ) {
      driverTbl.glVertex2iv = missing_glVertex2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex2iv == loader_glVertex2iv) {
      rCtx->dsp.emuTbl.glVertex2iv = driverTbl.glVertex2iv;
   }
   driverTbl.glVertex2iv(v);
}

static void REGAL_CALL missing_glVertex2s(GLshort x, GLshort y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertex2s" );
}

static void REGAL_CALL loader_glVertex2s(GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex2s, "glVertex2s");
   if ( !driverTbl.glVertex2s ) {
      driverTbl.glVertex2s = missing_glVertex2s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex2s == loader_glVertex2s) {
      rCtx->dsp.emuTbl.glVertex2s = driverTbl.glVertex2s;
   }
   driverTbl.glVertex2s(x, y);
}

static void REGAL_CALL missing_glVertex2sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex2sv" );
}

static void REGAL_CALL loader_glVertex2sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex2sv, "glVertex2sv");
   if ( !driverTbl.glVertex2sv ) {
      driverTbl.glVertex2sv = missing_glVertex2sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex2sv == loader_glVertex2sv) {
      rCtx->dsp.emuTbl.glVertex2sv = driverTbl.glVertex2sv;
   }
   driverTbl.glVertex2sv(v);
}

static void REGAL_CALL missing_glVertex3d(GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertex3d" );
}

static void REGAL_CALL loader_glVertex3d(GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex3d, "glVertex3d");
   if ( !driverTbl.glVertex3d ) {
      driverTbl.glVertex3d = missing_glVertex3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex3d == loader_glVertex3d) {
      rCtx->dsp.emuTbl.glVertex3d = driverTbl.glVertex3d;
   }
   driverTbl.glVertex3d(x, y, z);
}

static void REGAL_CALL missing_glVertex3dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex3dv" );
}

static void REGAL_CALL loader_glVertex3dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex3dv, "glVertex3dv");
   if ( !driverTbl.glVertex3dv ) {
      driverTbl.glVertex3dv = missing_glVertex3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex3dv == loader_glVertex3dv) {
      rCtx->dsp.emuTbl.glVertex3dv = driverTbl.glVertex3dv;
   }
   driverTbl.glVertex3dv(v);
}

static void REGAL_CALL missing_glVertex3f(GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertex3f" );
}

static void REGAL_CALL loader_glVertex3f(GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex3f, "glVertex3f");
   if ( !driverTbl.glVertex3f ) {
      driverTbl.glVertex3f = missing_glVertex3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex3f == loader_glVertex3f) {
      rCtx->dsp.emuTbl.glVertex3f = driverTbl.glVertex3f;
   }
   driverTbl.glVertex3f(x, y, z);
}

static void REGAL_CALL missing_glVertex3fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex3fv" );
}

static void REGAL_CALL loader_glVertex3fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex3fv, "glVertex3fv");
   if ( !driverTbl.glVertex3fv ) {
      driverTbl.glVertex3fv = missing_glVertex3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex3fv == loader_glVertex3fv) {
      rCtx->dsp.emuTbl.glVertex3fv = driverTbl.glVertex3fv;
   }
   driverTbl.glVertex3fv(v);
}

static void REGAL_CALL missing_glVertex3i(GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertex3i" );
}

static void REGAL_CALL loader_glVertex3i(GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex3i, "glVertex3i");
   if ( !driverTbl.glVertex3i ) {
      driverTbl.glVertex3i = missing_glVertex3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex3i == loader_glVertex3i) {
      rCtx->dsp.emuTbl.glVertex3i = driverTbl.glVertex3i;
   }
   driverTbl.glVertex3i(x, y, z);
}

static void REGAL_CALL missing_glVertex3iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex3iv" );
}

static void REGAL_CALL loader_glVertex3iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex3iv, "glVertex3iv");
   if ( !driverTbl.glVertex3iv ) {
      driverTbl.glVertex3iv = missing_glVertex3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex3iv == loader_glVertex3iv) {
      rCtx->dsp.emuTbl.glVertex3iv = driverTbl.glVertex3iv;
   }
   driverTbl.glVertex3iv(v);
}

static void REGAL_CALL missing_glVertex3s(GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertex3s" );
}

static void REGAL_CALL loader_glVertex3s(GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex3s, "glVertex3s");
   if ( !driverTbl.glVertex3s ) {
      driverTbl.glVertex3s = missing_glVertex3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex3s == loader_glVertex3s) {
      rCtx->dsp.emuTbl.glVertex3s = driverTbl.glVertex3s;
   }
   driverTbl.glVertex3s(x, y, z);
}

static void REGAL_CALL missing_glVertex3sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex3sv" );
}

static void REGAL_CALL loader_glVertex3sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex3sv, "glVertex3sv");
   if ( !driverTbl.glVertex3sv ) {
      driverTbl.glVertex3sv = missing_glVertex3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex3sv == loader_glVertex3sv) {
      rCtx->dsp.emuTbl.glVertex3sv = driverTbl.glVertex3sv;
   }
   driverTbl.glVertex3sv(v);
}

static void REGAL_CALL missing_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertex4d" );
}

static void REGAL_CALL loader_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex4d, "glVertex4d");
   if ( !driverTbl.glVertex4d ) {
      driverTbl.glVertex4d = missing_glVertex4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex4d == loader_glVertex4d) {
      rCtx->dsp.emuTbl.glVertex4d = driverTbl.glVertex4d;
   }
   driverTbl.glVertex4d(x, y, z, w);
}

static void REGAL_CALL missing_glVertex4dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex4dv" );
}

static void REGAL_CALL loader_glVertex4dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex4dv, "glVertex4dv");
   if ( !driverTbl.glVertex4dv ) {
      driverTbl.glVertex4dv = missing_glVertex4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex4dv == loader_glVertex4dv) {
      rCtx->dsp.emuTbl.glVertex4dv = driverTbl.glVertex4dv;
   }
   driverTbl.glVertex4dv(v);
}

static void REGAL_CALL missing_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertex4f" );
}

static void REGAL_CALL loader_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex4f, "glVertex4f");
   if ( !driverTbl.glVertex4f ) {
      driverTbl.glVertex4f = missing_glVertex4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex4f == loader_glVertex4f) {
      rCtx->dsp.emuTbl.glVertex4f = driverTbl.glVertex4f;
   }
   driverTbl.glVertex4f(x, y, z, w);
}

static void REGAL_CALL missing_glVertex4fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex4fv" );
}

static void REGAL_CALL loader_glVertex4fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex4fv, "glVertex4fv");
   if ( !driverTbl.glVertex4fv ) {
      driverTbl.glVertex4fv = missing_glVertex4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex4fv == loader_glVertex4fv) {
      rCtx->dsp.emuTbl.glVertex4fv = driverTbl.glVertex4fv;
   }
   driverTbl.glVertex4fv(v);
}

static void REGAL_CALL missing_glVertex4i(GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertex4i" );
}

static void REGAL_CALL loader_glVertex4i(GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex4i, "glVertex4i");
   if ( !driverTbl.glVertex4i ) {
      driverTbl.glVertex4i = missing_glVertex4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex4i == loader_glVertex4i) {
      rCtx->dsp.emuTbl.glVertex4i = driverTbl.glVertex4i;
   }
   driverTbl.glVertex4i(x, y, z, w);
}

static void REGAL_CALL missing_glVertex4iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex4iv" );
}

static void REGAL_CALL loader_glVertex4iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex4iv, "glVertex4iv");
   if ( !driverTbl.glVertex4iv ) {
      driverTbl.glVertex4iv = missing_glVertex4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex4iv == loader_glVertex4iv) {
      rCtx->dsp.emuTbl.glVertex4iv = driverTbl.glVertex4iv;
   }
   driverTbl.glVertex4iv(v);
}

static void REGAL_CALL missing_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertex4s" );
}

static void REGAL_CALL loader_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex4s, "glVertex4s");
   if ( !driverTbl.glVertex4s ) {
      driverTbl.glVertex4s = missing_glVertex4s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex4s == loader_glVertex4s) {
      rCtx->dsp.emuTbl.glVertex4s = driverTbl.glVertex4s;
   }
   driverTbl.glVertex4s(x, y, z, w);
}

static void REGAL_CALL missing_glVertex4sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex4sv" );
}

static void REGAL_CALL loader_glVertex4sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex4sv, "glVertex4sv");
   if ( !driverTbl.glVertex4sv ) {
      driverTbl.glVertex4sv = missing_glVertex4sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex4sv == loader_glVertex4sv) {
      rCtx->dsp.emuTbl.glVertex4sv = driverTbl.glVertex4sv;
   }
   driverTbl.glVertex4sv(v);
}

static void REGAL_CALL missing_glClipPlane(GLenum plane, const GLdouble *equation)
{
   UNUSED_PARAMETER(plane);
   UNUSED_PARAMETER(equation);
   Warning( "Called missing function glClipPlane" );
}

static void REGAL_CALL loader_glClipPlane(GLenum plane, const GLdouble *equation)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClipPlane, "glClipPlane");
   if ( !driverTbl.glClipPlane ) {
      driverTbl.glClipPlane = missing_glClipPlane;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClipPlane == loader_glClipPlane) {
      rCtx->dsp.emuTbl.glClipPlane = driverTbl.glClipPlane;
   }
   driverTbl.glClipPlane(plane, equation);
}

static void REGAL_CALL missing_glColorMaterial(GLenum face, GLenum mode)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glColorMaterial" );
}

static void REGAL_CALL loader_glColorMaterial(GLenum face, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorMaterial, "glColorMaterial");
   if ( !driverTbl.glColorMaterial ) {
      driverTbl.glColorMaterial = missing_glColorMaterial;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorMaterial == loader_glColorMaterial) {
      rCtx->dsp.emuTbl.glColorMaterial = driverTbl.glColorMaterial;
   }
   driverTbl.glColorMaterial(face, mode);
}

static void REGAL_CALL missing_glCullFace(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glCullFace" );
}

static void REGAL_CALL loader_glCullFace(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCullFace, "glCullFace");
   if ( !driverTbl.glCullFace ) {
      driverTbl.glCullFace = missing_glCullFace;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCullFace == loader_glCullFace) {
      rCtx->dsp.emuTbl.glCullFace = driverTbl.glCullFace;
   }
   driverTbl.glCullFace(mode);
}

static void REGAL_CALL missing_glFogf(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glFogf" );
}

static void REGAL_CALL loader_glFogf(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogf, "glFogf");
   if ( !driverTbl.glFogf ) {
      driverTbl.glFogf = missing_glFogf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogf == loader_glFogf) {
      rCtx->dsp.emuTbl.glFogf = driverTbl.glFogf;
   }
   driverTbl.glFogf(pname, param);
}

static void REGAL_CALL missing_glFogfv(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glFogfv" );
}

static void REGAL_CALL loader_glFogfv(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogfv, "glFogfv");
   if ( !driverTbl.glFogfv ) {
      driverTbl.glFogfv = missing_glFogfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogfv == loader_glFogfv) {
      rCtx->dsp.emuTbl.glFogfv = driverTbl.glFogfv;
   }
   driverTbl.glFogfv(pname, params);
}

static void REGAL_CALL missing_glFogi(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glFogi" );
}

static void REGAL_CALL loader_glFogi(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogi, "glFogi");
   if ( !driverTbl.glFogi ) {
      driverTbl.glFogi = missing_glFogi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogi == loader_glFogi) {
      rCtx->dsp.emuTbl.glFogi = driverTbl.glFogi;
   }
   driverTbl.glFogi(pname, param);
}

static void REGAL_CALL missing_glFogiv(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glFogiv" );
}

static void REGAL_CALL loader_glFogiv(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogiv, "glFogiv");
   if ( !driverTbl.glFogiv ) {
      driverTbl.glFogiv = missing_glFogiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogiv == loader_glFogiv) {
      rCtx->dsp.emuTbl.glFogiv = driverTbl.glFogiv;
   }
   driverTbl.glFogiv(pname, params);
}

static void REGAL_CALL missing_glFrontFace(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glFrontFace" );
}

static void REGAL_CALL loader_glFrontFace(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFrontFace, "glFrontFace");
   if ( !driverTbl.glFrontFace ) {
      driverTbl.glFrontFace = missing_glFrontFace;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFrontFace == loader_glFrontFace) {
      rCtx->dsp.emuTbl.glFrontFace = driverTbl.glFrontFace;
   }
   driverTbl.glFrontFace(mode);
}

static void REGAL_CALL missing_glHint(GLenum target, GLenum mode)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glHint" );
}

static void REGAL_CALL loader_glHint(GLenum target, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glHint, "glHint");
   if ( !driverTbl.glHint ) {
      driverTbl.glHint = missing_glHint;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glHint == loader_glHint) {
      rCtx->dsp.emuTbl.glHint = driverTbl.glHint;
   }
   driverTbl.glHint(target, mode);
}

static void REGAL_CALL missing_glLightf(GLenum light, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glLightf" );
}

static void REGAL_CALL loader_glLightf(GLenum light, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLightf, "glLightf");
   if ( !driverTbl.glLightf ) {
      driverTbl.glLightf = missing_glLightf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLightf == loader_glLightf) {
      rCtx->dsp.emuTbl.glLightf = driverTbl.glLightf;
   }
   driverTbl.glLightf(light, pname, param);
}

static void REGAL_CALL missing_glLightfv(GLenum light, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glLightfv" );
}

static void REGAL_CALL loader_glLightfv(GLenum light, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLightfv, "glLightfv");
   if ( !driverTbl.glLightfv ) {
      driverTbl.glLightfv = missing_glLightfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLightfv == loader_glLightfv) {
      rCtx->dsp.emuTbl.glLightfv = driverTbl.glLightfv;
   }
   driverTbl.glLightfv(light, pname, params);
}

static void REGAL_CALL missing_glLighti(GLenum light, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glLighti" );
}

static void REGAL_CALL loader_glLighti(GLenum light, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLighti, "glLighti");
   if ( !driverTbl.glLighti ) {
      driverTbl.glLighti = missing_glLighti;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLighti == loader_glLighti) {
      rCtx->dsp.emuTbl.glLighti = driverTbl.glLighti;
   }
   driverTbl.glLighti(light, pname, param);
}

static void REGAL_CALL missing_glLightiv(GLenum light, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glLightiv" );
}

static void REGAL_CALL loader_glLightiv(GLenum light, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLightiv, "glLightiv");
   if ( !driverTbl.glLightiv ) {
      driverTbl.glLightiv = missing_glLightiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLightiv == loader_glLightiv) {
      rCtx->dsp.emuTbl.glLightiv = driverTbl.glLightiv;
   }
   driverTbl.glLightiv(light, pname, params);
}

static void REGAL_CALL missing_glLightModelf(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glLightModelf" );
}

static void REGAL_CALL loader_glLightModelf(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLightModelf, "glLightModelf");
   if ( !driverTbl.glLightModelf ) {
      driverTbl.glLightModelf = missing_glLightModelf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLightModelf == loader_glLightModelf) {
      rCtx->dsp.emuTbl.glLightModelf = driverTbl.glLightModelf;
   }
   driverTbl.glLightModelf(pname, param);
}

static void REGAL_CALL missing_glLightModelfv(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glLightModelfv" );
}

static void REGAL_CALL loader_glLightModelfv(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLightModelfv, "glLightModelfv");
   if ( !driverTbl.glLightModelfv ) {
      driverTbl.glLightModelfv = missing_glLightModelfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLightModelfv == loader_glLightModelfv) {
      rCtx->dsp.emuTbl.glLightModelfv = driverTbl.glLightModelfv;
   }
   driverTbl.glLightModelfv(pname, params);
}

static void REGAL_CALL missing_glLightModeli(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glLightModeli" );
}

static void REGAL_CALL loader_glLightModeli(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLightModeli, "glLightModeli");
   if ( !driverTbl.glLightModeli ) {
      driverTbl.glLightModeli = missing_glLightModeli;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLightModeli == loader_glLightModeli) {
      rCtx->dsp.emuTbl.glLightModeli = driverTbl.glLightModeli;
   }
   driverTbl.glLightModeli(pname, param);
}

static void REGAL_CALL missing_glLightModeliv(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glLightModeliv" );
}

static void REGAL_CALL loader_glLightModeliv(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLightModeliv, "glLightModeliv");
   if ( !driverTbl.glLightModeliv ) {
      driverTbl.glLightModeliv = missing_glLightModeliv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLightModeliv == loader_glLightModeliv) {
      rCtx->dsp.emuTbl.glLightModeliv = driverTbl.glLightModeliv;
   }
   driverTbl.glLightModeliv(pname, params);
}

static void REGAL_CALL missing_glLineStipple(GLint factor, GLushort pattern)
{
   UNUSED_PARAMETER(factor);
   UNUSED_PARAMETER(pattern);
   Warning( "Called missing function glLineStipple" );
}

static void REGAL_CALL loader_glLineStipple(GLint factor, GLushort pattern)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLineStipple, "glLineStipple");
   if ( !driverTbl.glLineStipple ) {
      driverTbl.glLineStipple = missing_glLineStipple;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLineStipple == loader_glLineStipple) {
      rCtx->dsp.emuTbl.glLineStipple = driverTbl.glLineStipple;
   }
   driverTbl.glLineStipple(factor, pattern);
}

static void REGAL_CALL missing_glLineWidth(GLfloat width)
{
   UNUSED_PARAMETER(width);
   Warning( "Called missing function glLineWidth" );
}

static void REGAL_CALL loader_glLineWidth(GLfloat width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLineWidth, "glLineWidth");
   if ( !driverTbl.glLineWidth ) {
      driverTbl.glLineWidth = missing_glLineWidth;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLineWidth == loader_glLineWidth) {
      rCtx->dsp.emuTbl.glLineWidth = driverTbl.glLineWidth;
   }
   driverTbl.glLineWidth(width);
}

static void REGAL_CALL missing_glMaterialf(GLenum face, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glMaterialf" );
}

static void REGAL_CALL loader_glMaterialf(GLenum face, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMaterialf, "glMaterialf");
   if ( !driverTbl.glMaterialf ) {
      driverTbl.glMaterialf = missing_glMaterialf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMaterialf == loader_glMaterialf) {
      rCtx->dsp.emuTbl.glMaterialf = driverTbl.glMaterialf;
   }
   driverTbl.glMaterialf(face, pname, param);
}

static void REGAL_CALL missing_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glMaterialfv" );
}

static void REGAL_CALL loader_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMaterialfv, "glMaterialfv");
   if ( !driverTbl.glMaterialfv ) {
      driverTbl.glMaterialfv = missing_glMaterialfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMaterialfv == loader_glMaterialfv) {
      rCtx->dsp.emuTbl.glMaterialfv = driverTbl.glMaterialfv;
   }
   driverTbl.glMaterialfv(face, pname, params);
}

static void REGAL_CALL missing_glMateriali(GLenum face, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glMateriali" );
}

static void REGAL_CALL loader_glMateriali(GLenum face, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMateriali, "glMateriali");
   if ( !driverTbl.glMateriali ) {
      driverTbl.glMateriali = missing_glMateriali;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMateriali == loader_glMateriali) {
      rCtx->dsp.emuTbl.glMateriali = driverTbl.glMateriali;
   }
   driverTbl.glMateriali(face, pname, param);
}

static void REGAL_CALL missing_glMaterialiv(GLenum face, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glMaterialiv" );
}

static void REGAL_CALL loader_glMaterialiv(GLenum face, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMaterialiv, "glMaterialiv");
   if ( !driverTbl.glMaterialiv ) {
      driverTbl.glMaterialiv = missing_glMaterialiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMaterialiv == loader_glMaterialiv) {
      rCtx->dsp.emuTbl.glMaterialiv = driverTbl.glMaterialiv;
   }
   driverTbl.glMaterialiv(face, pname, params);
}

static void REGAL_CALL missing_glPointSize(GLfloat size)
{
   UNUSED_PARAMETER(size);
   Warning( "Called missing function glPointSize" );
}

static void REGAL_CALL loader_glPointSize(GLfloat size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPointSize, "glPointSize");
   if ( !driverTbl.glPointSize ) {
      driverTbl.glPointSize = missing_glPointSize;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPointSize == loader_glPointSize) {
      rCtx->dsp.emuTbl.glPointSize = driverTbl.glPointSize;
   }
   driverTbl.glPointSize(size);
}

static void REGAL_CALL missing_glPolygonMode(GLenum face, GLenum mode)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glPolygonMode" );
}

static void REGAL_CALL loader_glPolygonMode(GLenum face, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPolygonMode, "glPolygonMode");
   if ( !driverTbl.glPolygonMode ) {
      driverTbl.glPolygonMode = missing_glPolygonMode;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPolygonMode == loader_glPolygonMode) {
      rCtx->dsp.emuTbl.glPolygonMode = driverTbl.glPolygonMode;
   }
   driverTbl.glPolygonMode(face, mode);
}

static void REGAL_CALL missing_glPolygonStipple(const GLubyte *mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glPolygonStipple" );
}

static void REGAL_CALL loader_glPolygonStipple(const GLubyte *mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPolygonStipple, "glPolygonStipple");
   if ( !driverTbl.glPolygonStipple ) {
      driverTbl.glPolygonStipple = missing_glPolygonStipple;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPolygonStipple == loader_glPolygonStipple) {
      rCtx->dsp.emuTbl.glPolygonStipple = driverTbl.glPolygonStipple;
   }
   driverTbl.glPolygonStipple(mask);
}

static void REGAL_CALL missing_glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glScissor" );
}

static void REGAL_CALL loader_glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glScissor, "glScissor");
   if ( !driverTbl.glScissor ) {
      driverTbl.glScissor = missing_glScissor;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glScissor == loader_glScissor) {
      rCtx->dsp.emuTbl.glScissor = driverTbl.glScissor;
   }
   driverTbl.glScissor(x, y, width, height);
}

static void REGAL_CALL missing_glShadeModel(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glShadeModel" );
}

static void REGAL_CALL loader_glShadeModel(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glShadeModel, "glShadeModel");
   if ( !driverTbl.glShadeModel ) {
      driverTbl.glShadeModel = missing_glShadeModel;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glShadeModel == loader_glShadeModel) {
      rCtx->dsp.emuTbl.glShadeModel = driverTbl.glShadeModel;
   }
   driverTbl.glShadeModel(mode);
}

static void REGAL_CALL missing_glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glTexParameterf" );
}

static void REGAL_CALL loader_glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexParameterf, "glTexParameterf");
   if ( !driverTbl.glTexParameterf ) {
      driverTbl.glTexParameterf = missing_glTexParameterf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexParameterf == loader_glTexParameterf) {
      rCtx->dsp.emuTbl.glTexParameterf = driverTbl.glTexParameterf;
   }
   driverTbl.glTexParameterf(target, pname, param);
}

static void REGAL_CALL missing_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glTexParameterfv" );
}

static void REGAL_CALL loader_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexParameterfv, "glTexParameterfv");
   if ( !driverTbl.glTexParameterfv ) {
      driverTbl.glTexParameterfv = missing_glTexParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexParameterfv == loader_glTexParameterfv) {
      rCtx->dsp.emuTbl.glTexParameterfv = driverTbl.glTexParameterfv;
   }
   driverTbl.glTexParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glTexParameteri(GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glTexParameteri" );
}

static void REGAL_CALL loader_glTexParameteri(GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexParameteri, "glTexParameteri");
   if ( !driverTbl.glTexParameteri ) {
      driverTbl.glTexParameteri = missing_glTexParameteri;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexParameteri == loader_glTexParameteri) {
      rCtx->dsp.emuTbl.glTexParameteri = driverTbl.glTexParameteri;
   }
   driverTbl.glTexParameteri(target, pname, param);
}

static void REGAL_CALL missing_glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glTexParameteriv" );
}

static void REGAL_CALL loader_glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexParameteriv, "glTexParameteriv");
   if ( !driverTbl.glTexParameteriv ) {
      driverTbl.glTexParameteriv = missing_glTexParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexParameteriv == loader_glTexParameteriv) {
      rCtx->dsp.emuTbl.glTexParameteriv = driverTbl.glTexParameteriv;
   }
   driverTbl.glTexParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTexImage1D" );
}

static void REGAL_CALL loader_glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexImage1D, "glTexImage1D");
   if ( !driverTbl.glTexImage1D ) {
      driverTbl.glTexImage1D = missing_glTexImage1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexImage1D == loader_glTexImage1D) {
      rCtx->dsp.emuTbl.glTexImage1D = driverTbl.glTexImage1D;
   }
   driverTbl.glTexImage1D(target, level, internalformat, width, border, format, type, pixels);
}

static void REGAL_CALL missing_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTexImage2D" );
}

static void REGAL_CALL loader_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexImage2D, "glTexImage2D");
   if ( !driverTbl.glTexImage2D ) {
      driverTbl.glTexImage2D = missing_glTexImage2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexImage2D == loader_glTexImage2D) {
      rCtx->dsp.emuTbl.glTexImage2D = driverTbl.glTexImage2D;
   }
   driverTbl.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
}

static void REGAL_CALL missing_glTexEnvf(GLenum target, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glTexEnvf" );
}

static void REGAL_CALL loader_glTexEnvf(GLenum target, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexEnvf, "glTexEnvf");
   if ( !driverTbl.glTexEnvf ) {
      driverTbl.glTexEnvf = missing_glTexEnvf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexEnvf == loader_glTexEnvf) {
      rCtx->dsp.emuTbl.glTexEnvf = driverTbl.glTexEnvf;
   }
   driverTbl.glTexEnvf(target, pname, param);
}

static void REGAL_CALL missing_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glTexEnvfv" );
}

static void REGAL_CALL loader_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexEnvfv, "glTexEnvfv");
   if ( !driverTbl.glTexEnvfv ) {
      driverTbl.glTexEnvfv = missing_glTexEnvfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexEnvfv == loader_glTexEnvfv) {
      rCtx->dsp.emuTbl.glTexEnvfv = driverTbl.glTexEnvfv;
   }
   driverTbl.glTexEnvfv(target, pname, params);
}

static void REGAL_CALL missing_glTexEnvi(GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glTexEnvi" );
}

static void REGAL_CALL loader_glTexEnvi(GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexEnvi, "glTexEnvi");
   if ( !driverTbl.glTexEnvi ) {
      driverTbl.glTexEnvi = missing_glTexEnvi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexEnvi == loader_glTexEnvi) {
      rCtx->dsp.emuTbl.glTexEnvi = driverTbl.glTexEnvi;
   }
   driverTbl.glTexEnvi(target, pname, param);
}

static void REGAL_CALL missing_glTexEnviv(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glTexEnviv" );
}

static void REGAL_CALL loader_glTexEnviv(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexEnviv, "glTexEnviv");
   if ( !driverTbl.glTexEnviv ) {
      driverTbl.glTexEnviv = missing_glTexEnviv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexEnviv == loader_glTexEnviv) {
      rCtx->dsp.emuTbl.glTexEnviv = driverTbl.glTexEnviv;
   }
   driverTbl.glTexEnviv(target, pname, params);
}

static void REGAL_CALL missing_glTexGend(GLenum coord, GLenum pname, GLdouble param)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glTexGend" );
}

static void REGAL_CALL loader_glTexGend(GLenum coord, GLenum pname, GLdouble param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexGend, "glTexGend");
   if ( !driverTbl.glTexGend ) {
      driverTbl.glTexGend = missing_glTexGend;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexGend == loader_glTexGend) {
      rCtx->dsp.emuTbl.glTexGend = driverTbl.glTexGend;
   }
   driverTbl.glTexGend(coord, pname, param);
}

static void REGAL_CALL missing_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glTexGendv" );
}

static void REGAL_CALL loader_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexGendv, "glTexGendv");
   if ( !driverTbl.glTexGendv ) {
      driverTbl.glTexGendv = missing_glTexGendv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexGendv == loader_glTexGendv) {
      rCtx->dsp.emuTbl.glTexGendv = driverTbl.glTexGendv;
   }
   driverTbl.glTexGendv(coord, pname, params);
}

static void REGAL_CALL missing_glTexGenf(GLenum coord, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glTexGenf" );
}

static void REGAL_CALL loader_glTexGenf(GLenum coord, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexGenf, "glTexGenf");
   if ( !driverTbl.glTexGenf ) {
      driverTbl.glTexGenf = missing_glTexGenf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexGenf == loader_glTexGenf) {
      rCtx->dsp.emuTbl.glTexGenf = driverTbl.glTexGenf;
   }
   driverTbl.glTexGenf(coord, pname, param);
}

static void REGAL_CALL missing_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glTexGenfv" );
}

static void REGAL_CALL loader_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexGenfv, "glTexGenfv");
   if ( !driverTbl.glTexGenfv ) {
      driverTbl.glTexGenfv = missing_glTexGenfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexGenfv == loader_glTexGenfv) {
      rCtx->dsp.emuTbl.glTexGenfv = driverTbl.glTexGenfv;
   }
   driverTbl.glTexGenfv(coord, pname, params);
}

static void REGAL_CALL missing_glTexGeni(GLenum coord, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glTexGeni" );
}

static void REGAL_CALL loader_glTexGeni(GLenum coord, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexGeni, "glTexGeni");
   if ( !driverTbl.glTexGeni ) {
      driverTbl.glTexGeni = missing_glTexGeni;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexGeni == loader_glTexGeni) {
      rCtx->dsp.emuTbl.glTexGeni = driverTbl.glTexGeni;
   }
   driverTbl.glTexGeni(coord, pname, param);
}

static void REGAL_CALL missing_glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glTexGeniv" );
}

static void REGAL_CALL loader_glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexGeniv, "glTexGeniv");
   if ( !driverTbl.glTexGeniv ) {
      driverTbl.glTexGeniv = missing_glTexGeniv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexGeniv == loader_glTexGeniv) {
      rCtx->dsp.emuTbl.glTexGeniv = driverTbl.glTexGeniv;
   }
   driverTbl.glTexGeniv(coord, pname, params);
}

static void REGAL_CALL missing_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glFeedbackBuffer" );
}

static void REGAL_CALL loader_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFeedbackBuffer, "glFeedbackBuffer");
   if ( !driverTbl.glFeedbackBuffer ) {
      driverTbl.glFeedbackBuffer = missing_glFeedbackBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFeedbackBuffer == loader_glFeedbackBuffer) {
      rCtx->dsp.emuTbl.glFeedbackBuffer = driverTbl.glFeedbackBuffer;
   }
   driverTbl.glFeedbackBuffer(size, type, buffer);
}

static void REGAL_CALL missing_glSelectBuffer(GLsizei size, GLuint *buffer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glSelectBuffer" );
}

static void REGAL_CALL loader_glSelectBuffer(GLsizei size, GLuint *buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSelectBuffer, "glSelectBuffer");
   if ( !driverTbl.glSelectBuffer ) {
      driverTbl.glSelectBuffer = missing_glSelectBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSelectBuffer == loader_glSelectBuffer) {
      rCtx->dsp.emuTbl.glSelectBuffer = driverTbl.glSelectBuffer;
   }
   driverTbl.glSelectBuffer(size, buffer);
}

static GLint REGAL_CALL missing_glRenderMode(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glRenderMode" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glRenderMode(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRenderMode, "glRenderMode");
   if ( !driverTbl.glRenderMode ) {
      driverTbl.glRenderMode = missing_glRenderMode;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRenderMode == loader_glRenderMode) {
      rCtx->dsp.emuTbl.glRenderMode = driverTbl.glRenderMode;
   }
   return driverTbl.glRenderMode(mode);
}

static void REGAL_CALL missing_glInitNames(void)
{
   Warning( "Called missing function glInitNames" );
}

static void REGAL_CALL loader_glInitNames(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glInitNames, "glInitNames");
   if ( !driverTbl.glInitNames ) {
      driverTbl.glInitNames = missing_glInitNames;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glInitNames == loader_glInitNames) {
      rCtx->dsp.emuTbl.glInitNames = driverTbl.glInitNames;
   }
   driverTbl.glInitNames();
}

static void REGAL_CALL missing_glLoadName(GLuint name)
{
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glLoadName" );
}

static void REGAL_CALL loader_glLoadName(GLuint name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLoadName, "glLoadName");
   if ( !driverTbl.glLoadName ) {
      driverTbl.glLoadName = missing_glLoadName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLoadName == loader_glLoadName) {
      rCtx->dsp.emuTbl.glLoadName = driverTbl.glLoadName;
   }
   driverTbl.glLoadName(name);
}

static void REGAL_CALL missing_glPassThrough(GLfloat token)
{
   UNUSED_PARAMETER(token);
   Warning( "Called missing function glPassThrough" );
}

static void REGAL_CALL loader_glPassThrough(GLfloat token)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPassThrough, "glPassThrough");
   if ( !driverTbl.glPassThrough ) {
      driverTbl.glPassThrough = missing_glPassThrough;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPassThrough == loader_glPassThrough) {
      rCtx->dsp.emuTbl.glPassThrough = driverTbl.glPassThrough;
   }
   driverTbl.glPassThrough(token);
}

static void REGAL_CALL missing_glPopName(void)
{
   Warning( "Called missing function glPopName" );
}

static void REGAL_CALL loader_glPopName(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPopName, "glPopName");
   if ( !driverTbl.glPopName ) {
      driverTbl.glPopName = missing_glPopName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPopName == loader_glPopName) {
      rCtx->dsp.emuTbl.glPopName = driverTbl.glPopName;
   }
   driverTbl.glPopName();
}

static void REGAL_CALL missing_glPushName(GLuint name)
{
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glPushName" );
}

static void REGAL_CALL loader_glPushName(GLuint name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPushName, "glPushName");
   if ( !driverTbl.glPushName ) {
      driverTbl.glPushName = missing_glPushName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPushName == loader_glPushName) {
      rCtx->dsp.emuTbl.glPushName = driverTbl.glPushName;
   }
   driverTbl.glPushName(name);
}

static void REGAL_CALL missing_glDrawBuffer(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glDrawBuffer" );
}

static void REGAL_CALL loader_glDrawBuffer(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawBuffer, "glDrawBuffer");
   if ( !driverTbl.glDrawBuffer ) {
      driverTbl.glDrawBuffer = missing_glDrawBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawBuffer == loader_glDrawBuffer) {
      rCtx->dsp.emuTbl.glDrawBuffer = driverTbl.glDrawBuffer;
   }
   driverTbl.glDrawBuffer(mode);
}

static void REGAL_CALL missing_glClear(GLbitfield mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glClear" );
}

static void REGAL_CALL loader_glClear(GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClear, "glClear");
   if ( !driverTbl.glClear ) {
      driverTbl.glClear = missing_glClear;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClear == loader_glClear) {
      rCtx->dsp.emuTbl.glClear = driverTbl.glClear;
   }
   driverTbl.glClear(mask);
}

static void REGAL_CALL missing_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glClearAccum" );
}

static void REGAL_CALL loader_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClearAccum, "glClearAccum");
   if ( !driverTbl.glClearAccum ) {
      driverTbl.glClearAccum = missing_glClearAccum;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClearAccum == loader_glClearAccum) {
      rCtx->dsp.emuTbl.glClearAccum = driverTbl.glClearAccum;
   }
   driverTbl.glClearAccum(red, green, blue, alpha);
}

static void REGAL_CALL missing_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glClearColor" );
}

static void REGAL_CALL loader_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClearColor, "glClearColor");
   if ( !driverTbl.glClearColor ) {
      driverTbl.glClearColor = missing_glClearColor;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClearColor == loader_glClearColor) {
      rCtx->dsp.emuTbl.glClearColor = driverTbl.glClearColor;
   }
   driverTbl.glClearColor(red, green, blue, alpha);
}

static void REGAL_CALL missing_glClearDepth(GLclampd depth)
{
   UNUSED_PARAMETER(depth);
   Warning( "Called missing function glClearDepth" );
}

static void REGAL_CALL loader_glClearDepth(GLclampd depth)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClearDepth, "glClearDepth");
   if ( !driverTbl.glClearDepth ) {
      driverTbl.glClearDepth = missing_glClearDepth;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClearDepth == loader_glClearDepth) {
      rCtx->dsp.emuTbl.glClearDepth = driverTbl.glClearDepth;
   }
   driverTbl.glClearDepth(depth);
}

static void REGAL_CALL missing_glClearIndex(GLfloat c)
{
   UNUSED_PARAMETER(c);
   Warning( "Called missing function glClearIndex" );
}

static void REGAL_CALL loader_glClearIndex(GLfloat c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClearIndex, "glClearIndex");
   if ( !driverTbl.glClearIndex ) {
      driverTbl.glClearIndex = missing_glClearIndex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClearIndex == loader_glClearIndex) {
      rCtx->dsp.emuTbl.glClearIndex = driverTbl.glClearIndex;
   }
   driverTbl.glClearIndex(c);
}

static void REGAL_CALL missing_glClearStencil(GLint s)
{
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glClearStencil" );
}

static void REGAL_CALL loader_glClearStencil(GLint s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClearStencil, "glClearStencil");
   if ( !driverTbl.glClearStencil ) {
      driverTbl.glClearStencil = missing_glClearStencil;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClearStencil == loader_glClearStencil) {
      rCtx->dsp.emuTbl.glClearStencil = driverTbl.glClearStencil;
   }
   driverTbl.glClearStencil(s);
}

static void REGAL_CALL missing_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glColorMask" );
}

static void REGAL_CALL loader_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorMask, "glColorMask");
   if ( !driverTbl.glColorMask ) {
      driverTbl.glColorMask = missing_glColorMask;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorMask == loader_glColorMask) {
      rCtx->dsp.emuTbl.glColorMask = driverTbl.glColorMask;
   }
   driverTbl.glColorMask(red, green, blue, alpha);
}

static void REGAL_CALL missing_glDepthMask(GLboolean flag)
{
   UNUSED_PARAMETER(flag);
   Warning( "Called missing function glDepthMask" );
}

static void REGAL_CALL loader_glDepthMask(GLboolean flag)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDepthMask, "glDepthMask");
   if ( !driverTbl.glDepthMask ) {
      driverTbl.glDepthMask = missing_glDepthMask;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDepthMask == loader_glDepthMask) {
      rCtx->dsp.emuTbl.glDepthMask = driverTbl.glDepthMask;
   }
   driverTbl.glDepthMask(flag);
}

static void REGAL_CALL missing_glIndexMask(GLuint mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glIndexMask" );
}

static void REGAL_CALL loader_glIndexMask(GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexMask, "glIndexMask");
   if ( !driverTbl.glIndexMask ) {
      driverTbl.glIndexMask = missing_glIndexMask;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexMask == loader_glIndexMask) {
      rCtx->dsp.emuTbl.glIndexMask = driverTbl.glIndexMask;
   }
   driverTbl.glIndexMask(mask);
}

static void REGAL_CALL missing_glStencilMask(GLuint mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glStencilMask" );
}

static void REGAL_CALL loader_glStencilMask(GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStencilMask, "glStencilMask");
   if ( !driverTbl.glStencilMask ) {
      driverTbl.glStencilMask = missing_glStencilMask;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStencilMask == loader_glStencilMask) {
      rCtx->dsp.emuTbl.glStencilMask = driverTbl.glStencilMask;
   }
   driverTbl.glStencilMask(mask);
}

static void REGAL_CALL missing_glAccum(GLenum op, GLfloat value)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glAccum" );
}

static void REGAL_CALL loader_glAccum(GLenum op, GLfloat value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glAccum, "glAccum");
   if ( !driverTbl.glAccum ) {
      driverTbl.glAccum = missing_glAccum;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glAccum == loader_glAccum) {
      rCtx->dsp.emuTbl.glAccum = driverTbl.glAccum;
   }
   driverTbl.glAccum(op, value);
}

static void REGAL_CALL missing_glDisable(GLenum cap)
{
   UNUSED_PARAMETER(cap);
   Warning( "Called missing function glDisable" );
}

static void REGAL_CALL loader_glDisable(GLenum cap)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDisable, "glDisable");
   if ( !driverTbl.glDisable ) {
      driverTbl.glDisable = missing_glDisable;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDisable == loader_glDisable) {
      rCtx->dsp.emuTbl.glDisable = driverTbl.glDisable;
   }
   driverTbl.glDisable(cap);
}

static void REGAL_CALL missing_glEnable(GLenum cap)
{
   UNUSED_PARAMETER(cap);
   Warning( "Called missing function glEnable" );
}

static void REGAL_CALL loader_glEnable(GLenum cap)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEnable, "glEnable");
   if ( !driverTbl.glEnable ) {
      driverTbl.glEnable = missing_glEnable;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEnable == loader_glEnable) {
      rCtx->dsp.emuTbl.glEnable = driverTbl.glEnable;
   }
   driverTbl.glEnable(cap);
}

static void REGAL_CALL missing_glFinish(void)
{
   Warning( "Called missing function glFinish" );
}

static void REGAL_CALL loader_glFinish(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFinish, "glFinish");
   if ( !driverTbl.glFinish ) {
      driverTbl.glFinish = missing_glFinish;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFinish == loader_glFinish) {
      rCtx->dsp.emuTbl.glFinish = driverTbl.glFinish;
   }
   driverTbl.glFinish();
}

static void REGAL_CALL missing_glFlush(void)
{
   Warning( "Called missing function glFlush" );
}

static void REGAL_CALL loader_glFlush(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFlush, "glFlush");
   if ( !driverTbl.glFlush ) {
      driverTbl.glFlush = missing_glFlush;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFlush == loader_glFlush) {
      rCtx->dsp.emuTbl.glFlush = driverTbl.glFlush;
   }
   driverTbl.glFlush();
}

static void REGAL_CALL missing_glPopAttrib(void)
{
   Warning( "Called missing function glPopAttrib" );
}

static void REGAL_CALL loader_glPopAttrib(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPopAttrib, "glPopAttrib");
   if ( !driverTbl.glPopAttrib ) {
      driverTbl.glPopAttrib = missing_glPopAttrib;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPopAttrib == loader_glPopAttrib) {
      rCtx->dsp.emuTbl.glPopAttrib = driverTbl.glPopAttrib;
   }
   driverTbl.glPopAttrib();
}

static void REGAL_CALL missing_glPushAttrib(GLbitfield mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glPushAttrib" );
}

static void REGAL_CALL loader_glPushAttrib(GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPushAttrib, "glPushAttrib");
   if ( !driverTbl.glPushAttrib ) {
      driverTbl.glPushAttrib = missing_glPushAttrib;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPushAttrib == loader_glPushAttrib) {
      rCtx->dsp.emuTbl.glPushAttrib = driverTbl.glPushAttrib;
   }
   driverTbl.glPushAttrib(mask);
}

static void REGAL_CALL missing_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(order);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glMap1d" );
}

static void REGAL_CALL loader_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMap1d, "glMap1d");
   if ( !driverTbl.glMap1d ) {
      driverTbl.glMap1d = missing_glMap1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMap1d == loader_glMap1d) {
      rCtx->dsp.emuTbl.glMap1d = driverTbl.glMap1d;
   }
   driverTbl.glMap1d(target, u1, u2, stride, order, points);
}

static void REGAL_CALL missing_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(order);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glMap1f" );
}

static void REGAL_CALL loader_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMap1f, "glMap1f");
   if ( !driverTbl.glMap1f ) {
      driverTbl.glMap1f = missing_glMap1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMap1f == loader_glMap1f) {
      rCtx->dsp.emuTbl.glMap1f = driverTbl.glMap1f;
   }
   driverTbl.glMap1f(target, u1, u2, stride, order, points);
}

static void REGAL_CALL missing_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(uorder);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(vorder);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glMap2d" );
}

static void REGAL_CALL loader_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMap2d, "glMap2d");
   if ( !driverTbl.glMap2d ) {
      driverTbl.glMap2d = missing_glMap2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMap2d == loader_glMap2d) {
      rCtx->dsp.emuTbl.glMap2d = driverTbl.glMap2d;
   }
   driverTbl.glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

static void REGAL_CALL missing_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(uorder);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(vorder);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glMap2f" );
}

static void REGAL_CALL loader_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMap2f, "glMap2f");
   if ( !driverTbl.glMap2f ) {
      driverTbl.glMap2f = missing_glMap2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMap2f == loader_glMap2f) {
      rCtx->dsp.emuTbl.glMap2f = driverTbl.glMap2f;
   }
   driverTbl.glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

static void REGAL_CALL missing_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
{
   UNUSED_PARAMETER(un);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   Warning( "Called missing function glMapGrid1d" );
}

static void REGAL_CALL loader_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapGrid1d, "glMapGrid1d");
   if ( !driverTbl.glMapGrid1d ) {
      driverTbl.glMapGrid1d = missing_glMapGrid1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapGrid1d == loader_glMapGrid1d) {
      rCtx->dsp.emuTbl.glMapGrid1d = driverTbl.glMapGrid1d;
   }
   driverTbl.glMapGrid1d(un, u1, u2);
}

static void REGAL_CALL missing_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
{
   UNUSED_PARAMETER(un);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   Warning( "Called missing function glMapGrid1f" );
}

static void REGAL_CALL loader_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapGrid1f, "glMapGrid1f");
   if ( !driverTbl.glMapGrid1f ) {
      driverTbl.glMapGrid1f = missing_glMapGrid1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapGrid1f == loader_glMapGrid1f) {
      rCtx->dsp.emuTbl.glMapGrid1f = driverTbl.glMapGrid1f;
   }
   driverTbl.glMapGrid1f(un, u1, u2);
}

static void REGAL_CALL missing_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{
   UNUSED_PARAMETER(un);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(vn);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glMapGrid2d" );
}

static void REGAL_CALL loader_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapGrid2d, "glMapGrid2d");
   if ( !driverTbl.glMapGrid2d ) {
      driverTbl.glMapGrid2d = missing_glMapGrid2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapGrid2d == loader_glMapGrid2d) {
      rCtx->dsp.emuTbl.glMapGrid2d = driverTbl.glMapGrid2d;
   }
   driverTbl.glMapGrid2d(un, u1, u2, vn, v1, v2);
}

static void REGAL_CALL missing_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{
   UNUSED_PARAMETER(un);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(vn);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glMapGrid2f" );
}

static void REGAL_CALL loader_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapGrid2f, "glMapGrid2f");
   if ( !driverTbl.glMapGrid2f ) {
      driverTbl.glMapGrid2f = missing_glMapGrid2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapGrid2f == loader_glMapGrid2f) {
      rCtx->dsp.emuTbl.glMapGrid2f = driverTbl.glMapGrid2f;
   }
   driverTbl.glMapGrid2f(un, u1, u2, vn, v1, v2);
}

static void REGAL_CALL missing_glEvalCoord1d(GLdouble u)
{
   UNUSED_PARAMETER(u);
   Warning( "Called missing function glEvalCoord1d" );
}

static void REGAL_CALL loader_glEvalCoord1d(GLdouble u)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEvalCoord1d, "glEvalCoord1d");
   if ( !driverTbl.glEvalCoord1d ) {
      driverTbl.glEvalCoord1d = missing_glEvalCoord1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEvalCoord1d == loader_glEvalCoord1d) {
      rCtx->dsp.emuTbl.glEvalCoord1d = driverTbl.glEvalCoord1d;
   }
   driverTbl.glEvalCoord1d(u);
}

static void REGAL_CALL missing_glEvalCoord1dv(const GLdouble *u)
{
   UNUSED_PARAMETER(u);
   Warning( "Called missing function glEvalCoord1dv" );
}

static void REGAL_CALL loader_glEvalCoord1dv(const GLdouble *u)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEvalCoord1dv, "glEvalCoord1dv");
   if ( !driverTbl.glEvalCoord1dv ) {
      driverTbl.glEvalCoord1dv = missing_glEvalCoord1dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEvalCoord1dv == loader_glEvalCoord1dv) {
      rCtx->dsp.emuTbl.glEvalCoord1dv = driverTbl.glEvalCoord1dv;
   }
   driverTbl.glEvalCoord1dv(u);
}

static void REGAL_CALL missing_glEvalCoord1f(GLfloat u)
{
   UNUSED_PARAMETER(u);
   Warning( "Called missing function glEvalCoord1f" );
}

static void REGAL_CALL loader_glEvalCoord1f(GLfloat u)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEvalCoord1f, "glEvalCoord1f");
   if ( !driverTbl.glEvalCoord1f ) {
      driverTbl.glEvalCoord1f = missing_glEvalCoord1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEvalCoord1f == loader_glEvalCoord1f) {
      rCtx->dsp.emuTbl.glEvalCoord1f = driverTbl.glEvalCoord1f;
   }
   driverTbl.glEvalCoord1f(u);
}

static void REGAL_CALL missing_glEvalCoord1fv(const GLfloat *u)
{
   UNUSED_PARAMETER(u);
   Warning( "Called missing function glEvalCoord1fv" );
}

static void REGAL_CALL loader_glEvalCoord1fv(const GLfloat *u)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEvalCoord1fv, "glEvalCoord1fv");
   if ( !driverTbl.glEvalCoord1fv ) {
      driverTbl.glEvalCoord1fv = missing_glEvalCoord1fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEvalCoord1fv == loader_glEvalCoord1fv) {
      rCtx->dsp.emuTbl.glEvalCoord1fv = driverTbl.glEvalCoord1fv;
   }
   driverTbl.glEvalCoord1fv(u);
}

static void REGAL_CALL missing_glEvalCoord2d(GLdouble u, GLdouble v)
{
   UNUSED_PARAMETER(u);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glEvalCoord2d" );
}

static void REGAL_CALL loader_glEvalCoord2d(GLdouble u, GLdouble v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEvalCoord2d, "glEvalCoord2d");
   if ( !driverTbl.glEvalCoord2d ) {
      driverTbl.glEvalCoord2d = missing_glEvalCoord2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEvalCoord2d == loader_glEvalCoord2d) {
      rCtx->dsp.emuTbl.glEvalCoord2d = driverTbl.glEvalCoord2d;
   }
   driverTbl.glEvalCoord2d(u, v);
}

static void REGAL_CALL missing_glEvalCoord2dv(const GLdouble *u)
{
   UNUSED_PARAMETER(u);
   Warning( "Called missing function glEvalCoord2dv" );
}

static void REGAL_CALL loader_glEvalCoord2dv(const GLdouble *u)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEvalCoord2dv, "glEvalCoord2dv");
   if ( !driverTbl.glEvalCoord2dv ) {
      driverTbl.glEvalCoord2dv = missing_glEvalCoord2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEvalCoord2dv == loader_glEvalCoord2dv) {
      rCtx->dsp.emuTbl.glEvalCoord2dv = driverTbl.glEvalCoord2dv;
   }
   driverTbl.glEvalCoord2dv(u);
}

static void REGAL_CALL missing_glEvalCoord2f(GLfloat u, GLfloat v)
{
   UNUSED_PARAMETER(u);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glEvalCoord2f" );
}

static void REGAL_CALL loader_glEvalCoord2f(GLfloat u, GLfloat v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEvalCoord2f, "glEvalCoord2f");
   if ( !driverTbl.glEvalCoord2f ) {
      driverTbl.glEvalCoord2f = missing_glEvalCoord2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEvalCoord2f == loader_glEvalCoord2f) {
      rCtx->dsp.emuTbl.glEvalCoord2f = driverTbl.glEvalCoord2f;
   }
   driverTbl.glEvalCoord2f(u, v);
}

static void REGAL_CALL missing_glEvalCoord2fv(const GLfloat *u)
{
   UNUSED_PARAMETER(u);
   Warning( "Called missing function glEvalCoord2fv" );
}

static void REGAL_CALL loader_glEvalCoord2fv(const GLfloat *u)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEvalCoord2fv, "glEvalCoord2fv");
   if ( !driverTbl.glEvalCoord2fv ) {
      driverTbl.glEvalCoord2fv = missing_glEvalCoord2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEvalCoord2fv == loader_glEvalCoord2fv) {
      rCtx->dsp.emuTbl.glEvalCoord2fv = driverTbl.glEvalCoord2fv;
   }
   driverTbl.glEvalCoord2fv(u);
}

static void REGAL_CALL missing_glEvalMesh1(GLenum mode, GLint i1, GLint i2)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(i1);
   UNUSED_PARAMETER(i2);
   Warning( "Called missing function glEvalMesh1" );
}

static void REGAL_CALL loader_glEvalMesh1(GLenum mode, GLint i1, GLint i2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEvalMesh1, "glEvalMesh1");
   if ( !driverTbl.glEvalMesh1 ) {
      driverTbl.glEvalMesh1 = missing_glEvalMesh1;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEvalMesh1 == loader_glEvalMesh1) {
      rCtx->dsp.emuTbl.glEvalMesh1 = driverTbl.glEvalMesh1;
   }
   driverTbl.glEvalMesh1(mode, i1, i2);
}

static void REGAL_CALL missing_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(i1);
   UNUSED_PARAMETER(i2);
   UNUSED_PARAMETER(j1);
   UNUSED_PARAMETER(j2);
   Warning( "Called missing function glEvalMesh2" );
}

static void REGAL_CALL loader_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEvalMesh2, "glEvalMesh2");
   if ( !driverTbl.glEvalMesh2 ) {
      driverTbl.glEvalMesh2 = missing_glEvalMesh2;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEvalMesh2 == loader_glEvalMesh2) {
      rCtx->dsp.emuTbl.glEvalMesh2 = driverTbl.glEvalMesh2;
   }
   driverTbl.glEvalMesh2(mode, i1, i2, j1, j2);
}

static void REGAL_CALL missing_glEvalPoint1(GLint i)
{
   UNUSED_PARAMETER(i);
   Warning( "Called missing function glEvalPoint1" );
}

static void REGAL_CALL loader_glEvalPoint1(GLint i)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEvalPoint1, "glEvalPoint1");
   if ( !driverTbl.glEvalPoint1 ) {
      driverTbl.glEvalPoint1 = missing_glEvalPoint1;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEvalPoint1 == loader_glEvalPoint1) {
      rCtx->dsp.emuTbl.glEvalPoint1 = driverTbl.glEvalPoint1;
   }
   driverTbl.glEvalPoint1(i);
}

static void REGAL_CALL missing_glEvalPoint2(GLint i, GLint j)
{
   UNUSED_PARAMETER(i);
   UNUSED_PARAMETER(j);
   Warning( "Called missing function glEvalPoint2" );
}

static void REGAL_CALL loader_glEvalPoint2(GLint i, GLint j)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEvalPoint2, "glEvalPoint2");
   if ( !driverTbl.glEvalPoint2 ) {
      driverTbl.glEvalPoint2 = missing_glEvalPoint2;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEvalPoint2 == loader_glEvalPoint2) {
      rCtx->dsp.emuTbl.glEvalPoint2 = driverTbl.glEvalPoint2;
   }
   driverTbl.glEvalPoint2(i, j);
}

static void REGAL_CALL missing_glAlphaFunc(GLenum func, GLclampf ref)
{
   UNUSED_PARAMETER(func);
   UNUSED_PARAMETER(ref);
   Warning( "Called missing function glAlphaFunc" );
}

static void REGAL_CALL loader_glAlphaFunc(GLenum func, GLclampf ref)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glAlphaFunc, "glAlphaFunc");
   if ( !driverTbl.glAlphaFunc ) {
      driverTbl.glAlphaFunc = missing_glAlphaFunc;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glAlphaFunc == loader_glAlphaFunc) {
      rCtx->dsp.emuTbl.glAlphaFunc = driverTbl.glAlphaFunc;
   }
   driverTbl.glAlphaFunc(func, ref);
}

static void REGAL_CALL missing_glBlendFunc(GLenum sfactor, GLenum dfactor)
{
   UNUSED_PARAMETER(sfactor);
   UNUSED_PARAMETER(dfactor);
   Warning( "Called missing function glBlendFunc" );
}

static void REGAL_CALL loader_glBlendFunc(GLenum sfactor, GLenum dfactor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendFunc, "glBlendFunc");
   if ( !driverTbl.glBlendFunc ) {
      driverTbl.glBlendFunc = missing_glBlendFunc;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendFunc == loader_glBlendFunc) {
      rCtx->dsp.emuTbl.glBlendFunc = driverTbl.glBlendFunc;
   }
   driverTbl.glBlendFunc(sfactor, dfactor);
}

static void REGAL_CALL missing_glDepthFunc(GLenum func)
{
   UNUSED_PARAMETER(func);
   Warning( "Called missing function glDepthFunc" );
}

static void REGAL_CALL loader_glDepthFunc(GLenum func)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDepthFunc, "glDepthFunc");
   if ( !driverTbl.glDepthFunc ) {
      driverTbl.glDepthFunc = missing_glDepthFunc;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDepthFunc == loader_glDepthFunc) {
      rCtx->dsp.emuTbl.glDepthFunc = driverTbl.glDepthFunc;
   }
   driverTbl.glDepthFunc(func);
}

static void REGAL_CALL missing_glStencilFunc(GLenum func, GLint ref, GLuint mask)
{
   UNUSED_PARAMETER(func);
   UNUSED_PARAMETER(ref);
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glStencilFunc" );
}

static void REGAL_CALL loader_glStencilFunc(GLenum func, GLint ref, GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStencilFunc, "glStencilFunc");
   if ( !driverTbl.glStencilFunc ) {
      driverTbl.glStencilFunc = missing_glStencilFunc;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStencilFunc == loader_glStencilFunc) {
      rCtx->dsp.emuTbl.glStencilFunc = driverTbl.glStencilFunc;
   }
   driverTbl.glStencilFunc(func, ref, mask);
}

static void REGAL_CALL missing_glLogicOp(GLenum opcode)
{
   UNUSED_PARAMETER(opcode);
   Warning( "Called missing function glLogicOp" );
}

static void REGAL_CALL loader_glLogicOp(GLenum opcode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLogicOp, "glLogicOp");
   if ( !driverTbl.glLogicOp ) {
      driverTbl.glLogicOp = missing_glLogicOp;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLogicOp == loader_glLogicOp) {
      rCtx->dsp.emuTbl.glLogicOp = driverTbl.glLogicOp;
   }
   driverTbl.glLogicOp(opcode);
}

static void REGAL_CALL missing_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
   UNUSED_PARAMETER(fail);
   UNUSED_PARAMETER(zfail);
   UNUSED_PARAMETER(zpass);
   Warning( "Called missing function glStencilOp" );
}

static void REGAL_CALL loader_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStencilOp, "glStencilOp");
   if ( !driverTbl.glStencilOp ) {
      driverTbl.glStencilOp = missing_glStencilOp;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStencilOp == loader_glStencilOp) {
      rCtx->dsp.emuTbl.glStencilOp = driverTbl.glStencilOp;
   }
   driverTbl.glStencilOp(fail, zfail, zpass);
}

static void REGAL_CALL missing_glPixelZoom(GLfloat xfactor, GLfloat yfactor)
{
   UNUSED_PARAMETER(xfactor);
   UNUSED_PARAMETER(yfactor);
   Warning( "Called missing function glPixelZoom" );
}

static void REGAL_CALL loader_glPixelZoom(GLfloat xfactor, GLfloat yfactor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelZoom, "glPixelZoom");
   if ( !driverTbl.glPixelZoom ) {
      driverTbl.glPixelZoom = missing_glPixelZoom;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelZoom == loader_glPixelZoom) {
      rCtx->dsp.emuTbl.glPixelZoom = driverTbl.glPixelZoom;
   }
   driverTbl.glPixelZoom(xfactor, yfactor);
}

static void REGAL_CALL missing_glPixelTransferf(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPixelTransferf" );
}

static void REGAL_CALL loader_glPixelTransferf(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelTransferf, "glPixelTransferf");
   if ( !driverTbl.glPixelTransferf ) {
      driverTbl.glPixelTransferf = missing_glPixelTransferf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelTransferf == loader_glPixelTransferf) {
      rCtx->dsp.emuTbl.glPixelTransferf = driverTbl.glPixelTransferf;
   }
   driverTbl.glPixelTransferf(pname, param);
}

static void REGAL_CALL missing_glPixelTransferi(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPixelTransferi" );
}

static void REGAL_CALL loader_glPixelTransferi(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelTransferi, "glPixelTransferi");
   if ( !driverTbl.glPixelTransferi ) {
      driverTbl.glPixelTransferi = missing_glPixelTransferi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelTransferi == loader_glPixelTransferi) {
      rCtx->dsp.emuTbl.glPixelTransferi = driverTbl.glPixelTransferi;
   }
   driverTbl.glPixelTransferi(pname, param);
}

static void REGAL_CALL missing_glPixelStoref(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPixelStoref" );
}

static void REGAL_CALL loader_glPixelStoref(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelStoref, "glPixelStoref");
   if ( !driverTbl.glPixelStoref ) {
      driverTbl.glPixelStoref = missing_glPixelStoref;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelStoref == loader_glPixelStoref) {
      rCtx->dsp.emuTbl.glPixelStoref = driverTbl.glPixelStoref;
   }
   driverTbl.glPixelStoref(pname, param);
}

static void REGAL_CALL missing_glPixelStorei(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPixelStorei" );
}

static void REGAL_CALL loader_glPixelStorei(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelStorei, "glPixelStorei");
   if ( !driverTbl.glPixelStorei ) {
      driverTbl.glPixelStorei = missing_glPixelStorei;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelStorei == loader_glPixelStorei) {
      rCtx->dsp.emuTbl.glPixelStorei = driverTbl.glPixelStorei;
   }
   driverTbl.glPixelStorei(pname, param);
}

static void REGAL_CALL missing_glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(mapsize);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glPixelMapfv" );
}

static void REGAL_CALL loader_glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelMapfv, "glPixelMapfv");
   if ( !driverTbl.glPixelMapfv ) {
      driverTbl.glPixelMapfv = missing_glPixelMapfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelMapfv == loader_glPixelMapfv) {
      rCtx->dsp.emuTbl.glPixelMapfv = driverTbl.glPixelMapfv;
   }
   driverTbl.glPixelMapfv(map, mapsize, values);
}

static void REGAL_CALL missing_glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(mapsize);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glPixelMapuiv" );
}

static void REGAL_CALL loader_glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelMapuiv, "glPixelMapuiv");
   if ( !driverTbl.glPixelMapuiv ) {
      driverTbl.glPixelMapuiv = missing_glPixelMapuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelMapuiv == loader_glPixelMapuiv) {
      rCtx->dsp.emuTbl.glPixelMapuiv = driverTbl.glPixelMapuiv;
   }
   driverTbl.glPixelMapuiv(map, mapsize, values);
}

static void REGAL_CALL missing_glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(mapsize);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glPixelMapusv" );
}

static void REGAL_CALL loader_glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelMapusv, "glPixelMapusv");
   if ( !driverTbl.glPixelMapusv ) {
      driverTbl.glPixelMapusv = missing_glPixelMapusv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelMapusv == loader_glPixelMapusv) {
      rCtx->dsp.emuTbl.glPixelMapusv = driverTbl.glPixelMapusv;
   }
   driverTbl.glPixelMapusv(map, mapsize, values);
}

static void REGAL_CALL missing_glReadBuffer(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glReadBuffer" );
}

static void REGAL_CALL loader_glReadBuffer(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReadBuffer, "glReadBuffer");
   if ( !driverTbl.glReadBuffer ) {
      driverTbl.glReadBuffer = missing_glReadBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReadBuffer == loader_glReadBuffer) {
      rCtx->dsp.emuTbl.glReadBuffer = driverTbl.glReadBuffer;
   }
   driverTbl.glReadBuffer(mode);
}

static void REGAL_CALL missing_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(type);
   Warning( "Called missing function glCopyPixels" );
}

static void REGAL_CALL loader_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyPixels, "glCopyPixels");
   if ( !driverTbl.glCopyPixels ) {
      driverTbl.glCopyPixels = missing_glCopyPixels;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyPixels == loader_glCopyPixels) {
      rCtx->dsp.emuTbl.glCopyPixels = driverTbl.glCopyPixels;
   }
   driverTbl.glCopyPixels(x, y, width, height, type);
}

static void REGAL_CALL missing_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glReadPixels" );
}

static void REGAL_CALL loader_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReadPixels, "glReadPixels");
   if ( !driverTbl.glReadPixels ) {
      driverTbl.glReadPixels = missing_glReadPixels;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReadPixels == loader_glReadPixels) {
      rCtx->dsp.emuTbl.glReadPixels = driverTbl.glReadPixels;
   }
   driverTbl.glReadPixels(x, y, width, height, format, type, pixels);
}

static void REGAL_CALL missing_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glDrawPixels" );
}

static void REGAL_CALL loader_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawPixels, "glDrawPixels");
   if ( !driverTbl.glDrawPixels ) {
      driverTbl.glDrawPixels = missing_glDrawPixels;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawPixels == loader_glDrawPixels) {
      rCtx->dsp.emuTbl.glDrawPixels = driverTbl.glDrawPixels;
   }
   driverTbl.glDrawPixels(width, height, format, type, pixels);
}

static void REGAL_CALL missing_glGetBooleanv(GLenum pname, GLboolean *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetBooleanv" );
}

static void REGAL_CALL loader_glGetBooleanv(GLenum pname, GLboolean *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetBooleanv, "glGetBooleanv");
   if ( !driverTbl.glGetBooleanv ) {
      driverTbl.glGetBooleanv = missing_glGetBooleanv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetBooleanv == loader_glGetBooleanv) {
      rCtx->dsp.emuTbl.glGetBooleanv = driverTbl.glGetBooleanv;
   }
   driverTbl.glGetBooleanv(pname, params);
}

static void REGAL_CALL missing_glGetDoublev(GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetDoublev" );
}

static void REGAL_CALL loader_glGetDoublev(GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetDoublev, "glGetDoublev");
   if ( !driverTbl.glGetDoublev ) {
      driverTbl.glGetDoublev = missing_glGetDoublev;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetDoublev == loader_glGetDoublev) {
      rCtx->dsp.emuTbl.glGetDoublev = driverTbl.glGetDoublev;
   }
   driverTbl.glGetDoublev(pname, params);
}

static void REGAL_CALL missing_glGetFloatv(GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFloatv" );
}

static void REGAL_CALL loader_glGetFloatv(GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFloatv, "glGetFloatv");
   if ( !driverTbl.glGetFloatv ) {
      driverTbl.glGetFloatv = missing_glGetFloatv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFloatv == loader_glGetFloatv) {
      rCtx->dsp.emuTbl.glGetFloatv = driverTbl.glGetFloatv;
   }
   driverTbl.glGetFloatv(pname, params);
}

static void REGAL_CALL missing_glGetIntegerv(GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetIntegerv" );
}

static void REGAL_CALL loader_glGetIntegerv(GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetIntegerv, "glGetIntegerv");
   if ( !driverTbl.glGetIntegerv ) {
      driverTbl.glGetIntegerv = missing_glGetIntegerv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetIntegerv == loader_glGetIntegerv) {
      rCtx->dsp.emuTbl.glGetIntegerv = driverTbl.glGetIntegerv;
   }
   driverTbl.glGetIntegerv(pname, params);
}

static void REGAL_CALL missing_glGetClipPlane(GLenum plane, GLdouble *equation)
{
   UNUSED_PARAMETER(plane);
   UNUSED_PARAMETER(equation);
   Warning( "Called missing function glGetClipPlane" );
}

static void REGAL_CALL loader_glGetClipPlane(GLenum plane, GLdouble *equation)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetClipPlane, "glGetClipPlane");
   if ( !driverTbl.glGetClipPlane ) {
      driverTbl.glGetClipPlane = missing_glGetClipPlane;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetClipPlane == loader_glGetClipPlane) {
      rCtx->dsp.emuTbl.glGetClipPlane = driverTbl.glGetClipPlane;
   }
   driverTbl.glGetClipPlane(plane, equation);
}

static GLenum REGAL_CALL missing_glGetError(void)
{
   Warning( "Called missing function glGetError" );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glGetError(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetError, "glGetError");
   if ( !driverTbl.glGetError ) {
      driverTbl.glGetError = missing_glGetError;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetError == loader_glGetError) {
      rCtx->dsp.emuTbl.glGetError = driverTbl.glGetError;
   }
   return driverTbl.glGetError();
}

static void REGAL_CALL missing_glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetLightfv" );
}

static void REGAL_CALL loader_glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetLightfv, "glGetLightfv");
   if ( !driverTbl.glGetLightfv ) {
      driverTbl.glGetLightfv = missing_glGetLightfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetLightfv == loader_glGetLightfv) {
      rCtx->dsp.emuTbl.glGetLightfv = driverTbl.glGetLightfv;
   }
   driverTbl.glGetLightfv(light, pname, params);
}

static void REGAL_CALL missing_glGetLightiv(GLenum light, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetLightiv" );
}

static void REGAL_CALL loader_glGetLightiv(GLenum light, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetLightiv, "glGetLightiv");
   if ( !driverTbl.glGetLightiv ) {
      driverTbl.glGetLightiv = missing_glGetLightiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetLightiv == loader_glGetLightiv) {
      rCtx->dsp.emuTbl.glGetLightiv = driverTbl.glGetLightiv;
   }
   driverTbl.glGetLightiv(light, pname, params);
}

static void REGAL_CALL missing_glGetMapdv(GLenum target, GLenum query, GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(query);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glGetMapdv" );
}

static void REGAL_CALL loader_glGetMapdv(GLenum target, GLenum query, GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMapdv, "glGetMapdv");
   if ( !driverTbl.glGetMapdv ) {
      driverTbl.glGetMapdv = missing_glGetMapdv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMapdv == loader_glGetMapdv) {
      rCtx->dsp.emuTbl.glGetMapdv = driverTbl.glGetMapdv;
   }
   driverTbl.glGetMapdv(target, query, v);
}

static void REGAL_CALL missing_glGetMapfv(GLenum target, GLenum query, GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(query);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glGetMapfv" );
}

static void REGAL_CALL loader_glGetMapfv(GLenum target, GLenum query, GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMapfv, "glGetMapfv");
   if ( !driverTbl.glGetMapfv ) {
      driverTbl.glGetMapfv = missing_glGetMapfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMapfv == loader_glGetMapfv) {
      rCtx->dsp.emuTbl.glGetMapfv = driverTbl.glGetMapfv;
   }
   driverTbl.glGetMapfv(target, query, v);
}

static void REGAL_CALL missing_glGetMapiv(GLenum target, GLenum query, GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(query);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glGetMapiv" );
}

static void REGAL_CALL loader_glGetMapiv(GLenum target, GLenum query, GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMapiv, "glGetMapiv");
   if ( !driverTbl.glGetMapiv ) {
      driverTbl.glGetMapiv = missing_glGetMapiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMapiv == loader_glGetMapiv) {
      rCtx->dsp.emuTbl.glGetMapiv = driverTbl.glGetMapiv;
   }
   driverTbl.glGetMapiv(target, query, v);
}

static void REGAL_CALL missing_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMaterialfv" );
}

static void REGAL_CALL loader_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMaterialfv, "glGetMaterialfv");
   if ( !driverTbl.glGetMaterialfv ) {
      driverTbl.glGetMaterialfv = missing_glGetMaterialfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMaterialfv == loader_glGetMaterialfv) {
      rCtx->dsp.emuTbl.glGetMaterialfv = driverTbl.glGetMaterialfv;
   }
   driverTbl.glGetMaterialfv(face, pname, params);
}

static void REGAL_CALL missing_glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMaterialiv" );
}

static void REGAL_CALL loader_glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMaterialiv, "glGetMaterialiv");
   if ( !driverTbl.glGetMaterialiv ) {
      driverTbl.glGetMaterialiv = missing_glGetMaterialiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMaterialiv == loader_glGetMaterialiv) {
      rCtx->dsp.emuTbl.glGetMaterialiv = driverTbl.glGetMaterialiv;
   }
   driverTbl.glGetMaterialiv(face, pname, params);
}

static void REGAL_CALL missing_glGetPixelMapfv(GLenum map, GLfloat *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetPixelMapfv" );
}

static void REGAL_CALL loader_glGetPixelMapfv(GLenum map, GLfloat *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPixelMapfv, "glGetPixelMapfv");
   if ( !driverTbl.glGetPixelMapfv ) {
      driverTbl.glGetPixelMapfv = missing_glGetPixelMapfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPixelMapfv == loader_glGetPixelMapfv) {
      rCtx->dsp.emuTbl.glGetPixelMapfv = driverTbl.glGetPixelMapfv;
   }
   driverTbl.glGetPixelMapfv(map, values);
}

static void REGAL_CALL missing_glGetPixelMapuiv(GLenum map, GLuint *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetPixelMapuiv" );
}

static void REGAL_CALL loader_glGetPixelMapuiv(GLenum map, GLuint *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPixelMapuiv, "glGetPixelMapuiv");
   if ( !driverTbl.glGetPixelMapuiv ) {
      driverTbl.glGetPixelMapuiv = missing_glGetPixelMapuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPixelMapuiv == loader_glGetPixelMapuiv) {
      rCtx->dsp.emuTbl.glGetPixelMapuiv = driverTbl.glGetPixelMapuiv;
   }
   driverTbl.glGetPixelMapuiv(map, values);
}

static void REGAL_CALL missing_glGetPixelMapusv(GLenum map, GLushort *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetPixelMapusv" );
}

static void REGAL_CALL loader_glGetPixelMapusv(GLenum map, GLushort *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPixelMapusv, "glGetPixelMapusv");
   if ( !driverTbl.glGetPixelMapusv ) {
      driverTbl.glGetPixelMapusv = missing_glGetPixelMapusv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPixelMapusv == loader_glGetPixelMapusv) {
      rCtx->dsp.emuTbl.glGetPixelMapusv = driverTbl.glGetPixelMapusv;
   }
   driverTbl.glGetPixelMapusv(map, values);
}

static void REGAL_CALL missing_glGetPolygonStipple(GLubyte *mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glGetPolygonStipple" );
}

static void REGAL_CALL loader_glGetPolygonStipple(GLubyte *mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPolygonStipple, "glGetPolygonStipple");
   if ( !driverTbl.glGetPolygonStipple ) {
      driverTbl.glGetPolygonStipple = missing_glGetPolygonStipple;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPolygonStipple == loader_glGetPolygonStipple) {
      rCtx->dsp.emuTbl.glGetPolygonStipple = driverTbl.glGetPolygonStipple;
   }
   driverTbl.glGetPolygonStipple(mask);
}

static const GLubyte *REGAL_CALL missing_glGetString(GLenum name)
{
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetString" );
  const GLubyte * ret = NULL;
  return ret;
}

static const GLubyte *REGAL_CALL loader_glGetString(GLenum name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetString, "glGetString");
   if ( !driverTbl.glGetString ) {
      driverTbl.glGetString = missing_glGetString;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetString == loader_glGetString) {
      rCtx->dsp.emuTbl.glGetString = driverTbl.glGetString;
   }
   return driverTbl.glGetString(name);
}

static void REGAL_CALL missing_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTexEnvfv" );
}

static void REGAL_CALL loader_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexEnvfv, "glGetTexEnvfv");
   if ( !driverTbl.glGetTexEnvfv ) {
      driverTbl.glGetTexEnvfv = missing_glGetTexEnvfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexEnvfv == loader_glGetTexEnvfv) {
      rCtx->dsp.emuTbl.glGetTexEnvfv = driverTbl.glGetTexEnvfv;
   }
   driverTbl.glGetTexEnvfv(target, pname, params);
}

static void REGAL_CALL missing_glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTexEnviv" );
}

static void REGAL_CALL loader_glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexEnviv, "glGetTexEnviv");
   if ( !driverTbl.glGetTexEnviv ) {
      driverTbl.glGetTexEnviv = missing_glGetTexEnviv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexEnviv == loader_glGetTexEnviv) {
      rCtx->dsp.emuTbl.glGetTexEnviv = driverTbl.glGetTexEnviv;
   }
   driverTbl.glGetTexEnviv(target, pname, params);
}

static void REGAL_CALL missing_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTexGendv" );
}

static void REGAL_CALL loader_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexGendv, "glGetTexGendv");
   if ( !driverTbl.glGetTexGendv ) {
      driverTbl.glGetTexGendv = missing_glGetTexGendv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexGendv == loader_glGetTexGendv) {
      rCtx->dsp.emuTbl.glGetTexGendv = driverTbl.glGetTexGendv;
   }
   driverTbl.glGetTexGendv(coord, pname, params);
}

static void REGAL_CALL missing_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTexGenfv" );
}

static void REGAL_CALL loader_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexGenfv, "glGetTexGenfv");
   if ( !driverTbl.glGetTexGenfv ) {
      driverTbl.glGetTexGenfv = missing_glGetTexGenfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexGenfv == loader_glGetTexGenfv) {
      rCtx->dsp.emuTbl.glGetTexGenfv = driverTbl.glGetTexGenfv;
   }
   driverTbl.glGetTexGenfv(coord, pname, params);
}

static void REGAL_CALL missing_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTexGeniv" );
}

static void REGAL_CALL loader_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexGeniv, "glGetTexGeniv");
   if ( !driverTbl.glGetTexGeniv ) {
      driverTbl.glGetTexGeniv = missing_glGetTexGeniv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexGeniv == loader_glGetTexGeniv) {
      rCtx->dsp.emuTbl.glGetTexGeniv = driverTbl.glGetTexGeniv;
   }
   driverTbl.glGetTexGeniv(coord, pname, params);
}

static void REGAL_CALL missing_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glGetTexImage" );
}

static void REGAL_CALL loader_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexImage, "glGetTexImage");
   if ( !driverTbl.glGetTexImage ) {
      driverTbl.glGetTexImage = missing_glGetTexImage;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexImage == loader_glGetTexImage) {
      rCtx->dsp.emuTbl.glGetTexImage = driverTbl.glGetTexImage;
   }
   driverTbl.glGetTexImage(target, level, format, type, pixels);
}

static void REGAL_CALL missing_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTexParameterfv" );
}

static void REGAL_CALL loader_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexParameterfv, "glGetTexParameterfv");
   if ( !driverTbl.glGetTexParameterfv ) {
      driverTbl.glGetTexParameterfv = missing_glGetTexParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexParameterfv == loader_glGetTexParameterfv) {
      rCtx->dsp.emuTbl.glGetTexParameterfv = driverTbl.glGetTexParameterfv;
   }
   driverTbl.glGetTexParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTexParameteriv" );
}

static void REGAL_CALL loader_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexParameteriv, "glGetTexParameteriv");
   if ( !driverTbl.glGetTexParameteriv ) {
      driverTbl.glGetTexParameteriv = missing_glGetTexParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexParameteriv == loader_glGetTexParameteriv) {
      rCtx->dsp.emuTbl.glGetTexParameteriv = driverTbl.glGetTexParameteriv;
   }
   driverTbl.glGetTexParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTexLevelParameterfv" );
}

static void REGAL_CALL loader_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexLevelParameterfv, "glGetTexLevelParameterfv");
   if ( !driverTbl.glGetTexLevelParameterfv ) {
      driverTbl.glGetTexLevelParameterfv = missing_glGetTexLevelParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexLevelParameterfv == loader_glGetTexLevelParameterfv) {
      rCtx->dsp.emuTbl.glGetTexLevelParameterfv = driverTbl.glGetTexLevelParameterfv;
   }
   driverTbl.glGetTexLevelParameterfv(target, level, pname, params);
}

static void REGAL_CALL missing_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTexLevelParameteriv" );
}

static void REGAL_CALL loader_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexLevelParameteriv, "glGetTexLevelParameteriv");
   if ( !driverTbl.glGetTexLevelParameteriv ) {
      driverTbl.glGetTexLevelParameteriv = missing_glGetTexLevelParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexLevelParameteriv == loader_glGetTexLevelParameteriv) {
      rCtx->dsp.emuTbl.glGetTexLevelParameteriv = driverTbl.glGetTexLevelParameteriv;
   }
   driverTbl.glGetTexLevelParameteriv(target, level, pname, params);
}

static GLboolean REGAL_CALL missing_glIsEnabled(GLenum cap)
{
   UNUSED_PARAMETER(cap);
   Warning( "Called missing function glIsEnabled" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsEnabled(GLenum cap)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsEnabled, "glIsEnabled");
   if ( !driverTbl.glIsEnabled ) {
      driverTbl.glIsEnabled = missing_glIsEnabled;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsEnabled == loader_glIsEnabled) {
      rCtx->dsp.emuTbl.glIsEnabled = driverTbl.glIsEnabled;
   }
   return driverTbl.glIsEnabled(cap);
}

static GLboolean REGAL_CALL missing_glIsList(GLuint list)
{
   UNUSED_PARAMETER(list);
   Warning( "Called missing function glIsList" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsList(GLuint list)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsList, "glIsList");
   if ( !driverTbl.glIsList ) {
      driverTbl.glIsList = missing_glIsList;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsList == loader_glIsList) {
      rCtx->dsp.emuTbl.glIsList = driverTbl.glIsList;
   }
   return driverTbl.glIsList(list);
}

static void REGAL_CALL missing_glDepthRange(GLclampd zNear, GLclampd zFar)
{
   UNUSED_PARAMETER(zNear);
   UNUSED_PARAMETER(zFar);
   Warning( "Called missing function glDepthRange" );
}

static void REGAL_CALL loader_glDepthRange(GLclampd zNear, GLclampd zFar)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDepthRange, "glDepthRange");
   if ( !driverTbl.glDepthRange ) {
      driverTbl.glDepthRange = missing_glDepthRange;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDepthRange == loader_glDepthRange) {
      rCtx->dsp.emuTbl.glDepthRange = driverTbl.glDepthRange;
   }
   driverTbl.glDepthRange(zNear, zFar);
}

static void REGAL_CALL missing_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   UNUSED_PARAMETER(left);
   UNUSED_PARAMETER(right);
   UNUSED_PARAMETER(bottom);
   UNUSED_PARAMETER(top);
   UNUSED_PARAMETER(zNear);
   UNUSED_PARAMETER(zFar);
   Warning( "Called missing function glFrustum" );
}

static void REGAL_CALL loader_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFrustum, "glFrustum");
   if ( !driverTbl.glFrustum ) {
      driverTbl.glFrustum = missing_glFrustum;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFrustum == loader_glFrustum) {
      rCtx->dsp.emuTbl.glFrustum = driverTbl.glFrustum;
   }
   driverTbl.glFrustum(left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL missing_glLoadIdentity(void)
{
   Warning( "Called missing function glLoadIdentity" );
}

static void REGAL_CALL loader_glLoadIdentity(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLoadIdentity, "glLoadIdentity");
   if ( !driverTbl.glLoadIdentity ) {
      driverTbl.glLoadIdentity = missing_glLoadIdentity;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLoadIdentity == loader_glLoadIdentity) {
      rCtx->dsp.emuTbl.glLoadIdentity = driverTbl.glLoadIdentity;
   }
   driverTbl.glLoadIdentity();
}

static void REGAL_CALL missing_glLoadMatrixd(const GLdouble *m)
{
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glLoadMatrixd" );
}

static void REGAL_CALL loader_glLoadMatrixd(const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLoadMatrixd, "glLoadMatrixd");
   if ( !driverTbl.glLoadMatrixd ) {
      driverTbl.glLoadMatrixd = missing_glLoadMatrixd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLoadMatrixd == loader_glLoadMatrixd) {
      rCtx->dsp.emuTbl.glLoadMatrixd = driverTbl.glLoadMatrixd;
   }
   driverTbl.glLoadMatrixd(m);
}

static void REGAL_CALL missing_glLoadMatrixf(const GLfloat *m)
{
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glLoadMatrixf" );
}

static void REGAL_CALL loader_glLoadMatrixf(const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLoadMatrixf, "glLoadMatrixf");
   if ( !driverTbl.glLoadMatrixf ) {
      driverTbl.glLoadMatrixf = missing_glLoadMatrixf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLoadMatrixf == loader_glLoadMatrixf) {
      rCtx->dsp.emuTbl.glLoadMatrixf = driverTbl.glLoadMatrixf;
   }
   driverTbl.glLoadMatrixf(m);
}

static void REGAL_CALL missing_glMatrixMode(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glMatrixMode" );
}

static void REGAL_CALL loader_glMatrixMode(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixMode, "glMatrixMode");
   if ( !driverTbl.glMatrixMode ) {
      driverTbl.glMatrixMode = missing_glMatrixMode;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixMode == loader_glMatrixMode) {
      rCtx->dsp.emuTbl.glMatrixMode = driverTbl.glMatrixMode;
   }
   driverTbl.glMatrixMode(mode);
}

static void REGAL_CALL missing_glMultMatrixd(const GLdouble *m)
{
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glMultMatrixd" );
}

static void REGAL_CALL loader_glMultMatrixd(const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultMatrixd, "glMultMatrixd");
   if ( !driverTbl.glMultMatrixd ) {
      driverTbl.glMultMatrixd = missing_glMultMatrixd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultMatrixd == loader_glMultMatrixd) {
      rCtx->dsp.emuTbl.glMultMatrixd = driverTbl.glMultMatrixd;
   }
   driverTbl.glMultMatrixd(m);
}

static void REGAL_CALL missing_glMultMatrixf(const GLfloat *m)
{
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glMultMatrixf" );
}

static void REGAL_CALL loader_glMultMatrixf(const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultMatrixf, "glMultMatrixf");
   if ( !driverTbl.glMultMatrixf ) {
      driverTbl.glMultMatrixf = missing_glMultMatrixf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultMatrixf == loader_glMultMatrixf) {
      rCtx->dsp.emuTbl.glMultMatrixf = driverTbl.glMultMatrixf;
   }
   driverTbl.glMultMatrixf(m);
}

static void REGAL_CALL missing_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   UNUSED_PARAMETER(left);
   UNUSED_PARAMETER(right);
   UNUSED_PARAMETER(bottom);
   UNUSED_PARAMETER(top);
   UNUSED_PARAMETER(zNear);
   UNUSED_PARAMETER(zFar);
   Warning( "Called missing function glOrtho" );
}

static void REGAL_CALL loader_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glOrtho, "glOrtho");
   if ( !driverTbl.glOrtho ) {
      driverTbl.glOrtho = missing_glOrtho;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glOrtho == loader_glOrtho) {
      rCtx->dsp.emuTbl.glOrtho = driverTbl.glOrtho;
   }
   driverTbl.glOrtho(left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL missing_glPopMatrix(void)
{
   Warning( "Called missing function glPopMatrix" );
}

static void REGAL_CALL loader_glPopMatrix(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPopMatrix, "glPopMatrix");
   if ( !driverTbl.glPopMatrix ) {
      driverTbl.glPopMatrix = missing_glPopMatrix;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPopMatrix == loader_glPopMatrix) {
      rCtx->dsp.emuTbl.glPopMatrix = driverTbl.glPopMatrix;
   }
   driverTbl.glPopMatrix();
}

static void REGAL_CALL missing_glPushMatrix(void)
{
   Warning( "Called missing function glPushMatrix" );
}

static void REGAL_CALL loader_glPushMatrix(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPushMatrix, "glPushMatrix");
   if ( !driverTbl.glPushMatrix ) {
      driverTbl.glPushMatrix = missing_glPushMatrix;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPushMatrix == loader_glPushMatrix) {
      rCtx->dsp.emuTbl.glPushMatrix = driverTbl.glPushMatrix;
   }
   driverTbl.glPushMatrix();
}

static void REGAL_CALL missing_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(angle);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glRotated" );
}

static void REGAL_CALL loader_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRotated, "glRotated");
   if ( !driverTbl.glRotated ) {
      driverTbl.glRotated = missing_glRotated;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRotated == loader_glRotated) {
      rCtx->dsp.emuTbl.glRotated = driverTbl.glRotated;
   }
   driverTbl.glRotated(angle, x, y, z);
}

static void REGAL_CALL missing_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(angle);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glRotatef" );
}

static void REGAL_CALL loader_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRotatef, "glRotatef");
   if ( !driverTbl.glRotatef ) {
      driverTbl.glRotatef = missing_glRotatef;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRotatef == loader_glRotatef) {
      rCtx->dsp.emuTbl.glRotatef = driverTbl.glRotatef;
   }
   driverTbl.glRotatef(angle, x, y, z);
}

static void REGAL_CALL missing_glScaled(GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glScaled" );
}

static void REGAL_CALL loader_glScaled(GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glScaled, "glScaled");
   if ( !driverTbl.glScaled ) {
      driverTbl.glScaled = missing_glScaled;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glScaled == loader_glScaled) {
      rCtx->dsp.emuTbl.glScaled = driverTbl.glScaled;
   }
   driverTbl.glScaled(x, y, z);
}

static void REGAL_CALL missing_glScalef(GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glScalef" );
}

static void REGAL_CALL loader_glScalef(GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glScalef, "glScalef");
   if ( !driverTbl.glScalef ) {
      driverTbl.glScalef = missing_glScalef;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glScalef == loader_glScalef) {
      rCtx->dsp.emuTbl.glScalef = driverTbl.glScalef;
   }
   driverTbl.glScalef(x, y, z);
}

static void REGAL_CALL missing_glTranslated(GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glTranslated" );
}

static void REGAL_CALL loader_glTranslated(GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTranslated, "glTranslated");
   if ( !driverTbl.glTranslated ) {
      driverTbl.glTranslated = missing_glTranslated;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTranslated == loader_glTranslated) {
      rCtx->dsp.emuTbl.glTranslated = driverTbl.glTranslated;
   }
   driverTbl.glTranslated(x, y, z);
}

static void REGAL_CALL missing_glTranslatef(GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glTranslatef" );
}

static void REGAL_CALL loader_glTranslatef(GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTranslatef, "glTranslatef");
   if ( !driverTbl.glTranslatef ) {
      driverTbl.glTranslatef = missing_glTranslatef;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTranslatef == loader_glTranslatef) {
      rCtx->dsp.emuTbl.glTranslatef = driverTbl.glTranslatef;
   }
   driverTbl.glTranslatef(x, y, z);
}

static void REGAL_CALL missing_glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glViewport" );
}

static void REGAL_CALL loader_glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glViewport, "glViewport");
   if ( !driverTbl.glViewport ) {
      driverTbl.glViewport = missing_glViewport;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glViewport == loader_glViewport) {
      rCtx->dsp.emuTbl.glViewport = driverTbl.glViewport;
   }
   driverTbl.glViewport(x, y, width, height);
}

// GL_VERSION_1_1

static void REGAL_CALL missing_glArrayElement(GLint index)
{
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glArrayElement" );
}

static void REGAL_CALL loader_glArrayElement(GLint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glArrayElement, "glArrayElement");
   if ( !driverTbl.glArrayElement ) {
      driverTbl.glArrayElement = missing_glArrayElement;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glArrayElement == loader_glArrayElement) {
      rCtx->dsp.emuTbl.glArrayElement = driverTbl.glArrayElement;
   }
   driverTbl.glArrayElement(index);
}

static void REGAL_CALL missing_glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   Warning( "Called missing function glDrawArrays" );
}

static void REGAL_CALL loader_glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawArrays, "glDrawArrays");
   if ( !driverTbl.glDrawArrays ) {
      driverTbl.glDrawArrays = missing_glDrawArrays;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawArrays == loader_glDrawArrays) {
      rCtx->dsp.emuTbl.glDrawArrays = driverTbl.glDrawArrays;
   }
   driverTbl.glDrawArrays(mode, first, count);
}

static void REGAL_CALL missing_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   Warning( "Called missing function glDrawElements" );
}

static void REGAL_CALL loader_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawElements, "glDrawElements");
   if ( !driverTbl.glDrawElements ) {
      driverTbl.glDrawElements = missing_glDrawElements;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawElements == loader_glDrawElements) {
      rCtx->dsp.emuTbl.glDrawElements = driverTbl.glDrawElements;
   }
   driverTbl.glDrawElements(mode, count, type, indices);
}

static void REGAL_CALL missing_glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glInterleavedArrays" );
}

static void REGAL_CALL loader_glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glInterleavedArrays, "glInterleavedArrays");
   if ( !driverTbl.glInterleavedArrays ) {
      driverTbl.glInterleavedArrays = missing_glInterleavedArrays;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glInterleavedArrays == loader_glInterleavedArrays) {
      rCtx->dsp.emuTbl.glInterleavedArrays = driverTbl.glInterleavedArrays;
   }
   driverTbl.glInterleavedArrays(format, stride, pointer);
}

static void REGAL_CALL missing_glDisableClientState(GLenum cap)
{
   UNUSED_PARAMETER(cap);
   Warning( "Called missing function glDisableClientState" );
}

static void REGAL_CALL loader_glDisableClientState(GLenum cap)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDisableClientState, "glDisableClientState");
   if ( !driverTbl.glDisableClientState ) {
      driverTbl.glDisableClientState = missing_glDisableClientState;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDisableClientState == loader_glDisableClientState) {
      rCtx->dsp.emuTbl.glDisableClientState = driverTbl.glDisableClientState;
   }
   driverTbl.glDisableClientState(cap);
}

static void REGAL_CALL missing_glEnableClientState(GLenum cap)
{
   UNUSED_PARAMETER(cap);
   Warning( "Called missing function glEnableClientState" );
}

static void REGAL_CALL loader_glEnableClientState(GLenum cap)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEnableClientState, "glEnableClientState");
   if ( !driverTbl.glEnableClientState ) {
      driverTbl.glEnableClientState = missing_glEnableClientState;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEnableClientState == loader_glEnableClientState) {
      rCtx->dsp.emuTbl.glEnableClientState = driverTbl.glEnableClientState;
   }
   driverTbl.glEnableClientState(cap);
}

static void REGAL_CALL missing_glGetPointerv(GLenum pname, GLvoid **params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetPointerv" );
}

static void REGAL_CALL loader_glGetPointerv(GLenum pname, GLvoid **params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPointerv, "glGetPointerv");
   if ( !driverTbl.glGetPointerv ) {
      driverTbl.glGetPointerv = missing_glGetPointerv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPointerv == loader_glGetPointerv) {
      rCtx->dsp.emuTbl.glGetPointerv = driverTbl.glGetPointerv;
   }
   driverTbl.glGetPointerv(pname, params);
}

static void REGAL_CALL missing_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glColorPointer" );
}

static void REGAL_CALL loader_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorPointer, "glColorPointer");
   if ( !driverTbl.glColorPointer ) {
      driverTbl.glColorPointer = missing_glColorPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorPointer == loader_glColorPointer) {
      rCtx->dsp.emuTbl.glColorPointer = driverTbl.glColorPointer;
   }
   driverTbl.glColorPointer(size, type, stride, pointer);
}

static void REGAL_CALL missing_glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glEdgeFlagPointer" );
}

static void REGAL_CALL loader_glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEdgeFlagPointer, "glEdgeFlagPointer");
   if ( !driverTbl.glEdgeFlagPointer ) {
      driverTbl.glEdgeFlagPointer = missing_glEdgeFlagPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEdgeFlagPointer == loader_glEdgeFlagPointer) {
      rCtx->dsp.emuTbl.glEdgeFlagPointer = driverTbl.glEdgeFlagPointer;
   }
   driverTbl.glEdgeFlagPointer(stride, pointer);
}

static void REGAL_CALL missing_glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glIndexPointer" );
}

static void REGAL_CALL loader_glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexPointer, "glIndexPointer");
   if ( !driverTbl.glIndexPointer ) {
      driverTbl.glIndexPointer = missing_glIndexPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexPointer == loader_glIndexPointer) {
      rCtx->dsp.emuTbl.glIndexPointer = driverTbl.glIndexPointer;
   }
   driverTbl.glIndexPointer(type, stride, pointer);
}

static void REGAL_CALL missing_glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glNormalPointer" );
}

static void REGAL_CALL loader_glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalPointer, "glNormalPointer");
   if ( !driverTbl.glNormalPointer ) {
      driverTbl.glNormalPointer = missing_glNormalPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalPointer == loader_glNormalPointer) {
      rCtx->dsp.emuTbl.glNormalPointer = driverTbl.glNormalPointer;
   }
   driverTbl.glNormalPointer(type, stride, pointer);
}

static void REGAL_CALL missing_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glTexCoordPointer" );
}

static void REGAL_CALL loader_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoordPointer, "glTexCoordPointer");
   if ( !driverTbl.glTexCoordPointer ) {
      driverTbl.glTexCoordPointer = missing_glTexCoordPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoordPointer == loader_glTexCoordPointer) {
      rCtx->dsp.emuTbl.glTexCoordPointer = driverTbl.glTexCoordPointer;
   }
   driverTbl.glTexCoordPointer(size, type, stride, pointer);
}

static void REGAL_CALL missing_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glVertexPointer" );
}

static void REGAL_CALL loader_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexPointer, "glVertexPointer");
   if ( !driverTbl.glVertexPointer ) {
      driverTbl.glVertexPointer = missing_glVertexPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexPointer == loader_glVertexPointer) {
      rCtx->dsp.emuTbl.glVertexPointer = driverTbl.glVertexPointer;
   }
   driverTbl.glVertexPointer(size, type, stride, pointer);
}

static void REGAL_CALL missing_glPolygonOffset(GLfloat factor, GLfloat units)
{
   UNUSED_PARAMETER(factor);
   UNUSED_PARAMETER(units);
   Warning( "Called missing function glPolygonOffset" );
}

static void REGAL_CALL loader_glPolygonOffset(GLfloat factor, GLfloat units)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPolygonOffset, "glPolygonOffset");
   if ( !driverTbl.glPolygonOffset ) {
      driverTbl.glPolygonOffset = missing_glPolygonOffset;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPolygonOffset == loader_glPolygonOffset) {
      rCtx->dsp.emuTbl.glPolygonOffset = driverTbl.glPolygonOffset;
   }
   driverTbl.glPolygonOffset(factor, units);
}

static void REGAL_CALL missing_glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   Warning( "Called missing function glCopyTexImage1D" );
}

static void REGAL_CALL loader_glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTexImage1D, "glCopyTexImage1D");
   if ( !driverTbl.glCopyTexImage1D ) {
      driverTbl.glCopyTexImage1D = missing_glCopyTexImage1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTexImage1D == loader_glCopyTexImage1D) {
      rCtx->dsp.emuTbl.glCopyTexImage1D = driverTbl.glCopyTexImage1D;
   }
   driverTbl.glCopyTexImage1D(target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL missing_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   Warning( "Called missing function glCopyTexImage2D" );
}

static void REGAL_CALL loader_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTexImage2D, "glCopyTexImage2D");
   if ( !driverTbl.glCopyTexImage2D ) {
      driverTbl.glCopyTexImage2D = missing_glCopyTexImage2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTexImage2D == loader_glCopyTexImage2D) {
      rCtx->dsp.emuTbl.glCopyTexImage2D = driverTbl.glCopyTexImage2D;
   }
   driverTbl.glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL missing_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "Called missing function glCopyTexSubImage1D" );
}

static void REGAL_CALL loader_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTexSubImage1D, "glCopyTexSubImage1D");
   if ( !driverTbl.glCopyTexSubImage1D ) {
      driverTbl.glCopyTexSubImage1D = missing_glCopyTexSubImage1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTexSubImage1D == loader_glCopyTexSubImage1D) {
      rCtx->dsp.emuTbl.glCopyTexSubImage1D = driverTbl.glCopyTexSubImage1D;
   }
   driverTbl.glCopyTexSubImage1D(target, level, xoffset, x, y, width);
}

static void REGAL_CALL missing_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glCopyTexSubImage2D" );
}

static void REGAL_CALL loader_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTexSubImage2D, "glCopyTexSubImage2D");
   if ( !driverTbl.glCopyTexSubImage2D ) {
      driverTbl.glCopyTexSubImage2D = missing_glCopyTexSubImage2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTexSubImage2D == loader_glCopyTexSubImage2D) {
      rCtx->dsp.emuTbl.glCopyTexSubImage2D = driverTbl.glCopyTexSubImage2D;
   }
   driverTbl.glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL missing_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTexSubImage1D" );
}

static void REGAL_CALL loader_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexSubImage1D, "glTexSubImage1D");
   if ( !driverTbl.glTexSubImage1D ) {
      driverTbl.glTexSubImage1D = missing_glTexSubImage1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexSubImage1D == loader_glTexSubImage1D) {
      rCtx->dsp.emuTbl.glTexSubImage1D = driverTbl.glTexSubImage1D;
   }
   driverTbl.glTexSubImage1D(target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL missing_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTexSubImage2D" );
}

static void REGAL_CALL loader_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexSubImage2D, "glTexSubImage2D");
   if ( !driverTbl.glTexSubImage2D ) {
      driverTbl.glTexSubImage2D = missing_glTexSubImage2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexSubImage2D == loader_glTexSubImage2D) {
      rCtx->dsp.emuTbl.glTexSubImage2D = driverTbl.glTexSubImage2D;
   }
   driverTbl.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static GLboolean REGAL_CALL missing_glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   UNUSED_PARAMETER(residences);
   Warning( "Called missing function glAreTexturesResident" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glAreTexturesResident, "glAreTexturesResident");
   if ( !driverTbl.glAreTexturesResident ) {
      driverTbl.glAreTexturesResident = missing_glAreTexturesResident;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glAreTexturesResident == loader_glAreTexturesResident) {
      rCtx->dsp.emuTbl.glAreTexturesResident = driverTbl.glAreTexturesResident;
   }
   return driverTbl.glAreTexturesResident(n, textures, residences);
}

static void REGAL_CALL missing_glBindTexture(GLenum target, GLuint texture)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(texture);
   Warning( "Called missing function glBindTexture" );
}

static void REGAL_CALL loader_glBindTexture(GLenum target, GLuint texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindTexture, "glBindTexture");
   if ( !driverTbl.glBindTexture ) {
      driverTbl.glBindTexture = missing_glBindTexture;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindTexture == loader_glBindTexture) {
      rCtx->dsp.emuTbl.glBindTexture = driverTbl.glBindTexture;
   }
   driverTbl.glBindTexture(target, texture);
}

static void REGAL_CALL missing_glDeleteTextures(GLsizei n, const GLuint *textures)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   Warning( "Called missing function glDeleteTextures" );
}

static void REGAL_CALL loader_glDeleteTextures(GLsizei n, const GLuint *textures)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteTextures, "glDeleteTextures");
   if ( !driverTbl.glDeleteTextures ) {
      driverTbl.glDeleteTextures = missing_glDeleteTextures;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteTextures == loader_glDeleteTextures) {
      rCtx->dsp.emuTbl.glDeleteTextures = driverTbl.glDeleteTextures;
   }
   driverTbl.glDeleteTextures(n, textures);
}

static void REGAL_CALL missing_glGenTextures(GLsizei n, GLuint *textures)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   Warning( "Called missing function glGenTextures" );
}

static void REGAL_CALL loader_glGenTextures(GLsizei n, GLuint *textures)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenTextures, "glGenTextures");
   if ( !driverTbl.glGenTextures ) {
      driverTbl.glGenTextures = missing_glGenTextures;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenTextures == loader_glGenTextures) {
      rCtx->dsp.emuTbl.glGenTextures = driverTbl.glGenTextures;
   }
   driverTbl.glGenTextures(n, textures);
}

static GLboolean REGAL_CALL missing_glIsTexture(GLuint texture)
{
   UNUSED_PARAMETER(texture);
   Warning( "Called missing function glIsTexture" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsTexture(GLuint texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsTexture, "glIsTexture");
   if ( !driverTbl.glIsTexture ) {
      driverTbl.glIsTexture = missing_glIsTexture;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsTexture == loader_glIsTexture) {
      rCtx->dsp.emuTbl.glIsTexture = driverTbl.glIsTexture;
   }
   return driverTbl.glIsTexture(texture);
}

static void REGAL_CALL missing_glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   UNUSED_PARAMETER(priorities);
   Warning( "Called missing function glPrioritizeTextures" );
}

static void REGAL_CALL loader_glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPrioritizeTextures, "glPrioritizeTextures");
   if ( !driverTbl.glPrioritizeTextures ) {
      driverTbl.glPrioritizeTextures = missing_glPrioritizeTextures;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPrioritizeTextures == loader_glPrioritizeTextures) {
      rCtx->dsp.emuTbl.glPrioritizeTextures = driverTbl.glPrioritizeTextures;
   }
   driverTbl.glPrioritizeTextures(n, textures, priorities);
}

static void REGAL_CALL missing_glIndexub(GLubyte c)
{
   UNUSED_PARAMETER(c);
   Warning( "Called missing function glIndexub" );
}

static void REGAL_CALL loader_glIndexub(GLubyte c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexub, "glIndexub");
   if ( !driverTbl.glIndexub ) {
      driverTbl.glIndexub = missing_glIndexub;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexub == loader_glIndexub) {
      rCtx->dsp.emuTbl.glIndexub = driverTbl.glIndexub;
   }
   driverTbl.glIndexub(c);
}

static void REGAL_CALL missing_glIndexubv(const GLubyte *c)
{
   UNUSED_PARAMETER(c);
   Warning( "Called missing function glIndexubv" );
}

static void REGAL_CALL loader_glIndexubv(const GLubyte *c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexubv, "glIndexubv");
   if ( !driverTbl.glIndexubv ) {
      driverTbl.glIndexubv = missing_glIndexubv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexubv == loader_glIndexubv) {
      rCtx->dsp.emuTbl.glIndexubv = driverTbl.glIndexubv;
   }
   driverTbl.glIndexubv(c);
}

static void REGAL_CALL missing_glPopClientAttrib(void)
{
   Warning( "Called missing function glPopClientAttrib" );
}

static void REGAL_CALL loader_glPopClientAttrib(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPopClientAttrib, "glPopClientAttrib");
   if ( !driverTbl.glPopClientAttrib ) {
      driverTbl.glPopClientAttrib = missing_glPopClientAttrib;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPopClientAttrib == loader_glPopClientAttrib) {
      rCtx->dsp.emuTbl.glPopClientAttrib = driverTbl.glPopClientAttrib;
   }
   driverTbl.glPopClientAttrib();
}

static void REGAL_CALL missing_glPushClientAttrib(GLbitfield mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glPushClientAttrib" );
}

static void REGAL_CALL loader_glPushClientAttrib(GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPushClientAttrib, "glPushClientAttrib");
   if ( !driverTbl.glPushClientAttrib ) {
      driverTbl.glPushClientAttrib = missing_glPushClientAttrib;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPushClientAttrib == loader_glPushClientAttrib) {
      rCtx->dsp.emuTbl.glPushClientAttrib = driverTbl.glPushClientAttrib;
   }
   driverTbl.glPushClientAttrib(mask);
}

// GL_VERSION_1_2

static void REGAL_CALL missing_glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glBlendColor" );
}

static void REGAL_CALL loader_glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendColor, "glBlendColor");
   if ( !driverTbl.glBlendColor ) {
      driverTbl.glBlendColor = missing_glBlendColor;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendColor == loader_glBlendColor) {
      rCtx->dsp.emuTbl.glBlendColor = driverTbl.glBlendColor;
   }
   driverTbl.glBlendColor(red, green, blue, alpha);
}

static void REGAL_CALL missing_glBlendEquation(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glBlendEquation" );
}

static void REGAL_CALL loader_glBlendEquation(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendEquation, "glBlendEquation");
   if ( !driverTbl.glBlendEquation ) {
      driverTbl.glBlendEquation = missing_glBlendEquation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendEquation == loader_glBlendEquation) {
      rCtx->dsp.emuTbl.glBlendEquation = driverTbl.glBlendEquation;
   }
   driverTbl.glBlendEquation(mode);
}

static void REGAL_CALL missing_glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(end);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   Warning( "Called missing function glDrawRangeElements" );
}

static void REGAL_CALL loader_glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawRangeElements, "glDrawRangeElements");
   if ( !driverTbl.glDrawRangeElements ) {
      driverTbl.glDrawRangeElements = missing_glDrawRangeElements;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawRangeElements == loader_glDrawRangeElements) {
      rCtx->dsp.emuTbl.glDrawRangeElements = driverTbl.glDrawRangeElements;
   }
   driverTbl.glDrawRangeElements(mode, start, end, count, type, indices);
}

static void REGAL_CALL missing_glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTexImage3D" );
}

static void REGAL_CALL loader_glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexImage3D, "glTexImage3D");
   if ( !driverTbl.glTexImage3D ) {
      driverTbl.glTexImage3D = missing_glTexImage3D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexImage3D == loader_glTexImage3D) {
      rCtx->dsp.emuTbl.glTexImage3D = driverTbl.glTexImage3D;
   }
   driverTbl.glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

static void REGAL_CALL missing_glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTexSubImage3D" );
}

static void REGAL_CALL loader_glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexSubImage3D, "glTexSubImage3D");
   if ( !driverTbl.glTexSubImage3D ) {
      driverTbl.glTexSubImage3D = missing_glTexSubImage3D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexSubImage3D == loader_glTexSubImage3D) {
      rCtx->dsp.emuTbl.glTexSubImage3D = driverTbl.glTexSubImage3D;
   }
   driverTbl.glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

static void REGAL_CALL missing_glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glCopyTexSubImage3D" );
}

static void REGAL_CALL loader_glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTexSubImage3D, "glCopyTexSubImage3D");
   if ( !driverTbl.glCopyTexSubImage3D ) {
      driverTbl.glCopyTexSubImage3D = missing_glCopyTexSubImage3D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTexSubImage3D == loader_glCopyTexSubImage3D) {
      rCtx->dsp.emuTbl.glCopyTexSubImage3D = driverTbl.glCopyTexSubImage3D;
   }
   driverTbl.glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

// GL_ARB_imaging

static void REGAL_CALL missing_glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(table);
   Warning( "Called missing function glColorTable" );
}

static void REGAL_CALL loader_glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorTable, "glColorTable");
   if ( !driverTbl.glColorTable ) {
      driverTbl.glColorTable = missing_glColorTable;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorTable == loader_glColorTable) {
      rCtx->dsp.emuTbl.glColorTable = driverTbl.glColorTable;
   }
   driverTbl.glColorTable(target, internalformat, width, format, type, table);
}

static void REGAL_CALL missing_glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glColorTableParameterfv" );
}

static void REGAL_CALL loader_glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorTableParameterfv, "glColorTableParameterfv");
   if ( !driverTbl.glColorTableParameterfv ) {
      driverTbl.glColorTableParameterfv = missing_glColorTableParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorTableParameterfv == loader_glColorTableParameterfv) {
      rCtx->dsp.emuTbl.glColorTableParameterfv = driverTbl.glColorTableParameterfv;
   }
   driverTbl.glColorTableParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glColorTableParameteriv" );
}

static void REGAL_CALL loader_glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorTableParameteriv, "glColorTableParameteriv");
   if ( !driverTbl.glColorTableParameteriv ) {
      driverTbl.glColorTableParameteriv = missing_glColorTableParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorTableParameteriv == loader_glColorTableParameteriv) {
      rCtx->dsp.emuTbl.glColorTableParameteriv = driverTbl.glColorTableParameteriv;
   }
   driverTbl.glColorTableParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "Called missing function glCopyColorTable" );
}

static void REGAL_CALL loader_glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyColorTable, "glCopyColorTable");
   if ( !driverTbl.glCopyColorTable ) {
      driverTbl.glCopyColorTable = missing_glCopyColorTable;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyColorTable == loader_glCopyColorTable) {
      rCtx->dsp.emuTbl.glCopyColorTable = driverTbl.glCopyColorTable;
   }
   driverTbl.glCopyColorTable(target, internalformat, x, y, width);
}

static void REGAL_CALL missing_glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(table);
   Warning( "Called missing function glGetColorTable" );
}

static void REGAL_CALL loader_glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetColorTable, "glGetColorTable");
   if ( !driverTbl.glGetColorTable ) {
      driverTbl.glGetColorTable = missing_glGetColorTable;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetColorTable == loader_glGetColorTable) {
      rCtx->dsp.emuTbl.glGetColorTable = driverTbl.glGetColorTable;
   }
   driverTbl.glGetColorTable(target, format, type, table);
}

static void REGAL_CALL missing_glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetColorTableParameterfv" );
}

static void REGAL_CALL loader_glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetColorTableParameterfv, "glGetColorTableParameterfv");
   if ( !driverTbl.glGetColorTableParameterfv ) {
      driverTbl.glGetColorTableParameterfv = missing_glGetColorTableParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetColorTableParameterfv == loader_glGetColorTableParameterfv) {
      rCtx->dsp.emuTbl.glGetColorTableParameterfv = driverTbl.glGetColorTableParameterfv;
   }
   driverTbl.glGetColorTableParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetColorTableParameteriv" );
}

static void REGAL_CALL loader_glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetColorTableParameteriv, "glGetColorTableParameteriv");
   if ( !driverTbl.glGetColorTableParameteriv ) {
      driverTbl.glGetColorTableParameteriv = missing_glGetColorTableParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetColorTableParameteriv == loader_glGetColorTableParameteriv) {
      rCtx->dsp.emuTbl.glGetColorTableParameteriv = driverTbl.glGetColorTableParameteriv;
   }
   driverTbl.glGetColorTableParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glColorSubTable" );
}

static void REGAL_CALL loader_glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorSubTable, "glColorSubTable");
   if ( !driverTbl.glColorSubTable ) {
      driverTbl.glColorSubTable = missing_glColorSubTable;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorSubTable == loader_glColorSubTable) {
      rCtx->dsp.emuTbl.glColorSubTable = driverTbl.glColorSubTable;
   }
   driverTbl.glColorSubTable(target, start, count, format, type, data);
}

static void REGAL_CALL missing_glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "Called missing function glCopyColorSubTable" );
}

static void REGAL_CALL loader_glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyColorSubTable, "glCopyColorSubTable");
   if ( !driverTbl.glCopyColorSubTable ) {
      driverTbl.glCopyColorSubTable = missing_glCopyColorSubTable;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyColorSubTable == loader_glCopyColorSubTable) {
      rCtx->dsp.emuTbl.glCopyColorSubTable = driverTbl.glCopyColorSubTable;
   }
   driverTbl.glCopyColorSubTable(target, start, x, y, width);
}

static void REGAL_CALL missing_glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(image);
   Warning( "Called missing function glConvolutionFilter1D" );
}

static void REGAL_CALL loader_glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glConvolutionFilter1D, "glConvolutionFilter1D");
   if ( !driverTbl.glConvolutionFilter1D ) {
      driverTbl.glConvolutionFilter1D = missing_glConvolutionFilter1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glConvolutionFilter1D == loader_glConvolutionFilter1D) {
      rCtx->dsp.emuTbl.glConvolutionFilter1D = driverTbl.glConvolutionFilter1D;
   }
   driverTbl.glConvolutionFilter1D(target, internalformat, width, format, type, image);
}

static void REGAL_CALL missing_glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(image);
   Warning( "Called missing function glConvolutionFilter2D" );
}

static void REGAL_CALL loader_glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glConvolutionFilter2D, "glConvolutionFilter2D");
   if ( !driverTbl.glConvolutionFilter2D ) {
      driverTbl.glConvolutionFilter2D = missing_glConvolutionFilter2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glConvolutionFilter2D == loader_glConvolutionFilter2D) {
      rCtx->dsp.emuTbl.glConvolutionFilter2D = driverTbl.glConvolutionFilter2D;
   }
   driverTbl.glConvolutionFilter2D(target, internalformat, width, height, format, type, image);
}

static void REGAL_CALL missing_glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glConvolutionParameterf" );
}

static void REGAL_CALL loader_glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glConvolutionParameterf, "glConvolutionParameterf");
   if ( !driverTbl.glConvolutionParameterf ) {
      driverTbl.glConvolutionParameterf = missing_glConvolutionParameterf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glConvolutionParameterf == loader_glConvolutionParameterf) {
      rCtx->dsp.emuTbl.glConvolutionParameterf = driverTbl.glConvolutionParameterf;
   }
   driverTbl.glConvolutionParameterf(target, pname, params);
}

static void REGAL_CALL missing_glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glConvolutionParameterfv" );
}

static void REGAL_CALL loader_glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glConvolutionParameterfv, "glConvolutionParameterfv");
   if ( !driverTbl.glConvolutionParameterfv ) {
      driverTbl.glConvolutionParameterfv = missing_glConvolutionParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glConvolutionParameterfv == loader_glConvolutionParameterfv) {
      rCtx->dsp.emuTbl.glConvolutionParameterfv = driverTbl.glConvolutionParameterfv;
   }
   driverTbl.glConvolutionParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glConvolutionParameteri" );
}

static void REGAL_CALL loader_glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glConvolutionParameteri, "glConvolutionParameteri");
   if ( !driverTbl.glConvolutionParameteri ) {
      driverTbl.glConvolutionParameteri = missing_glConvolutionParameteri;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glConvolutionParameteri == loader_glConvolutionParameteri) {
      rCtx->dsp.emuTbl.glConvolutionParameteri = driverTbl.glConvolutionParameteri;
   }
   driverTbl.glConvolutionParameteri(target, pname, params);
}

static void REGAL_CALL missing_glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glConvolutionParameteriv" );
}

static void REGAL_CALL loader_glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glConvolutionParameteriv, "glConvolutionParameteriv");
   if ( !driverTbl.glConvolutionParameteriv ) {
      driverTbl.glConvolutionParameteriv = missing_glConvolutionParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glConvolutionParameteriv == loader_glConvolutionParameteriv) {
      rCtx->dsp.emuTbl.glConvolutionParameteriv = driverTbl.glConvolutionParameteriv;
   }
   driverTbl.glConvolutionParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "Called missing function glCopyConvolutionFilter1D" );
}

static void REGAL_CALL loader_glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyConvolutionFilter1D, "glCopyConvolutionFilter1D");
   if ( !driverTbl.glCopyConvolutionFilter1D ) {
      driverTbl.glCopyConvolutionFilter1D = missing_glCopyConvolutionFilter1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyConvolutionFilter1D == loader_glCopyConvolutionFilter1D) {
      rCtx->dsp.emuTbl.glCopyConvolutionFilter1D = driverTbl.glCopyConvolutionFilter1D;
   }
   driverTbl.glCopyConvolutionFilter1D(target, internalformat, x, y, width);
}

static void REGAL_CALL missing_glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glCopyConvolutionFilter2D" );
}

static void REGAL_CALL loader_glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyConvolutionFilter2D, "glCopyConvolutionFilter2D");
   if ( !driverTbl.glCopyConvolutionFilter2D ) {
      driverTbl.glCopyConvolutionFilter2D = missing_glCopyConvolutionFilter2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyConvolutionFilter2D == loader_glCopyConvolutionFilter2D) {
      rCtx->dsp.emuTbl.glCopyConvolutionFilter2D = driverTbl.glCopyConvolutionFilter2D;
   }
   driverTbl.glCopyConvolutionFilter2D(target, internalformat, x, y, width, height);
}

static void REGAL_CALL missing_glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(image);
   Warning( "Called missing function glGetConvolutionFilter" );
}

static void REGAL_CALL loader_glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetConvolutionFilter, "glGetConvolutionFilter");
   if ( !driverTbl.glGetConvolutionFilter ) {
      driverTbl.glGetConvolutionFilter = missing_glGetConvolutionFilter;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetConvolutionFilter == loader_glGetConvolutionFilter) {
      rCtx->dsp.emuTbl.glGetConvolutionFilter = driverTbl.glGetConvolutionFilter;
   }
   driverTbl.glGetConvolutionFilter(target, format, type, image);
}

static void REGAL_CALL missing_glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetConvolutionParameterfv" );
}

static void REGAL_CALL loader_glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetConvolutionParameterfv, "glGetConvolutionParameterfv");
   if ( !driverTbl.glGetConvolutionParameterfv ) {
      driverTbl.glGetConvolutionParameterfv = missing_glGetConvolutionParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetConvolutionParameterfv == loader_glGetConvolutionParameterfv) {
      rCtx->dsp.emuTbl.glGetConvolutionParameterfv = driverTbl.glGetConvolutionParameterfv;
   }
   driverTbl.glGetConvolutionParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetConvolutionParameteriv" );
}

static void REGAL_CALL loader_glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetConvolutionParameteriv, "glGetConvolutionParameteriv");
   if ( !driverTbl.glGetConvolutionParameteriv ) {
      driverTbl.glGetConvolutionParameteriv = missing_glGetConvolutionParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetConvolutionParameteriv == loader_glGetConvolutionParameteriv) {
      rCtx->dsp.emuTbl.glGetConvolutionParameteriv = driverTbl.glGetConvolutionParameteriv;
   }
   driverTbl.glGetConvolutionParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(row);
   UNUSED_PARAMETER(column);
   UNUSED_PARAMETER(span);
   Warning( "Called missing function glGetSeparableFilter" );
}

static void REGAL_CALL loader_glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetSeparableFilter, "glGetSeparableFilter");
   if ( !driverTbl.glGetSeparableFilter ) {
      driverTbl.glGetSeparableFilter = missing_glGetSeparableFilter;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetSeparableFilter == loader_glGetSeparableFilter) {
      rCtx->dsp.emuTbl.glGetSeparableFilter = driverTbl.glGetSeparableFilter;
   }
   driverTbl.glGetSeparableFilter(target, format, type, row, column, span);
}

static void REGAL_CALL missing_glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(row);
   UNUSED_PARAMETER(column);
   Warning( "Called missing function glSeparableFilter2D" );
}

static void REGAL_CALL loader_glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSeparableFilter2D, "glSeparableFilter2D");
   if ( !driverTbl.glSeparableFilter2D ) {
      driverTbl.glSeparableFilter2D = missing_glSeparableFilter2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSeparableFilter2D == loader_glSeparableFilter2D) {
      rCtx->dsp.emuTbl.glSeparableFilter2D = driverTbl.glSeparableFilter2D;
   }
   driverTbl.glSeparableFilter2D(target, internalformat, width, height, format, type, row, column);
}

static void REGAL_CALL missing_glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(reset);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetHistogram" );
}

static void REGAL_CALL loader_glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetHistogram, "glGetHistogram");
   if ( !driverTbl.glGetHistogram ) {
      driverTbl.glGetHistogram = missing_glGetHistogram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetHistogram == loader_glGetHistogram) {
      rCtx->dsp.emuTbl.glGetHistogram = driverTbl.glGetHistogram;
   }
   driverTbl.glGetHistogram(target, reset, format, type, values);
}

static void REGAL_CALL missing_glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetHistogramParameterfv" );
}

static void REGAL_CALL loader_glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetHistogramParameterfv, "glGetHistogramParameterfv");
   if ( !driverTbl.glGetHistogramParameterfv ) {
      driverTbl.glGetHistogramParameterfv = missing_glGetHistogramParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetHistogramParameterfv == loader_glGetHistogramParameterfv) {
      rCtx->dsp.emuTbl.glGetHistogramParameterfv = driverTbl.glGetHistogramParameterfv;
   }
   driverTbl.glGetHistogramParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetHistogramParameteriv" );
}

static void REGAL_CALL loader_glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetHistogramParameteriv, "glGetHistogramParameteriv");
   if ( !driverTbl.glGetHistogramParameteriv ) {
      driverTbl.glGetHistogramParameteriv = missing_glGetHistogramParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetHistogramParameteriv == loader_glGetHistogramParameteriv) {
      rCtx->dsp.emuTbl.glGetHistogramParameteriv = driverTbl.glGetHistogramParameteriv;
   }
   driverTbl.glGetHistogramParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(reset);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(types);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetMinmax" );
}

static void REGAL_CALL loader_glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMinmax, "glGetMinmax");
   if ( !driverTbl.glGetMinmax ) {
      driverTbl.glGetMinmax = missing_glGetMinmax;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMinmax == loader_glGetMinmax) {
      rCtx->dsp.emuTbl.glGetMinmax = driverTbl.glGetMinmax;
   }
   driverTbl.glGetMinmax(target, reset, format, types, values);
}

static void REGAL_CALL missing_glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMinmaxParameterfv" );
}

static void REGAL_CALL loader_glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMinmaxParameterfv, "glGetMinmaxParameterfv");
   if ( !driverTbl.glGetMinmaxParameterfv ) {
      driverTbl.glGetMinmaxParameterfv = missing_glGetMinmaxParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMinmaxParameterfv == loader_glGetMinmaxParameterfv) {
      rCtx->dsp.emuTbl.glGetMinmaxParameterfv = driverTbl.glGetMinmaxParameterfv;
   }
   driverTbl.glGetMinmaxParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMinmaxParameteriv" );
}

static void REGAL_CALL loader_glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMinmaxParameteriv, "glGetMinmaxParameteriv");
   if ( !driverTbl.glGetMinmaxParameteriv ) {
      driverTbl.glGetMinmaxParameteriv = missing_glGetMinmaxParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMinmaxParameteriv == loader_glGetMinmaxParameteriv) {
      rCtx->dsp.emuTbl.glGetMinmaxParameteriv = driverTbl.glGetMinmaxParameteriv;
   }
   driverTbl.glGetMinmaxParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(sink);
   Warning( "Called missing function glHistogram" );
}

static void REGAL_CALL loader_glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glHistogram, "glHistogram");
   if ( !driverTbl.glHistogram ) {
      driverTbl.glHistogram = missing_glHistogram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glHistogram == loader_glHistogram) {
      rCtx->dsp.emuTbl.glHistogram = driverTbl.glHistogram;
   }
   driverTbl.glHistogram(target, width, internalformat, sink);
}

static void REGAL_CALL missing_glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(sink);
   Warning( "Called missing function glMinmax" );
}

static void REGAL_CALL loader_glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMinmax, "glMinmax");
   if ( !driverTbl.glMinmax ) {
      driverTbl.glMinmax = missing_glMinmax;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMinmax == loader_glMinmax) {
      rCtx->dsp.emuTbl.glMinmax = driverTbl.glMinmax;
   }
   driverTbl.glMinmax(target, internalformat, sink);
}

static void REGAL_CALL missing_glResetHistogram(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glResetHistogram" );
}

static void REGAL_CALL loader_glResetHistogram(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glResetHistogram, "glResetHistogram");
   if ( !driverTbl.glResetHistogram ) {
      driverTbl.glResetHistogram = missing_glResetHistogram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glResetHistogram == loader_glResetHistogram) {
      rCtx->dsp.emuTbl.glResetHistogram = driverTbl.glResetHistogram;
   }
   driverTbl.glResetHistogram(target);
}

static void REGAL_CALL missing_glResetMinmax(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glResetMinmax" );
}

static void REGAL_CALL loader_glResetMinmax(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glResetMinmax, "glResetMinmax");
   if ( !driverTbl.glResetMinmax ) {
      driverTbl.glResetMinmax = missing_glResetMinmax;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glResetMinmax == loader_glResetMinmax) {
      rCtx->dsp.emuTbl.glResetMinmax = driverTbl.glResetMinmax;
   }
   driverTbl.glResetMinmax(target);
}

// GL_VERSION_1_3

static void REGAL_CALL missing_glActiveTexture(GLenum texture)
{
   UNUSED_PARAMETER(texture);
   Warning( "Called missing function glActiveTexture" );
}

static void REGAL_CALL loader_glActiveTexture(GLenum texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glActiveTexture, "glActiveTexture");
   if ( !driverTbl.glActiveTexture ) {
      driverTbl.glActiveTexture = missing_glActiveTexture;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glActiveTexture == loader_glActiveTexture) {
      rCtx->dsp.emuTbl.glActiveTexture = driverTbl.glActiveTexture;
   }
   driverTbl.glActiveTexture(texture);
}

static void REGAL_CALL missing_glSampleCoverage(GLclampf value, GLboolean invert)
{
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(invert);
   Warning( "Called missing function glSampleCoverage" );
}

static void REGAL_CALL loader_glSampleCoverage(GLclampf value, GLboolean invert)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSampleCoverage, "glSampleCoverage");
   if ( !driverTbl.glSampleCoverage ) {
      driverTbl.glSampleCoverage = missing_glSampleCoverage;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSampleCoverage == loader_glSampleCoverage) {
      rCtx->dsp.emuTbl.glSampleCoverage = driverTbl.glSampleCoverage;
   }
   driverTbl.glSampleCoverage(value, invert);
}

static void REGAL_CALL missing_glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedTexImage3D" );
}

static void REGAL_CALL loader_glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTexImage3D, "glCompressedTexImage3D");
   if ( !driverTbl.glCompressedTexImage3D ) {
      driverTbl.glCompressedTexImage3D = missing_glCompressedTexImage3D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTexImage3D == loader_glCompressedTexImage3D) {
      rCtx->dsp.emuTbl.glCompressedTexImage3D = driverTbl.glCompressedTexImage3D;
   }
   driverTbl.glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedTexImage2D" );
}

static void REGAL_CALL loader_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTexImage2D, "glCompressedTexImage2D");
   if ( !driverTbl.glCompressedTexImage2D ) {
      driverTbl.glCompressedTexImage2D = missing_glCompressedTexImage2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTexImage2D == loader_glCompressedTexImage2D) {
      rCtx->dsp.emuTbl.glCompressedTexImage2D = driverTbl.glCompressedTexImage2D;
   }
   driverTbl.glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedTexImage1D" );
}

static void REGAL_CALL loader_glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTexImage1D, "glCompressedTexImage1D");
   if ( !driverTbl.glCompressedTexImage1D ) {
      driverTbl.glCompressedTexImage1D = missing_glCompressedTexImage1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTexImage1D == loader_glCompressedTexImage1D) {
      rCtx->dsp.emuTbl.glCompressedTexImage1D = driverTbl.glCompressedTexImage1D;
   }
   driverTbl.glCompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedTexSubImage3D" );
}

static void REGAL_CALL loader_glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTexSubImage3D, "glCompressedTexSubImage3D");
   if ( !driverTbl.glCompressedTexSubImage3D ) {
      driverTbl.glCompressedTexSubImage3D = missing_glCompressedTexSubImage3D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTexSubImage3D == loader_glCompressedTexSubImage3D) {
      rCtx->dsp.emuTbl.glCompressedTexSubImage3D = driverTbl.glCompressedTexSubImage3D;
   }
   driverTbl.glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedTexSubImage2D" );
}

static void REGAL_CALL loader_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTexSubImage2D, "glCompressedTexSubImage2D");
   if ( !driverTbl.glCompressedTexSubImage2D ) {
      driverTbl.glCompressedTexSubImage2D = missing_glCompressedTexSubImage2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTexSubImage2D == loader_glCompressedTexSubImage2D) {
      rCtx->dsp.emuTbl.glCompressedTexSubImage2D = driverTbl.glCompressedTexSubImage2D;
   }
   driverTbl.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedTexSubImage1D" );
}

static void REGAL_CALL loader_glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTexSubImage1D, "glCompressedTexSubImage1D");
   if ( !driverTbl.glCompressedTexSubImage1D ) {
      driverTbl.glCompressedTexSubImage1D = missing_glCompressedTexSubImage1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTexSubImage1D == loader_glCompressedTexSubImage1D) {
      rCtx->dsp.emuTbl.glCompressedTexSubImage1D = driverTbl.glCompressedTexSubImage1D;
   }
   driverTbl.glCompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);
}

static void REGAL_CALL missing_glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(lod);
   UNUSED_PARAMETER(img);
   Warning( "Called missing function glGetCompressedTexImage" );
}

static void REGAL_CALL loader_glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetCompressedTexImage, "glGetCompressedTexImage");
   if ( !driverTbl.glGetCompressedTexImage ) {
      driverTbl.glGetCompressedTexImage = missing_glGetCompressedTexImage;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetCompressedTexImage == loader_glGetCompressedTexImage) {
      rCtx->dsp.emuTbl.glGetCompressedTexImage = driverTbl.glGetCompressedTexImage;
   }
   driverTbl.glGetCompressedTexImage(target, lod, img);
}

static void REGAL_CALL missing_glClientActiveTexture(GLenum texture)
{
   UNUSED_PARAMETER(texture);
   Warning( "Called missing function glClientActiveTexture" );
}

static void REGAL_CALL loader_glClientActiveTexture(GLenum texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClientActiveTexture, "glClientActiveTexture");
   if ( !driverTbl.glClientActiveTexture ) {
      driverTbl.glClientActiveTexture = missing_glClientActiveTexture;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClientActiveTexture == loader_glClientActiveTexture) {
      rCtx->dsp.emuTbl.glClientActiveTexture = driverTbl.glClientActiveTexture;
   }
   driverTbl.glClientActiveTexture(texture);
}

static void REGAL_CALL missing_glMultiTexCoord1d(GLenum target, GLdouble s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glMultiTexCoord1d" );
}

static void REGAL_CALL loader_glMultiTexCoord1d(GLenum target, GLdouble s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1d, "glMultiTexCoord1d");
   if ( !driverTbl.glMultiTexCoord1d ) {
      driverTbl.glMultiTexCoord1d = missing_glMultiTexCoord1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1d == loader_glMultiTexCoord1d) {
      rCtx->dsp.emuTbl.glMultiTexCoord1d = driverTbl.glMultiTexCoord1d;
   }
   driverTbl.glMultiTexCoord1d(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1dv(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord1dv" );
}

static void REGAL_CALL loader_glMultiTexCoord1dv(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1dv, "glMultiTexCoord1dv");
   if ( !driverTbl.glMultiTexCoord1dv ) {
      driverTbl.glMultiTexCoord1dv = missing_glMultiTexCoord1dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1dv == loader_glMultiTexCoord1dv) {
      rCtx->dsp.emuTbl.glMultiTexCoord1dv = driverTbl.glMultiTexCoord1dv;
   }
   driverTbl.glMultiTexCoord1dv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord1f(GLenum target, GLfloat s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glMultiTexCoord1f" );
}

static void REGAL_CALL loader_glMultiTexCoord1f(GLenum target, GLfloat s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1f, "glMultiTexCoord1f");
   if ( !driverTbl.glMultiTexCoord1f ) {
      driverTbl.glMultiTexCoord1f = missing_glMultiTexCoord1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1f == loader_glMultiTexCoord1f) {
      rCtx->dsp.emuTbl.glMultiTexCoord1f = driverTbl.glMultiTexCoord1f;
   }
   driverTbl.glMultiTexCoord1f(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1fv(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord1fv" );
}

static void REGAL_CALL loader_glMultiTexCoord1fv(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1fv, "glMultiTexCoord1fv");
   if ( !driverTbl.glMultiTexCoord1fv ) {
      driverTbl.glMultiTexCoord1fv = missing_glMultiTexCoord1fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1fv == loader_glMultiTexCoord1fv) {
      rCtx->dsp.emuTbl.glMultiTexCoord1fv = driverTbl.glMultiTexCoord1fv;
   }
   driverTbl.glMultiTexCoord1fv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord1i(GLenum target, GLint s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glMultiTexCoord1i" );
}

static void REGAL_CALL loader_glMultiTexCoord1i(GLenum target, GLint s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1i, "glMultiTexCoord1i");
   if ( !driverTbl.glMultiTexCoord1i ) {
      driverTbl.glMultiTexCoord1i = missing_glMultiTexCoord1i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1i == loader_glMultiTexCoord1i) {
      rCtx->dsp.emuTbl.glMultiTexCoord1i = driverTbl.glMultiTexCoord1i;
   }
   driverTbl.glMultiTexCoord1i(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1iv(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord1iv" );
}

static void REGAL_CALL loader_glMultiTexCoord1iv(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1iv, "glMultiTexCoord1iv");
   if ( !driverTbl.glMultiTexCoord1iv ) {
      driverTbl.glMultiTexCoord1iv = missing_glMultiTexCoord1iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1iv == loader_glMultiTexCoord1iv) {
      rCtx->dsp.emuTbl.glMultiTexCoord1iv = driverTbl.glMultiTexCoord1iv;
   }
   driverTbl.glMultiTexCoord1iv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord1s(GLenum target, GLshort s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glMultiTexCoord1s" );
}

static void REGAL_CALL loader_glMultiTexCoord1s(GLenum target, GLshort s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1s, "glMultiTexCoord1s");
   if ( !driverTbl.glMultiTexCoord1s ) {
      driverTbl.glMultiTexCoord1s = missing_glMultiTexCoord1s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1s == loader_glMultiTexCoord1s) {
      rCtx->dsp.emuTbl.glMultiTexCoord1s = driverTbl.glMultiTexCoord1s;
   }
   driverTbl.glMultiTexCoord1s(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1sv(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord1sv" );
}

static void REGAL_CALL loader_glMultiTexCoord1sv(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1sv, "glMultiTexCoord1sv");
   if ( !driverTbl.glMultiTexCoord1sv ) {
      driverTbl.glMultiTexCoord1sv = missing_glMultiTexCoord1sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1sv == loader_glMultiTexCoord1sv) {
      rCtx->dsp.emuTbl.glMultiTexCoord1sv = driverTbl.glMultiTexCoord1sv;
   }
   driverTbl.glMultiTexCoord1sv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "Called missing function glMultiTexCoord2d" );
}

static void REGAL_CALL loader_glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2d, "glMultiTexCoord2d");
   if ( !driverTbl.glMultiTexCoord2d ) {
      driverTbl.glMultiTexCoord2d = missing_glMultiTexCoord2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2d == loader_glMultiTexCoord2d) {
      rCtx->dsp.emuTbl.glMultiTexCoord2d = driverTbl.glMultiTexCoord2d;
   }
   driverTbl.glMultiTexCoord2d(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2dv(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord2dv" );
}

static void REGAL_CALL loader_glMultiTexCoord2dv(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2dv, "glMultiTexCoord2dv");
   if ( !driverTbl.glMultiTexCoord2dv ) {
      driverTbl.glMultiTexCoord2dv = missing_glMultiTexCoord2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2dv == loader_glMultiTexCoord2dv) {
      rCtx->dsp.emuTbl.glMultiTexCoord2dv = driverTbl.glMultiTexCoord2dv;
   }
   driverTbl.glMultiTexCoord2dv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "Called missing function glMultiTexCoord2f" );
}

static void REGAL_CALL loader_glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2f, "glMultiTexCoord2f");
   if ( !driverTbl.glMultiTexCoord2f ) {
      driverTbl.glMultiTexCoord2f = missing_glMultiTexCoord2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2f == loader_glMultiTexCoord2f) {
      rCtx->dsp.emuTbl.glMultiTexCoord2f = driverTbl.glMultiTexCoord2f;
   }
   driverTbl.glMultiTexCoord2f(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2fv(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord2fv" );
}

static void REGAL_CALL loader_glMultiTexCoord2fv(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2fv, "glMultiTexCoord2fv");
   if ( !driverTbl.glMultiTexCoord2fv ) {
      driverTbl.glMultiTexCoord2fv = missing_glMultiTexCoord2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2fv == loader_glMultiTexCoord2fv) {
      rCtx->dsp.emuTbl.glMultiTexCoord2fv = driverTbl.glMultiTexCoord2fv;
   }
   driverTbl.glMultiTexCoord2fv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2i(GLenum target, GLint s, GLint t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "Called missing function glMultiTexCoord2i" );
}

static void REGAL_CALL loader_glMultiTexCoord2i(GLenum target, GLint s, GLint t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2i, "glMultiTexCoord2i");
   if ( !driverTbl.glMultiTexCoord2i ) {
      driverTbl.glMultiTexCoord2i = missing_glMultiTexCoord2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2i == loader_glMultiTexCoord2i) {
      rCtx->dsp.emuTbl.glMultiTexCoord2i = driverTbl.glMultiTexCoord2i;
   }
   driverTbl.glMultiTexCoord2i(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2iv(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord2iv" );
}

static void REGAL_CALL loader_glMultiTexCoord2iv(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2iv, "glMultiTexCoord2iv");
   if ( !driverTbl.glMultiTexCoord2iv ) {
      driverTbl.glMultiTexCoord2iv = missing_glMultiTexCoord2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2iv == loader_glMultiTexCoord2iv) {
      rCtx->dsp.emuTbl.glMultiTexCoord2iv = driverTbl.glMultiTexCoord2iv;
   }
   driverTbl.glMultiTexCoord2iv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "Called missing function glMultiTexCoord2s" );
}

static void REGAL_CALL loader_glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2s, "glMultiTexCoord2s");
   if ( !driverTbl.glMultiTexCoord2s ) {
      driverTbl.glMultiTexCoord2s = missing_glMultiTexCoord2s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2s == loader_glMultiTexCoord2s) {
      rCtx->dsp.emuTbl.glMultiTexCoord2s = driverTbl.glMultiTexCoord2s;
   }
   driverTbl.glMultiTexCoord2s(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2sv(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord2sv" );
}

static void REGAL_CALL loader_glMultiTexCoord2sv(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2sv, "glMultiTexCoord2sv");
   if ( !driverTbl.glMultiTexCoord2sv ) {
      driverTbl.glMultiTexCoord2sv = missing_glMultiTexCoord2sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2sv == loader_glMultiTexCoord2sv) {
      rCtx->dsp.emuTbl.glMultiTexCoord2sv = driverTbl.glMultiTexCoord2sv;
   }
   driverTbl.glMultiTexCoord2sv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "Called missing function glMultiTexCoord3d" );
}

static void REGAL_CALL loader_glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3d, "glMultiTexCoord3d");
   if ( !driverTbl.glMultiTexCoord3d ) {
      driverTbl.glMultiTexCoord3d = missing_glMultiTexCoord3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3d == loader_glMultiTexCoord3d) {
      rCtx->dsp.emuTbl.glMultiTexCoord3d = driverTbl.glMultiTexCoord3d;
   }
   driverTbl.glMultiTexCoord3d(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3dv(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord3dv" );
}

static void REGAL_CALL loader_glMultiTexCoord3dv(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3dv, "glMultiTexCoord3dv");
   if ( !driverTbl.glMultiTexCoord3dv ) {
      driverTbl.glMultiTexCoord3dv = missing_glMultiTexCoord3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3dv == loader_glMultiTexCoord3dv) {
      rCtx->dsp.emuTbl.glMultiTexCoord3dv = driverTbl.glMultiTexCoord3dv;
   }
   driverTbl.glMultiTexCoord3dv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "Called missing function glMultiTexCoord3f" );
}

static void REGAL_CALL loader_glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3f, "glMultiTexCoord3f");
   if ( !driverTbl.glMultiTexCoord3f ) {
      driverTbl.glMultiTexCoord3f = missing_glMultiTexCoord3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3f == loader_glMultiTexCoord3f) {
      rCtx->dsp.emuTbl.glMultiTexCoord3f = driverTbl.glMultiTexCoord3f;
   }
   driverTbl.glMultiTexCoord3f(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3fv(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord3fv" );
}

static void REGAL_CALL loader_glMultiTexCoord3fv(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3fv, "glMultiTexCoord3fv");
   if ( !driverTbl.glMultiTexCoord3fv ) {
      driverTbl.glMultiTexCoord3fv = missing_glMultiTexCoord3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3fv == loader_glMultiTexCoord3fv) {
      rCtx->dsp.emuTbl.glMultiTexCoord3fv = driverTbl.glMultiTexCoord3fv;
   }
   driverTbl.glMultiTexCoord3fv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "Called missing function glMultiTexCoord3i" );
}

static void REGAL_CALL loader_glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3i, "glMultiTexCoord3i");
   if ( !driverTbl.glMultiTexCoord3i ) {
      driverTbl.glMultiTexCoord3i = missing_glMultiTexCoord3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3i == loader_glMultiTexCoord3i) {
      rCtx->dsp.emuTbl.glMultiTexCoord3i = driverTbl.glMultiTexCoord3i;
   }
   driverTbl.glMultiTexCoord3i(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3iv(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord3iv" );
}

static void REGAL_CALL loader_glMultiTexCoord3iv(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3iv, "glMultiTexCoord3iv");
   if ( !driverTbl.glMultiTexCoord3iv ) {
      driverTbl.glMultiTexCoord3iv = missing_glMultiTexCoord3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3iv == loader_glMultiTexCoord3iv) {
      rCtx->dsp.emuTbl.glMultiTexCoord3iv = driverTbl.glMultiTexCoord3iv;
   }
   driverTbl.glMultiTexCoord3iv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "Called missing function glMultiTexCoord3s" );
}

static void REGAL_CALL loader_glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3s, "glMultiTexCoord3s");
   if ( !driverTbl.glMultiTexCoord3s ) {
      driverTbl.glMultiTexCoord3s = missing_glMultiTexCoord3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3s == loader_glMultiTexCoord3s) {
      rCtx->dsp.emuTbl.glMultiTexCoord3s = driverTbl.glMultiTexCoord3s;
   }
   driverTbl.glMultiTexCoord3s(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3sv(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord3sv" );
}

static void REGAL_CALL loader_glMultiTexCoord3sv(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3sv, "glMultiTexCoord3sv");
   if ( !driverTbl.glMultiTexCoord3sv ) {
      driverTbl.glMultiTexCoord3sv = missing_glMultiTexCoord3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3sv == loader_glMultiTexCoord3sv) {
      rCtx->dsp.emuTbl.glMultiTexCoord3sv = driverTbl.glMultiTexCoord3sv;
   }
   driverTbl.glMultiTexCoord3sv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "Called missing function glMultiTexCoord4d" );
}

static void REGAL_CALL loader_glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4d, "glMultiTexCoord4d");
   if ( !driverTbl.glMultiTexCoord4d ) {
      driverTbl.glMultiTexCoord4d = missing_glMultiTexCoord4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4d == loader_glMultiTexCoord4d) {
      rCtx->dsp.emuTbl.glMultiTexCoord4d = driverTbl.glMultiTexCoord4d;
   }
   driverTbl.glMultiTexCoord4d(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4dv(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord4dv" );
}

static void REGAL_CALL loader_glMultiTexCoord4dv(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4dv, "glMultiTexCoord4dv");
   if ( !driverTbl.glMultiTexCoord4dv ) {
      driverTbl.glMultiTexCoord4dv = missing_glMultiTexCoord4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4dv == loader_glMultiTexCoord4dv) {
      rCtx->dsp.emuTbl.glMultiTexCoord4dv = driverTbl.glMultiTexCoord4dv;
   }
   driverTbl.glMultiTexCoord4dv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "Called missing function glMultiTexCoord4f" );
}

static void REGAL_CALL loader_glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4f, "glMultiTexCoord4f");
   if ( !driverTbl.glMultiTexCoord4f ) {
      driverTbl.glMultiTexCoord4f = missing_glMultiTexCoord4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4f == loader_glMultiTexCoord4f) {
      rCtx->dsp.emuTbl.glMultiTexCoord4f = driverTbl.glMultiTexCoord4f;
   }
   driverTbl.glMultiTexCoord4f(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4fv(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord4fv" );
}

static void REGAL_CALL loader_glMultiTexCoord4fv(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4fv, "glMultiTexCoord4fv");
   if ( !driverTbl.glMultiTexCoord4fv ) {
      driverTbl.glMultiTexCoord4fv = missing_glMultiTexCoord4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4fv == loader_glMultiTexCoord4fv) {
      rCtx->dsp.emuTbl.glMultiTexCoord4fv = driverTbl.glMultiTexCoord4fv;
   }
   driverTbl.glMultiTexCoord4fv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "Called missing function glMultiTexCoord4i" );
}

static void REGAL_CALL loader_glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4i, "glMultiTexCoord4i");
   if ( !driverTbl.glMultiTexCoord4i ) {
      driverTbl.glMultiTexCoord4i = missing_glMultiTexCoord4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4i == loader_glMultiTexCoord4i) {
      rCtx->dsp.emuTbl.glMultiTexCoord4i = driverTbl.glMultiTexCoord4i;
   }
   driverTbl.glMultiTexCoord4i(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4iv(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord4iv" );
}

static void REGAL_CALL loader_glMultiTexCoord4iv(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4iv, "glMultiTexCoord4iv");
   if ( !driverTbl.glMultiTexCoord4iv ) {
      driverTbl.glMultiTexCoord4iv = missing_glMultiTexCoord4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4iv == loader_glMultiTexCoord4iv) {
      rCtx->dsp.emuTbl.glMultiTexCoord4iv = driverTbl.glMultiTexCoord4iv;
   }
   driverTbl.glMultiTexCoord4iv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "Called missing function glMultiTexCoord4s" );
}

static void REGAL_CALL loader_glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4s, "glMultiTexCoord4s");
   if ( !driverTbl.glMultiTexCoord4s ) {
      driverTbl.glMultiTexCoord4s = missing_glMultiTexCoord4s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4s == loader_glMultiTexCoord4s) {
      rCtx->dsp.emuTbl.glMultiTexCoord4s = driverTbl.glMultiTexCoord4s;
   }
   driverTbl.glMultiTexCoord4s(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4sv(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord4sv" );
}

static void REGAL_CALL loader_glMultiTexCoord4sv(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4sv, "glMultiTexCoord4sv");
   if ( !driverTbl.glMultiTexCoord4sv ) {
      driverTbl.glMultiTexCoord4sv = missing_glMultiTexCoord4sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4sv == loader_glMultiTexCoord4sv) {
      rCtx->dsp.emuTbl.glMultiTexCoord4sv = driverTbl.glMultiTexCoord4sv;
   }
   driverTbl.glMultiTexCoord4sv(target, v);
}

static void REGAL_CALL missing_glLoadTransposeMatrixf(const GLfloat *m)
{
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glLoadTransposeMatrixf" );
}

static void REGAL_CALL loader_glLoadTransposeMatrixf(const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLoadTransposeMatrixf, "glLoadTransposeMatrixf");
   if ( !driverTbl.glLoadTransposeMatrixf ) {
      driverTbl.glLoadTransposeMatrixf = missing_glLoadTransposeMatrixf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLoadTransposeMatrixf == loader_glLoadTransposeMatrixf) {
      rCtx->dsp.emuTbl.glLoadTransposeMatrixf = driverTbl.glLoadTransposeMatrixf;
   }
   driverTbl.glLoadTransposeMatrixf(m);
}

static void REGAL_CALL missing_glLoadTransposeMatrixd(const GLdouble *m)
{
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glLoadTransposeMatrixd" );
}

static void REGAL_CALL loader_glLoadTransposeMatrixd(const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLoadTransposeMatrixd, "glLoadTransposeMatrixd");
   if ( !driverTbl.glLoadTransposeMatrixd ) {
      driverTbl.glLoadTransposeMatrixd = missing_glLoadTransposeMatrixd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLoadTransposeMatrixd == loader_glLoadTransposeMatrixd) {
      rCtx->dsp.emuTbl.glLoadTransposeMatrixd = driverTbl.glLoadTransposeMatrixd;
   }
   driverTbl.glLoadTransposeMatrixd(m);
}

static void REGAL_CALL missing_glMultTransposeMatrixf(const GLfloat *m)
{
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glMultTransposeMatrixf" );
}

static void REGAL_CALL loader_glMultTransposeMatrixf(const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultTransposeMatrixf, "glMultTransposeMatrixf");
   if ( !driverTbl.glMultTransposeMatrixf ) {
      driverTbl.glMultTransposeMatrixf = missing_glMultTransposeMatrixf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultTransposeMatrixf == loader_glMultTransposeMatrixf) {
      rCtx->dsp.emuTbl.glMultTransposeMatrixf = driverTbl.glMultTransposeMatrixf;
   }
   driverTbl.glMultTransposeMatrixf(m);
}

static void REGAL_CALL missing_glMultTransposeMatrixd(const GLdouble *m)
{
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glMultTransposeMatrixd" );
}

static void REGAL_CALL loader_glMultTransposeMatrixd(const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultTransposeMatrixd, "glMultTransposeMatrixd");
   if ( !driverTbl.glMultTransposeMatrixd ) {
      driverTbl.glMultTransposeMatrixd = missing_glMultTransposeMatrixd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultTransposeMatrixd == loader_glMultTransposeMatrixd) {
      rCtx->dsp.emuTbl.glMultTransposeMatrixd = driverTbl.glMultTransposeMatrixd;
   }
   driverTbl.glMultTransposeMatrixd(m);
}

// GL_VERSION_1_4

static void REGAL_CALL missing_glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
   UNUSED_PARAMETER(sfactorRGB);
   UNUSED_PARAMETER(dfactorRGB);
   UNUSED_PARAMETER(sfactorAlpha);
   UNUSED_PARAMETER(dfactorAlpha);
   Warning( "Called missing function glBlendFuncSeparate" );
}

static void REGAL_CALL loader_glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendFuncSeparate, "glBlendFuncSeparate");
   if ( !driverTbl.glBlendFuncSeparate ) {
      driverTbl.glBlendFuncSeparate = missing_glBlendFuncSeparate;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendFuncSeparate == loader_glBlendFuncSeparate) {
      rCtx->dsp.emuTbl.glBlendFuncSeparate = driverTbl.glBlendFuncSeparate;
   }
   driverTbl.glBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

static void REGAL_CALL missing_glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   Warning( "Called missing function glMultiDrawArrays" );
}

static void REGAL_CALL loader_glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiDrawArrays, "glMultiDrawArrays");
   if ( !driverTbl.glMultiDrawArrays ) {
      driverTbl.glMultiDrawArrays = missing_glMultiDrawArrays;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiDrawArrays == loader_glMultiDrawArrays) {
      rCtx->dsp.emuTbl.glMultiDrawArrays = driverTbl.glMultiDrawArrays;
   }
   driverTbl.glMultiDrawArrays(mode, first, count, primcount);
}

static void REGAL_CALL missing_glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   Warning( "Called missing function glMultiDrawElements" );
}

static void REGAL_CALL loader_glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiDrawElements, "glMultiDrawElements");
   if ( !driverTbl.glMultiDrawElements ) {
      driverTbl.glMultiDrawElements = missing_glMultiDrawElements;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiDrawElements == loader_glMultiDrawElements) {
      rCtx->dsp.emuTbl.glMultiDrawElements = driverTbl.glMultiDrawElements;
   }
   driverTbl.glMultiDrawElements(mode, count, type, indices, primcount);
}

static void REGAL_CALL missing_glPointParameterf(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPointParameterf" );
}

static void REGAL_CALL loader_glPointParameterf(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPointParameterf, "glPointParameterf");
   if ( !driverTbl.glPointParameterf ) {
      driverTbl.glPointParameterf = missing_glPointParameterf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPointParameterf == loader_glPointParameterf) {
      rCtx->dsp.emuTbl.glPointParameterf = driverTbl.glPointParameterf;
   }
   driverTbl.glPointParameterf(pname, param);
}

static void REGAL_CALL missing_glPointParameterfv(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glPointParameterfv" );
}

static void REGAL_CALL loader_glPointParameterfv(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPointParameterfv, "glPointParameterfv");
   if ( !driverTbl.glPointParameterfv ) {
      driverTbl.glPointParameterfv = missing_glPointParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPointParameterfv == loader_glPointParameterfv) {
      rCtx->dsp.emuTbl.glPointParameterfv = driverTbl.glPointParameterfv;
   }
   driverTbl.glPointParameterfv(pname, params);
}

static void REGAL_CALL missing_glPointParameteri(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPointParameteri" );
}

static void REGAL_CALL loader_glPointParameteri(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPointParameteri, "glPointParameteri");
   if ( !driverTbl.glPointParameteri ) {
      driverTbl.glPointParameteri = missing_glPointParameteri;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPointParameteri == loader_glPointParameteri) {
      rCtx->dsp.emuTbl.glPointParameteri = driverTbl.glPointParameteri;
   }
   driverTbl.glPointParameteri(pname, param);
}

static void REGAL_CALL missing_glPointParameteriv(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glPointParameteriv" );
}

static void REGAL_CALL loader_glPointParameteriv(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPointParameteriv, "glPointParameteriv");
   if ( !driverTbl.glPointParameteriv ) {
      driverTbl.glPointParameteriv = missing_glPointParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPointParameteriv == loader_glPointParameteriv) {
      rCtx->dsp.emuTbl.glPointParameteriv = driverTbl.glPointParameteriv;
   }
   driverTbl.glPointParameteriv(pname, params);
}

static void REGAL_CALL missing_glFogCoordf(GLfloat coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "Called missing function glFogCoordf" );
}

static void REGAL_CALL loader_glFogCoordf(GLfloat coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogCoordf, "glFogCoordf");
   if ( !driverTbl.glFogCoordf ) {
      driverTbl.glFogCoordf = missing_glFogCoordf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogCoordf == loader_glFogCoordf) {
      rCtx->dsp.emuTbl.glFogCoordf = driverTbl.glFogCoordf;
   }
   driverTbl.glFogCoordf(coord);
}

static void REGAL_CALL missing_glFogCoordfv(const GLfloat *coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "Called missing function glFogCoordfv" );
}

static void REGAL_CALL loader_glFogCoordfv(const GLfloat *coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogCoordfv, "glFogCoordfv");
   if ( !driverTbl.glFogCoordfv ) {
      driverTbl.glFogCoordfv = missing_glFogCoordfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogCoordfv == loader_glFogCoordfv) {
      rCtx->dsp.emuTbl.glFogCoordfv = driverTbl.glFogCoordfv;
   }
   driverTbl.glFogCoordfv(coord);
}

static void REGAL_CALL missing_glFogCoordd(GLdouble coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "Called missing function glFogCoordd" );
}

static void REGAL_CALL loader_glFogCoordd(GLdouble coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogCoordd, "glFogCoordd");
   if ( !driverTbl.glFogCoordd ) {
      driverTbl.glFogCoordd = missing_glFogCoordd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogCoordd == loader_glFogCoordd) {
      rCtx->dsp.emuTbl.glFogCoordd = driverTbl.glFogCoordd;
   }
   driverTbl.glFogCoordd(coord);
}

static void REGAL_CALL missing_glFogCoorddv(const GLdouble *coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "Called missing function glFogCoorddv" );
}

static void REGAL_CALL loader_glFogCoorddv(const GLdouble *coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogCoorddv, "glFogCoorddv");
   if ( !driverTbl.glFogCoorddv ) {
      driverTbl.glFogCoorddv = missing_glFogCoorddv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogCoorddv == loader_glFogCoorddv) {
      rCtx->dsp.emuTbl.glFogCoorddv = driverTbl.glFogCoorddv;
   }
   driverTbl.glFogCoorddv(coord);
}

static void REGAL_CALL missing_glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glFogCoordPointer" );
}

static void REGAL_CALL loader_glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogCoordPointer, "glFogCoordPointer");
   if ( !driverTbl.glFogCoordPointer ) {
      driverTbl.glFogCoordPointer = missing_glFogCoordPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogCoordPointer == loader_glFogCoordPointer) {
      rCtx->dsp.emuTbl.glFogCoordPointer = driverTbl.glFogCoordPointer;
   }
   driverTbl.glFogCoordPointer(type, stride, pointer);
}

static void REGAL_CALL missing_glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3b" );
}

static void REGAL_CALL loader_glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3b, "glSecondaryColor3b");
   if ( !driverTbl.glSecondaryColor3b ) {
      driverTbl.glSecondaryColor3b = missing_glSecondaryColor3b;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3b == loader_glSecondaryColor3b) {
      rCtx->dsp.emuTbl.glSecondaryColor3b = driverTbl.glSecondaryColor3b;
   }
   driverTbl.glSecondaryColor3b(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3bv(const GLbyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3bv" );
}

static void REGAL_CALL loader_glSecondaryColor3bv(const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3bv, "glSecondaryColor3bv");
   if ( !driverTbl.glSecondaryColor3bv ) {
      driverTbl.glSecondaryColor3bv = missing_glSecondaryColor3bv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3bv == loader_glSecondaryColor3bv) {
      rCtx->dsp.emuTbl.glSecondaryColor3bv = driverTbl.glSecondaryColor3bv;
   }
   driverTbl.glSecondaryColor3bv(v);
}

static void REGAL_CALL missing_glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3d" );
}

static void REGAL_CALL loader_glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3d, "glSecondaryColor3d");
   if ( !driverTbl.glSecondaryColor3d ) {
      driverTbl.glSecondaryColor3d = missing_glSecondaryColor3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3d == loader_glSecondaryColor3d) {
      rCtx->dsp.emuTbl.glSecondaryColor3d = driverTbl.glSecondaryColor3d;
   }
   driverTbl.glSecondaryColor3d(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3dv" );
}

static void REGAL_CALL loader_glSecondaryColor3dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3dv, "glSecondaryColor3dv");
   if ( !driverTbl.glSecondaryColor3dv ) {
      driverTbl.glSecondaryColor3dv = missing_glSecondaryColor3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3dv == loader_glSecondaryColor3dv) {
      rCtx->dsp.emuTbl.glSecondaryColor3dv = driverTbl.glSecondaryColor3dv;
   }
   driverTbl.glSecondaryColor3dv(v);
}

static void REGAL_CALL missing_glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3f" );
}

static void REGAL_CALL loader_glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3f, "glSecondaryColor3f");
   if ( !driverTbl.glSecondaryColor3f ) {
      driverTbl.glSecondaryColor3f = missing_glSecondaryColor3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3f == loader_glSecondaryColor3f) {
      rCtx->dsp.emuTbl.glSecondaryColor3f = driverTbl.glSecondaryColor3f;
   }
   driverTbl.glSecondaryColor3f(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3fv" );
}

static void REGAL_CALL loader_glSecondaryColor3fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3fv, "glSecondaryColor3fv");
   if ( !driverTbl.glSecondaryColor3fv ) {
      driverTbl.glSecondaryColor3fv = missing_glSecondaryColor3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3fv == loader_glSecondaryColor3fv) {
      rCtx->dsp.emuTbl.glSecondaryColor3fv = driverTbl.glSecondaryColor3fv;
   }
   driverTbl.glSecondaryColor3fv(v);
}

static void REGAL_CALL missing_glSecondaryColor3i(GLint red, GLint green, GLint blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3i" );
}

static void REGAL_CALL loader_glSecondaryColor3i(GLint red, GLint green, GLint blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3i, "glSecondaryColor3i");
   if ( !driverTbl.glSecondaryColor3i ) {
      driverTbl.glSecondaryColor3i = missing_glSecondaryColor3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3i == loader_glSecondaryColor3i) {
      rCtx->dsp.emuTbl.glSecondaryColor3i = driverTbl.glSecondaryColor3i;
   }
   driverTbl.glSecondaryColor3i(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3iv" );
}

static void REGAL_CALL loader_glSecondaryColor3iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3iv, "glSecondaryColor3iv");
   if ( !driverTbl.glSecondaryColor3iv ) {
      driverTbl.glSecondaryColor3iv = missing_glSecondaryColor3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3iv == loader_glSecondaryColor3iv) {
      rCtx->dsp.emuTbl.glSecondaryColor3iv = driverTbl.glSecondaryColor3iv;
   }
   driverTbl.glSecondaryColor3iv(v);
}

static void REGAL_CALL missing_glSecondaryColor3s(GLshort red, GLshort green, GLshort blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3s" );
}

static void REGAL_CALL loader_glSecondaryColor3s(GLshort red, GLshort green, GLshort blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3s, "glSecondaryColor3s");
   if ( !driverTbl.glSecondaryColor3s ) {
      driverTbl.glSecondaryColor3s = missing_glSecondaryColor3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3s == loader_glSecondaryColor3s) {
      rCtx->dsp.emuTbl.glSecondaryColor3s = driverTbl.glSecondaryColor3s;
   }
   driverTbl.glSecondaryColor3s(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3sv" );
}

static void REGAL_CALL loader_glSecondaryColor3sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3sv, "glSecondaryColor3sv");
   if ( !driverTbl.glSecondaryColor3sv ) {
      driverTbl.glSecondaryColor3sv = missing_glSecondaryColor3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3sv == loader_glSecondaryColor3sv) {
      rCtx->dsp.emuTbl.glSecondaryColor3sv = driverTbl.glSecondaryColor3sv;
   }
   driverTbl.glSecondaryColor3sv(v);
}

static void REGAL_CALL missing_glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3ub" );
}

static void REGAL_CALL loader_glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3ub, "glSecondaryColor3ub");
   if ( !driverTbl.glSecondaryColor3ub ) {
      driverTbl.glSecondaryColor3ub = missing_glSecondaryColor3ub;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3ub == loader_glSecondaryColor3ub) {
      rCtx->dsp.emuTbl.glSecondaryColor3ub = driverTbl.glSecondaryColor3ub;
   }
   driverTbl.glSecondaryColor3ub(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3ubv(const GLubyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3ubv" );
}

static void REGAL_CALL loader_glSecondaryColor3ubv(const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3ubv, "glSecondaryColor3ubv");
   if ( !driverTbl.glSecondaryColor3ubv ) {
      driverTbl.glSecondaryColor3ubv = missing_glSecondaryColor3ubv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3ubv == loader_glSecondaryColor3ubv) {
      rCtx->dsp.emuTbl.glSecondaryColor3ubv = driverTbl.glSecondaryColor3ubv;
   }
   driverTbl.glSecondaryColor3ubv(v);
}

static void REGAL_CALL missing_glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3ui" );
}

static void REGAL_CALL loader_glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3ui, "glSecondaryColor3ui");
   if ( !driverTbl.glSecondaryColor3ui ) {
      driverTbl.glSecondaryColor3ui = missing_glSecondaryColor3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3ui == loader_glSecondaryColor3ui) {
      rCtx->dsp.emuTbl.glSecondaryColor3ui = driverTbl.glSecondaryColor3ui;
   }
   driverTbl.glSecondaryColor3ui(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3uiv(const GLuint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3uiv" );
}

static void REGAL_CALL loader_glSecondaryColor3uiv(const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3uiv, "glSecondaryColor3uiv");
   if ( !driverTbl.glSecondaryColor3uiv ) {
      driverTbl.glSecondaryColor3uiv = missing_glSecondaryColor3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3uiv == loader_glSecondaryColor3uiv) {
      rCtx->dsp.emuTbl.glSecondaryColor3uiv = driverTbl.glSecondaryColor3uiv;
   }
   driverTbl.glSecondaryColor3uiv(v);
}

static void REGAL_CALL missing_glSecondaryColor3us(GLushort red, GLushort green, GLushort blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3us" );
}

static void REGAL_CALL loader_glSecondaryColor3us(GLushort red, GLushort green, GLushort blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3us, "glSecondaryColor3us");
   if ( !driverTbl.glSecondaryColor3us ) {
      driverTbl.glSecondaryColor3us = missing_glSecondaryColor3us;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3us == loader_glSecondaryColor3us) {
      rCtx->dsp.emuTbl.glSecondaryColor3us = driverTbl.glSecondaryColor3us;
   }
   driverTbl.glSecondaryColor3us(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3usv(const GLushort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3usv" );
}

static void REGAL_CALL loader_glSecondaryColor3usv(const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3usv, "glSecondaryColor3usv");
   if ( !driverTbl.glSecondaryColor3usv ) {
      driverTbl.glSecondaryColor3usv = missing_glSecondaryColor3usv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3usv == loader_glSecondaryColor3usv) {
      rCtx->dsp.emuTbl.glSecondaryColor3usv = driverTbl.glSecondaryColor3usv;
   }
   driverTbl.glSecondaryColor3usv(v);
}

static void REGAL_CALL missing_glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glSecondaryColorPointer" );
}

static void REGAL_CALL loader_glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColorPointer, "glSecondaryColorPointer");
   if ( !driverTbl.glSecondaryColorPointer ) {
      driverTbl.glSecondaryColorPointer = missing_glSecondaryColorPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColorPointer == loader_glSecondaryColorPointer) {
      rCtx->dsp.emuTbl.glSecondaryColorPointer = driverTbl.glSecondaryColorPointer;
   }
   driverTbl.glSecondaryColorPointer(size, type, stride, pointer);
}

static void REGAL_CALL missing_glWindowPos2d(GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glWindowPos2d" );
}

static void REGAL_CALL loader_glWindowPos2d(GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2d, "glWindowPos2d");
   if ( !driverTbl.glWindowPos2d ) {
      driverTbl.glWindowPos2d = missing_glWindowPos2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2d == loader_glWindowPos2d) {
      rCtx->dsp.emuTbl.glWindowPos2d = driverTbl.glWindowPos2d;
   }
   driverTbl.glWindowPos2d(x, y);
}

static void REGAL_CALL missing_glWindowPos2dv(const GLdouble *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos2dv" );
}

static void REGAL_CALL loader_glWindowPos2dv(const GLdouble *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2dv, "glWindowPos2dv");
   if ( !driverTbl.glWindowPos2dv ) {
      driverTbl.glWindowPos2dv = missing_glWindowPos2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2dv == loader_glWindowPos2dv) {
      rCtx->dsp.emuTbl.glWindowPos2dv = driverTbl.glWindowPos2dv;
   }
   driverTbl.glWindowPos2dv(p);
}

static void REGAL_CALL missing_glWindowPos2f(GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glWindowPos2f" );
}

static void REGAL_CALL loader_glWindowPos2f(GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2f, "glWindowPos2f");
   if ( !driverTbl.glWindowPos2f ) {
      driverTbl.glWindowPos2f = missing_glWindowPos2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2f == loader_glWindowPos2f) {
      rCtx->dsp.emuTbl.glWindowPos2f = driverTbl.glWindowPos2f;
   }
   driverTbl.glWindowPos2f(x, y);
}

static void REGAL_CALL missing_glWindowPos2fv(const GLfloat *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos2fv" );
}

static void REGAL_CALL loader_glWindowPos2fv(const GLfloat *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2fv, "glWindowPos2fv");
   if ( !driverTbl.glWindowPos2fv ) {
      driverTbl.glWindowPos2fv = missing_glWindowPos2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2fv == loader_glWindowPos2fv) {
      rCtx->dsp.emuTbl.glWindowPos2fv = driverTbl.glWindowPos2fv;
   }
   driverTbl.glWindowPos2fv(p);
}

static void REGAL_CALL missing_glWindowPos2i(GLint x, GLint y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glWindowPos2i" );
}

static void REGAL_CALL loader_glWindowPos2i(GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2i, "glWindowPos2i");
   if ( !driverTbl.glWindowPos2i ) {
      driverTbl.glWindowPos2i = missing_glWindowPos2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2i == loader_glWindowPos2i) {
      rCtx->dsp.emuTbl.glWindowPos2i = driverTbl.glWindowPos2i;
   }
   driverTbl.glWindowPos2i(x, y);
}

static void REGAL_CALL missing_glWindowPos2iv(const GLint *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos2iv" );
}

static void REGAL_CALL loader_glWindowPos2iv(const GLint *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2iv, "glWindowPos2iv");
   if ( !driverTbl.glWindowPos2iv ) {
      driverTbl.glWindowPos2iv = missing_glWindowPos2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2iv == loader_glWindowPos2iv) {
      rCtx->dsp.emuTbl.glWindowPos2iv = driverTbl.glWindowPos2iv;
   }
   driverTbl.glWindowPos2iv(p);
}

static void REGAL_CALL missing_glWindowPos2s(GLshort x, GLshort y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glWindowPos2s" );
}

static void REGAL_CALL loader_glWindowPos2s(GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2s, "glWindowPos2s");
   if ( !driverTbl.glWindowPos2s ) {
      driverTbl.glWindowPos2s = missing_glWindowPos2s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2s == loader_glWindowPos2s) {
      rCtx->dsp.emuTbl.glWindowPos2s = driverTbl.glWindowPos2s;
   }
   driverTbl.glWindowPos2s(x, y);
}

static void REGAL_CALL missing_glWindowPos2sv(const GLshort *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos2sv" );
}

static void REGAL_CALL loader_glWindowPos2sv(const GLshort *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2sv, "glWindowPos2sv");
   if ( !driverTbl.glWindowPos2sv ) {
      driverTbl.glWindowPos2sv = missing_glWindowPos2sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2sv == loader_glWindowPos2sv) {
      rCtx->dsp.emuTbl.glWindowPos2sv = driverTbl.glWindowPos2sv;
   }
   driverTbl.glWindowPos2sv(p);
}

static void REGAL_CALL missing_glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glWindowPos3d" );
}

static void REGAL_CALL loader_glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3d, "glWindowPos3d");
   if ( !driverTbl.glWindowPos3d ) {
      driverTbl.glWindowPos3d = missing_glWindowPos3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3d == loader_glWindowPos3d) {
      rCtx->dsp.emuTbl.glWindowPos3d = driverTbl.glWindowPos3d;
   }
   driverTbl.glWindowPos3d(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3dv(const GLdouble *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos3dv" );
}

static void REGAL_CALL loader_glWindowPos3dv(const GLdouble *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3dv, "glWindowPos3dv");
   if ( !driverTbl.glWindowPos3dv ) {
      driverTbl.glWindowPos3dv = missing_glWindowPos3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3dv == loader_glWindowPos3dv) {
      rCtx->dsp.emuTbl.glWindowPos3dv = driverTbl.glWindowPos3dv;
   }
   driverTbl.glWindowPos3dv(p);
}

static void REGAL_CALL missing_glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glWindowPos3f" );
}

static void REGAL_CALL loader_glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3f, "glWindowPos3f");
   if ( !driverTbl.glWindowPos3f ) {
      driverTbl.glWindowPos3f = missing_glWindowPos3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3f == loader_glWindowPos3f) {
      rCtx->dsp.emuTbl.glWindowPos3f = driverTbl.glWindowPos3f;
   }
   driverTbl.glWindowPos3f(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3fv(const GLfloat *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos3fv" );
}

static void REGAL_CALL loader_glWindowPos3fv(const GLfloat *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3fv, "glWindowPos3fv");
   if ( !driverTbl.glWindowPos3fv ) {
      driverTbl.glWindowPos3fv = missing_glWindowPos3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3fv == loader_glWindowPos3fv) {
      rCtx->dsp.emuTbl.glWindowPos3fv = driverTbl.glWindowPos3fv;
   }
   driverTbl.glWindowPos3fv(p);
}

static void REGAL_CALL missing_glWindowPos3i(GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glWindowPos3i" );
}

static void REGAL_CALL loader_glWindowPos3i(GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3i, "glWindowPos3i");
   if ( !driverTbl.glWindowPos3i ) {
      driverTbl.glWindowPos3i = missing_glWindowPos3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3i == loader_glWindowPos3i) {
      rCtx->dsp.emuTbl.glWindowPos3i = driverTbl.glWindowPos3i;
   }
   driverTbl.glWindowPos3i(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3iv(const GLint *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos3iv" );
}

static void REGAL_CALL loader_glWindowPos3iv(const GLint *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3iv, "glWindowPos3iv");
   if ( !driverTbl.glWindowPos3iv ) {
      driverTbl.glWindowPos3iv = missing_glWindowPos3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3iv == loader_glWindowPos3iv) {
      rCtx->dsp.emuTbl.glWindowPos3iv = driverTbl.glWindowPos3iv;
   }
   driverTbl.glWindowPos3iv(p);
}

static void REGAL_CALL missing_glWindowPos3s(GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glWindowPos3s" );
}

static void REGAL_CALL loader_glWindowPos3s(GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3s, "glWindowPos3s");
   if ( !driverTbl.glWindowPos3s ) {
      driverTbl.glWindowPos3s = missing_glWindowPos3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3s == loader_glWindowPos3s) {
      rCtx->dsp.emuTbl.glWindowPos3s = driverTbl.glWindowPos3s;
   }
   driverTbl.glWindowPos3s(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3sv(const GLshort *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos3sv" );
}

static void REGAL_CALL loader_glWindowPos3sv(const GLshort *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3sv, "glWindowPos3sv");
   if ( !driverTbl.glWindowPos3sv ) {
      driverTbl.glWindowPos3sv = missing_glWindowPos3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3sv == loader_glWindowPos3sv) {
      rCtx->dsp.emuTbl.glWindowPos3sv = driverTbl.glWindowPos3sv;
   }
   driverTbl.glWindowPos3sv(p);
}

// GL_VERSION_1_5

static void REGAL_CALL missing_glGenQueries(GLsizei n, GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "Called missing function glGenQueries" );
}

static void REGAL_CALL loader_glGenQueries(GLsizei n, GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenQueries, "glGenQueries");
   if ( !driverTbl.glGenQueries ) {
      driverTbl.glGenQueries = missing_glGenQueries;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenQueries == loader_glGenQueries) {
      rCtx->dsp.emuTbl.glGenQueries = driverTbl.glGenQueries;
   }
   driverTbl.glGenQueries(n, ids);
}

static void REGAL_CALL missing_glDeleteQueries(GLsizei n, const GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "Called missing function glDeleteQueries" );
}

static void REGAL_CALL loader_glDeleteQueries(GLsizei n, const GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteQueries, "glDeleteQueries");
   if ( !driverTbl.glDeleteQueries ) {
      driverTbl.glDeleteQueries = missing_glDeleteQueries;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteQueries == loader_glDeleteQueries) {
      rCtx->dsp.emuTbl.glDeleteQueries = driverTbl.glDeleteQueries;
   }
   driverTbl.glDeleteQueries(n, ids);
}

static GLboolean REGAL_CALL missing_glIsQuery(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glIsQuery" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsQuery(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsQuery, "glIsQuery");
   if ( !driverTbl.glIsQuery ) {
      driverTbl.glIsQuery = missing_glIsQuery;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsQuery == loader_glIsQuery) {
      rCtx->dsp.emuTbl.glIsQuery = driverTbl.glIsQuery;
   }
   return driverTbl.glIsQuery(id);
}

static void REGAL_CALL missing_glBeginQuery(GLenum target, GLuint id)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glBeginQuery" );
}

static void REGAL_CALL loader_glBeginQuery(GLenum target, GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBeginQuery, "glBeginQuery");
   if ( !driverTbl.glBeginQuery ) {
      driverTbl.glBeginQuery = missing_glBeginQuery;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBeginQuery == loader_glBeginQuery) {
      rCtx->dsp.emuTbl.glBeginQuery = driverTbl.glBeginQuery;
   }
   driverTbl.glBeginQuery(target, id);
}

static void REGAL_CALL missing_glEndQuery(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glEndQuery" );
}

static void REGAL_CALL loader_glEndQuery(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndQuery, "glEndQuery");
   if ( !driverTbl.glEndQuery ) {
      driverTbl.glEndQuery = missing_glEndQuery;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndQuery == loader_glEndQuery) {
      rCtx->dsp.emuTbl.glEndQuery = driverTbl.glEndQuery;
   }
   driverTbl.glEndQuery(target);
}

static void REGAL_CALL missing_glGetQueryiv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetQueryiv" );
}

static void REGAL_CALL loader_glGetQueryiv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetQueryiv, "glGetQueryiv");
   if ( !driverTbl.glGetQueryiv ) {
      driverTbl.glGetQueryiv = missing_glGetQueryiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetQueryiv == loader_glGetQueryiv) {
      rCtx->dsp.emuTbl.glGetQueryiv = driverTbl.glGetQueryiv;
   }
   driverTbl.glGetQueryiv(target, pname, params);
}

static void REGAL_CALL missing_glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetQueryObjectiv" );
}

static void REGAL_CALL loader_glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetQueryObjectiv, "glGetQueryObjectiv");
   if ( !driverTbl.glGetQueryObjectiv ) {
      driverTbl.glGetQueryObjectiv = missing_glGetQueryObjectiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetQueryObjectiv == loader_glGetQueryObjectiv) {
      rCtx->dsp.emuTbl.glGetQueryObjectiv = driverTbl.glGetQueryObjectiv;
   }
   driverTbl.glGetQueryObjectiv(id, pname, params);
}

static void REGAL_CALL missing_glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetQueryObjectuiv" );
}

static void REGAL_CALL loader_glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetQueryObjectuiv, "glGetQueryObjectuiv");
   if ( !driverTbl.glGetQueryObjectuiv ) {
      driverTbl.glGetQueryObjectuiv = missing_glGetQueryObjectuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetQueryObjectuiv == loader_glGetQueryObjectuiv) {
      rCtx->dsp.emuTbl.glGetQueryObjectuiv = driverTbl.glGetQueryObjectuiv;
   }
   driverTbl.glGetQueryObjectuiv(id, pname, params);
}

static void REGAL_CALL missing_glBindBuffer(GLenum target, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glBindBuffer" );
}

static void REGAL_CALL loader_glBindBuffer(GLenum target, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindBuffer, "glBindBuffer");
   if ( !driverTbl.glBindBuffer ) {
      driverTbl.glBindBuffer = missing_glBindBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindBuffer == loader_glBindBuffer) {
      rCtx->dsp.emuTbl.glBindBuffer = driverTbl.glBindBuffer;
   }
   driverTbl.glBindBuffer(target, buffer);
}

static void REGAL_CALL missing_glDeleteBuffers(GLsizei n, const GLuint *buffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(buffers);
   Warning( "Called missing function glDeleteBuffers" );
}

static void REGAL_CALL loader_glDeleteBuffers(GLsizei n, const GLuint *buffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteBuffers, "glDeleteBuffers");
   if ( !driverTbl.glDeleteBuffers ) {
      driverTbl.glDeleteBuffers = missing_glDeleteBuffers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteBuffers == loader_glDeleteBuffers) {
      rCtx->dsp.emuTbl.glDeleteBuffers = driverTbl.glDeleteBuffers;
   }
   driverTbl.glDeleteBuffers(n, buffers);
}

static void REGAL_CALL missing_glGenBuffers(GLsizei n, GLuint *buffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(buffers);
   Warning( "Called missing function glGenBuffers" );
}

static void REGAL_CALL loader_glGenBuffers(GLsizei n, GLuint *buffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenBuffers, "glGenBuffers");
   if ( !driverTbl.glGenBuffers ) {
      driverTbl.glGenBuffers = missing_glGenBuffers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenBuffers == loader_glGenBuffers) {
      rCtx->dsp.emuTbl.glGenBuffers = driverTbl.glGenBuffers;
   }
   driverTbl.glGenBuffers(n, buffers);
}

static GLboolean REGAL_CALL missing_glIsBuffer(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glIsBuffer" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsBuffer(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsBuffer, "glIsBuffer");
   if ( !driverTbl.glIsBuffer ) {
      driverTbl.glIsBuffer = missing_glIsBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsBuffer == loader_glIsBuffer) {
      rCtx->dsp.emuTbl.glIsBuffer = driverTbl.glIsBuffer;
   }
   return driverTbl.glIsBuffer(buffer);
}

static void REGAL_CALL missing_glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   UNUSED_PARAMETER(usage);
   Warning( "Called missing function glBufferData" );
}

static void REGAL_CALL loader_glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBufferData, "glBufferData");
   if ( !driverTbl.glBufferData ) {
      driverTbl.glBufferData = missing_glBufferData;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBufferData == loader_glBufferData) {
      rCtx->dsp.emuTbl.glBufferData = driverTbl.glBufferData;
   }
   driverTbl.glBufferData(target, size, data, usage);
}

static void REGAL_CALL missing_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glBufferSubData" );
}

static void REGAL_CALL loader_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBufferSubData, "glBufferSubData");
   if ( !driverTbl.glBufferSubData ) {
      driverTbl.glBufferSubData = missing_glBufferSubData;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBufferSubData == loader_glBufferSubData) {
      rCtx->dsp.emuTbl.glBufferSubData = driverTbl.glBufferSubData;
   }
   driverTbl.glBufferSubData(target, offset, size, data);
}

static void REGAL_CALL missing_glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetBufferSubData" );
}

static void REGAL_CALL loader_glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetBufferSubData, "glGetBufferSubData");
   if ( !driverTbl.glGetBufferSubData ) {
      driverTbl.glGetBufferSubData = missing_glGetBufferSubData;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetBufferSubData == loader_glGetBufferSubData) {
      rCtx->dsp.emuTbl.glGetBufferSubData = driverTbl.glGetBufferSubData;
   }
   driverTbl.glGetBufferSubData(target, offset, size, data);
}

static GLvoid *REGAL_CALL missing_glMapBuffer(GLenum target, GLenum access)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(access);
   Warning( "Called missing function glMapBuffer" );
  GLvoid * ret = NULL;
  return ret;
}

static GLvoid *REGAL_CALL loader_glMapBuffer(GLenum target, GLenum access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapBuffer, "glMapBuffer");
   if ( !driverTbl.glMapBuffer ) {
      driverTbl.glMapBuffer = missing_glMapBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapBuffer == loader_glMapBuffer) {
      rCtx->dsp.emuTbl.glMapBuffer = driverTbl.glMapBuffer;
   }
   return driverTbl.glMapBuffer(target, access);
}

static GLboolean REGAL_CALL missing_glUnmapBuffer(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glUnmapBuffer" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glUnmapBuffer(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUnmapBuffer, "glUnmapBuffer");
   if ( !driverTbl.glUnmapBuffer ) {
      driverTbl.glUnmapBuffer = missing_glUnmapBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUnmapBuffer == loader_glUnmapBuffer) {
      rCtx->dsp.emuTbl.glUnmapBuffer = driverTbl.glUnmapBuffer;
   }
   return driverTbl.glUnmapBuffer(target);
}

static void REGAL_CALL missing_glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetBufferParameteriv" );
}

static void REGAL_CALL loader_glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetBufferParameteriv, "glGetBufferParameteriv");
   if ( !driverTbl.glGetBufferParameteriv ) {
      driverTbl.glGetBufferParameteriv = missing_glGetBufferParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetBufferParameteriv == loader_glGetBufferParameteriv) {
      rCtx->dsp.emuTbl.glGetBufferParameteriv = driverTbl.glGetBufferParameteriv;
   }
   driverTbl.glGetBufferParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glGetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetBufferPointerv" );
}

static void REGAL_CALL loader_glGetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetBufferPointerv, "glGetBufferPointerv");
   if ( !driverTbl.glGetBufferPointerv ) {
      driverTbl.glGetBufferPointerv = missing_glGetBufferPointerv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetBufferPointerv == loader_glGetBufferPointerv) {
      rCtx->dsp.emuTbl.glGetBufferPointerv = driverTbl.glGetBufferPointerv;
   }
   driverTbl.glGetBufferPointerv(target, pname, params);
}

// GL_VERSION_2_0

static void REGAL_CALL missing_glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
   UNUSED_PARAMETER(modeRGB);
   UNUSED_PARAMETER(modeAlpha);
   Warning( "Called missing function glBlendEquationSeparate" );
}

static void REGAL_CALL loader_glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendEquationSeparate, "glBlendEquationSeparate");
   if ( !driverTbl.glBlendEquationSeparate ) {
      driverTbl.glBlendEquationSeparate = missing_glBlendEquationSeparate;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendEquationSeparate == loader_glBlendEquationSeparate) {
      rCtx->dsp.emuTbl.glBlendEquationSeparate = driverTbl.glBlendEquationSeparate;
   }
   driverTbl.glBlendEquationSeparate(modeRGB, modeAlpha);
}

static void REGAL_CALL missing_glDrawBuffers(GLsizei n, const GLenum *bufs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(bufs);
   Warning( "Called missing function glDrawBuffers" );
}

static void REGAL_CALL loader_glDrawBuffers(GLsizei n, const GLenum *bufs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawBuffers, "glDrawBuffers");
   if ( !driverTbl.glDrawBuffers ) {
      driverTbl.glDrawBuffers = missing_glDrawBuffers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawBuffers == loader_glDrawBuffers) {
      rCtx->dsp.emuTbl.glDrawBuffers = driverTbl.glDrawBuffers;
   }
   driverTbl.glDrawBuffers(n, bufs);
}

static void REGAL_CALL missing_glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(fail);
   UNUSED_PARAMETER(zfail);
   UNUSED_PARAMETER(zpass);
   Warning( "Called missing function glStencilOpSeparate" );
}

static void REGAL_CALL loader_glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStencilOpSeparate, "glStencilOpSeparate");
   if ( !driverTbl.glStencilOpSeparate ) {
      driverTbl.glStencilOpSeparate = missing_glStencilOpSeparate;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStencilOpSeparate == loader_glStencilOpSeparate) {
      rCtx->dsp.emuTbl.glStencilOpSeparate = driverTbl.glStencilOpSeparate;
   }
   driverTbl.glStencilOpSeparate(face, fail, zfail, zpass);
}

static void REGAL_CALL missing_glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(func);
   UNUSED_PARAMETER(ref);
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glStencilFuncSeparate" );
}

static void REGAL_CALL loader_glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStencilFuncSeparate, "glStencilFuncSeparate");
   if ( !driverTbl.glStencilFuncSeparate ) {
      driverTbl.glStencilFuncSeparate = missing_glStencilFuncSeparate;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStencilFuncSeparate == loader_glStencilFuncSeparate) {
      rCtx->dsp.emuTbl.glStencilFuncSeparate = driverTbl.glStencilFuncSeparate;
   }
   driverTbl.glStencilFuncSeparate(face, func, ref, mask);
}

static void REGAL_CALL missing_glStencilMaskSeparate(GLenum face, GLuint mask)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glStencilMaskSeparate" );
}

static void REGAL_CALL loader_glStencilMaskSeparate(GLenum face, GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStencilMaskSeparate, "glStencilMaskSeparate");
   if ( !driverTbl.glStencilMaskSeparate ) {
      driverTbl.glStencilMaskSeparate = missing_glStencilMaskSeparate;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStencilMaskSeparate == loader_glStencilMaskSeparate) {
      rCtx->dsp.emuTbl.glStencilMaskSeparate = driverTbl.glStencilMaskSeparate;
   }
   driverTbl.glStencilMaskSeparate(face, mask);
}

static void REGAL_CALL missing_glAttachShader(GLuint program, GLuint shader)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shader);
   Warning( "Called missing function glAttachShader" );
}

static void REGAL_CALL loader_glAttachShader(GLuint program, GLuint shader)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glAttachShader, "glAttachShader");
   if ( !driverTbl.glAttachShader ) {
      driverTbl.glAttachShader = missing_glAttachShader;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glAttachShader == loader_glAttachShader) {
      rCtx->dsp.emuTbl.glAttachShader = driverTbl.glAttachShader;
   }
   driverTbl.glAttachShader(program, shader);
}

static void REGAL_CALL missing_glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glBindAttribLocation" );
}

static void REGAL_CALL loader_glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindAttribLocation, "glBindAttribLocation");
   if ( !driverTbl.glBindAttribLocation ) {
      driverTbl.glBindAttribLocation = missing_glBindAttribLocation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindAttribLocation == loader_glBindAttribLocation) {
      rCtx->dsp.emuTbl.glBindAttribLocation = driverTbl.glBindAttribLocation;
   }
   driverTbl.glBindAttribLocation(program, index, name);
}

static void REGAL_CALL missing_glCompileShader(GLuint shader)
{
   UNUSED_PARAMETER(shader);
   Warning( "Called missing function glCompileShader" );
}

static void REGAL_CALL loader_glCompileShader(GLuint shader)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompileShader, "glCompileShader");
   if ( !driverTbl.glCompileShader ) {
      driverTbl.glCompileShader = missing_glCompileShader;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompileShader == loader_glCompileShader) {
      rCtx->dsp.emuTbl.glCompileShader = driverTbl.glCompileShader;
   }
   driverTbl.glCompileShader(shader);
}

static GLuint REGAL_CALL missing_glCreateProgram(void)
{
   Warning( "Called missing function glCreateProgram" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glCreateProgram(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCreateProgram, "glCreateProgram");
   if ( !driverTbl.glCreateProgram ) {
      driverTbl.glCreateProgram = missing_glCreateProgram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCreateProgram == loader_glCreateProgram) {
      rCtx->dsp.emuTbl.glCreateProgram = driverTbl.glCreateProgram;
   }
   return driverTbl.glCreateProgram();
}

static GLuint REGAL_CALL missing_glCreateShader(GLenum type)
{
   UNUSED_PARAMETER(type);
   Warning( "Called missing function glCreateShader" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glCreateShader(GLenum type)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCreateShader, "glCreateShader");
   if ( !driverTbl.glCreateShader ) {
      driverTbl.glCreateShader = missing_glCreateShader;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCreateShader == loader_glCreateShader) {
      rCtx->dsp.emuTbl.glCreateShader = driverTbl.glCreateShader;
   }
   return driverTbl.glCreateShader(type);
}

static void REGAL_CALL missing_glDeleteProgram(GLuint program)
{
   UNUSED_PARAMETER(program);
   Warning( "Called missing function glDeleteProgram" );
}

static void REGAL_CALL loader_glDeleteProgram(GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteProgram, "glDeleteProgram");
   if ( !driverTbl.glDeleteProgram ) {
      driverTbl.glDeleteProgram = missing_glDeleteProgram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteProgram == loader_glDeleteProgram) {
      rCtx->dsp.emuTbl.glDeleteProgram = driverTbl.glDeleteProgram;
   }
   driverTbl.glDeleteProgram(program);
}

static void REGAL_CALL missing_glDeleteShader(GLuint shader)
{
   UNUSED_PARAMETER(shader);
   Warning( "Called missing function glDeleteShader" );
}

static void REGAL_CALL loader_glDeleteShader(GLuint shader)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteShader, "glDeleteShader");
   if ( !driverTbl.glDeleteShader ) {
      driverTbl.glDeleteShader = missing_glDeleteShader;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteShader == loader_glDeleteShader) {
      rCtx->dsp.emuTbl.glDeleteShader = driverTbl.glDeleteShader;
   }
   driverTbl.glDeleteShader(shader);
}

static void REGAL_CALL missing_glDetachShader(GLuint program, GLuint shader)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shader);
   Warning( "Called missing function glDetachShader" );
}

static void REGAL_CALL loader_glDetachShader(GLuint program, GLuint shader)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDetachShader, "glDetachShader");
   if ( !driverTbl.glDetachShader ) {
      driverTbl.glDetachShader = missing_glDetachShader;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDetachShader == loader_glDetachShader) {
      rCtx->dsp.emuTbl.glDetachShader = driverTbl.glDetachShader;
   }
   driverTbl.glDetachShader(program, shader);
}

static void REGAL_CALL missing_glDisableVertexAttribArray(GLuint index)
{
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glDisableVertexAttribArray" );
}

static void REGAL_CALL loader_glDisableVertexAttribArray(GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDisableVertexAttribArray, "glDisableVertexAttribArray");
   if ( !driverTbl.glDisableVertexAttribArray ) {
      driverTbl.glDisableVertexAttribArray = missing_glDisableVertexAttribArray;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDisableVertexAttribArray == loader_glDisableVertexAttribArray) {
      rCtx->dsp.emuTbl.glDisableVertexAttribArray = driverTbl.glDisableVertexAttribArray;
   }
   driverTbl.glDisableVertexAttribArray(index);
}

static void REGAL_CALL missing_glEnableVertexAttribArray(GLuint index)
{
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glEnableVertexAttribArray" );
}

static void REGAL_CALL loader_glEnableVertexAttribArray(GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEnableVertexAttribArray, "glEnableVertexAttribArray");
   if ( !driverTbl.glEnableVertexAttribArray ) {
      driverTbl.glEnableVertexAttribArray = missing_glEnableVertexAttribArray;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEnableVertexAttribArray == loader_glEnableVertexAttribArray) {
      rCtx->dsp.emuTbl.glEnableVertexAttribArray = driverTbl.glEnableVertexAttribArray;
   }
   driverTbl.glEnableVertexAttribArray(index);
}

static void REGAL_CALL missing_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetActiveAttrib" );
}

static void REGAL_CALL loader_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetActiveAttrib, "glGetActiveAttrib");
   if ( !driverTbl.glGetActiveAttrib ) {
      driverTbl.glGetActiveAttrib = missing_glGetActiveAttrib;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetActiveAttrib == loader_glGetActiveAttrib) {
      rCtx->dsp.emuTbl.glGetActiveAttrib = driverTbl.glGetActiveAttrib;
   }
   driverTbl.glGetActiveAttrib(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL missing_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetActiveUniform" );
}

static void REGAL_CALL loader_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetActiveUniform, "glGetActiveUniform");
   if ( !driverTbl.glGetActiveUniform ) {
      driverTbl.glGetActiveUniform = missing_glGetActiveUniform;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetActiveUniform == loader_glGetActiveUniform) {
      rCtx->dsp.emuTbl.glGetActiveUniform = driverTbl.glGetActiveUniform;
   }
   driverTbl.glGetActiveUniform(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL missing_glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(maxCount);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(shaders);
   Warning( "Called missing function glGetAttachedShaders" );
}

static void REGAL_CALL loader_glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetAttachedShaders, "glGetAttachedShaders");
   if ( !driverTbl.glGetAttachedShaders ) {
      driverTbl.glGetAttachedShaders = missing_glGetAttachedShaders;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetAttachedShaders == loader_glGetAttachedShaders) {
      rCtx->dsp.emuTbl.glGetAttachedShaders = driverTbl.glGetAttachedShaders;
   }
   driverTbl.glGetAttachedShaders(program, maxCount, count, shaders);
}

static GLint REGAL_CALL missing_glGetAttribLocation(GLuint program, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetAttribLocation" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetAttribLocation(GLuint program, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetAttribLocation, "glGetAttribLocation");
   if ( !driverTbl.glGetAttribLocation ) {
      driverTbl.glGetAttribLocation = missing_glGetAttribLocation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetAttribLocation == loader_glGetAttribLocation) {
      rCtx->dsp.emuTbl.glGetAttribLocation = driverTbl.glGetAttribLocation;
   }
   return driverTbl.glGetAttribLocation(program, name);
}

static void REGAL_CALL missing_glGetProgramiv(GLuint program, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramiv" );
}

static void REGAL_CALL loader_glGetProgramiv(GLuint program, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramiv, "glGetProgramiv");
   if ( !driverTbl.glGetProgramiv ) {
      driverTbl.glGetProgramiv = missing_glGetProgramiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramiv == loader_glGetProgramiv) {
      rCtx->dsp.emuTbl.glGetProgramiv = driverTbl.glGetProgramiv;
   }
   driverTbl.glGetProgramiv(program, pname, params);
}

static void REGAL_CALL missing_glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(infoLog);
   Warning( "Called missing function glGetProgramInfoLog" );
}

static void REGAL_CALL loader_glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramInfoLog, "glGetProgramInfoLog");
   if ( !driverTbl.glGetProgramInfoLog ) {
      driverTbl.glGetProgramInfoLog = missing_glGetProgramInfoLog;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramInfoLog == loader_glGetProgramInfoLog) {
      rCtx->dsp.emuTbl.glGetProgramInfoLog = driverTbl.glGetProgramInfoLog;
   }
   driverTbl.glGetProgramInfoLog(program, bufSize, length, infoLog);
}

static void REGAL_CALL missing_glGetShaderiv(GLuint shader, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(shader);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetShaderiv" );
}

static void REGAL_CALL loader_glGetShaderiv(GLuint shader, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetShaderiv, "glGetShaderiv");
   if ( !driverTbl.glGetShaderiv ) {
      driverTbl.glGetShaderiv = missing_glGetShaderiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetShaderiv == loader_glGetShaderiv) {
      rCtx->dsp.emuTbl.glGetShaderiv = driverTbl.glGetShaderiv;
   }
   driverTbl.glGetShaderiv(shader, pname, params);
}

static void REGAL_CALL missing_glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
   UNUSED_PARAMETER(shader);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(infoLog);
   Warning( "Called missing function glGetShaderInfoLog" );
}

static void REGAL_CALL loader_glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetShaderInfoLog, "glGetShaderInfoLog");
   if ( !driverTbl.glGetShaderInfoLog ) {
      driverTbl.glGetShaderInfoLog = missing_glGetShaderInfoLog;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetShaderInfoLog == loader_glGetShaderInfoLog) {
      rCtx->dsp.emuTbl.glGetShaderInfoLog = driverTbl.glGetShaderInfoLog;
   }
   driverTbl.glGetShaderInfoLog(shader, bufSize, length, infoLog);
}

static void REGAL_CALL missing_glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)
{
   UNUSED_PARAMETER(shader);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(source);
   Warning( "Called missing function glGetShaderSource" );
}

static void REGAL_CALL loader_glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetShaderSource, "glGetShaderSource");
   if ( !driverTbl.glGetShaderSource ) {
      driverTbl.glGetShaderSource = missing_glGetShaderSource;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetShaderSource == loader_glGetShaderSource) {
      rCtx->dsp.emuTbl.glGetShaderSource = driverTbl.glGetShaderSource;
   }
   driverTbl.glGetShaderSource(shader, bufSize, length, source);
}

static GLint REGAL_CALL missing_glGetUniformLocation(GLuint program, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetUniformLocation" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetUniformLocation(GLuint program, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformLocation, "glGetUniformLocation");
   if ( !driverTbl.glGetUniformLocation ) {
      driverTbl.glGetUniformLocation = missing_glGetUniformLocation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformLocation == loader_glGetUniformLocation) {
      rCtx->dsp.emuTbl.glGetUniformLocation = driverTbl.glGetUniformLocation;
   }
   return driverTbl.glGetUniformLocation(program, name);
}

static void REGAL_CALL missing_glGetUniformfv(GLuint program, GLint location, GLfloat *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetUniformfv" );
}

static void REGAL_CALL loader_glGetUniformfv(GLuint program, GLint location, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformfv, "glGetUniformfv");
   if ( !driverTbl.glGetUniformfv ) {
      driverTbl.glGetUniformfv = missing_glGetUniformfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformfv == loader_glGetUniformfv) {
      rCtx->dsp.emuTbl.glGetUniformfv = driverTbl.glGetUniformfv;
   }
   driverTbl.glGetUniformfv(program, location, params);
}

static void REGAL_CALL missing_glGetUniformiv(GLuint program, GLint location, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetUniformiv" );
}

static void REGAL_CALL loader_glGetUniformiv(GLuint program, GLint location, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformiv, "glGetUniformiv");
   if ( !driverTbl.glGetUniformiv ) {
      driverTbl.glGetUniformiv = missing_glGetUniformiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformiv == loader_glGetUniformiv) {
      rCtx->dsp.emuTbl.glGetUniformiv = driverTbl.glGetUniformiv;
   }
   driverTbl.glGetUniformiv(program, location, params);
}

static void REGAL_CALL missing_glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribdv" );
}

static void REGAL_CALL loader_glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribdv, "glGetVertexAttribdv");
   if ( !driverTbl.glGetVertexAttribdv ) {
      driverTbl.glGetVertexAttribdv = missing_glGetVertexAttribdv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribdv == loader_glGetVertexAttribdv) {
      rCtx->dsp.emuTbl.glGetVertexAttribdv = driverTbl.glGetVertexAttribdv;
   }
   driverTbl.glGetVertexAttribdv(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribfv" );
}

static void REGAL_CALL loader_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribfv, "glGetVertexAttribfv");
   if ( !driverTbl.glGetVertexAttribfv ) {
      driverTbl.glGetVertexAttribfv = missing_glGetVertexAttribfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribfv == loader_glGetVertexAttribfv) {
      rCtx->dsp.emuTbl.glGetVertexAttribfv = driverTbl.glGetVertexAttribfv;
   }
   driverTbl.glGetVertexAttribfv(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribiv" );
}

static void REGAL_CALL loader_glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribiv, "glGetVertexAttribiv");
   if ( !driverTbl.glGetVertexAttribiv ) {
      driverTbl.glGetVertexAttribiv = missing_glGetVertexAttribiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribiv == loader_glGetVertexAttribiv) {
      rCtx->dsp.emuTbl.glGetVertexAttribiv = driverTbl.glGetVertexAttribiv;
   }
   driverTbl.glGetVertexAttribiv(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glGetVertexAttribPointerv" );
}

static void REGAL_CALL loader_glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribPointerv, "glGetVertexAttribPointerv");
   if ( !driverTbl.glGetVertexAttribPointerv ) {
      driverTbl.glGetVertexAttribPointerv = missing_glGetVertexAttribPointerv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribPointerv == loader_glGetVertexAttribPointerv) {
      rCtx->dsp.emuTbl.glGetVertexAttribPointerv = driverTbl.glGetVertexAttribPointerv;
   }
   driverTbl.glGetVertexAttribPointerv(index, pname, pointer);
}

static GLboolean REGAL_CALL missing_glIsProgram(GLuint program)
{
   UNUSED_PARAMETER(program);
   Warning( "Called missing function glIsProgram" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsProgram(GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsProgram, "glIsProgram");
   if ( !driverTbl.glIsProgram ) {
      driverTbl.glIsProgram = missing_glIsProgram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsProgram == loader_glIsProgram) {
      rCtx->dsp.emuTbl.glIsProgram = driverTbl.glIsProgram;
   }
   return driverTbl.glIsProgram(program);
}

static GLboolean REGAL_CALL missing_glIsShader(GLuint shader)
{
   UNUSED_PARAMETER(shader);
   Warning( "Called missing function glIsShader" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsShader(GLuint shader)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsShader, "glIsShader");
   if ( !driverTbl.glIsShader ) {
      driverTbl.glIsShader = missing_glIsShader;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsShader == loader_glIsShader) {
      rCtx->dsp.emuTbl.glIsShader = driverTbl.glIsShader;
   }
   return driverTbl.glIsShader(shader);
}

static void REGAL_CALL missing_glLinkProgram(GLuint program)
{
   UNUSED_PARAMETER(program);
   Warning( "Called missing function glLinkProgram" );
}

static void REGAL_CALL loader_glLinkProgram(GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLinkProgram, "glLinkProgram");
   if ( !driverTbl.glLinkProgram ) {
      driverTbl.glLinkProgram = missing_glLinkProgram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLinkProgram == loader_glLinkProgram) {
      rCtx->dsp.emuTbl.glLinkProgram = driverTbl.glLinkProgram;
   }
   driverTbl.glLinkProgram(program);
}

static void REGAL_CALL missing_glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length)
{
   UNUSED_PARAMETER(shader);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(string);
   UNUSED_PARAMETER(length);
   Warning( "Called missing function glShaderSource" );
}

static void REGAL_CALL loader_glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glShaderSource, "glShaderSource");
   if ( !driverTbl.glShaderSource ) {
      driverTbl.glShaderSource = missing_glShaderSource;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glShaderSource == loader_glShaderSource) {
      rCtx->dsp.emuTbl.glShaderSource = driverTbl.glShaderSource;
   }
   driverTbl.glShaderSource(shader, count, string, length);
}

static void REGAL_CALL missing_glUseProgram(GLuint program)
{
   UNUSED_PARAMETER(program);
   Warning( "Called missing function glUseProgram" );
}

static void REGAL_CALL loader_glUseProgram(GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUseProgram, "glUseProgram");
   if ( !driverTbl.glUseProgram ) {
      driverTbl.glUseProgram = missing_glUseProgram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUseProgram == loader_glUseProgram) {
      rCtx->dsp.emuTbl.glUseProgram = driverTbl.glUseProgram;
   }
   driverTbl.glUseProgram(program);
}

static void REGAL_CALL missing_glUniform1f(GLint location, GLfloat v0)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "Called missing function glUniform1f" );
}

static void REGAL_CALL loader_glUniform1f(GLint location, GLfloat v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1f, "glUniform1f");
   if ( !driverTbl.glUniform1f ) {
      driverTbl.glUniform1f = missing_glUniform1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1f == loader_glUniform1f) {
      rCtx->dsp.emuTbl.glUniform1f = driverTbl.glUniform1f;
   }
   driverTbl.glUniform1f(location, v0);
}

static void REGAL_CALL missing_glUniform2f(GLint location, GLfloat v0, GLfloat v1)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "Called missing function glUniform2f" );
}

static void REGAL_CALL loader_glUniform2f(GLint location, GLfloat v0, GLfloat v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2f, "glUniform2f");
   if ( !driverTbl.glUniform2f ) {
      driverTbl.glUniform2f = missing_glUniform2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2f == loader_glUniform2f) {
      rCtx->dsp.emuTbl.glUniform2f = driverTbl.glUniform2f;
   }
   driverTbl.glUniform2f(location, v0, v1);
}

static void REGAL_CALL missing_glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glUniform3f" );
}

static void REGAL_CALL loader_glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3f, "glUniform3f");
   if ( !driverTbl.glUniform3f ) {
      driverTbl.glUniform3f = missing_glUniform3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3f == loader_glUniform3f) {
      rCtx->dsp.emuTbl.glUniform3f = driverTbl.glUniform3f;
   }
   driverTbl.glUniform3f(location, v0, v1, v2);
}

static void REGAL_CALL missing_glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "Called missing function glUniform4f" );
}

static void REGAL_CALL loader_glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4f, "glUniform4f");
   if ( !driverTbl.glUniform4f ) {
      driverTbl.glUniform4f = missing_glUniform4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4f == loader_glUniform4f) {
      rCtx->dsp.emuTbl.glUniform4f = driverTbl.glUniform4f;
   }
   driverTbl.glUniform4f(location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glUniform1i(GLint location, GLint v0)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "Called missing function glUniform1i" );
}

static void REGAL_CALL loader_glUniform1i(GLint location, GLint v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1i, "glUniform1i");
   if ( !driverTbl.glUniform1i ) {
      driverTbl.glUniform1i = missing_glUniform1i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1i == loader_glUniform1i) {
      rCtx->dsp.emuTbl.glUniform1i = driverTbl.glUniform1i;
   }
   driverTbl.glUniform1i(location, v0);
}

static void REGAL_CALL missing_glUniform2i(GLint location, GLint v0, GLint v1)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "Called missing function glUniform2i" );
}

static void REGAL_CALL loader_glUniform2i(GLint location, GLint v0, GLint v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2i, "glUniform2i");
   if ( !driverTbl.glUniform2i ) {
      driverTbl.glUniform2i = missing_glUniform2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2i == loader_glUniform2i) {
      rCtx->dsp.emuTbl.glUniform2i = driverTbl.glUniform2i;
   }
   driverTbl.glUniform2i(location, v0, v1);
}

static void REGAL_CALL missing_glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glUniform3i" );
}

static void REGAL_CALL loader_glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3i, "glUniform3i");
   if ( !driverTbl.glUniform3i ) {
      driverTbl.glUniform3i = missing_glUniform3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3i == loader_glUniform3i) {
      rCtx->dsp.emuTbl.glUniform3i = driverTbl.glUniform3i;
   }
   driverTbl.glUniform3i(location, v0, v1, v2);
}

static void REGAL_CALL missing_glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "Called missing function glUniform4i" );
}

static void REGAL_CALL loader_glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4i, "glUniform4i");
   if ( !driverTbl.glUniform4i ) {
      driverTbl.glUniform4i = missing_glUniform4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4i == loader_glUniform4i) {
      rCtx->dsp.emuTbl.glUniform4i = driverTbl.glUniform4i;
   }
   driverTbl.glUniform4i(location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glUniform1fv(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform1fv" );
}

static void REGAL_CALL loader_glUniform1fv(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1fv, "glUniform1fv");
   if ( !driverTbl.glUniform1fv ) {
      driverTbl.glUniform1fv = missing_glUniform1fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1fv == loader_glUniform1fv) {
      rCtx->dsp.emuTbl.glUniform1fv = driverTbl.glUniform1fv;
   }
   driverTbl.glUniform1fv(location, count, value);
}

static void REGAL_CALL missing_glUniform2fv(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform2fv" );
}

static void REGAL_CALL loader_glUniform2fv(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2fv, "glUniform2fv");
   if ( !driverTbl.glUniform2fv ) {
      driverTbl.glUniform2fv = missing_glUniform2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2fv == loader_glUniform2fv) {
      rCtx->dsp.emuTbl.glUniform2fv = driverTbl.glUniform2fv;
   }
   driverTbl.glUniform2fv(location, count, value);
}

static void REGAL_CALL missing_glUniform3fv(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform3fv" );
}

static void REGAL_CALL loader_glUniform3fv(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3fv, "glUniform3fv");
   if ( !driverTbl.glUniform3fv ) {
      driverTbl.glUniform3fv = missing_glUniform3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3fv == loader_glUniform3fv) {
      rCtx->dsp.emuTbl.glUniform3fv = driverTbl.glUniform3fv;
   }
   driverTbl.glUniform3fv(location, count, value);
}

static void REGAL_CALL missing_glUniform4fv(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform4fv" );
}

static void REGAL_CALL loader_glUniform4fv(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4fv, "glUniform4fv");
   if ( !driverTbl.glUniform4fv ) {
      driverTbl.glUniform4fv = missing_glUniform4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4fv == loader_glUniform4fv) {
      rCtx->dsp.emuTbl.glUniform4fv = driverTbl.glUniform4fv;
   }
   driverTbl.glUniform4fv(location, count, value);
}

static void REGAL_CALL missing_glUniform1iv(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform1iv" );
}

static void REGAL_CALL loader_glUniform1iv(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1iv, "glUniform1iv");
   if ( !driverTbl.glUniform1iv ) {
      driverTbl.glUniform1iv = missing_glUniform1iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1iv == loader_glUniform1iv) {
      rCtx->dsp.emuTbl.glUniform1iv = driverTbl.glUniform1iv;
   }
   driverTbl.glUniform1iv(location, count, value);
}

static void REGAL_CALL missing_glUniform2iv(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform2iv" );
}

static void REGAL_CALL loader_glUniform2iv(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2iv, "glUniform2iv");
   if ( !driverTbl.glUniform2iv ) {
      driverTbl.glUniform2iv = missing_glUniform2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2iv == loader_glUniform2iv) {
      rCtx->dsp.emuTbl.glUniform2iv = driverTbl.glUniform2iv;
   }
   driverTbl.glUniform2iv(location, count, value);
}

static void REGAL_CALL missing_glUniform3iv(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform3iv" );
}

static void REGAL_CALL loader_glUniform3iv(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3iv, "glUniform3iv");
   if ( !driverTbl.glUniform3iv ) {
      driverTbl.glUniform3iv = missing_glUniform3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3iv == loader_glUniform3iv) {
      rCtx->dsp.emuTbl.glUniform3iv = driverTbl.glUniform3iv;
   }
   driverTbl.glUniform3iv(location, count, value);
}

static void REGAL_CALL missing_glUniform4iv(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform4iv" );
}

static void REGAL_CALL loader_glUniform4iv(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4iv, "glUniform4iv");
   if ( !driverTbl.glUniform4iv ) {
      driverTbl.glUniform4iv = missing_glUniform4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4iv == loader_glUniform4iv) {
      rCtx->dsp.emuTbl.glUniform4iv = driverTbl.glUniform4iv;
   }
   driverTbl.glUniform4iv(location, count, value);
}

static void REGAL_CALL missing_glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix2fv" );
}

static void REGAL_CALL loader_glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix2fv, "glUniformMatrix2fv");
   if ( !driverTbl.glUniformMatrix2fv ) {
      driverTbl.glUniformMatrix2fv = missing_glUniformMatrix2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix2fv == loader_glUniformMatrix2fv) {
      rCtx->dsp.emuTbl.glUniformMatrix2fv = driverTbl.glUniformMatrix2fv;
   }
   driverTbl.glUniformMatrix2fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix3fv" );
}

static void REGAL_CALL loader_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix3fv, "glUniformMatrix3fv");
   if ( !driverTbl.glUniformMatrix3fv ) {
      driverTbl.glUniformMatrix3fv = missing_glUniformMatrix3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix3fv == loader_glUniformMatrix3fv) {
      rCtx->dsp.emuTbl.glUniformMatrix3fv = driverTbl.glUniformMatrix3fv;
   }
   driverTbl.glUniformMatrix3fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix4fv" );
}

static void REGAL_CALL loader_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix4fv, "glUniformMatrix4fv");
   if ( !driverTbl.glUniformMatrix4fv ) {
      driverTbl.glUniformMatrix4fv = missing_glUniformMatrix4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix4fv == loader_glUniformMatrix4fv) {
      rCtx->dsp.emuTbl.glUniformMatrix4fv = driverTbl.glUniformMatrix4fv;
   }
   driverTbl.glUniformMatrix4fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glValidateProgram(GLuint program)
{
   UNUSED_PARAMETER(program);
   Warning( "Called missing function glValidateProgram" );
}

static void REGAL_CALL loader_glValidateProgram(GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glValidateProgram, "glValidateProgram");
   if ( !driverTbl.glValidateProgram ) {
      driverTbl.glValidateProgram = missing_glValidateProgram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glValidateProgram == loader_glValidateProgram) {
      rCtx->dsp.emuTbl.glValidateProgram = driverTbl.glValidateProgram;
   }
   driverTbl.glValidateProgram(program);
}

static void REGAL_CALL missing_glVertexAttrib1d(GLuint index, GLdouble x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttrib1d" );
}

static void REGAL_CALL loader_glVertexAttrib1d(GLuint index, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1d, "glVertexAttrib1d");
   if ( !driverTbl.glVertexAttrib1d ) {
      driverTbl.glVertexAttrib1d = missing_glVertexAttrib1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1d == loader_glVertexAttrib1d) {
      rCtx->dsp.emuTbl.glVertexAttrib1d = driverTbl.glVertexAttrib1d;
   }
   driverTbl.glVertexAttrib1d(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib1dv" );
}

static void REGAL_CALL loader_glVertexAttrib1dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1dv, "glVertexAttrib1dv");
   if ( !driverTbl.glVertexAttrib1dv ) {
      driverTbl.glVertexAttrib1dv = missing_glVertexAttrib1dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1dv == loader_glVertexAttrib1dv) {
      rCtx->dsp.emuTbl.glVertexAttrib1dv = driverTbl.glVertexAttrib1dv;
   }
   driverTbl.glVertexAttrib1dv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib1f(GLuint index, GLfloat x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttrib1f" );
}

static void REGAL_CALL loader_glVertexAttrib1f(GLuint index, GLfloat x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1f, "glVertexAttrib1f");
   if ( !driverTbl.glVertexAttrib1f ) {
      driverTbl.glVertexAttrib1f = missing_glVertexAttrib1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1f == loader_glVertexAttrib1f) {
      rCtx->dsp.emuTbl.glVertexAttrib1f = driverTbl.glVertexAttrib1f;
   }
   driverTbl.glVertexAttrib1f(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1fv(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib1fv" );
}

static void REGAL_CALL loader_glVertexAttrib1fv(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1fv, "glVertexAttrib1fv");
   if ( !driverTbl.glVertexAttrib1fv ) {
      driverTbl.glVertexAttrib1fv = missing_glVertexAttrib1fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1fv == loader_glVertexAttrib1fv) {
      rCtx->dsp.emuTbl.glVertexAttrib1fv = driverTbl.glVertexAttrib1fv;
   }
   driverTbl.glVertexAttrib1fv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib1s(GLuint index, GLshort x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttrib1s" );
}

static void REGAL_CALL loader_glVertexAttrib1s(GLuint index, GLshort x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1s, "glVertexAttrib1s");
   if ( !driverTbl.glVertexAttrib1s ) {
      driverTbl.glVertexAttrib1s = missing_glVertexAttrib1s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1s == loader_glVertexAttrib1s) {
      rCtx->dsp.emuTbl.glVertexAttrib1s = driverTbl.glVertexAttrib1s;
   }
   driverTbl.glVertexAttrib1s(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1sv(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib1sv" );
}

static void REGAL_CALL loader_glVertexAttrib1sv(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1sv, "glVertexAttrib1sv");
   if ( !driverTbl.glVertexAttrib1sv ) {
      driverTbl.glVertexAttrib1sv = missing_glVertexAttrib1sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1sv == loader_glVertexAttrib1sv) {
      rCtx->dsp.emuTbl.glVertexAttrib1sv = driverTbl.glVertexAttrib1sv;
   }
   driverTbl.glVertexAttrib1sv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttrib2d" );
}

static void REGAL_CALL loader_glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2d, "glVertexAttrib2d");
   if ( !driverTbl.glVertexAttrib2d ) {
      driverTbl.glVertexAttrib2d = missing_glVertexAttrib2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2d == loader_glVertexAttrib2d) {
      rCtx->dsp.emuTbl.glVertexAttrib2d = driverTbl.glVertexAttrib2d;
   }
   driverTbl.glVertexAttrib2d(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib2dv" );
}

static void REGAL_CALL loader_glVertexAttrib2dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2dv, "glVertexAttrib2dv");
   if ( !driverTbl.glVertexAttrib2dv ) {
      driverTbl.glVertexAttrib2dv = missing_glVertexAttrib2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2dv == loader_glVertexAttrib2dv) {
      rCtx->dsp.emuTbl.glVertexAttrib2dv = driverTbl.glVertexAttrib2dv;
   }
   driverTbl.glVertexAttrib2dv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttrib2f" );
}

static void REGAL_CALL loader_glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2f, "glVertexAttrib2f");
   if ( !driverTbl.glVertexAttrib2f ) {
      driverTbl.glVertexAttrib2f = missing_glVertexAttrib2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2f == loader_glVertexAttrib2f) {
      rCtx->dsp.emuTbl.glVertexAttrib2f = driverTbl.glVertexAttrib2f;
   }
   driverTbl.glVertexAttrib2f(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2fv(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib2fv" );
}

static void REGAL_CALL loader_glVertexAttrib2fv(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2fv, "glVertexAttrib2fv");
   if ( !driverTbl.glVertexAttrib2fv ) {
      driverTbl.glVertexAttrib2fv = missing_glVertexAttrib2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2fv == loader_glVertexAttrib2fv) {
      rCtx->dsp.emuTbl.glVertexAttrib2fv = driverTbl.glVertexAttrib2fv;
   }
   driverTbl.glVertexAttrib2fv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2s(GLuint index, GLshort x, GLshort y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttrib2s" );
}

static void REGAL_CALL loader_glVertexAttrib2s(GLuint index, GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2s, "glVertexAttrib2s");
   if ( !driverTbl.glVertexAttrib2s ) {
      driverTbl.glVertexAttrib2s = missing_glVertexAttrib2s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2s == loader_glVertexAttrib2s) {
      rCtx->dsp.emuTbl.glVertexAttrib2s = driverTbl.glVertexAttrib2s;
   }
   driverTbl.glVertexAttrib2s(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2sv(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib2sv" );
}

static void REGAL_CALL loader_glVertexAttrib2sv(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2sv, "glVertexAttrib2sv");
   if ( !driverTbl.glVertexAttrib2sv ) {
      driverTbl.glVertexAttrib2sv = missing_glVertexAttrib2sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2sv == loader_glVertexAttrib2sv) {
      rCtx->dsp.emuTbl.glVertexAttrib2sv = driverTbl.glVertexAttrib2sv;
   }
   driverTbl.glVertexAttrib2sv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttrib3d" );
}

static void REGAL_CALL loader_glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3d, "glVertexAttrib3d");
   if ( !driverTbl.glVertexAttrib3d ) {
      driverTbl.glVertexAttrib3d = missing_glVertexAttrib3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3d == loader_glVertexAttrib3d) {
      rCtx->dsp.emuTbl.glVertexAttrib3d = driverTbl.glVertexAttrib3d;
   }
   driverTbl.glVertexAttrib3d(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib3dv" );
}

static void REGAL_CALL loader_glVertexAttrib3dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3dv, "glVertexAttrib3dv");
   if ( !driverTbl.glVertexAttrib3dv ) {
      driverTbl.glVertexAttrib3dv = missing_glVertexAttrib3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3dv == loader_glVertexAttrib3dv) {
      rCtx->dsp.emuTbl.glVertexAttrib3dv = driverTbl.glVertexAttrib3dv;
   }
   driverTbl.glVertexAttrib3dv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttrib3f" );
}

static void REGAL_CALL loader_glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3f, "glVertexAttrib3f");
   if ( !driverTbl.glVertexAttrib3f ) {
      driverTbl.glVertexAttrib3f = missing_glVertexAttrib3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3f == loader_glVertexAttrib3f) {
      rCtx->dsp.emuTbl.glVertexAttrib3f = driverTbl.glVertexAttrib3f;
   }
   driverTbl.glVertexAttrib3f(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3fv(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib3fv" );
}

static void REGAL_CALL loader_glVertexAttrib3fv(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3fv, "glVertexAttrib3fv");
   if ( !driverTbl.glVertexAttrib3fv ) {
      driverTbl.glVertexAttrib3fv = missing_glVertexAttrib3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3fv == loader_glVertexAttrib3fv) {
      rCtx->dsp.emuTbl.glVertexAttrib3fv = driverTbl.glVertexAttrib3fv;
   }
   driverTbl.glVertexAttrib3fv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttrib3s" );
}

static void REGAL_CALL loader_glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3s, "glVertexAttrib3s");
   if ( !driverTbl.glVertexAttrib3s ) {
      driverTbl.glVertexAttrib3s = missing_glVertexAttrib3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3s == loader_glVertexAttrib3s) {
      rCtx->dsp.emuTbl.glVertexAttrib3s = driverTbl.glVertexAttrib3s;
   }
   driverTbl.glVertexAttrib3s(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3sv(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib3sv" );
}

static void REGAL_CALL loader_glVertexAttrib3sv(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3sv, "glVertexAttrib3sv");
   if ( !driverTbl.glVertexAttrib3sv ) {
      driverTbl.glVertexAttrib3sv = missing_glVertexAttrib3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3sv == loader_glVertexAttrib3sv) {
      rCtx->dsp.emuTbl.glVertexAttrib3sv = driverTbl.glVertexAttrib3sv;
   }
   driverTbl.glVertexAttrib3sv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4Nbv(GLuint index, const GLbyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4Nbv" );
}

static void REGAL_CALL loader_glVertexAttrib4Nbv(GLuint index, const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4Nbv, "glVertexAttrib4Nbv");
   if ( !driverTbl.glVertexAttrib4Nbv ) {
      driverTbl.glVertexAttrib4Nbv = missing_glVertexAttrib4Nbv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4Nbv == loader_glVertexAttrib4Nbv) {
      rCtx->dsp.emuTbl.glVertexAttrib4Nbv = driverTbl.glVertexAttrib4Nbv;
   }
   driverTbl.glVertexAttrib4Nbv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4Niv(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4Niv" );
}

static void REGAL_CALL loader_glVertexAttrib4Niv(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4Niv, "glVertexAttrib4Niv");
   if ( !driverTbl.glVertexAttrib4Niv ) {
      driverTbl.glVertexAttrib4Niv = missing_glVertexAttrib4Niv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4Niv == loader_glVertexAttrib4Niv) {
      rCtx->dsp.emuTbl.glVertexAttrib4Niv = driverTbl.glVertexAttrib4Niv;
   }
   driverTbl.glVertexAttrib4Niv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4Nsv(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4Nsv" );
}

static void REGAL_CALL loader_glVertexAttrib4Nsv(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4Nsv, "glVertexAttrib4Nsv");
   if ( !driverTbl.glVertexAttrib4Nsv ) {
      driverTbl.glVertexAttrib4Nsv = missing_glVertexAttrib4Nsv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4Nsv == loader_glVertexAttrib4Nsv) {
      rCtx->dsp.emuTbl.glVertexAttrib4Nsv = driverTbl.glVertexAttrib4Nsv;
   }
   driverTbl.glVertexAttrib4Nsv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttrib4Nub" );
}

static void REGAL_CALL loader_glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4Nub, "glVertexAttrib4Nub");
   if ( !driverTbl.glVertexAttrib4Nub ) {
      driverTbl.glVertexAttrib4Nub = missing_glVertexAttrib4Nub;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4Nub == loader_glVertexAttrib4Nub) {
      rCtx->dsp.emuTbl.glVertexAttrib4Nub = driverTbl.glVertexAttrib4Nub;
   }
   driverTbl.glVertexAttrib4Nub(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4Nubv(GLuint index, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4Nubv" );
}

static void REGAL_CALL loader_glVertexAttrib4Nubv(GLuint index, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4Nubv, "glVertexAttrib4Nubv");
   if ( !driverTbl.glVertexAttrib4Nubv ) {
      driverTbl.glVertexAttrib4Nubv = missing_glVertexAttrib4Nubv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4Nubv == loader_glVertexAttrib4Nubv) {
      rCtx->dsp.emuTbl.glVertexAttrib4Nubv = driverTbl.glVertexAttrib4Nubv;
   }
   driverTbl.glVertexAttrib4Nubv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4Nuiv(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4Nuiv" );
}

static void REGAL_CALL loader_glVertexAttrib4Nuiv(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4Nuiv, "glVertexAttrib4Nuiv");
   if ( !driverTbl.glVertexAttrib4Nuiv ) {
      driverTbl.glVertexAttrib4Nuiv = missing_glVertexAttrib4Nuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4Nuiv == loader_glVertexAttrib4Nuiv) {
      rCtx->dsp.emuTbl.glVertexAttrib4Nuiv = driverTbl.glVertexAttrib4Nuiv;
   }
   driverTbl.glVertexAttrib4Nuiv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4Nusv(GLuint index, const GLushort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4Nusv" );
}

static void REGAL_CALL loader_glVertexAttrib4Nusv(GLuint index, const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4Nusv, "glVertexAttrib4Nusv");
   if ( !driverTbl.glVertexAttrib4Nusv ) {
      driverTbl.glVertexAttrib4Nusv = missing_glVertexAttrib4Nusv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4Nusv == loader_glVertexAttrib4Nusv) {
      rCtx->dsp.emuTbl.glVertexAttrib4Nusv = driverTbl.glVertexAttrib4Nusv;
   }
   driverTbl.glVertexAttrib4Nusv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4bv(GLuint index, const GLbyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4bv" );
}

static void REGAL_CALL loader_glVertexAttrib4bv(GLuint index, const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4bv, "glVertexAttrib4bv");
   if ( !driverTbl.glVertexAttrib4bv ) {
      driverTbl.glVertexAttrib4bv = missing_glVertexAttrib4bv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4bv == loader_glVertexAttrib4bv) {
      rCtx->dsp.emuTbl.glVertexAttrib4bv = driverTbl.glVertexAttrib4bv;
   }
   driverTbl.glVertexAttrib4bv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttrib4d" );
}

static void REGAL_CALL loader_glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4d, "glVertexAttrib4d");
   if ( !driverTbl.glVertexAttrib4d ) {
      driverTbl.glVertexAttrib4d = missing_glVertexAttrib4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4d == loader_glVertexAttrib4d) {
      rCtx->dsp.emuTbl.glVertexAttrib4d = driverTbl.glVertexAttrib4d;
   }
   driverTbl.glVertexAttrib4d(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4dv" );
}

static void REGAL_CALL loader_glVertexAttrib4dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4dv, "glVertexAttrib4dv");
   if ( !driverTbl.glVertexAttrib4dv ) {
      driverTbl.glVertexAttrib4dv = missing_glVertexAttrib4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4dv == loader_glVertexAttrib4dv) {
      rCtx->dsp.emuTbl.glVertexAttrib4dv = driverTbl.glVertexAttrib4dv;
   }
   driverTbl.glVertexAttrib4dv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttrib4f" );
}

static void REGAL_CALL loader_glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4f, "glVertexAttrib4f");
   if ( !driverTbl.glVertexAttrib4f ) {
      driverTbl.glVertexAttrib4f = missing_glVertexAttrib4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4f == loader_glVertexAttrib4f) {
      rCtx->dsp.emuTbl.glVertexAttrib4f = driverTbl.glVertexAttrib4f;
   }
   driverTbl.glVertexAttrib4f(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4fv(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4fv" );
}

static void REGAL_CALL loader_glVertexAttrib4fv(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4fv, "glVertexAttrib4fv");
   if ( !driverTbl.glVertexAttrib4fv ) {
      driverTbl.glVertexAttrib4fv = missing_glVertexAttrib4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4fv == loader_glVertexAttrib4fv) {
      rCtx->dsp.emuTbl.glVertexAttrib4fv = driverTbl.glVertexAttrib4fv;
   }
   driverTbl.glVertexAttrib4fv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4iv(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4iv" );
}

static void REGAL_CALL loader_glVertexAttrib4iv(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4iv, "glVertexAttrib4iv");
   if ( !driverTbl.glVertexAttrib4iv ) {
      driverTbl.glVertexAttrib4iv = missing_glVertexAttrib4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4iv == loader_glVertexAttrib4iv) {
      rCtx->dsp.emuTbl.glVertexAttrib4iv = driverTbl.glVertexAttrib4iv;
   }
   driverTbl.glVertexAttrib4iv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttrib4s" );
}

static void REGAL_CALL loader_glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4s, "glVertexAttrib4s");
   if ( !driverTbl.glVertexAttrib4s ) {
      driverTbl.glVertexAttrib4s = missing_glVertexAttrib4s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4s == loader_glVertexAttrib4s) {
      rCtx->dsp.emuTbl.glVertexAttrib4s = driverTbl.glVertexAttrib4s;
   }
   driverTbl.glVertexAttrib4s(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4sv(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4sv" );
}

static void REGAL_CALL loader_glVertexAttrib4sv(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4sv, "glVertexAttrib4sv");
   if ( !driverTbl.glVertexAttrib4sv ) {
      driverTbl.glVertexAttrib4sv = missing_glVertexAttrib4sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4sv == loader_glVertexAttrib4sv) {
      rCtx->dsp.emuTbl.glVertexAttrib4sv = driverTbl.glVertexAttrib4sv;
   }
   driverTbl.glVertexAttrib4sv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4ubv(GLuint index, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4ubv" );
}

static void REGAL_CALL loader_glVertexAttrib4ubv(GLuint index, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4ubv, "glVertexAttrib4ubv");
   if ( !driverTbl.glVertexAttrib4ubv ) {
      driverTbl.glVertexAttrib4ubv = missing_glVertexAttrib4ubv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4ubv == loader_glVertexAttrib4ubv) {
      rCtx->dsp.emuTbl.glVertexAttrib4ubv = driverTbl.glVertexAttrib4ubv;
   }
   driverTbl.glVertexAttrib4ubv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4uiv(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4uiv" );
}

static void REGAL_CALL loader_glVertexAttrib4uiv(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4uiv, "glVertexAttrib4uiv");
   if ( !driverTbl.glVertexAttrib4uiv ) {
      driverTbl.glVertexAttrib4uiv = missing_glVertexAttrib4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4uiv == loader_glVertexAttrib4uiv) {
      rCtx->dsp.emuTbl.glVertexAttrib4uiv = driverTbl.glVertexAttrib4uiv;
   }
   driverTbl.glVertexAttrib4uiv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4usv(GLuint index, const GLushort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4usv" );
}

static void REGAL_CALL loader_glVertexAttrib4usv(GLuint index, const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4usv, "glVertexAttrib4usv");
   if ( !driverTbl.glVertexAttrib4usv ) {
      driverTbl.glVertexAttrib4usv = missing_glVertexAttrib4usv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4usv == loader_glVertexAttrib4usv) {
      rCtx->dsp.emuTbl.glVertexAttrib4usv = driverTbl.glVertexAttrib4usv;
   }
   driverTbl.glVertexAttrib4usv(index, v);
}

static void REGAL_CALL missing_glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glVertexAttribPointer" );
}

static void REGAL_CALL loader_glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribPointer, "glVertexAttribPointer");
   if ( !driverTbl.glVertexAttribPointer ) {
      driverTbl.glVertexAttribPointer = missing_glVertexAttribPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribPointer == loader_glVertexAttribPointer) {
      rCtx->dsp.emuTbl.glVertexAttribPointer = driverTbl.glVertexAttribPointer;
   }
   driverTbl.glVertexAttribPointer(index, size, type, normalized, stride, pointer);
}

// GL_VERSION_2_1

static void REGAL_CALL missing_glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix2x3fv" );
}

static void REGAL_CALL loader_glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix2x3fv, "glUniformMatrix2x3fv");
   if ( !driverTbl.glUniformMatrix2x3fv ) {
      driverTbl.glUniformMatrix2x3fv = missing_glUniformMatrix2x3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix2x3fv == loader_glUniformMatrix2x3fv) {
      rCtx->dsp.emuTbl.glUniformMatrix2x3fv = driverTbl.glUniformMatrix2x3fv;
   }
   driverTbl.glUniformMatrix2x3fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix3x2fv" );
}

static void REGAL_CALL loader_glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix3x2fv, "glUniformMatrix3x2fv");
   if ( !driverTbl.glUniformMatrix3x2fv ) {
      driverTbl.glUniformMatrix3x2fv = missing_glUniformMatrix3x2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix3x2fv == loader_glUniformMatrix3x2fv) {
      rCtx->dsp.emuTbl.glUniformMatrix3x2fv = driverTbl.glUniformMatrix3x2fv;
   }
   driverTbl.glUniformMatrix3x2fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix2x4fv" );
}

static void REGAL_CALL loader_glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix2x4fv, "glUniformMatrix2x4fv");
   if ( !driverTbl.glUniformMatrix2x4fv ) {
      driverTbl.glUniformMatrix2x4fv = missing_glUniformMatrix2x4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix2x4fv == loader_glUniformMatrix2x4fv) {
      rCtx->dsp.emuTbl.glUniformMatrix2x4fv = driverTbl.glUniformMatrix2x4fv;
   }
   driverTbl.glUniformMatrix2x4fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix4x2fv" );
}

static void REGAL_CALL loader_glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix4x2fv, "glUniformMatrix4x2fv");
   if ( !driverTbl.glUniformMatrix4x2fv ) {
      driverTbl.glUniformMatrix4x2fv = missing_glUniformMatrix4x2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix4x2fv == loader_glUniformMatrix4x2fv) {
      rCtx->dsp.emuTbl.glUniformMatrix4x2fv = driverTbl.glUniformMatrix4x2fv;
   }
   driverTbl.glUniformMatrix4x2fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix3x4fv" );
}

static void REGAL_CALL loader_glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix3x4fv, "glUniformMatrix3x4fv");
   if ( !driverTbl.glUniformMatrix3x4fv ) {
      driverTbl.glUniformMatrix3x4fv = missing_glUniformMatrix3x4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix3x4fv == loader_glUniformMatrix3x4fv) {
      rCtx->dsp.emuTbl.glUniformMatrix3x4fv = driverTbl.glUniformMatrix3x4fv;
   }
   driverTbl.glUniformMatrix3x4fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix4x3fv" );
}

static void REGAL_CALL loader_glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix4x3fv, "glUniformMatrix4x3fv");
   if ( !driverTbl.glUniformMatrix4x3fv ) {
      driverTbl.glUniformMatrix4x3fv = missing_glUniformMatrix4x3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix4x3fv == loader_glUniformMatrix4x3fv) {
      rCtx->dsp.emuTbl.glUniformMatrix4x3fv = driverTbl.glUniformMatrix4x3fv;
   }
   driverTbl.glUniformMatrix4x3fv(location, count, transpose, value);
}

// GL_VERSION_3_0

static void REGAL_CALL missing_glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   Warning( "Called missing function glColorMaski" );
}

static void REGAL_CALL loader_glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorMaski, "glColorMaski");
   if ( !driverTbl.glColorMaski ) {
      driverTbl.glColorMaski = missing_glColorMaski;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorMaski == loader_glColorMaski) {
      rCtx->dsp.emuTbl.glColorMaski = driverTbl.glColorMaski;
   }
   driverTbl.glColorMaski(index, r, g, b, a);
}

static void REGAL_CALL missing_glGetBooleani_v(GLenum target, GLuint index, GLboolean *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetBooleani_v" );
}

static void REGAL_CALL loader_glGetBooleani_v(GLenum target, GLuint index, GLboolean *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetBooleani_v, "glGetBooleani_v");
   if ( !driverTbl.glGetBooleani_v ) {
      driverTbl.glGetBooleani_v = missing_glGetBooleani_v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetBooleani_v == loader_glGetBooleani_v) {
      rCtx->dsp.emuTbl.glGetBooleani_v = driverTbl.glGetBooleani_v;
   }
   driverTbl.glGetBooleani_v(target, index, data);
}

// GL_ARB_uniform_buffer_object

static void REGAL_CALL missing_glGetIntegeri_v(GLenum target, GLuint index, GLint *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetIntegeri_v" );
}

static void REGAL_CALL loader_glGetIntegeri_v(GLenum target, GLuint index, GLint *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetIntegeri_v, "glGetIntegeri_v");
   if ( !driverTbl.glGetIntegeri_v ) {
      driverTbl.glGetIntegeri_v = missing_glGetIntegeri_v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetIntegeri_v == loader_glGetIntegeri_v) {
      rCtx->dsp.emuTbl.glGetIntegeri_v = driverTbl.glGetIntegeri_v;
   }
   driverTbl.glGetIntegeri_v(target, index, data);
}

// GL_VERSION_3_0

static void REGAL_CALL missing_glEnablei(GLenum cap, GLuint index)
{
   UNUSED_PARAMETER(cap);
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glEnablei" );
}

static void REGAL_CALL loader_glEnablei(GLenum cap, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEnablei, "glEnablei");
   if ( !driverTbl.glEnablei ) {
      driverTbl.glEnablei = missing_glEnablei;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEnablei == loader_glEnablei) {
      rCtx->dsp.emuTbl.glEnablei = driverTbl.glEnablei;
   }
   driverTbl.glEnablei(cap, index);
}

static void REGAL_CALL missing_glDisablei(GLenum cap, GLuint index)
{
   UNUSED_PARAMETER(cap);
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glDisablei" );
}

static void REGAL_CALL loader_glDisablei(GLenum cap, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDisablei, "glDisablei");
   if ( !driverTbl.glDisablei ) {
      driverTbl.glDisablei = missing_glDisablei;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDisablei == loader_glDisablei) {
      rCtx->dsp.emuTbl.glDisablei = driverTbl.glDisablei;
   }
   driverTbl.glDisablei(cap, index);
}

static GLboolean REGAL_CALL missing_glIsEnabledi(GLenum target, GLuint index)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glIsEnabledi" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsEnabledi(GLenum target, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsEnabledi, "glIsEnabledi");
   if ( !driverTbl.glIsEnabledi ) {
      driverTbl.glIsEnabledi = missing_glIsEnabledi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsEnabledi == loader_glIsEnabledi) {
      rCtx->dsp.emuTbl.glIsEnabledi = driverTbl.glIsEnabledi;
   }
   return driverTbl.glIsEnabledi(target, index);
}

static void REGAL_CALL missing_glBeginTransformFeedback(GLenum primitiveMode)
{
   UNUSED_PARAMETER(primitiveMode);
   Warning( "Called missing function glBeginTransformFeedback" );
}

static void REGAL_CALL loader_glBeginTransformFeedback(GLenum primitiveMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBeginTransformFeedback, "glBeginTransformFeedback");
   if ( !driverTbl.glBeginTransformFeedback ) {
      driverTbl.glBeginTransformFeedback = missing_glBeginTransformFeedback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBeginTransformFeedback == loader_glBeginTransformFeedback) {
      rCtx->dsp.emuTbl.glBeginTransformFeedback = driverTbl.glBeginTransformFeedback;
   }
   driverTbl.glBeginTransformFeedback(primitiveMode);
}

static void REGAL_CALL missing_glEndTransformFeedback(void)
{
   Warning( "Called missing function glEndTransformFeedback" );
}

static void REGAL_CALL loader_glEndTransformFeedback(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndTransformFeedback, "glEndTransformFeedback");
   if ( !driverTbl.glEndTransformFeedback ) {
      driverTbl.glEndTransformFeedback = missing_glEndTransformFeedback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndTransformFeedback == loader_glEndTransformFeedback) {
      rCtx->dsp.emuTbl.glEndTransformFeedback = driverTbl.glEndTransformFeedback;
   }
   driverTbl.glEndTransformFeedback();
}

// GL_ARB_uniform_buffer_object

static void REGAL_CALL missing_glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   Warning( "Called missing function glBindBufferRange" );
}

static void REGAL_CALL loader_glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindBufferRange, "glBindBufferRange");
   if ( !driverTbl.glBindBufferRange ) {
      driverTbl.glBindBufferRange = missing_glBindBufferRange;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindBufferRange == loader_glBindBufferRange) {
      rCtx->dsp.emuTbl.glBindBufferRange = driverTbl.glBindBufferRange;
   }
   driverTbl.glBindBufferRange(target, index, buffer, offset, size);
}

static void REGAL_CALL missing_glBindBufferBase(GLenum target, GLuint index, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glBindBufferBase" );
}

static void REGAL_CALL loader_glBindBufferBase(GLenum target, GLuint index, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindBufferBase, "glBindBufferBase");
   if ( !driverTbl.glBindBufferBase ) {
      driverTbl.glBindBufferBase = missing_glBindBufferBase;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindBufferBase == loader_glBindBufferBase) {
      rCtx->dsp.emuTbl.glBindBufferBase = driverTbl.glBindBufferBase;
   }
   driverTbl.glBindBufferBase(target, index, buffer);
}

// GL_VERSION_3_0

static void REGAL_CALL missing_glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar **varyings, GLenum bufferMode)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(varyings);
   UNUSED_PARAMETER(bufferMode);
   Warning( "Called missing function glTransformFeedbackVaryings" );
}

static void REGAL_CALL loader_glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar **varyings, GLenum bufferMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTransformFeedbackVaryings, "glTransformFeedbackVaryings");
   if ( !driverTbl.glTransformFeedbackVaryings ) {
      driverTbl.glTransformFeedbackVaryings = missing_glTransformFeedbackVaryings;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTransformFeedbackVaryings == loader_glTransformFeedbackVaryings) {
      rCtx->dsp.emuTbl.glTransformFeedbackVaryings = driverTbl.glTransformFeedbackVaryings;
   }
   driverTbl.glTransformFeedbackVaryings(program, count, varyings, bufferMode);
}

static void REGAL_CALL missing_glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetTransformFeedbackVarying" );
}

static void REGAL_CALL loader_glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTransformFeedbackVarying, "glGetTransformFeedbackVarying");
   if ( !driverTbl.glGetTransformFeedbackVarying ) {
      driverTbl.glGetTransformFeedbackVarying = missing_glGetTransformFeedbackVarying;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTransformFeedbackVarying == loader_glGetTransformFeedbackVarying) {
      rCtx->dsp.emuTbl.glGetTransformFeedbackVarying = driverTbl.glGetTransformFeedbackVarying;
   }
   driverTbl.glGetTransformFeedbackVarying(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL missing_glClampColor(GLenum target, GLenum clamp)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(clamp);
   Warning( "Called missing function glClampColor" );
}

static void REGAL_CALL loader_glClampColor(GLenum target, GLenum clamp)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClampColor, "glClampColor");
   if ( !driverTbl.glClampColor ) {
      driverTbl.glClampColor = missing_glClampColor;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClampColor == loader_glClampColor) {
      rCtx->dsp.emuTbl.glClampColor = driverTbl.glClampColor;
   }
   driverTbl.glClampColor(target, clamp);
}

static void REGAL_CALL missing_glBeginConditionalRender(GLuint id, GLenum mode)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glBeginConditionalRender" );
}

static void REGAL_CALL loader_glBeginConditionalRender(GLuint id, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBeginConditionalRender, "glBeginConditionalRender");
   if ( !driverTbl.glBeginConditionalRender ) {
      driverTbl.glBeginConditionalRender = missing_glBeginConditionalRender;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBeginConditionalRender == loader_glBeginConditionalRender) {
      rCtx->dsp.emuTbl.glBeginConditionalRender = driverTbl.glBeginConditionalRender;
   }
   driverTbl.glBeginConditionalRender(id, mode);
}

static void REGAL_CALL missing_glEndConditionalRender(void)
{
   Warning( "Called missing function glEndConditionalRender" );
}

static void REGAL_CALL loader_glEndConditionalRender(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndConditionalRender, "glEndConditionalRender");
   if ( !driverTbl.glEndConditionalRender ) {
      driverTbl.glEndConditionalRender = missing_glEndConditionalRender;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndConditionalRender == loader_glEndConditionalRender) {
      rCtx->dsp.emuTbl.glEndConditionalRender = driverTbl.glEndConditionalRender;
   }
   driverTbl.glEndConditionalRender();
}

static void REGAL_CALL missing_glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glVertexAttribIPointer" );
}

static void REGAL_CALL loader_glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribIPointer, "glVertexAttribIPointer");
   if ( !driverTbl.glVertexAttribIPointer ) {
      driverTbl.glVertexAttribIPointer = missing_glVertexAttribIPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribIPointer == loader_glVertexAttribIPointer) {
      rCtx->dsp.emuTbl.glVertexAttribIPointer = driverTbl.glVertexAttribIPointer;
   }
   driverTbl.glVertexAttribIPointer(index, size, type, stride, pointer);
}

static void REGAL_CALL missing_glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribIiv" );
}

static void REGAL_CALL loader_glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribIiv, "glGetVertexAttribIiv");
   if ( !driverTbl.glGetVertexAttribIiv ) {
      driverTbl.glGetVertexAttribIiv = missing_glGetVertexAttribIiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribIiv == loader_glGetVertexAttribIiv) {
      rCtx->dsp.emuTbl.glGetVertexAttribIiv = driverTbl.glGetVertexAttribIiv;
   }
   driverTbl.glGetVertexAttribIiv(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribIuiv" );
}

static void REGAL_CALL loader_glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribIuiv, "glGetVertexAttribIuiv");
   if ( !driverTbl.glGetVertexAttribIuiv ) {
      driverTbl.glGetVertexAttribIuiv = missing_glGetVertexAttribIuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribIuiv == loader_glGetVertexAttribIuiv) {
      rCtx->dsp.emuTbl.glGetVertexAttribIuiv = driverTbl.glGetVertexAttribIuiv;
   }
   driverTbl.glGetVertexAttribIuiv(index, pname, params);
}

static void REGAL_CALL missing_glVertexAttribI1i(GLuint index, GLint x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttribI1i" );
}

static void REGAL_CALL loader_glVertexAttribI1i(GLuint index, GLint x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI1i, "glVertexAttribI1i");
   if ( !driverTbl.glVertexAttribI1i ) {
      driverTbl.glVertexAttribI1i = missing_glVertexAttribI1i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI1i == loader_glVertexAttribI1i) {
      rCtx->dsp.emuTbl.glVertexAttribI1i = driverTbl.glVertexAttribI1i;
   }
   driverTbl.glVertexAttribI1i(index, x);
}

static void REGAL_CALL missing_glVertexAttribI2i(GLuint index, GLint x, GLint y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttribI2i" );
}

static void REGAL_CALL loader_glVertexAttribI2i(GLuint index, GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI2i, "glVertexAttribI2i");
   if ( !driverTbl.glVertexAttribI2i ) {
      driverTbl.glVertexAttribI2i = missing_glVertexAttribI2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI2i == loader_glVertexAttribI2i) {
      rCtx->dsp.emuTbl.glVertexAttribI2i = driverTbl.glVertexAttribI2i;
   }
   driverTbl.glVertexAttribI2i(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttribI3i" );
}

static void REGAL_CALL loader_glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI3i, "glVertexAttribI3i");
   if ( !driverTbl.glVertexAttribI3i ) {
      driverTbl.glVertexAttribI3i = missing_glVertexAttribI3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI3i == loader_glVertexAttribI3i) {
      rCtx->dsp.emuTbl.glVertexAttribI3i = driverTbl.glVertexAttribI3i;
   }
   driverTbl.glVertexAttribI3i(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttribI4i" );
}

static void REGAL_CALL loader_glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4i, "glVertexAttribI4i");
   if ( !driverTbl.glVertexAttribI4i ) {
      driverTbl.glVertexAttribI4i = missing_glVertexAttribI4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4i == loader_glVertexAttribI4i) {
      rCtx->dsp.emuTbl.glVertexAttribI4i = driverTbl.glVertexAttribI4i;
   }
   driverTbl.glVertexAttribI4i(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribI1ui(GLuint index, GLuint x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttribI1ui" );
}

static void REGAL_CALL loader_glVertexAttribI1ui(GLuint index, GLuint x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI1ui, "glVertexAttribI1ui");
   if ( !driverTbl.glVertexAttribI1ui ) {
      driverTbl.glVertexAttribI1ui = missing_glVertexAttribI1ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI1ui == loader_glVertexAttribI1ui) {
      rCtx->dsp.emuTbl.glVertexAttribI1ui = driverTbl.glVertexAttribI1ui;
   }
   driverTbl.glVertexAttribI1ui(index, x);
}

static void REGAL_CALL missing_glVertexAttribI2ui(GLuint index, GLuint x, GLuint y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttribI2ui" );
}

static void REGAL_CALL loader_glVertexAttribI2ui(GLuint index, GLuint x, GLuint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI2ui, "glVertexAttribI2ui");
   if ( !driverTbl.glVertexAttribI2ui ) {
      driverTbl.glVertexAttribI2ui = missing_glVertexAttribI2ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI2ui == loader_glVertexAttribI2ui) {
      rCtx->dsp.emuTbl.glVertexAttribI2ui = driverTbl.glVertexAttribI2ui;
   }
   driverTbl.glVertexAttribI2ui(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttribI3ui" );
}

static void REGAL_CALL loader_glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI3ui, "glVertexAttribI3ui");
   if ( !driverTbl.glVertexAttribI3ui ) {
      driverTbl.glVertexAttribI3ui = missing_glVertexAttribI3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI3ui == loader_glVertexAttribI3ui) {
      rCtx->dsp.emuTbl.glVertexAttribI3ui = driverTbl.glVertexAttribI3ui;
   }
   driverTbl.glVertexAttribI3ui(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttribI4ui" );
}

static void REGAL_CALL loader_glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4ui, "glVertexAttribI4ui");
   if ( !driverTbl.glVertexAttribI4ui ) {
      driverTbl.glVertexAttribI4ui = missing_glVertexAttribI4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4ui == loader_glVertexAttribI4ui) {
      rCtx->dsp.emuTbl.glVertexAttribI4ui = driverTbl.glVertexAttribI4ui;
   }
   driverTbl.glVertexAttribI4ui(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribI1iv(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI1iv" );
}

static void REGAL_CALL loader_glVertexAttribI1iv(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI1iv, "glVertexAttribI1iv");
   if ( !driverTbl.glVertexAttribI1iv ) {
      driverTbl.glVertexAttribI1iv = missing_glVertexAttribI1iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI1iv == loader_glVertexAttribI1iv) {
      rCtx->dsp.emuTbl.glVertexAttribI1iv = driverTbl.glVertexAttribI1iv;
   }
   driverTbl.glVertexAttribI1iv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI2iv(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI2iv" );
}

static void REGAL_CALL loader_glVertexAttribI2iv(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI2iv, "glVertexAttribI2iv");
   if ( !driverTbl.glVertexAttribI2iv ) {
      driverTbl.glVertexAttribI2iv = missing_glVertexAttribI2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI2iv == loader_glVertexAttribI2iv) {
      rCtx->dsp.emuTbl.glVertexAttribI2iv = driverTbl.glVertexAttribI2iv;
   }
   driverTbl.glVertexAttribI2iv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI3iv(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI3iv" );
}

static void REGAL_CALL loader_glVertexAttribI3iv(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI3iv, "glVertexAttribI3iv");
   if ( !driverTbl.glVertexAttribI3iv ) {
      driverTbl.glVertexAttribI3iv = missing_glVertexAttribI3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI3iv == loader_glVertexAttribI3iv) {
      rCtx->dsp.emuTbl.glVertexAttribI3iv = driverTbl.glVertexAttribI3iv;
   }
   driverTbl.glVertexAttribI3iv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4iv(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI4iv" );
}

static void REGAL_CALL loader_glVertexAttribI4iv(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4iv, "glVertexAttribI4iv");
   if ( !driverTbl.glVertexAttribI4iv ) {
      driverTbl.glVertexAttribI4iv = missing_glVertexAttribI4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4iv == loader_glVertexAttribI4iv) {
      rCtx->dsp.emuTbl.glVertexAttribI4iv = driverTbl.glVertexAttribI4iv;
   }
   driverTbl.glVertexAttribI4iv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI1uiv(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI1uiv" );
}

static void REGAL_CALL loader_glVertexAttribI1uiv(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI1uiv, "glVertexAttribI1uiv");
   if ( !driverTbl.glVertexAttribI1uiv ) {
      driverTbl.glVertexAttribI1uiv = missing_glVertexAttribI1uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI1uiv == loader_glVertexAttribI1uiv) {
      rCtx->dsp.emuTbl.glVertexAttribI1uiv = driverTbl.glVertexAttribI1uiv;
   }
   driverTbl.glVertexAttribI1uiv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI2uiv(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI2uiv" );
}

static void REGAL_CALL loader_glVertexAttribI2uiv(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI2uiv, "glVertexAttribI2uiv");
   if ( !driverTbl.glVertexAttribI2uiv ) {
      driverTbl.glVertexAttribI2uiv = missing_glVertexAttribI2uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI2uiv == loader_glVertexAttribI2uiv) {
      rCtx->dsp.emuTbl.glVertexAttribI2uiv = driverTbl.glVertexAttribI2uiv;
   }
   driverTbl.glVertexAttribI2uiv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI3uiv(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI3uiv" );
}

static void REGAL_CALL loader_glVertexAttribI3uiv(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI3uiv, "glVertexAttribI3uiv");
   if ( !driverTbl.glVertexAttribI3uiv ) {
      driverTbl.glVertexAttribI3uiv = missing_glVertexAttribI3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI3uiv == loader_glVertexAttribI3uiv) {
      rCtx->dsp.emuTbl.glVertexAttribI3uiv = driverTbl.glVertexAttribI3uiv;
   }
   driverTbl.glVertexAttribI3uiv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4uiv(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI4uiv" );
}

static void REGAL_CALL loader_glVertexAttribI4uiv(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4uiv, "glVertexAttribI4uiv");
   if ( !driverTbl.glVertexAttribI4uiv ) {
      driverTbl.glVertexAttribI4uiv = missing_glVertexAttribI4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4uiv == loader_glVertexAttribI4uiv) {
      rCtx->dsp.emuTbl.glVertexAttribI4uiv = driverTbl.glVertexAttribI4uiv;
   }
   driverTbl.glVertexAttribI4uiv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4bv(GLuint index, const GLbyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI4bv" );
}

static void REGAL_CALL loader_glVertexAttribI4bv(GLuint index, const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4bv, "glVertexAttribI4bv");
   if ( !driverTbl.glVertexAttribI4bv ) {
      driverTbl.glVertexAttribI4bv = missing_glVertexAttribI4bv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4bv == loader_glVertexAttribI4bv) {
      rCtx->dsp.emuTbl.glVertexAttribI4bv = driverTbl.glVertexAttribI4bv;
   }
   driverTbl.glVertexAttribI4bv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4sv(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI4sv" );
}

static void REGAL_CALL loader_glVertexAttribI4sv(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4sv, "glVertexAttribI4sv");
   if ( !driverTbl.glVertexAttribI4sv ) {
      driverTbl.glVertexAttribI4sv = missing_glVertexAttribI4sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4sv == loader_glVertexAttribI4sv) {
      rCtx->dsp.emuTbl.glVertexAttribI4sv = driverTbl.glVertexAttribI4sv;
   }
   driverTbl.glVertexAttribI4sv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4ubv(GLuint index, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI4ubv" );
}

static void REGAL_CALL loader_glVertexAttribI4ubv(GLuint index, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4ubv, "glVertexAttribI4ubv");
   if ( !driverTbl.glVertexAttribI4ubv ) {
      driverTbl.glVertexAttribI4ubv = missing_glVertexAttribI4ubv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4ubv == loader_glVertexAttribI4ubv) {
      rCtx->dsp.emuTbl.glVertexAttribI4ubv = driverTbl.glVertexAttribI4ubv;
   }
   driverTbl.glVertexAttribI4ubv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4usv(GLuint index, const GLushort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI4usv" );
}

static void REGAL_CALL loader_glVertexAttribI4usv(GLuint index, const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4usv, "glVertexAttribI4usv");
   if ( !driverTbl.glVertexAttribI4usv ) {
      driverTbl.glVertexAttribI4usv = missing_glVertexAttribI4usv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4usv == loader_glVertexAttribI4usv) {
      rCtx->dsp.emuTbl.glVertexAttribI4usv = driverTbl.glVertexAttribI4usv;
   }
   driverTbl.glVertexAttribI4usv(index, v);
}

static void REGAL_CALL missing_glGetUniformuiv(GLuint program, GLint location, GLuint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetUniformuiv" );
}

static void REGAL_CALL loader_glGetUniformuiv(GLuint program, GLint location, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformuiv, "glGetUniformuiv");
   if ( !driverTbl.glGetUniformuiv ) {
      driverTbl.glGetUniformuiv = missing_glGetUniformuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformuiv == loader_glGetUniformuiv) {
      rCtx->dsp.emuTbl.glGetUniformuiv = driverTbl.glGetUniformuiv;
   }
   driverTbl.glGetUniformuiv(program, location, params);
}

static void REGAL_CALL missing_glBindFragDataLocation(GLuint program, GLuint color, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(color);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glBindFragDataLocation" );
}

static void REGAL_CALL loader_glBindFragDataLocation(GLuint program, GLuint color, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindFragDataLocation, "glBindFragDataLocation");
   if ( !driverTbl.glBindFragDataLocation ) {
      driverTbl.glBindFragDataLocation = missing_glBindFragDataLocation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindFragDataLocation == loader_glBindFragDataLocation) {
      rCtx->dsp.emuTbl.glBindFragDataLocation = driverTbl.glBindFragDataLocation;
   }
   driverTbl.glBindFragDataLocation(program, color, name);
}

static GLint REGAL_CALL missing_glGetFragDataLocation(GLuint program, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetFragDataLocation" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetFragDataLocation(GLuint program, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFragDataLocation, "glGetFragDataLocation");
   if ( !driverTbl.glGetFragDataLocation ) {
      driverTbl.glGetFragDataLocation = missing_glGetFragDataLocation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFragDataLocation == loader_glGetFragDataLocation) {
      rCtx->dsp.emuTbl.glGetFragDataLocation = driverTbl.glGetFragDataLocation;
   }
   return driverTbl.glGetFragDataLocation(program, name);
}

static void REGAL_CALL missing_glUniform1ui(GLint location, GLuint v0)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "Called missing function glUniform1ui" );
}

static void REGAL_CALL loader_glUniform1ui(GLint location, GLuint v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1ui, "glUniform1ui");
   if ( !driverTbl.glUniform1ui ) {
      driverTbl.glUniform1ui = missing_glUniform1ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1ui == loader_glUniform1ui) {
      rCtx->dsp.emuTbl.glUniform1ui = driverTbl.glUniform1ui;
   }
   driverTbl.glUniform1ui(location, v0);
}

static void REGAL_CALL missing_glUniform2ui(GLint location, GLuint v0, GLuint v1)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "Called missing function glUniform2ui" );
}

static void REGAL_CALL loader_glUniform2ui(GLint location, GLuint v0, GLuint v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2ui, "glUniform2ui");
   if ( !driverTbl.glUniform2ui ) {
      driverTbl.glUniform2ui = missing_glUniform2ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2ui == loader_glUniform2ui) {
      rCtx->dsp.emuTbl.glUniform2ui = driverTbl.glUniform2ui;
   }
   driverTbl.glUniform2ui(location, v0, v1);
}

static void REGAL_CALL missing_glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glUniform3ui" );
}

static void REGAL_CALL loader_glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3ui, "glUniform3ui");
   if ( !driverTbl.glUniform3ui ) {
      driverTbl.glUniform3ui = missing_glUniform3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3ui == loader_glUniform3ui) {
      rCtx->dsp.emuTbl.glUniform3ui = driverTbl.glUniform3ui;
   }
   driverTbl.glUniform3ui(location, v0, v1, v2);
}

static void REGAL_CALL missing_glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "Called missing function glUniform4ui" );
}

static void REGAL_CALL loader_glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4ui, "glUniform4ui");
   if ( !driverTbl.glUniform4ui ) {
      driverTbl.glUniform4ui = missing_glUniform4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4ui == loader_glUniform4ui) {
      rCtx->dsp.emuTbl.glUniform4ui = driverTbl.glUniform4ui;
   }
   driverTbl.glUniform4ui(location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glUniform1uiv(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform1uiv" );
}

static void REGAL_CALL loader_glUniform1uiv(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1uiv, "glUniform1uiv");
   if ( !driverTbl.glUniform1uiv ) {
      driverTbl.glUniform1uiv = missing_glUniform1uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1uiv == loader_glUniform1uiv) {
      rCtx->dsp.emuTbl.glUniform1uiv = driverTbl.glUniform1uiv;
   }
   driverTbl.glUniform1uiv(location, count, value);
}

static void REGAL_CALL missing_glUniform2uiv(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform2uiv" );
}

static void REGAL_CALL loader_glUniform2uiv(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2uiv, "glUniform2uiv");
   if ( !driverTbl.glUniform2uiv ) {
      driverTbl.glUniform2uiv = missing_glUniform2uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2uiv == loader_glUniform2uiv) {
      rCtx->dsp.emuTbl.glUniform2uiv = driverTbl.glUniform2uiv;
   }
   driverTbl.glUniform2uiv(location, count, value);
}

static void REGAL_CALL missing_glUniform3uiv(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform3uiv" );
}

static void REGAL_CALL loader_glUniform3uiv(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3uiv, "glUniform3uiv");
   if ( !driverTbl.glUniform3uiv ) {
      driverTbl.glUniform3uiv = missing_glUniform3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3uiv == loader_glUniform3uiv) {
      rCtx->dsp.emuTbl.glUniform3uiv = driverTbl.glUniform3uiv;
   }
   driverTbl.glUniform3uiv(location, count, value);
}

static void REGAL_CALL missing_glUniform4uiv(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform4uiv" );
}

static void REGAL_CALL loader_glUniform4uiv(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4uiv, "glUniform4uiv");
   if ( !driverTbl.glUniform4uiv ) {
      driverTbl.glUniform4uiv = missing_glUniform4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4uiv == loader_glUniform4uiv) {
      rCtx->dsp.emuTbl.glUniform4uiv = driverTbl.glUniform4uiv;
   }
   driverTbl.glUniform4uiv(location, count, value);
}

static void REGAL_CALL missing_glTexParameterIiv(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glTexParameterIiv" );
}

static void REGAL_CALL loader_glTexParameterIiv(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexParameterIiv, "glTexParameterIiv");
   if ( !driverTbl.glTexParameterIiv ) {
      driverTbl.glTexParameterIiv = missing_glTexParameterIiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexParameterIiv == loader_glTexParameterIiv) {
      rCtx->dsp.emuTbl.glTexParameterIiv = driverTbl.glTexParameterIiv;
   }
   driverTbl.glTexParameterIiv(target, pname, params);
}

static void REGAL_CALL missing_glTexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glTexParameterIuiv" );
}

static void REGAL_CALL loader_glTexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexParameterIuiv, "glTexParameterIuiv");
   if ( !driverTbl.glTexParameterIuiv ) {
      driverTbl.glTexParameterIuiv = missing_glTexParameterIuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexParameterIuiv == loader_glTexParameterIuiv) {
      rCtx->dsp.emuTbl.glTexParameterIuiv = driverTbl.glTexParameterIuiv;
   }
   driverTbl.glTexParameterIuiv(target, pname, params);
}

static void REGAL_CALL missing_glGetTexParameterIiv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTexParameterIiv" );
}

static void REGAL_CALL loader_glGetTexParameterIiv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexParameterIiv, "glGetTexParameterIiv");
   if ( !driverTbl.glGetTexParameterIiv ) {
      driverTbl.glGetTexParameterIiv = missing_glGetTexParameterIiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexParameterIiv == loader_glGetTexParameterIiv) {
      rCtx->dsp.emuTbl.glGetTexParameterIiv = driverTbl.glGetTexParameterIiv;
   }
   driverTbl.glGetTexParameterIiv(target, pname, params);
}

static void REGAL_CALL missing_glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTexParameterIuiv" );
}

static void REGAL_CALL loader_glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexParameterIuiv, "glGetTexParameterIuiv");
   if ( !driverTbl.glGetTexParameterIuiv ) {
      driverTbl.glGetTexParameterIuiv = missing_glGetTexParameterIuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexParameterIuiv == loader_glGetTexParameterIuiv) {
      rCtx->dsp.emuTbl.glGetTexParameterIuiv = driverTbl.glGetTexParameterIuiv;
   }
   driverTbl.glGetTexParameterIuiv(target, pname, params);
}

static void REGAL_CALL missing_glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(drawbuffer);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glClearBufferiv" );
}

static void REGAL_CALL loader_glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClearBufferiv, "glClearBufferiv");
   if ( !driverTbl.glClearBufferiv ) {
      driverTbl.glClearBufferiv = missing_glClearBufferiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClearBufferiv == loader_glClearBufferiv) {
      rCtx->dsp.emuTbl.glClearBufferiv = driverTbl.glClearBufferiv;
   }
   driverTbl.glClearBufferiv(buffer, drawbuffer, value);
}

static void REGAL_CALL missing_glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(drawbuffer);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glClearBufferuiv" );
}

static void REGAL_CALL loader_glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClearBufferuiv, "glClearBufferuiv");
   if ( !driverTbl.glClearBufferuiv ) {
      driverTbl.glClearBufferuiv = missing_glClearBufferuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClearBufferuiv == loader_glClearBufferuiv) {
      rCtx->dsp.emuTbl.glClearBufferuiv = driverTbl.glClearBufferuiv;
   }
   driverTbl.glClearBufferuiv(buffer, drawbuffer, value);
}

static void REGAL_CALL missing_glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(drawbuffer);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glClearBufferfv" );
}

static void REGAL_CALL loader_glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClearBufferfv, "glClearBufferfv");
   if ( !driverTbl.glClearBufferfv ) {
      driverTbl.glClearBufferfv = missing_glClearBufferfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClearBufferfv == loader_glClearBufferfv) {
      rCtx->dsp.emuTbl.glClearBufferfv = driverTbl.glClearBufferfv;
   }
   driverTbl.glClearBufferfv(buffer, drawbuffer, value);
}

static void REGAL_CALL missing_glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(drawbuffer);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(stencil);
   Warning( "Called missing function glClearBufferfi" );
}

static void REGAL_CALL loader_glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClearBufferfi, "glClearBufferfi");
   if ( !driverTbl.glClearBufferfi ) {
      driverTbl.glClearBufferfi = missing_glClearBufferfi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClearBufferfi == loader_glClearBufferfi) {
      rCtx->dsp.emuTbl.glClearBufferfi = driverTbl.glClearBufferfi;
   }
   driverTbl.glClearBufferfi(buffer, drawbuffer, depth, stencil);
}

static const GLubyte *REGAL_CALL missing_glGetStringi(GLenum name, GLuint index)
{
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glGetStringi" );
  const GLubyte * ret = NULL;
  return ret;
}

static const GLubyte *REGAL_CALL loader_glGetStringi(GLenum name, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetStringi, "glGetStringi");
   if ( !driverTbl.glGetStringi ) {
      driverTbl.glGetStringi = missing_glGetStringi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetStringi == loader_glGetStringi) {
      rCtx->dsp.emuTbl.glGetStringi = driverTbl.glGetStringi;
   }
   return driverTbl.glGetStringi(name, index);
}

// GL_VERSION_3_1

static void REGAL_CALL missing_glDrawArraysInstanced(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   Warning( "Called missing function glDrawArraysInstanced" );
}

static void REGAL_CALL loader_glDrawArraysInstanced(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawArraysInstanced, "glDrawArraysInstanced");
   if ( !driverTbl.glDrawArraysInstanced ) {
      driverTbl.glDrawArraysInstanced = missing_glDrawArraysInstanced;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawArraysInstanced == loader_glDrawArraysInstanced) {
      rCtx->dsp.emuTbl.glDrawArraysInstanced = driverTbl.glDrawArraysInstanced;
   }
   driverTbl.glDrawArraysInstanced(mode, start, count, primcount);
}

static void REGAL_CALL missing_glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   Warning( "Called missing function glDrawElementsInstanced" );
}

static void REGAL_CALL loader_glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawElementsInstanced, "glDrawElementsInstanced");
   if ( !driverTbl.glDrawElementsInstanced ) {
      driverTbl.glDrawElementsInstanced = missing_glDrawElementsInstanced;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawElementsInstanced == loader_glDrawElementsInstanced) {
      rCtx->dsp.emuTbl.glDrawElementsInstanced = driverTbl.glDrawElementsInstanced;
   }
   driverTbl.glDrawElementsInstanced(mode, count, type, indices, primcount);
}

static void REGAL_CALL missing_glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glTexBuffer" );
}

static void REGAL_CALL loader_glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexBuffer, "glTexBuffer");
   if ( !driverTbl.glTexBuffer ) {
      driverTbl.glTexBuffer = missing_glTexBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexBuffer == loader_glTexBuffer) {
      rCtx->dsp.emuTbl.glTexBuffer = driverTbl.glTexBuffer;
   }
   driverTbl.glTexBuffer(target, internalformat, buffer);
}

static void REGAL_CALL missing_glPrimitiveRestartIndex(GLuint index)
{
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glPrimitiveRestartIndex" );
}

static void REGAL_CALL loader_glPrimitiveRestartIndex(GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPrimitiveRestartIndex, "glPrimitiveRestartIndex");
   if ( !driverTbl.glPrimitiveRestartIndex ) {
      driverTbl.glPrimitiveRestartIndex = missing_glPrimitiveRestartIndex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPrimitiveRestartIndex == loader_glPrimitiveRestartIndex) {
      rCtx->dsp.emuTbl.glPrimitiveRestartIndex = driverTbl.glPrimitiveRestartIndex;
   }
   driverTbl.glPrimitiveRestartIndex(index);
}

// GL_VERSION_3_2

static void REGAL_CALL missing_glGetInteger64i_v(GLenum target, GLuint index, GLint64 *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetInteger64i_v" );
}

static void REGAL_CALL loader_glGetInteger64i_v(GLenum target, GLuint index, GLint64 *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetInteger64i_v, "glGetInteger64i_v");
   if ( !driverTbl.glGetInteger64i_v ) {
      driverTbl.glGetInteger64i_v = missing_glGetInteger64i_v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetInteger64i_v == loader_glGetInteger64i_v) {
      rCtx->dsp.emuTbl.glGetInteger64i_v = driverTbl.glGetInteger64i_v;
   }
   driverTbl.glGetInteger64i_v(target, index, data);
}

static void REGAL_CALL missing_glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetBufferParameteri64v" );
}

static void REGAL_CALL loader_glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetBufferParameteri64v, "glGetBufferParameteri64v");
   if ( !driverTbl.glGetBufferParameteri64v ) {
      driverTbl.glGetBufferParameteri64v = missing_glGetBufferParameteri64v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetBufferParameteri64v == loader_glGetBufferParameteri64v) {
      rCtx->dsp.emuTbl.glGetBufferParameteri64v = driverTbl.glGetBufferParameteri64v;
   }
   driverTbl.glGetBufferParameteri64v(target, pname, params);
}

static void REGAL_CALL missing_glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "Called missing function glFramebufferTexture" );
}

static void REGAL_CALL loader_glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTexture, "glFramebufferTexture");
   if ( !driverTbl.glFramebufferTexture ) {
      driverTbl.glFramebufferTexture = missing_glFramebufferTexture;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTexture == loader_glFramebufferTexture) {
      rCtx->dsp.emuTbl.glFramebufferTexture = driverTbl.glFramebufferTexture;
   }
   driverTbl.glFramebufferTexture(target, attachment, texture, level);
}

static void REGAL_CALL missing_glFramebufferTextureFace(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(face);
   Warning( "Called missing function glFramebufferTextureFace" );
}

static void REGAL_CALL loader_glFramebufferTextureFace(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTextureFace, "glFramebufferTextureFace");
   if ( !driverTbl.glFramebufferTextureFace ) {
      driverTbl.glFramebufferTextureFace = missing_glFramebufferTextureFace;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTextureFace == loader_glFramebufferTextureFace) {
      rCtx->dsp.emuTbl.glFramebufferTextureFace = driverTbl.glFramebufferTextureFace;
   }
   driverTbl.glFramebufferTextureFace(target, attachment, texture, level, face);
}

// GL_ARB_sampler_objects

static void REGAL_CALL missing_glGenSamplers(GLsizei count, GLuint *samplers)
{
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(samplers);
   Warning( "Called missing function glGenSamplers" );
}

static void REGAL_CALL loader_glGenSamplers(GLsizei count, GLuint *samplers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenSamplers, "glGenSamplers");
   if ( !driverTbl.glGenSamplers ) {
      driverTbl.glGenSamplers = missing_glGenSamplers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenSamplers == loader_glGenSamplers) {
      rCtx->dsp.emuTbl.glGenSamplers = driverTbl.glGenSamplers;
   }
   driverTbl.glGenSamplers(count, samplers);
}

static void REGAL_CALL missing_glDeleteSamplers(GLsizei count, const GLuint *samplers)
{
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(samplers);
   Warning( "Called missing function glDeleteSamplers" );
}

static void REGAL_CALL loader_glDeleteSamplers(GLsizei count, const GLuint *samplers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteSamplers, "glDeleteSamplers");
   if ( !driverTbl.glDeleteSamplers ) {
      driverTbl.glDeleteSamplers = missing_glDeleteSamplers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteSamplers == loader_glDeleteSamplers) {
      rCtx->dsp.emuTbl.glDeleteSamplers = driverTbl.glDeleteSamplers;
   }
   driverTbl.glDeleteSamplers(count, samplers);
}

static GLboolean REGAL_CALL missing_glIsSampler(GLuint sampler)
{
   UNUSED_PARAMETER(sampler);
   Warning( "Called missing function glIsSampler" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsSampler(GLuint sampler)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsSampler, "glIsSampler");
   if ( !driverTbl.glIsSampler ) {
      driverTbl.glIsSampler = missing_glIsSampler;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsSampler == loader_glIsSampler) {
      rCtx->dsp.emuTbl.glIsSampler = driverTbl.glIsSampler;
   }
   return driverTbl.glIsSampler(sampler);
}

static void REGAL_CALL missing_glBindSampler(GLuint unit, GLuint sampler)
{
   UNUSED_PARAMETER(unit);
   UNUSED_PARAMETER(sampler);
   Warning( "Called missing function glBindSampler" );
}

static void REGAL_CALL loader_glBindSampler(GLuint unit, GLuint sampler)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindSampler, "glBindSampler");
   if ( !driverTbl.glBindSampler ) {
      driverTbl.glBindSampler = missing_glBindSampler;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindSampler == loader_glBindSampler) {
      rCtx->dsp.emuTbl.glBindSampler = driverTbl.glBindSampler;
   }
   driverTbl.glBindSampler(unit, sampler);
}

static void REGAL_CALL missing_glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glSamplerParameteri" );
}

static void REGAL_CALL loader_glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSamplerParameteri, "glSamplerParameteri");
   if ( !driverTbl.glSamplerParameteri ) {
      driverTbl.glSamplerParameteri = missing_glSamplerParameteri;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSamplerParameteri == loader_glSamplerParameteri) {
      rCtx->dsp.emuTbl.glSamplerParameteri = driverTbl.glSamplerParameteri;
   }
   driverTbl.glSamplerParameteri(sampler, pname, param);
}

static void REGAL_CALL missing_glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glSamplerParameterf" );
}

static void REGAL_CALL loader_glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSamplerParameterf, "glSamplerParameterf");
   if ( !driverTbl.glSamplerParameterf ) {
      driverTbl.glSamplerParameterf = missing_glSamplerParameterf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSamplerParameterf == loader_glSamplerParameterf) {
      rCtx->dsp.emuTbl.glSamplerParameterf = driverTbl.glSamplerParameterf;
   }
   driverTbl.glSamplerParameterf(sampler, pname, param);
}

static void REGAL_CALL missing_glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glSamplerParameteriv" );
}

static void REGAL_CALL loader_glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSamplerParameteriv, "glSamplerParameteriv");
   if ( !driverTbl.glSamplerParameteriv ) {
      driverTbl.glSamplerParameteriv = missing_glSamplerParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSamplerParameteriv == loader_glSamplerParameteriv) {
      rCtx->dsp.emuTbl.glSamplerParameteriv = driverTbl.glSamplerParameteriv;
   }
   driverTbl.glSamplerParameteriv(sampler, pname, params);
}

static void REGAL_CALL missing_glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glSamplerParameterfv" );
}

static void REGAL_CALL loader_glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSamplerParameterfv, "glSamplerParameterfv");
   if ( !driverTbl.glSamplerParameterfv ) {
      driverTbl.glSamplerParameterfv = missing_glSamplerParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSamplerParameterfv == loader_glSamplerParameterfv) {
      rCtx->dsp.emuTbl.glSamplerParameterfv = driverTbl.glSamplerParameterfv;
   }
   driverTbl.glSamplerParameterfv(sampler, pname, params);
}

static void REGAL_CALL missing_glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glSamplerParameterIiv" );
}

static void REGAL_CALL loader_glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSamplerParameterIiv, "glSamplerParameterIiv");
   if ( !driverTbl.glSamplerParameterIiv ) {
      driverTbl.glSamplerParameterIiv = missing_glSamplerParameterIiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSamplerParameterIiv == loader_glSamplerParameterIiv) {
      rCtx->dsp.emuTbl.glSamplerParameterIiv = driverTbl.glSamplerParameterIiv;
   }
   driverTbl.glSamplerParameterIiv(sampler, pname, params);
}

static void REGAL_CALL missing_glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glSamplerParameterIuiv" );
}

static void REGAL_CALL loader_glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSamplerParameterIuiv, "glSamplerParameterIuiv");
   if ( !driverTbl.glSamplerParameterIuiv ) {
      driverTbl.glSamplerParameterIuiv = missing_glSamplerParameterIuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSamplerParameterIuiv == loader_glSamplerParameterIuiv) {
      rCtx->dsp.emuTbl.glSamplerParameterIuiv = driverTbl.glSamplerParameterIuiv;
   }
   driverTbl.glSamplerParameterIuiv(sampler, pname, params);
}

static void REGAL_CALL missing_glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetSamplerParameteriv" );
}

static void REGAL_CALL loader_glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetSamplerParameteriv, "glGetSamplerParameteriv");
   if ( !driverTbl.glGetSamplerParameteriv ) {
      driverTbl.glGetSamplerParameteriv = missing_glGetSamplerParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetSamplerParameteriv == loader_glGetSamplerParameteriv) {
      rCtx->dsp.emuTbl.glGetSamplerParameteriv = driverTbl.glGetSamplerParameteriv;
   }
   driverTbl.glGetSamplerParameteriv(sampler, pname, params);
}

static void REGAL_CALL missing_glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetSamplerParameterfv" );
}

static void REGAL_CALL loader_glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetSamplerParameterfv, "glGetSamplerParameterfv");
   if ( !driverTbl.glGetSamplerParameterfv ) {
      driverTbl.glGetSamplerParameterfv = missing_glGetSamplerParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetSamplerParameterfv == loader_glGetSamplerParameterfv) {
      rCtx->dsp.emuTbl.glGetSamplerParameterfv = driverTbl.glGetSamplerParameterfv;
   }
   driverTbl.glGetSamplerParameterfv(sampler, pname, params);
}

static void REGAL_CALL missing_glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetSamplerParameterIiv" );
}

static void REGAL_CALL loader_glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetSamplerParameterIiv, "glGetSamplerParameterIiv");
   if ( !driverTbl.glGetSamplerParameterIiv ) {
      driverTbl.glGetSamplerParameterIiv = missing_glGetSamplerParameterIiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetSamplerParameterIiv == loader_glGetSamplerParameterIiv) {
      rCtx->dsp.emuTbl.glGetSamplerParameterIiv = driverTbl.glGetSamplerParameterIiv;
   }
   driverTbl.glGetSamplerParameterIiv(sampler, pname, params);
}

static void REGAL_CALL missing_glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetSamplerParameterIuiv" );
}

static void REGAL_CALL loader_glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetSamplerParameterIuiv, "glGetSamplerParameterIuiv");
   if ( !driverTbl.glGetSamplerParameterIuiv ) {
      driverTbl.glGetSamplerParameterIuiv = missing_glGetSamplerParameterIuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetSamplerParameterIuiv == loader_glGetSamplerParameterIuiv) {
      rCtx->dsp.emuTbl.glGetSamplerParameterIuiv = driverTbl.glGetSamplerParameterIuiv;
   }
   driverTbl.glGetSamplerParameterIuiv(sampler, pname, params);
}

// GL_ARB_blend_func_extended

static void REGAL_CALL missing_glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(colorNumber);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glBindFragDataLocationIndexed" );
}

static void REGAL_CALL loader_glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindFragDataLocationIndexed, "glBindFragDataLocationIndexed");
   if ( !driverTbl.glBindFragDataLocationIndexed ) {
      driverTbl.glBindFragDataLocationIndexed = missing_glBindFragDataLocationIndexed;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindFragDataLocationIndexed == loader_glBindFragDataLocationIndexed) {
      rCtx->dsp.emuTbl.glBindFragDataLocationIndexed = driverTbl.glBindFragDataLocationIndexed;
   }
   driverTbl.glBindFragDataLocationIndexed(program, colorNumber, index, name);
}

static GLint REGAL_CALL missing_glGetFragDataIndex(GLuint program, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetFragDataIndex" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetFragDataIndex(GLuint program, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFragDataIndex, "glGetFragDataIndex");
   if ( !driverTbl.glGetFragDataIndex ) {
      driverTbl.glGetFragDataIndex = missing_glGetFragDataIndex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFragDataIndex == loader_glGetFragDataIndex) {
      rCtx->dsp.emuTbl.glGetFragDataIndex = driverTbl.glGetFragDataIndex;
   }
   return driverTbl.glGetFragDataIndex(program, name);
}

// GL_ARB_timer_query

static void REGAL_CALL missing_glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetQueryObjecti64v" );
}

static void REGAL_CALL loader_glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetQueryObjecti64v, "glGetQueryObjecti64v");
   if ( !driverTbl.glGetQueryObjecti64v ) {
      driverTbl.glGetQueryObjecti64v = missing_glGetQueryObjecti64v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetQueryObjecti64v == loader_glGetQueryObjecti64v) {
      rCtx->dsp.emuTbl.glGetQueryObjecti64v = driverTbl.glGetQueryObjecti64v;
   }
   driverTbl.glGetQueryObjecti64v(id, pname, params);
}

static void REGAL_CALL missing_glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetQueryObjectui64v" );
}

static void REGAL_CALL loader_glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetQueryObjectui64v, "glGetQueryObjectui64v");
   if ( !driverTbl.glGetQueryObjectui64v ) {
      driverTbl.glGetQueryObjectui64v = missing_glGetQueryObjectui64v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetQueryObjectui64v == loader_glGetQueryObjectui64v) {
      rCtx->dsp.emuTbl.glGetQueryObjectui64v = driverTbl.glGetQueryObjectui64v;
   }
   driverTbl.glGetQueryObjectui64v(id, pname, params);
}

static void REGAL_CALL missing_glQueryCounter(GLuint id, GLenum target)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glQueryCounter" );
}

static void REGAL_CALL loader_glQueryCounter(GLuint id, GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glQueryCounter, "glQueryCounter");
   if ( !driverTbl.glQueryCounter ) {
      driverTbl.glQueryCounter = missing_glQueryCounter;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glQueryCounter == loader_glQueryCounter) {
      rCtx->dsp.emuTbl.glQueryCounter = driverTbl.glQueryCounter;
   }
   driverTbl.glQueryCounter(id, target);
}

// GL_VERSION_3_3

static void REGAL_CALL missing_glVertexAttribDivisor(GLuint index, GLuint divisor)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(divisor);
   Warning( "Called missing function glVertexAttribDivisor" );
}

static void REGAL_CALL loader_glVertexAttribDivisor(GLuint index, GLuint divisor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribDivisor, "glVertexAttribDivisor");
   if ( !driverTbl.glVertexAttribDivisor ) {
      driverTbl.glVertexAttribDivisor = missing_glVertexAttribDivisor;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribDivisor == loader_glVertexAttribDivisor) {
      rCtx->dsp.emuTbl.glVertexAttribDivisor = driverTbl.glVertexAttribDivisor;
   }
   driverTbl.glVertexAttribDivisor(index, divisor);
}

// GL_ARB_vertex_type_2_10_10_10_rev

static void REGAL_CALL missing_glVertexP2ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexP2ui" );
}

static void REGAL_CALL loader_glVertexP2ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexP2ui, "glVertexP2ui");
   if ( !driverTbl.glVertexP2ui ) {
      driverTbl.glVertexP2ui = missing_glVertexP2ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexP2ui == loader_glVertexP2ui) {
      rCtx->dsp.emuTbl.glVertexP2ui = driverTbl.glVertexP2ui;
   }
   driverTbl.glVertexP2ui(type, coords);
}

static void REGAL_CALL missing_glVertexP2uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexP2uiv" );
}

static void REGAL_CALL loader_glVertexP2uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexP2uiv, "glVertexP2uiv");
   if ( !driverTbl.glVertexP2uiv ) {
      driverTbl.glVertexP2uiv = missing_glVertexP2uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexP2uiv == loader_glVertexP2uiv) {
      rCtx->dsp.emuTbl.glVertexP2uiv = driverTbl.glVertexP2uiv;
   }
   driverTbl.glVertexP2uiv(type, coords);
}

static void REGAL_CALL missing_glVertexP3ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexP3ui" );
}

static void REGAL_CALL loader_glVertexP3ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexP3ui, "glVertexP3ui");
   if ( !driverTbl.glVertexP3ui ) {
      driverTbl.glVertexP3ui = missing_glVertexP3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexP3ui == loader_glVertexP3ui) {
      rCtx->dsp.emuTbl.glVertexP3ui = driverTbl.glVertexP3ui;
   }
   driverTbl.glVertexP3ui(type, coords);
}

static void REGAL_CALL missing_glVertexP3uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexP3uiv" );
}

static void REGAL_CALL loader_glVertexP3uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexP3uiv, "glVertexP3uiv");
   if ( !driverTbl.glVertexP3uiv ) {
      driverTbl.glVertexP3uiv = missing_glVertexP3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexP3uiv == loader_glVertexP3uiv) {
      rCtx->dsp.emuTbl.glVertexP3uiv = driverTbl.glVertexP3uiv;
   }
   driverTbl.glVertexP3uiv(type, coords);
}

static void REGAL_CALL missing_glVertexP4ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexP4ui" );
}

static void REGAL_CALL loader_glVertexP4ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexP4ui, "glVertexP4ui");
   if ( !driverTbl.glVertexP4ui ) {
      driverTbl.glVertexP4ui = missing_glVertexP4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexP4ui == loader_glVertexP4ui) {
      rCtx->dsp.emuTbl.glVertexP4ui = driverTbl.glVertexP4ui;
   }
   driverTbl.glVertexP4ui(type, coords);
}

static void REGAL_CALL missing_glVertexP4uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexP4uiv" );
}

static void REGAL_CALL loader_glVertexP4uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexP4uiv, "glVertexP4uiv");
   if ( !driverTbl.glVertexP4uiv ) {
      driverTbl.glVertexP4uiv = missing_glVertexP4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexP4uiv == loader_glVertexP4uiv) {
      rCtx->dsp.emuTbl.glVertexP4uiv = driverTbl.glVertexP4uiv;
   }
   driverTbl.glVertexP4uiv(type, coords);
}

static void REGAL_CALL missing_glTexCoordP1ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glTexCoordP1ui" );
}

static void REGAL_CALL loader_glTexCoordP1ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoordP1ui, "glTexCoordP1ui");
   if ( !driverTbl.glTexCoordP1ui ) {
      driverTbl.glTexCoordP1ui = missing_glTexCoordP1ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoordP1ui == loader_glTexCoordP1ui) {
      rCtx->dsp.emuTbl.glTexCoordP1ui = driverTbl.glTexCoordP1ui;
   }
   driverTbl.glTexCoordP1ui(type, coords);
}

static void REGAL_CALL missing_glTexCoordP1uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glTexCoordP1uiv" );
}

static void REGAL_CALL loader_glTexCoordP1uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoordP1uiv, "glTexCoordP1uiv");
   if ( !driverTbl.glTexCoordP1uiv ) {
      driverTbl.glTexCoordP1uiv = missing_glTexCoordP1uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoordP1uiv == loader_glTexCoordP1uiv) {
      rCtx->dsp.emuTbl.glTexCoordP1uiv = driverTbl.glTexCoordP1uiv;
   }
   driverTbl.glTexCoordP1uiv(type, coords);
}

static void REGAL_CALL missing_glTexCoordP2ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glTexCoordP2ui" );
}

static void REGAL_CALL loader_glTexCoordP2ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoordP2ui, "glTexCoordP2ui");
   if ( !driverTbl.glTexCoordP2ui ) {
      driverTbl.glTexCoordP2ui = missing_glTexCoordP2ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoordP2ui == loader_glTexCoordP2ui) {
      rCtx->dsp.emuTbl.glTexCoordP2ui = driverTbl.glTexCoordP2ui;
   }
   driverTbl.glTexCoordP2ui(type, coords);
}

static void REGAL_CALL missing_glTexCoordP2uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glTexCoordP2uiv" );
}

static void REGAL_CALL loader_glTexCoordP2uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoordP2uiv, "glTexCoordP2uiv");
   if ( !driverTbl.glTexCoordP2uiv ) {
      driverTbl.glTexCoordP2uiv = missing_glTexCoordP2uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoordP2uiv == loader_glTexCoordP2uiv) {
      rCtx->dsp.emuTbl.glTexCoordP2uiv = driverTbl.glTexCoordP2uiv;
   }
   driverTbl.glTexCoordP2uiv(type, coords);
}

static void REGAL_CALL missing_glTexCoordP3ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glTexCoordP3ui" );
}

static void REGAL_CALL loader_glTexCoordP3ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoordP3ui, "glTexCoordP3ui");
   if ( !driverTbl.glTexCoordP3ui ) {
      driverTbl.glTexCoordP3ui = missing_glTexCoordP3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoordP3ui == loader_glTexCoordP3ui) {
      rCtx->dsp.emuTbl.glTexCoordP3ui = driverTbl.glTexCoordP3ui;
   }
   driverTbl.glTexCoordP3ui(type, coords);
}

static void REGAL_CALL missing_glTexCoordP3uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glTexCoordP3uiv" );
}

static void REGAL_CALL loader_glTexCoordP3uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoordP3uiv, "glTexCoordP3uiv");
   if ( !driverTbl.glTexCoordP3uiv ) {
      driverTbl.glTexCoordP3uiv = missing_glTexCoordP3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoordP3uiv == loader_glTexCoordP3uiv) {
      rCtx->dsp.emuTbl.glTexCoordP3uiv = driverTbl.glTexCoordP3uiv;
   }
   driverTbl.glTexCoordP3uiv(type, coords);
}

static void REGAL_CALL missing_glTexCoordP4ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glTexCoordP4ui" );
}

static void REGAL_CALL loader_glTexCoordP4ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoordP4ui, "glTexCoordP4ui");
   if ( !driverTbl.glTexCoordP4ui ) {
      driverTbl.glTexCoordP4ui = missing_glTexCoordP4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoordP4ui == loader_glTexCoordP4ui) {
      rCtx->dsp.emuTbl.glTexCoordP4ui = driverTbl.glTexCoordP4ui;
   }
   driverTbl.glTexCoordP4ui(type, coords);
}

static void REGAL_CALL missing_glTexCoordP4uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glTexCoordP4uiv" );
}

static void REGAL_CALL loader_glTexCoordP4uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoordP4uiv, "glTexCoordP4uiv");
   if ( !driverTbl.glTexCoordP4uiv ) {
      driverTbl.glTexCoordP4uiv = missing_glTexCoordP4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoordP4uiv == loader_glTexCoordP4uiv) {
      rCtx->dsp.emuTbl.glTexCoordP4uiv = driverTbl.glTexCoordP4uiv;
   }
   driverTbl.glTexCoordP4uiv(type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glMultiTexCoordP1ui" );
}

static void REGAL_CALL loader_glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoordP1ui, "glMultiTexCoordP1ui");
   if ( !driverTbl.glMultiTexCoordP1ui ) {
      driverTbl.glMultiTexCoordP1ui = missing_glMultiTexCoordP1ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoordP1ui == loader_glMultiTexCoordP1ui) {
      rCtx->dsp.emuTbl.glMultiTexCoordP1ui = driverTbl.glMultiTexCoordP1ui;
   }
   driverTbl.glMultiTexCoordP1ui(texture, type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glMultiTexCoordP1uiv" );
}

static void REGAL_CALL loader_glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoordP1uiv, "glMultiTexCoordP1uiv");
   if ( !driverTbl.glMultiTexCoordP1uiv ) {
      driverTbl.glMultiTexCoordP1uiv = missing_glMultiTexCoordP1uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoordP1uiv == loader_glMultiTexCoordP1uiv) {
      rCtx->dsp.emuTbl.glMultiTexCoordP1uiv = driverTbl.glMultiTexCoordP1uiv;
   }
   driverTbl.glMultiTexCoordP1uiv(texture, type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glMultiTexCoordP2ui" );
}

static void REGAL_CALL loader_glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoordP2ui, "glMultiTexCoordP2ui");
   if ( !driverTbl.glMultiTexCoordP2ui ) {
      driverTbl.glMultiTexCoordP2ui = missing_glMultiTexCoordP2ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoordP2ui == loader_glMultiTexCoordP2ui) {
      rCtx->dsp.emuTbl.glMultiTexCoordP2ui = driverTbl.glMultiTexCoordP2ui;
   }
   driverTbl.glMultiTexCoordP2ui(texture, type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glMultiTexCoordP2uiv" );
}

static void REGAL_CALL loader_glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoordP2uiv, "glMultiTexCoordP2uiv");
   if ( !driverTbl.glMultiTexCoordP2uiv ) {
      driverTbl.glMultiTexCoordP2uiv = missing_glMultiTexCoordP2uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoordP2uiv == loader_glMultiTexCoordP2uiv) {
      rCtx->dsp.emuTbl.glMultiTexCoordP2uiv = driverTbl.glMultiTexCoordP2uiv;
   }
   driverTbl.glMultiTexCoordP2uiv(texture, type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glMultiTexCoordP3ui" );
}

static void REGAL_CALL loader_glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoordP3ui, "glMultiTexCoordP3ui");
   if ( !driverTbl.glMultiTexCoordP3ui ) {
      driverTbl.glMultiTexCoordP3ui = missing_glMultiTexCoordP3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoordP3ui == loader_glMultiTexCoordP3ui) {
      rCtx->dsp.emuTbl.glMultiTexCoordP3ui = driverTbl.glMultiTexCoordP3ui;
   }
   driverTbl.glMultiTexCoordP3ui(texture, type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glMultiTexCoordP3uiv" );
}

static void REGAL_CALL loader_glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoordP3uiv, "glMultiTexCoordP3uiv");
   if ( !driverTbl.glMultiTexCoordP3uiv ) {
      driverTbl.glMultiTexCoordP3uiv = missing_glMultiTexCoordP3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoordP3uiv == loader_glMultiTexCoordP3uiv) {
      rCtx->dsp.emuTbl.glMultiTexCoordP3uiv = driverTbl.glMultiTexCoordP3uiv;
   }
   driverTbl.glMultiTexCoordP3uiv(texture, type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glMultiTexCoordP4ui" );
}

static void REGAL_CALL loader_glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoordP4ui, "glMultiTexCoordP4ui");
   if ( !driverTbl.glMultiTexCoordP4ui ) {
      driverTbl.glMultiTexCoordP4ui = missing_glMultiTexCoordP4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoordP4ui == loader_glMultiTexCoordP4ui) {
      rCtx->dsp.emuTbl.glMultiTexCoordP4ui = driverTbl.glMultiTexCoordP4ui;
   }
   driverTbl.glMultiTexCoordP4ui(texture, type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glMultiTexCoordP4uiv" );
}

static void REGAL_CALL loader_glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoordP4uiv, "glMultiTexCoordP4uiv");
   if ( !driverTbl.glMultiTexCoordP4uiv ) {
      driverTbl.glMultiTexCoordP4uiv = missing_glMultiTexCoordP4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoordP4uiv == loader_glMultiTexCoordP4uiv) {
      rCtx->dsp.emuTbl.glMultiTexCoordP4uiv = driverTbl.glMultiTexCoordP4uiv;
   }
   driverTbl.glMultiTexCoordP4uiv(texture, type, coords);
}

static void REGAL_CALL missing_glNormalP3ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glNormalP3ui" );
}

static void REGAL_CALL loader_glNormalP3ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalP3ui, "glNormalP3ui");
   if ( !driverTbl.glNormalP3ui ) {
      driverTbl.glNormalP3ui = missing_glNormalP3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalP3ui == loader_glNormalP3ui) {
      rCtx->dsp.emuTbl.glNormalP3ui = driverTbl.glNormalP3ui;
   }
   driverTbl.glNormalP3ui(type, coords);
}

static void REGAL_CALL missing_glNormalP3uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glNormalP3uiv" );
}

static void REGAL_CALL loader_glNormalP3uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalP3uiv, "glNormalP3uiv");
   if ( !driverTbl.glNormalP3uiv ) {
      driverTbl.glNormalP3uiv = missing_glNormalP3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalP3uiv == loader_glNormalP3uiv) {
      rCtx->dsp.emuTbl.glNormalP3uiv = driverTbl.glNormalP3uiv;
   }
   driverTbl.glNormalP3uiv(type, coords);
}

static void REGAL_CALL missing_glColorP3ui(GLenum type, GLuint color)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(color);
   Warning( "Called missing function glColorP3ui" );
}

static void REGAL_CALL loader_glColorP3ui(GLenum type, GLuint color)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorP3ui, "glColorP3ui");
   if ( !driverTbl.glColorP3ui ) {
      driverTbl.glColorP3ui = missing_glColorP3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorP3ui == loader_glColorP3ui) {
      rCtx->dsp.emuTbl.glColorP3ui = driverTbl.glColorP3ui;
   }
   driverTbl.glColorP3ui(type, color);
}

static void REGAL_CALL missing_glColorP3uiv(GLenum type, const GLuint *color)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(color);
   Warning( "Called missing function glColorP3uiv" );
}

static void REGAL_CALL loader_glColorP3uiv(GLenum type, const GLuint *color)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorP3uiv, "glColorP3uiv");
   if ( !driverTbl.glColorP3uiv ) {
      driverTbl.glColorP3uiv = missing_glColorP3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorP3uiv == loader_glColorP3uiv) {
      rCtx->dsp.emuTbl.glColorP3uiv = driverTbl.glColorP3uiv;
   }
   driverTbl.glColorP3uiv(type, color);
}

static void REGAL_CALL missing_glColorP4ui(GLenum type, GLuint color)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(color);
   Warning( "Called missing function glColorP4ui" );
}

static void REGAL_CALL loader_glColorP4ui(GLenum type, GLuint color)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorP4ui, "glColorP4ui");
   if ( !driverTbl.glColorP4ui ) {
      driverTbl.glColorP4ui = missing_glColorP4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorP4ui == loader_glColorP4ui) {
      rCtx->dsp.emuTbl.glColorP4ui = driverTbl.glColorP4ui;
   }
   driverTbl.glColorP4ui(type, color);
}

static void REGAL_CALL missing_glColorP4uiv(GLenum type, const GLuint *color)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(color);
   Warning( "Called missing function glColorP4uiv" );
}

static void REGAL_CALL loader_glColorP4uiv(GLenum type, const GLuint *color)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorP4uiv, "glColorP4uiv");
   if ( !driverTbl.glColorP4uiv ) {
      driverTbl.glColorP4uiv = missing_glColorP4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorP4uiv == loader_glColorP4uiv) {
      rCtx->dsp.emuTbl.glColorP4uiv = driverTbl.glColorP4uiv;
   }
   driverTbl.glColorP4uiv(type, color);
}

static void REGAL_CALL missing_glSecondaryColorP3ui(GLenum type, GLuint color)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(color);
   Warning( "Called missing function glSecondaryColorP3ui" );
}

static void REGAL_CALL loader_glSecondaryColorP3ui(GLenum type, GLuint color)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColorP3ui, "glSecondaryColorP3ui");
   if ( !driverTbl.glSecondaryColorP3ui ) {
      driverTbl.glSecondaryColorP3ui = missing_glSecondaryColorP3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColorP3ui == loader_glSecondaryColorP3ui) {
      rCtx->dsp.emuTbl.glSecondaryColorP3ui = driverTbl.glSecondaryColorP3ui;
   }
   driverTbl.glSecondaryColorP3ui(type, color);
}

static void REGAL_CALL missing_glSecondaryColorP3uiv(GLenum type, const GLuint *color)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(color);
   Warning( "Called missing function glSecondaryColorP3uiv" );
}

static void REGAL_CALL loader_glSecondaryColorP3uiv(GLenum type, const GLuint *color)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColorP3uiv, "glSecondaryColorP3uiv");
   if ( !driverTbl.glSecondaryColorP3uiv ) {
      driverTbl.glSecondaryColorP3uiv = missing_glSecondaryColorP3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColorP3uiv == loader_glSecondaryColorP3uiv) {
      rCtx->dsp.emuTbl.glSecondaryColorP3uiv = driverTbl.glSecondaryColorP3uiv;
   }
   driverTbl.glSecondaryColorP3uiv(type, color);
}

static void REGAL_CALL missing_glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glVertexAttribP1ui" );
}

static void REGAL_CALL loader_glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribP1ui, "glVertexAttribP1ui");
   if ( !driverTbl.glVertexAttribP1ui ) {
      driverTbl.glVertexAttribP1ui = missing_glVertexAttribP1ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribP1ui == loader_glVertexAttribP1ui) {
      rCtx->dsp.emuTbl.glVertexAttribP1ui = driverTbl.glVertexAttribP1ui;
   }
   driverTbl.glVertexAttribP1ui(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glVertexAttribP1uiv" );
}

static void REGAL_CALL loader_glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribP1uiv, "glVertexAttribP1uiv");
   if ( !driverTbl.glVertexAttribP1uiv ) {
      driverTbl.glVertexAttribP1uiv = missing_glVertexAttribP1uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribP1uiv == loader_glVertexAttribP1uiv) {
      rCtx->dsp.emuTbl.glVertexAttribP1uiv = driverTbl.glVertexAttribP1uiv;
   }
   driverTbl.glVertexAttribP1uiv(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glVertexAttribP2ui" );
}

static void REGAL_CALL loader_glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribP2ui, "glVertexAttribP2ui");
   if ( !driverTbl.glVertexAttribP2ui ) {
      driverTbl.glVertexAttribP2ui = missing_glVertexAttribP2ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribP2ui == loader_glVertexAttribP2ui) {
      rCtx->dsp.emuTbl.glVertexAttribP2ui = driverTbl.glVertexAttribP2ui;
   }
   driverTbl.glVertexAttribP2ui(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glVertexAttribP2uiv" );
}

static void REGAL_CALL loader_glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribP2uiv, "glVertexAttribP2uiv");
   if ( !driverTbl.glVertexAttribP2uiv ) {
      driverTbl.glVertexAttribP2uiv = missing_glVertexAttribP2uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribP2uiv == loader_glVertexAttribP2uiv) {
      rCtx->dsp.emuTbl.glVertexAttribP2uiv = driverTbl.glVertexAttribP2uiv;
   }
   driverTbl.glVertexAttribP2uiv(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glVertexAttribP3ui" );
}

static void REGAL_CALL loader_glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribP3ui, "glVertexAttribP3ui");
   if ( !driverTbl.glVertexAttribP3ui ) {
      driverTbl.glVertexAttribP3ui = missing_glVertexAttribP3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribP3ui == loader_glVertexAttribP3ui) {
      rCtx->dsp.emuTbl.glVertexAttribP3ui = driverTbl.glVertexAttribP3ui;
   }
   driverTbl.glVertexAttribP3ui(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glVertexAttribP3uiv" );
}

static void REGAL_CALL loader_glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribP3uiv, "glVertexAttribP3uiv");
   if ( !driverTbl.glVertexAttribP3uiv ) {
      driverTbl.glVertexAttribP3uiv = missing_glVertexAttribP3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribP3uiv == loader_glVertexAttribP3uiv) {
      rCtx->dsp.emuTbl.glVertexAttribP3uiv = driverTbl.glVertexAttribP3uiv;
   }
   driverTbl.glVertexAttribP3uiv(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glVertexAttribP4ui" );
}

static void REGAL_CALL loader_glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribP4ui, "glVertexAttribP4ui");
   if ( !driverTbl.glVertexAttribP4ui ) {
      driverTbl.glVertexAttribP4ui = missing_glVertexAttribP4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribP4ui == loader_glVertexAttribP4ui) {
      rCtx->dsp.emuTbl.glVertexAttribP4ui = driverTbl.glVertexAttribP4ui;
   }
   driverTbl.glVertexAttribP4ui(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glVertexAttribP4uiv" );
}

static void REGAL_CALL loader_glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribP4uiv, "glVertexAttribP4uiv");
   if ( !driverTbl.glVertexAttribP4uiv ) {
      driverTbl.glVertexAttribP4uiv = missing_glVertexAttribP4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribP4uiv == loader_glVertexAttribP4uiv) {
      rCtx->dsp.emuTbl.glVertexAttribP4uiv = driverTbl.glVertexAttribP4uiv;
   }
   driverTbl.glVertexAttribP4uiv(index, type, normalized, value);
}

// GL_VERSION_4_0

static void REGAL_CALL missing_glBlendEquationi(GLuint buf, GLenum mode)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glBlendEquationi" );
}

static void REGAL_CALL loader_glBlendEquationi(GLuint buf, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendEquationi, "glBlendEquationi");
   if ( !driverTbl.glBlendEquationi ) {
      driverTbl.glBlendEquationi = missing_glBlendEquationi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendEquationi == loader_glBlendEquationi) {
      rCtx->dsp.emuTbl.glBlendEquationi = driverTbl.glBlendEquationi;
   }
   driverTbl.glBlendEquationi(buf, mode);
}

static void REGAL_CALL missing_glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(modeRGB);
   UNUSED_PARAMETER(modeAlpha);
   Warning( "Called missing function glBlendEquationSeparatei" );
}

static void REGAL_CALL loader_glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendEquationSeparatei, "glBlendEquationSeparatei");
   if ( !driverTbl.glBlendEquationSeparatei ) {
      driverTbl.glBlendEquationSeparatei = missing_glBlendEquationSeparatei;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendEquationSeparatei == loader_glBlendEquationSeparatei) {
      rCtx->dsp.emuTbl.glBlendEquationSeparatei = driverTbl.glBlendEquationSeparatei;
   }
   driverTbl.glBlendEquationSeparatei(buf, modeRGB, modeAlpha);
}

static void REGAL_CALL missing_glBlendFunci(GLuint buf, GLenum src, GLenum dst)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(src);
   UNUSED_PARAMETER(dst);
   Warning( "Called missing function glBlendFunci" );
}

static void REGAL_CALL loader_glBlendFunci(GLuint buf, GLenum src, GLenum dst)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendFunci, "glBlendFunci");
   if ( !driverTbl.glBlendFunci ) {
      driverTbl.glBlendFunci = missing_glBlendFunci;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendFunci == loader_glBlendFunci) {
      rCtx->dsp.emuTbl.glBlendFunci = driverTbl.glBlendFunci;
   }
   driverTbl.glBlendFunci(buf, src, dst);
}

static void REGAL_CALL missing_glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(srcRGB);
   UNUSED_PARAMETER(dstRGB);
   UNUSED_PARAMETER(srcAlpha);
   UNUSED_PARAMETER(dstAlpha);
   Warning( "Called missing function glBlendFuncSeparatei" );
}

static void REGAL_CALL loader_glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendFuncSeparatei, "glBlendFuncSeparatei");
   if ( !driverTbl.glBlendFuncSeparatei ) {
      driverTbl.glBlendFuncSeparatei = missing_glBlendFuncSeparatei;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendFuncSeparatei == loader_glBlendFuncSeparatei) {
      rCtx->dsp.emuTbl.glBlendFuncSeparatei = driverTbl.glBlendFuncSeparatei;
   }
   driverTbl.glBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

// GL_ARB_draw_indirect

static void REGAL_CALL missing_glDrawArraysIndirect(GLenum mode, const GLvoid *indirect)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(indirect);
   Warning( "Called missing function glDrawArraysIndirect" );
}

static void REGAL_CALL loader_glDrawArraysIndirect(GLenum mode, const GLvoid *indirect)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawArraysIndirect, "glDrawArraysIndirect");
   if ( !driverTbl.glDrawArraysIndirect ) {
      driverTbl.glDrawArraysIndirect = missing_glDrawArraysIndirect;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawArraysIndirect == loader_glDrawArraysIndirect) {
      rCtx->dsp.emuTbl.glDrawArraysIndirect = driverTbl.glDrawArraysIndirect;
   }
   driverTbl.glDrawArraysIndirect(mode, indirect);
}

static void REGAL_CALL missing_glDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indirect);
   Warning( "Called missing function glDrawElementsIndirect" );
}

static void REGAL_CALL loader_glDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawElementsIndirect, "glDrawElementsIndirect");
   if ( !driverTbl.glDrawElementsIndirect ) {
      driverTbl.glDrawElementsIndirect = missing_glDrawElementsIndirect;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawElementsIndirect == loader_glDrawElementsIndirect) {
      rCtx->dsp.emuTbl.glDrawElementsIndirect = driverTbl.glDrawElementsIndirect;
   }
   driverTbl.glDrawElementsIndirect(mode, type, indirect);
}

// GL_ARB_gpu_shader_fp64

static void REGAL_CALL missing_glUniform1d(GLint location, GLdouble x)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glUniform1d" );
}

static void REGAL_CALL loader_glUniform1d(GLint location, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1d, "glUniform1d");
   if ( !driverTbl.glUniform1d ) {
      driverTbl.glUniform1d = missing_glUniform1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1d == loader_glUniform1d) {
      rCtx->dsp.emuTbl.glUniform1d = driverTbl.glUniform1d;
   }
   driverTbl.glUniform1d(location, x);
}

static void REGAL_CALL missing_glUniform2d(GLint location, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glUniform2d" );
}

static void REGAL_CALL loader_glUniform2d(GLint location, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2d, "glUniform2d");
   if ( !driverTbl.glUniform2d ) {
      driverTbl.glUniform2d = missing_glUniform2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2d == loader_glUniform2d) {
      rCtx->dsp.emuTbl.glUniform2d = driverTbl.glUniform2d;
   }
   driverTbl.glUniform2d(location, x, y);
}

static void REGAL_CALL missing_glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glUniform3d" );
}

static void REGAL_CALL loader_glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3d, "glUniform3d");
   if ( !driverTbl.glUniform3d ) {
      driverTbl.glUniform3d = missing_glUniform3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3d == loader_glUniform3d) {
      rCtx->dsp.emuTbl.glUniform3d = driverTbl.glUniform3d;
   }
   driverTbl.glUniform3d(location, x, y, z);
}

static void REGAL_CALL missing_glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glUniform4d" );
}

static void REGAL_CALL loader_glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4d, "glUniform4d");
   if ( !driverTbl.glUniform4d ) {
      driverTbl.glUniform4d = missing_glUniform4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4d == loader_glUniform4d) {
      rCtx->dsp.emuTbl.glUniform4d = driverTbl.glUniform4d;
   }
   driverTbl.glUniform4d(location, x, y, z, w);
}

static void REGAL_CALL missing_glUniform1dv(GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform1dv" );
}

static void REGAL_CALL loader_glUniform1dv(GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1dv, "glUniform1dv");
   if ( !driverTbl.glUniform1dv ) {
      driverTbl.glUniform1dv = missing_glUniform1dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1dv == loader_glUniform1dv) {
      rCtx->dsp.emuTbl.glUniform1dv = driverTbl.glUniform1dv;
   }
   driverTbl.glUniform1dv(location, count, value);
}

static void REGAL_CALL missing_glUniform2dv(GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform2dv" );
}

static void REGAL_CALL loader_glUniform2dv(GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2dv, "glUniform2dv");
   if ( !driverTbl.glUniform2dv ) {
      driverTbl.glUniform2dv = missing_glUniform2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2dv == loader_glUniform2dv) {
      rCtx->dsp.emuTbl.glUniform2dv = driverTbl.glUniform2dv;
   }
   driverTbl.glUniform2dv(location, count, value);
}

static void REGAL_CALL missing_glUniform3dv(GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform3dv" );
}

static void REGAL_CALL loader_glUniform3dv(GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3dv, "glUniform3dv");
   if ( !driverTbl.glUniform3dv ) {
      driverTbl.glUniform3dv = missing_glUniform3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3dv == loader_glUniform3dv) {
      rCtx->dsp.emuTbl.glUniform3dv = driverTbl.glUniform3dv;
   }
   driverTbl.glUniform3dv(location, count, value);
}

static void REGAL_CALL missing_glUniform4dv(GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform4dv" );
}

static void REGAL_CALL loader_glUniform4dv(GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4dv, "glUniform4dv");
   if ( !driverTbl.glUniform4dv ) {
      driverTbl.glUniform4dv = missing_glUniform4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4dv == loader_glUniform4dv) {
      rCtx->dsp.emuTbl.glUniform4dv = driverTbl.glUniform4dv;
   }
   driverTbl.glUniform4dv(location, count, value);
}

static void REGAL_CALL missing_glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix2dv" );
}

static void REGAL_CALL loader_glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix2dv, "glUniformMatrix2dv");
   if ( !driverTbl.glUniformMatrix2dv ) {
      driverTbl.glUniformMatrix2dv = missing_glUniformMatrix2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix2dv == loader_glUniformMatrix2dv) {
      rCtx->dsp.emuTbl.glUniformMatrix2dv = driverTbl.glUniformMatrix2dv;
   }
   driverTbl.glUniformMatrix2dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix3dv" );
}

static void REGAL_CALL loader_glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix3dv, "glUniformMatrix3dv");
   if ( !driverTbl.glUniformMatrix3dv ) {
      driverTbl.glUniformMatrix3dv = missing_glUniformMatrix3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix3dv == loader_glUniformMatrix3dv) {
      rCtx->dsp.emuTbl.glUniformMatrix3dv = driverTbl.glUniformMatrix3dv;
   }
   driverTbl.glUniformMatrix3dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix4dv" );
}

static void REGAL_CALL loader_glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix4dv, "glUniformMatrix4dv");
   if ( !driverTbl.glUniformMatrix4dv ) {
      driverTbl.glUniformMatrix4dv = missing_glUniformMatrix4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix4dv == loader_glUniformMatrix4dv) {
      rCtx->dsp.emuTbl.glUniformMatrix4dv = driverTbl.glUniformMatrix4dv;
   }
   driverTbl.glUniformMatrix4dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix2x3dv" );
}

static void REGAL_CALL loader_glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix2x3dv, "glUniformMatrix2x3dv");
   if ( !driverTbl.glUniformMatrix2x3dv ) {
      driverTbl.glUniformMatrix2x3dv = missing_glUniformMatrix2x3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix2x3dv == loader_glUniformMatrix2x3dv) {
      rCtx->dsp.emuTbl.glUniformMatrix2x3dv = driverTbl.glUniformMatrix2x3dv;
   }
   driverTbl.glUniformMatrix2x3dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix2x4dv" );
}

static void REGAL_CALL loader_glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix2x4dv, "glUniformMatrix2x4dv");
   if ( !driverTbl.glUniformMatrix2x4dv ) {
      driverTbl.glUniformMatrix2x4dv = missing_glUniformMatrix2x4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix2x4dv == loader_glUniformMatrix2x4dv) {
      rCtx->dsp.emuTbl.glUniformMatrix2x4dv = driverTbl.glUniformMatrix2x4dv;
   }
   driverTbl.glUniformMatrix2x4dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix3x2dv" );
}

static void REGAL_CALL loader_glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix3x2dv, "glUniformMatrix3x2dv");
   if ( !driverTbl.glUniformMatrix3x2dv ) {
      driverTbl.glUniformMatrix3x2dv = missing_glUniformMatrix3x2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix3x2dv == loader_glUniformMatrix3x2dv) {
      rCtx->dsp.emuTbl.glUniformMatrix3x2dv = driverTbl.glUniformMatrix3x2dv;
   }
   driverTbl.glUniformMatrix3x2dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix3x4dv" );
}

static void REGAL_CALL loader_glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix3x4dv, "glUniformMatrix3x4dv");
   if ( !driverTbl.glUniformMatrix3x4dv ) {
      driverTbl.glUniformMatrix3x4dv = missing_glUniformMatrix3x4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix3x4dv == loader_glUniformMatrix3x4dv) {
      rCtx->dsp.emuTbl.glUniformMatrix3x4dv = driverTbl.glUniformMatrix3x4dv;
   }
   driverTbl.glUniformMatrix3x4dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix4x2dv" );
}

static void REGAL_CALL loader_glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix4x2dv, "glUniformMatrix4x2dv");
   if ( !driverTbl.glUniformMatrix4x2dv ) {
      driverTbl.glUniformMatrix4x2dv = missing_glUniformMatrix4x2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix4x2dv == loader_glUniformMatrix4x2dv) {
      rCtx->dsp.emuTbl.glUniformMatrix4x2dv = driverTbl.glUniformMatrix4x2dv;
   }
   driverTbl.glUniformMatrix4x2dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix4x3dv" );
}

static void REGAL_CALL loader_glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix4x3dv, "glUniformMatrix4x3dv");
   if ( !driverTbl.glUniformMatrix4x3dv ) {
      driverTbl.glUniformMatrix4x3dv = missing_glUniformMatrix4x3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix4x3dv == loader_glUniformMatrix4x3dv) {
      rCtx->dsp.emuTbl.glUniformMatrix4x3dv = driverTbl.glUniformMatrix4x3dv;
   }
   driverTbl.glUniformMatrix4x3dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glGetUniformdv(GLuint program, GLint location, GLdouble *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetUniformdv" );
}

static void REGAL_CALL loader_glGetUniformdv(GLuint program, GLint location, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformdv, "glGetUniformdv");
   if ( !driverTbl.glGetUniformdv ) {
      driverTbl.glGetUniformdv = missing_glGetUniformdv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformdv == loader_glGetUniformdv) {
      rCtx->dsp.emuTbl.glGetUniformdv = driverTbl.glGetUniformdv;
   }
   driverTbl.glGetUniformdv(program, location, params);
}

// GL_ARB_sample_shading

static void REGAL_CALL missing_glMinSampleShading(GLclampf value)
{
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glMinSampleShading" );
}

static void REGAL_CALL loader_glMinSampleShading(GLclampf value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMinSampleShading, "glMinSampleShading");
   if ( !driverTbl.glMinSampleShading ) {
      driverTbl.glMinSampleShading = missing_glMinSampleShading;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMinSampleShading == loader_glMinSampleShading) {
      rCtx->dsp.emuTbl.glMinSampleShading = driverTbl.glMinSampleShading;
   }
   driverTbl.glMinSampleShading(value);
}

// GL_ARB_tessellation_shader

static void REGAL_CALL missing_glPatchParameteri(GLenum pname, GLint value)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glPatchParameteri" );
}

static void REGAL_CALL loader_glPatchParameteri(GLenum pname, GLint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPatchParameteri, "glPatchParameteri");
   if ( !driverTbl.glPatchParameteri ) {
      driverTbl.glPatchParameteri = missing_glPatchParameteri;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPatchParameteri == loader_glPatchParameteri) {
      rCtx->dsp.emuTbl.glPatchParameteri = driverTbl.glPatchParameteri;
   }
   driverTbl.glPatchParameteri(pname, value);
}

static void REGAL_CALL missing_glPatchParameterfv(GLenum pname, const GLfloat *values)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glPatchParameterfv" );
}

static void REGAL_CALL loader_glPatchParameterfv(GLenum pname, const GLfloat *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPatchParameterfv, "glPatchParameterfv");
   if ( !driverTbl.glPatchParameterfv ) {
      driverTbl.glPatchParameterfv = missing_glPatchParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPatchParameterfv == loader_glPatchParameterfv) {
      rCtx->dsp.emuTbl.glPatchParameterfv = driverTbl.glPatchParameterfv;
   }
   driverTbl.glPatchParameterfv(pname, values);
}

// GL_ARB_transform_feedback2

static void REGAL_CALL missing_glGenTransformFeedbacks(GLsizei n, GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "Called missing function glGenTransformFeedbacks" );
}

static void REGAL_CALL loader_glGenTransformFeedbacks(GLsizei n, GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenTransformFeedbacks, "glGenTransformFeedbacks");
   if ( !driverTbl.glGenTransformFeedbacks ) {
      driverTbl.glGenTransformFeedbacks = missing_glGenTransformFeedbacks;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenTransformFeedbacks == loader_glGenTransformFeedbacks) {
      rCtx->dsp.emuTbl.glGenTransformFeedbacks = driverTbl.glGenTransformFeedbacks;
   }
   driverTbl.glGenTransformFeedbacks(n, ids);
}

static void REGAL_CALL missing_glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "Called missing function glDeleteTransformFeedbacks" );
}

static void REGAL_CALL loader_glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteTransformFeedbacks, "glDeleteTransformFeedbacks");
   if ( !driverTbl.glDeleteTransformFeedbacks ) {
      driverTbl.glDeleteTransformFeedbacks = missing_glDeleteTransformFeedbacks;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteTransformFeedbacks == loader_glDeleteTransformFeedbacks) {
      rCtx->dsp.emuTbl.glDeleteTransformFeedbacks = driverTbl.glDeleteTransformFeedbacks;
   }
   driverTbl.glDeleteTransformFeedbacks(n, ids);
}

static void REGAL_CALL missing_glBindTransformFeedback(GLenum target, GLuint id)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glBindTransformFeedback" );
}

static void REGAL_CALL loader_glBindTransformFeedback(GLenum target, GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindTransformFeedback, "glBindTransformFeedback");
   if ( !driverTbl.glBindTransformFeedback ) {
      driverTbl.glBindTransformFeedback = missing_glBindTransformFeedback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindTransformFeedback == loader_glBindTransformFeedback) {
      rCtx->dsp.emuTbl.glBindTransformFeedback = driverTbl.glBindTransformFeedback;
   }
   driverTbl.glBindTransformFeedback(target, id);
}

static GLboolean REGAL_CALL missing_glIsTransformFeedback(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glIsTransformFeedback" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsTransformFeedback(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsTransformFeedback, "glIsTransformFeedback");
   if ( !driverTbl.glIsTransformFeedback ) {
      driverTbl.glIsTransformFeedback = missing_glIsTransformFeedback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsTransformFeedback == loader_glIsTransformFeedback) {
      rCtx->dsp.emuTbl.glIsTransformFeedback = driverTbl.glIsTransformFeedback;
   }
   return driverTbl.glIsTransformFeedback(id);
}

static void REGAL_CALL missing_glPauseTransformFeedback(void)
{
   Warning( "Called missing function glPauseTransformFeedback" );
}

static void REGAL_CALL loader_glPauseTransformFeedback(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPauseTransformFeedback, "glPauseTransformFeedback");
   if ( !driverTbl.glPauseTransformFeedback ) {
      driverTbl.glPauseTransformFeedback = missing_glPauseTransformFeedback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPauseTransformFeedback == loader_glPauseTransformFeedback) {
      rCtx->dsp.emuTbl.glPauseTransformFeedback = driverTbl.glPauseTransformFeedback;
   }
   driverTbl.glPauseTransformFeedback();
}

static void REGAL_CALL missing_glResumeTransformFeedback(void)
{
   Warning( "Called missing function glResumeTransformFeedback" );
}

static void REGAL_CALL loader_glResumeTransformFeedback(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glResumeTransformFeedback, "glResumeTransformFeedback");
   if ( !driverTbl.glResumeTransformFeedback ) {
      driverTbl.glResumeTransformFeedback = missing_glResumeTransformFeedback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glResumeTransformFeedback == loader_glResumeTransformFeedback) {
      rCtx->dsp.emuTbl.glResumeTransformFeedback = driverTbl.glResumeTransformFeedback;
   }
   driverTbl.glResumeTransformFeedback();
}

static void REGAL_CALL missing_glDrawTransformFeedback(GLenum mode, GLuint name)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glDrawTransformFeedback" );
}

static void REGAL_CALL loader_glDrawTransformFeedback(GLenum mode, GLuint name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawTransformFeedback, "glDrawTransformFeedback");
   if ( !driverTbl.glDrawTransformFeedback ) {
      driverTbl.glDrawTransformFeedback = missing_glDrawTransformFeedback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawTransformFeedback == loader_glDrawTransformFeedback) {
      rCtx->dsp.emuTbl.glDrawTransformFeedback = driverTbl.glDrawTransformFeedback;
   }
   driverTbl.glDrawTransformFeedback(mode, name);
}

// GL_ARB_transform_feedback3

static void REGAL_CALL missing_glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(stream);
   Warning( "Called missing function glDrawTransformFeedbackStream" );
}

static void REGAL_CALL loader_glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawTransformFeedbackStream, "glDrawTransformFeedbackStream");
   if ( !driverTbl.glDrawTransformFeedbackStream ) {
      driverTbl.glDrawTransformFeedbackStream = missing_glDrawTransformFeedbackStream;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawTransformFeedbackStream == loader_glDrawTransformFeedbackStream) {
      rCtx->dsp.emuTbl.glDrawTransformFeedbackStream = driverTbl.glDrawTransformFeedbackStream;
   }
   driverTbl.glDrawTransformFeedbackStream(mode, id, stream);
}

static void REGAL_CALL missing_glBeginQueryIndexed(GLenum target, GLuint index, GLuint id)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glBeginQueryIndexed" );
}

static void REGAL_CALL loader_glBeginQueryIndexed(GLenum target, GLuint index, GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBeginQueryIndexed, "glBeginQueryIndexed");
   if ( !driverTbl.glBeginQueryIndexed ) {
      driverTbl.glBeginQueryIndexed = missing_glBeginQueryIndexed;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBeginQueryIndexed == loader_glBeginQueryIndexed) {
      rCtx->dsp.emuTbl.glBeginQueryIndexed = driverTbl.glBeginQueryIndexed;
   }
   driverTbl.glBeginQueryIndexed(target, index, id);
}

static void REGAL_CALL missing_glEndQueryIndexed(GLenum target, GLuint index)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glEndQueryIndexed" );
}

static void REGAL_CALL loader_glEndQueryIndexed(GLenum target, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndQueryIndexed, "glEndQueryIndexed");
   if ( !driverTbl.glEndQueryIndexed ) {
      driverTbl.glEndQueryIndexed = missing_glEndQueryIndexed;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndQueryIndexed == loader_glEndQueryIndexed) {
      rCtx->dsp.emuTbl.glEndQueryIndexed = driverTbl.glEndQueryIndexed;
   }
   driverTbl.glEndQueryIndexed(target, index);
}

static void REGAL_CALL missing_glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetQueryIndexediv" );
}

static void REGAL_CALL loader_glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetQueryIndexediv, "glGetQueryIndexediv");
   if ( !driverTbl.glGetQueryIndexediv ) {
      driverTbl.glGetQueryIndexediv = missing_glGetQueryIndexediv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetQueryIndexediv == loader_glGetQueryIndexediv) {
      rCtx->dsp.emuTbl.glGetQueryIndexediv = driverTbl.glGetQueryIndexediv;
   }
   driverTbl.glGetQueryIndexediv(target, index, pname, params);
}

// GL_ARB_shader_subroutine

static GLint REGAL_CALL missing_glGetSubroutineUniformLocation(GLuint program, GLenum shaderType, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetSubroutineUniformLocation" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetSubroutineUniformLocation(GLuint program, GLenum shaderType, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetSubroutineUniformLocation, "glGetSubroutineUniformLocation");
   if ( !driverTbl.glGetSubroutineUniformLocation ) {
      driverTbl.glGetSubroutineUniformLocation = missing_glGetSubroutineUniformLocation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetSubroutineUniformLocation == loader_glGetSubroutineUniformLocation) {
      rCtx->dsp.emuTbl.glGetSubroutineUniformLocation = driverTbl.glGetSubroutineUniformLocation;
   }
   return driverTbl.glGetSubroutineUniformLocation(program, shaderType, name);
}

static GLuint REGAL_CALL missing_glGetSubroutineIndex(GLuint program, GLenum shaderType, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetSubroutineIndex" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGetSubroutineIndex(GLuint program, GLenum shaderType, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetSubroutineIndex, "glGetSubroutineIndex");
   if ( !driverTbl.glGetSubroutineIndex ) {
      driverTbl.glGetSubroutineIndex = missing_glGetSubroutineIndex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetSubroutineIndex == loader_glGetSubroutineIndex) {
      rCtx->dsp.emuTbl.glGetSubroutineIndex = driverTbl.glGetSubroutineIndex;
   }
   return driverTbl.glGetSubroutineIndex(program, shaderType, name);
}

static void REGAL_CALL missing_glGetActiveSubroutineUniformiv(GLuint program, GLenum shaderType, GLuint index, GLenum pname, GLint *values)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetActiveSubroutineUniformiv" );
}

static void REGAL_CALL loader_glGetActiveSubroutineUniformiv(GLuint program, GLenum shaderType, GLuint index, GLenum pname, GLint *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetActiveSubroutineUniformiv, "glGetActiveSubroutineUniformiv");
   if ( !driverTbl.glGetActiveSubroutineUniformiv ) {
      driverTbl.glGetActiveSubroutineUniformiv = missing_glGetActiveSubroutineUniformiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetActiveSubroutineUniformiv == loader_glGetActiveSubroutineUniformiv) {
      rCtx->dsp.emuTbl.glGetActiveSubroutineUniformiv = driverTbl.glGetActiveSubroutineUniformiv;
   }
   driverTbl.glGetActiveSubroutineUniformiv(program, shaderType, index, pname, values);
}

static void REGAL_CALL missing_glGetActiveSubroutineUniformName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetActiveSubroutineUniformName" );
}

static void REGAL_CALL loader_glGetActiveSubroutineUniformName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetActiveSubroutineUniformName, "glGetActiveSubroutineUniformName");
   if ( !driverTbl.glGetActiveSubroutineUniformName ) {
      driverTbl.glGetActiveSubroutineUniformName = missing_glGetActiveSubroutineUniformName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetActiveSubroutineUniformName == loader_glGetActiveSubroutineUniformName) {
      rCtx->dsp.emuTbl.glGetActiveSubroutineUniformName = driverTbl.glGetActiveSubroutineUniformName;
   }
   driverTbl.glGetActiveSubroutineUniformName(program, shaderType, index, bufSize, length, name);
}

static void REGAL_CALL missing_glGetActiveSubroutineName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetActiveSubroutineName" );
}

static void REGAL_CALL loader_glGetActiveSubroutineName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetActiveSubroutineName, "glGetActiveSubroutineName");
   if ( !driverTbl.glGetActiveSubroutineName ) {
      driverTbl.glGetActiveSubroutineName = missing_glGetActiveSubroutineName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetActiveSubroutineName == loader_glGetActiveSubroutineName) {
      rCtx->dsp.emuTbl.glGetActiveSubroutineName = driverTbl.glGetActiveSubroutineName;
   }
   driverTbl.glGetActiveSubroutineName(program, shaderType, index, bufSize, length, name);
}

static void REGAL_CALL missing_glUniformSubroutinesuiv(GLenum shaderType, GLsizei count, const GLuint *indices)
{
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(indices);
   Warning( "Called missing function glUniformSubroutinesuiv" );
}

static void REGAL_CALL loader_glUniformSubroutinesuiv(GLenum shaderType, GLsizei count, const GLuint *indices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformSubroutinesuiv, "glUniformSubroutinesuiv");
   if ( !driverTbl.glUniformSubroutinesuiv ) {
      driverTbl.glUniformSubroutinesuiv = missing_glUniformSubroutinesuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformSubroutinesuiv == loader_glUniformSubroutinesuiv) {
      rCtx->dsp.emuTbl.glUniformSubroutinesuiv = driverTbl.glUniformSubroutinesuiv;
   }
   driverTbl.glUniformSubroutinesuiv(shaderType, count, indices);
}

static void REGAL_CALL missing_glGetUniformSubroutineuiv(GLenum shaderType, GLint location, GLuint *params)
{
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetUniformSubroutineuiv" );
}

static void REGAL_CALL loader_glGetUniformSubroutineuiv(GLenum shaderType, GLint location, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformSubroutineuiv, "glGetUniformSubroutineuiv");
   if ( !driverTbl.glGetUniformSubroutineuiv ) {
      driverTbl.glGetUniformSubroutineuiv = missing_glGetUniformSubroutineuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformSubroutineuiv == loader_glGetUniformSubroutineuiv) {
      rCtx->dsp.emuTbl.glGetUniformSubroutineuiv = driverTbl.glGetUniformSubroutineuiv;
   }
   driverTbl.glGetUniformSubroutineuiv(shaderType, location, params);
}

static void REGAL_CALL missing_glGetProgramStageiv(GLuint program, GLenum shaderType, GLenum pname, GLint *values)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetProgramStageiv" );
}

static void REGAL_CALL loader_glGetProgramStageiv(GLuint program, GLenum shaderType, GLenum pname, GLint *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramStageiv, "glGetProgramStageiv");
   if ( !driverTbl.glGetProgramStageiv ) {
      driverTbl.glGetProgramStageiv = missing_glGetProgramStageiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramStageiv == loader_glGetProgramStageiv) {
      rCtx->dsp.emuTbl.glGetProgramStageiv = driverTbl.glGetProgramStageiv;
   }
   driverTbl.glGetProgramStageiv(program, shaderType, pname, values);
}

// GL_ARB_vertex_attrib_64bit

static void REGAL_CALL missing_glVertexAttribL1d(GLuint index, GLdouble x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttribL1d" );
}

static void REGAL_CALL loader_glVertexAttribL1d(GLuint index, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL1d, "glVertexAttribL1d");
   if ( !driverTbl.glVertexAttribL1d ) {
      driverTbl.glVertexAttribL1d = missing_glVertexAttribL1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL1d == loader_glVertexAttribL1d) {
      rCtx->dsp.emuTbl.glVertexAttribL1d = driverTbl.glVertexAttribL1d;
   }
   driverTbl.glVertexAttribL1d(index, x);
}

static void REGAL_CALL missing_glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttribL2d" );
}

static void REGAL_CALL loader_glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL2d, "glVertexAttribL2d");
   if ( !driverTbl.glVertexAttribL2d ) {
      driverTbl.glVertexAttribL2d = missing_glVertexAttribL2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL2d == loader_glVertexAttribL2d) {
      rCtx->dsp.emuTbl.glVertexAttribL2d = driverTbl.glVertexAttribL2d;
   }
   driverTbl.glVertexAttribL2d(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttribL3d" );
}

static void REGAL_CALL loader_glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL3d, "glVertexAttribL3d");
   if ( !driverTbl.glVertexAttribL3d ) {
      driverTbl.glVertexAttribL3d = missing_glVertexAttribL3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL3d == loader_glVertexAttribL3d) {
      rCtx->dsp.emuTbl.glVertexAttribL3d = driverTbl.glVertexAttribL3d;
   }
   driverTbl.glVertexAttribL3d(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttribL4d" );
}

static void REGAL_CALL loader_glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL4d, "glVertexAttribL4d");
   if ( !driverTbl.glVertexAttribL4d ) {
      driverTbl.glVertexAttribL4d = missing_glVertexAttribL4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL4d == loader_glVertexAttribL4d) {
      rCtx->dsp.emuTbl.glVertexAttribL4d = driverTbl.glVertexAttribL4d;
   }
   driverTbl.glVertexAttribL4d(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribL1dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL1dv" );
}

static void REGAL_CALL loader_glVertexAttribL1dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL1dv, "glVertexAttribL1dv");
   if ( !driverTbl.glVertexAttribL1dv ) {
      driverTbl.glVertexAttribL1dv = missing_glVertexAttribL1dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL1dv == loader_glVertexAttribL1dv) {
      rCtx->dsp.emuTbl.glVertexAttribL1dv = driverTbl.glVertexAttribL1dv;
   }
   driverTbl.glVertexAttribL1dv(index, v);
}

static void REGAL_CALL missing_glVertexAttribL2dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL2dv" );
}

static void REGAL_CALL loader_glVertexAttribL2dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL2dv, "glVertexAttribL2dv");
   if ( !driverTbl.glVertexAttribL2dv ) {
      driverTbl.glVertexAttribL2dv = missing_glVertexAttribL2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL2dv == loader_glVertexAttribL2dv) {
      rCtx->dsp.emuTbl.glVertexAttribL2dv = driverTbl.glVertexAttribL2dv;
   }
   driverTbl.glVertexAttribL2dv(index, v);
}

static void REGAL_CALL missing_glVertexAttribL3dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL3dv" );
}

static void REGAL_CALL loader_glVertexAttribL3dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL3dv, "glVertexAttribL3dv");
   if ( !driverTbl.glVertexAttribL3dv ) {
      driverTbl.glVertexAttribL3dv = missing_glVertexAttribL3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL3dv == loader_glVertexAttribL3dv) {
      rCtx->dsp.emuTbl.glVertexAttribL3dv = driverTbl.glVertexAttribL3dv;
   }
   driverTbl.glVertexAttribL3dv(index, v);
}

static void REGAL_CALL missing_glVertexAttribL4dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL4dv" );
}

static void REGAL_CALL loader_glVertexAttribL4dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL4dv, "glVertexAttribL4dv");
   if ( !driverTbl.glVertexAttribL4dv ) {
      driverTbl.glVertexAttribL4dv = missing_glVertexAttribL4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL4dv == loader_glVertexAttribL4dv) {
      rCtx->dsp.emuTbl.glVertexAttribL4dv = driverTbl.glVertexAttribL4dv;
   }
   driverTbl.glVertexAttribL4dv(index, v);
}

static void REGAL_CALL missing_glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glVertexAttribLPointer" );
}

static void REGAL_CALL loader_glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribLPointer, "glVertexAttribLPointer");
   if ( !driverTbl.glVertexAttribLPointer ) {
      driverTbl.glVertexAttribLPointer = missing_glVertexAttribLPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribLPointer == loader_glVertexAttribLPointer) {
      rCtx->dsp.emuTbl.glVertexAttribLPointer = driverTbl.glVertexAttribLPointer;
   }
   driverTbl.glVertexAttribLPointer(index, size, type, stride, pointer);
}

static void REGAL_CALL missing_glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribLdv" );
}

static void REGAL_CALL loader_glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribLdv, "glGetVertexAttribLdv");
   if ( !driverTbl.glGetVertexAttribLdv ) {
      driverTbl.glGetVertexAttribLdv = missing_glGetVertexAttribLdv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribLdv == loader_glGetVertexAttribLdv) {
      rCtx->dsp.emuTbl.glGetVertexAttribLdv = driverTbl.glGetVertexAttribLdv;
   }
   driverTbl.glGetVertexAttribLdv(index, pname, params);
}

// GL_ARB_ES2_compatibility

static void REGAL_CALL missing_glReleaseShaderCompiler(void)
{
   Warning( "Called missing function glReleaseShaderCompiler" );
}

static void REGAL_CALL loader_glReleaseShaderCompiler(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReleaseShaderCompiler, "glReleaseShaderCompiler");
   if ( !driverTbl.glReleaseShaderCompiler ) {
      driverTbl.glReleaseShaderCompiler = missing_glReleaseShaderCompiler;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReleaseShaderCompiler == loader_glReleaseShaderCompiler) {
      rCtx->dsp.emuTbl.glReleaseShaderCompiler = driverTbl.glReleaseShaderCompiler;
   }
   driverTbl.glReleaseShaderCompiler();
}

static void REGAL_CALL missing_glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length)
{
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(shaders);
   UNUSED_PARAMETER(binaryformat);
   UNUSED_PARAMETER(binary);
   UNUSED_PARAMETER(length);
   Warning( "Called missing function glShaderBinary" );
}

static void REGAL_CALL loader_glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glShaderBinary, "glShaderBinary");
   if ( !driverTbl.glShaderBinary ) {
      driverTbl.glShaderBinary = missing_glShaderBinary;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glShaderBinary == loader_glShaderBinary) {
      rCtx->dsp.emuTbl.glShaderBinary = driverTbl.glShaderBinary;
   }
   driverTbl.glShaderBinary(count, shaders, binaryformat, binary, length);
}

static void REGAL_CALL missing_glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision)
{
   UNUSED_PARAMETER(shadertype);
   UNUSED_PARAMETER(precisiontype);
   UNUSED_PARAMETER(range);
   UNUSED_PARAMETER(precision);
   Warning( "Called missing function glGetShaderPrecisionFormat" );
}

static void REGAL_CALL loader_glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetShaderPrecisionFormat, "glGetShaderPrecisionFormat");
   if ( !driverTbl.glGetShaderPrecisionFormat ) {
      driverTbl.glGetShaderPrecisionFormat = missing_glGetShaderPrecisionFormat;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetShaderPrecisionFormat == loader_glGetShaderPrecisionFormat) {
      rCtx->dsp.emuTbl.glGetShaderPrecisionFormat = driverTbl.glGetShaderPrecisionFormat;
   }
   driverTbl.glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision);
}

static void REGAL_CALL missing_glDepthRangef(GLclampf n, GLclampf f)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(f);
   Warning( "Called missing function glDepthRangef" );
}

static void REGAL_CALL loader_glDepthRangef(GLclampf n, GLclampf f)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDepthRangef, "glDepthRangef");
   if ( !driverTbl.glDepthRangef ) {
      driverTbl.glDepthRangef = missing_glDepthRangef;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDepthRangef == loader_glDepthRangef) {
      rCtx->dsp.emuTbl.glDepthRangef = driverTbl.glDepthRangef;
   }
   driverTbl.glDepthRangef(n, f);
}

static void REGAL_CALL missing_glClearDepthf(GLclampf d)
{
   UNUSED_PARAMETER(d);
   Warning( "Called missing function glClearDepthf" );
}

static void REGAL_CALL loader_glClearDepthf(GLclampf d)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClearDepthf, "glClearDepthf");
   if ( !driverTbl.glClearDepthf ) {
      driverTbl.glClearDepthf = missing_glClearDepthf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClearDepthf == loader_glClearDepthf) {
      rCtx->dsp.emuTbl.glClearDepthf = driverTbl.glClearDepthf;
   }
   driverTbl.glClearDepthf(d);
}

// GL_ARB_get_program_binary

static void REGAL_CALL missing_glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(binaryFormat);
   UNUSED_PARAMETER(binary);
   Warning( "Called missing function glGetProgramBinary" );
}

static void REGAL_CALL loader_glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramBinary, "glGetProgramBinary");
   if ( !driverTbl.glGetProgramBinary ) {
      driverTbl.glGetProgramBinary = missing_glGetProgramBinary;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramBinary == loader_glGetProgramBinary) {
      rCtx->dsp.emuTbl.glGetProgramBinary = driverTbl.glGetProgramBinary;
   }
   driverTbl.glGetProgramBinary(program, bufSize, length, binaryFormat, binary);
}

static void REGAL_CALL missing_glProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(binaryFormat);
   UNUSED_PARAMETER(binary);
   UNUSED_PARAMETER(length);
   Warning( "Called missing function glProgramBinary" );
}

static void REGAL_CALL loader_glProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramBinary, "glProgramBinary");
   if ( !driverTbl.glProgramBinary ) {
      driverTbl.glProgramBinary = missing_glProgramBinary;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramBinary == loader_glProgramBinary) {
      rCtx->dsp.emuTbl.glProgramBinary = driverTbl.glProgramBinary;
   }
   driverTbl.glProgramBinary(program, binaryFormat, binary, length);
}

static void REGAL_CALL missing_glProgramParameteri(GLuint program, GLenum pname, GLint value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramParameteri" );
}

static void REGAL_CALL loader_glProgramParameteri(GLuint program, GLenum pname, GLint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramParameteri, "glProgramParameteri");
   if ( !driverTbl.glProgramParameteri ) {
      driverTbl.glProgramParameteri = missing_glProgramParameteri;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramParameteri == loader_glProgramParameteri) {
      rCtx->dsp.emuTbl.glProgramParameteri = driverTbl.glProgramParameteri;
   }
   driverTbl.glProgramParameteri(program, pname, value);
}

// GL_ARB_viewport_array

static void REGAL_CALL missing_glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v)
{
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glViewportArrayv" );
}

static void REGAL_CALL loader_glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glViewportArrayv, "glViewportArrayv");
   if ( !driverTbl.glViewportArrayv ) {
      driverTbl.glViewportArrayv = missing_glViewportArrayv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glViewportArrayv == loader_glViewportArrayv) {
      rCtx->dsp.emuTbl.glViewportArrayv = driverTbl.glViewportArrayv;
   }
   driverTbl.glViewportArrayv(first, count, v);
}

static void REGAL_CALL missing_glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(w);
   UNUSED_PARAMETER(h);
   Warning( "Called missing function glViewportIndexedf" );
}

static void REGAL_CALL loader_glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glViewportIndexedf, "glViewportIndexedf");
   if ( !driverTbl.glViewportIndexedf ) {
      driverTbl.glViewportIndexedf = missing_glViewportIndexedf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glViewportIndexedf == loader_glViewportIndexedf) {
      rCtx->dsp.emuTbl.glViewportIndexedf = driverTbl.glViewportIndexedf;
   }
   driverTbl.glViewportIndexedf(index, x, y, w, h);
}

static void REGAL_CALL missing_glViewportIndexedfv(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glViewportIndexedfv" );
}

static void REGAL_CALL loader_glViewportIndexedfv(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glViewportIndexedfv, "glViewportIndexedfv");
   if ( !driverTbl.glViewportIndexedfv ) {
      driverTbl.glViewportIndexedfv = missing_glViewportIndexedfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glViewportIndexedfv == loader_glViewportIndexedfv) {
      rCtx->dsp.emuTbl.glViewportIndexedfv = driverTbl.glViewportIndexedfv;
   }
   driverTbl.glViewportIndexedfv(index, v);
}

static void REGAL_CALL missing_glScissorArrayv(GLuint first, GLsizei count, const GLint *v)
{
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glScissorArrayv" );
}

static void REGAL_CALL loader_glScissorArrayv(GLuint first, GLsizei count, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glScissorArrayv, "glScissorArrayv");
   if ( !driverTbl.glScissorArrayv ) {
      driverTbl.glScissorArrayv = missing_glScissorArrayv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glScissorArrayv == loader_glScissorArrayv) {
      rCtx->dsp.emuTbl.glScissorArrayv = driverTbl.glScissorArrayv;
   }
   driverTbl.glScissorArrayv(first, count, v);
}

static void REGAL_CALL missing_glScissorIndexed(GLuint index, GLint left, GLint bottom, GLint width, GLint height)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(left);
   UNUSED_PARAMETER(bottom);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glScissorIndexed" );
}

static void REGAL_CALL loader_glScissorIndexed(GLuint index, GLint left, GLint bottom, GLint width, GLint height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glScissorIndexed, "glScissorIndexed");
   if ( !driverTbl.glScissorIndexed ) {
      driverTbl.glScissorIndexed = missing_glScissorIndexed;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glScissorIndexed == loader_glScissorIndexed) {
      rCtx->dsp.emuTbl.glScissorIndexed = driverTbl.glScissorIndexed;
   }
   driverTbl.glScissorIndexed(index, left, bottom, width, height);
}

static void REGAL_CALL missing_glScissorIndexedv(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glScissorIndexedv" );
}

static void REGAL_CALL loader_glScissorIndexedv(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glScissorIndexedv, "glScissorIndexedv");
   if ( !driverTbl.glScissorIndexedv ) {
      driverTbl.glScissorIndexedv = missing_glScissorIndexedv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glScissorIndexedv == loader_glScissorIndexedv) {
      rCtx->dsp.emuTbl.glScissorIndexedv = driverTbl.glScissorIndexedv;
   }
   driverTbl.glScissorIndexedv(index, v);
}

static void REGAL_CALL missing_glDepthRangeArrayv(GLuint first, GLsizei count, const GLclampd *v)
{
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glDepthRangeArrayv" );
}

static void REGAL_CALL loader_glDepthRangeArrayv(GLuint first, GLsizei count, const GLclampd *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDepthRangeArrayv, "glDepthRangeArrayv");
   if ( !driverTbl.glDepthRangeArrayv ) {
      driverTbl.glDepthRangeArrayv = missing_glDepthRangeArrayv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDepthRangeArrayv == loader_glDepthRangeArrayv) {
      rCtx->dsp.emuTbl.glDepthRangeArrayv = driverTbl.glDepthRangeArrayv;
   }
   driverTbl.glDepthRangeArrayv(first, count, v);
}

static void REGAL_CALL missing_glDepthRangeIndexed(GLuint index, GLclampd n, GLclampd f)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(f);
   Warning( "Called missing function glDepthRangeIndexed" );
}

static void REGAL_CALL loader_glDepthRangeIndexed(GLuint index, GLclampd n, GLclampd f)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDepthRangeIndexed, "glDepthRangeIndexed");
   if ( !driverTbl.glDepthRangeIndexed ) {
      driverTbl.glDepthRangeIndexed = missing_glDepthRangeIndexed;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDepthRangeIndexed == loader_glDepthRangeIndexed) {
      rCtx->dsp.emuTbl.glDepthRangeIndexed = driverTbl.glDepthRangeIndexed;
   }
   driverTbl.glDepthRangeIndexed(index, n, f);
}

static void REGAL_CALL missing_glGetFloati_v(GLenum target, GLuint index, GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glGetFloati_v" );
}

static void REGAL_CALL loader_glGetFloati_v(GLenum target, GLuint index, GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFloati_v, "glGetFloati_v");
   if ( !driverTbl.glGetFloati_v ) {
      driverTbl.glGetFloati_v = missing_glGetFloati_v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFloati_v == loader_glGetFloati_v) {
      rCtx->dsp.emuTbl.glGetFloati_v = driverTbl.glGetFloati_v;
   }
   driverTbl.glGetFloati_v(target, index, v);
}

static void REGAL_CALL missing_glGetDoublei_v(GLenum target, GLuint index, GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glGetDoublei_v" );
}

static void REGAL_CALL loader_glGetDoublei_v(GLenum target, GLuint index, GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetDoublei_v, "glGetDoublei_v");
   if ( !driverTbl.glGetDoublei_v ) {
      driverTbl.glGetDoublei_v = missing_glGetDoublei_v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetDoublei_v == loader_glGetDoublei_v) {
      rCtx->dsp.emuTbl.glGetDoublei_v = driverTbl.glGetDoublei_v;
   }
   driverTbl.glGetDoublei_v(target, index, v);
}

// GL_ARB_separate_shader_objects

static void REGAL_CALL missing_glActiveShaderProgram(GLuint pipeline, GLuint program)
{
   UNUSED_PARAMETER(pipeline);
   UNUSED_PARAMETER(program);
   Warning( "Called missing function glActiveShaderProgram" );
}

static void REGAL_CALL loader_glActiveShaderProgram(GLuint pipeline, GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glActiveShaderProgram, "glActiveShaderProgram");
   if ( !driverTbl.glActiveShaderProgram ) {
      driverTbl.glActiveShaderProgram = missing_glActiveShaderProgram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glActiveShaderProgram == loader_glActiveShaderProgram) {
      rCtx->dsp.emuTbl.glActiveShaderProgram = driverTbl.glActiveShaderProgram;
   }
   driverTbl.glActiveShaderProgram(pipeline, program);
}

static void REGAL_CALL missing_glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)
{
   UNUSED_PARAMETER(pipeline);
   UNUSED_PARAMETER(stages);
   UNUSED_PARAMETER(program);
   Warning( "Called missing function glUseProgramStages" );
}

static void REGAL_CALL loader_glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUseProgramStages, "glUseProgramStages");
   if ( !driverTbl.glUseProgramStages ) {
      driverTbl.glUseProgramStages = missing_glUseProgramStages;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUseProgramStages == loader_glUseProgramStages) {
      rCtx->dsp.emuTbl.glUseProgramStages = driverTbl.glUseProgramStages;
   }
   driverTbl.glUseProgramStages(pipeline, stages, program);
}

static GLuint REGAL_CALL missing_glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar **strings)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(strings);
   Warning( "Called missing function glCreateShaderProgramv" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar **strings)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCreateShaderProgramv, "glCreateShaderProgramv");
   if ( !driverTbl.glCreateShaderProgramv ) {
      driverTbl.glCreateShaderProgramv = missing_glCreateShaderProgramv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCreateShaderProgramv == loader_glCreateShaderProgramv) {
      rCtx->dsp.emuTbl.glCreateShaderProgramv = driverTbl.glCreateShaderProgramv;
   }
   return driverTbl.glCreateShaderProgramv(type, count, strings);
}

static void REGAL_CALL missing_glBindProgramPipeline(GLuint pipeline)
{
   UNUSED_PARAMETER(pipeline);
   Warning( "Called missing function glBindProgramPipeline" );
}

static void REGAL_CALL loader_glBindProgramPipeline(GLuint pipeline)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindProgramPipeline, "glBindProgramPipeline");
   if ( !driverTbl.glBindProgramPipeline ) {
      driverTbl.glBindProgramPipeline = missing_glBindProgramPipeline;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindProgramPipeline == loader_glBindProgramPipeline) {
      rCtx->dsp.emuTbl.glBindProgramPipeline = driverTbl.glBindProgramPipeline;
   }
   driverTbl.glBindProgramPipeline(pipeline);
}

static void REGAL_CALL missing_glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(pipelines);
   Warning( "Called missing function glDeleteProgramPipelines" );
}

static void REGAL_CALL loader_glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteProgramPipelines, "glDeleteProgramPipelines");
   if ( !driverTbl.glDeleteProgramPipelines ) {
      driverTbl.glDeleteProgramPipelines = missing_glDeleteProgramPipelines;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteProgramPipelines == loader_glDeleteProgramPipelines) {
      rCtx->dsp.emuTbl.glDeleteProgramPipelines = driverTbl.glDeleteProgramPipelines;
   }
   driverTbl.glDeleteProgramPipelines(n, pipelines);
}

static void REGAL_CALL missing_glGenProgramPipelines(GLsizei n, GLuint *pipelines)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(pipelines);
   Warning( "Called missing function glGenProgramPipelines" );
}

static void REGAL_CALL loader_glGenProgramPipelines(GLsizei n, GLuint *pipelines)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenProgramPipelines, "glGenProgramPipelines");
   if ( !driverTbl.glGenProgramPipelines ) {
      driverTbl.glGenProgramPipelines = missing_glGenProgramPipelines;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenProgramPipelines == loader_glGenProgramPipelines) {
      rCtx->dsp.emuTbl.glGenProgramPipelines = driverTbl.glGenProgramPipelines;
   }
   driverTbl.glGenProgramPipelines(n, pipelines);
}

static GLboolean REGAL_CALL missing_glIsProgramPipeline(GLuint pipeline)
{
   UNUSED_PARAMETER(pipeline);
   Warning( "Called missing function glIsProgramPipeline" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsProgramPipeline(GLuint pipeline)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsProgramPipeline, "glIsProgramPipeline");
   if ( !driverTbl.glIsProgramPipeline ) {
      driverTbl.glIsProgramPipeline = missing_glIsProgramPipeline;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsProgramPipeline == loader_glIsProgramPipeline) {
      rCtx->dsp.emuTbl.glIsProgramPipeline = driverTbl.glIsProgramPipeline;
   }
   return driverTbl.glIsProgramPipeline(pipeline);
}

static void REGAL_CALL missing_glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(pipeline);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramPipelineiv" );
}

static void REGAL_CALL loader_glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramPipelineiv, "glGetProgramPipelineiv");
   if ( !driverTbl.glGetProgramPipelineiv ) {
      driverTbl.glGetProgramPipelineiv = missing_glGetProgramPipelineiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramPipelineiv == loader_glGetProgramPipelineiv) {
      rCtx->dsp.emuTbl.glGetProgramPipelineiv = driverTbl.glGetProgramPipelineiv;
   }
   driverTbl.glGetProgramPipelineiv(pipeline, pname, params);
}

static void REGAL_CALL missing_glValidateProgramPipeline(GLuint pipeline)
{
   UNUSED_PARAMETER(pipeline);
   Warning( "Called missing function glValidateProgramPipeline" );
}

static void REGAL_CALL loader_glValidateProgramPipeline(GLuint pipeline)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glValidateProgramPipeline, "glValidateProgramPipeline");
   if ( !driverTbl.glValidateProgramPipeline ) {
      driverTbl.glValidateProgramPipeline = missing_glValidateProgramPipeline;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glValidateProgramPipeline == loader_glValidateProgramPipeline) {
      rCtx->dsp.emuTbl.glValidateProgramPipeline = driverTbl.glValidateProgramPipeline;
   }
   driverTbl.glValidateProgramPipeline(pipeline);
}

static void REGAL_CALL missing_glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
   UNUSED_PARAMETER(pipeline);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(infoLog);
   Warning( "Called missing function glGetProgramPipelineInfoLog" );
}

static void REGAL_CALL loader_glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramPipelineInfoLog, "glGetProgramPipelineInfoLog");
   if ( !driverTbl.glGetProgramPipelineInfoLog ) {
      driverTbl.glGetProgramPipelineInfoLog = missing_glGetProgramPipelineInfoLog;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramPipelineInfoLog == loader_glGetProgramPipelineInfoLog) {
      rCtx->dsp.emuTbl.glGetProgramPipelineInfoLog = driverTbl.glGetProgramPipelineInfoLog;
   }
   driverTbl.glGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
}

static void REGAL_CALL missing_glProgramUniform1f(GLuint program, GLint location, GLfloat x)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glProgramUniform1f" );
}

static void REGAL_CALL loader_glProgramUniform1f(GLuint program, GLint location, GLfloat x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1f, "glProgramUniform1f");
   if ( !driverTbl.glProgramUniform1f ) {
      driverTbl.glProgramUniform1f = missing_glProgramUniform1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1f == loader_glProgramUniform1f) {
      rCtx->dsp.emuTbl.glProgramUniform1f = driverTbl.glProgramUniform1f;
   }
   driverTbl.glProgramUniform1f(program, location, x);
}

static void REGAL_CALL missing_glProgramUniform2f(GLuint program, GLint location, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glProgramUniform2f" );
}

static void REGAL_CALL loader_glProgramUniform2f(GLuint program, GLint location, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2f, "glProgramUniform2f");
   if ( !driverTbl.glProgramUniform2f ) {
      driverTbl.glProgramUniform2f = missing_glProgramUniform2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2f == loader_glProgramUniform2f) {
      rCtx->dsp.emuTbl.glProgramUniform2f = driverTbl.glProgramUniform2f;
   }
   driverTbl.glProgramUniform2f(program, location, x, y);
}

static void REGAL_CALL missing_glProgramUniform3f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glProgramUniform3f" );
}

static void REGAL_CALL loader_glProgramUniform3f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3f, "glProgramUniform3f");
   if ( !driverTbl.glProgramUniform3f ) {
      driverTbl.glProgramUniform3f = missing_glProgramUniform3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3f == loader_glProgramUniform3f) {
      rCtx->dsp.emuTbl.glProgramUniform3f = driverTbl.glProgramUniform3f;
   }
   driverTbl.glProgramUniform3f(program, location, x, y, z);
}

static void REGAL_CALL missing_glProgramUniform4f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramUniform4f" );
}

static void REGAL_CALL loader_glProgramUniform4f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4f, "glProgramUniform4f");
   if ( !driverTbl.glProgramUniform4f ) {
      driverTbl.glProgramUniform4f = missing_glProgramUniform4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4f == loader_glProgramUniform4f) {
      rCtx->dsp.emuTbl.glProgramUniform4f = driverTbl.glProgramUniform4f;
   }
   driverTbl.glProgramUniform4f(program, location, x, y, z, w);
}

static void REGAL_CALL missing_glProgramUniform1i(GLuint program, GLint location, GLint x)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glProgramUniform1i" );
}

static void REGAL_CALL loader_glProgramUniform1i(GLuint program, GLint location, GLint x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1i, "glProgramUniform1i");
   if ( !driverTbl.glProgramUniform1i ) {
      driverTbl.glProgramUniform1i = missing_glProgramUniform1i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1i == loader_glProgramUniform1i) {
      rCtx->dsp.emuTbl.glProgramUniform1i = driverTbl.glProgramUniform1i;
   }
   driverTbl.glProgramUniform1i(program, location, x);
}

static void REGAL_CALL missing_glProgramUniform2i(GLuint program, GLint location, GLint x, GLint y)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glProgramUniform2i" );
}

static void REGAL_CALL loader_glProgramUniform2i(GLuint program, GLint location, GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2i, "glProgramUniform2i");
   if ( !driverTbl.glProgramUniform2i ) {
      driverTbl.glProgramUniform2i = missing_glProgramUniform2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2i == loader_glProgramUniform2i) {
      rCtx->dsp.emuTbl.glProgramUniform2i = driverTbl.glProgramUniform2i;
   }
   driverTbl.glProgramUniform2i(program, location, x, y);
}

static void REGAL_CALL missing_glProgramUniform3i(GLuint program, GLint location, GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glProgramUniform3i" );
}

static void REGAL_CALL loader_glProgramUniform3i(GLuint program, GLint location, GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3i, "glProgramUniform3i");
   if ( !driverTbl.glProgramUniform3i ) {
      driverTbl.glProgramUniform3i = missing_glProgramUniform3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3i == loader_glProgramUniform3i) {
      rCtx->dsp.emuTbl.glProgramUniform3i = driverTbl.glProgramUniform3i;
   }
   driverTbl.glProgramUniform3i(program, location, x, y, z);
}

static void REGAL_CALL missing_glProgramUniform4i(GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramUniform4i" );
}

static void REGAL_CALL loader_glProgramUniform4i(GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4i, "glProgramUniform4i");
   if ( !driverTbl.glProgramUniform4i ) {
      driverTbl.glProgramUniform4i = missing_glProgramUniform4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4i == loader_glProgramUniform4i) {
      rCtx->dsp.emuTbl.glProgramUniform4i = driverTbl.glProgramUniform4i;
   }
   driverTbl.glProgramUniform4i(program, location, x, y, z, w);
}

static void REGAL_CALL missing_glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform1fv" );
}

static void REGAL_CALL loader_glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1fv, "glProgramUniform1fv");
   if ( !driverTbl.glProgramUniform1fv ) {
      driverTbl.glProgramUniform1fv = missing_glProgramUniform1fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1fv == loader_glProgramUniform1fv) {
      rCtx->dsp.emuTbl.glProgramUniform1fv = driverTbl.glProgramUniform1fv;
   }
   driverTbl.glProgramUniform1fv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform2fv" );
}

static void REGAL_CALL loader_glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2fv, "glProgramUniform2fv");
   if ( !driverTbl.glProgramUniform2fv ) {
      driverTbl.glProgramUniform2fv = missing_glProgramUniform2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2fv == loader_glProgramUniform2fv) {
      rCtx->dsp.emuTbl.glProgramUniform2fv = driverTbl.glProgramUniform2fv;
   }
   driverTbl.glProgramUniform2fv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform3fv" );
}

static void REGAL_CALL loader_glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3fv, "glProgramUniform3fv");
   if ( !driverTbl.glProgramUniform3fv ) {
      driverTbl.glProgramUniform3fv = missing_glProgramUniform3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3fv == loader_glProgramUniform3fv) {
      rCtx->dsp.emuTbl.glProgramUniform3fv = driverTbl.glProgramUniform3fv;
   }
   driverTbl.glProgramUniform3fv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform4fv" );
}

static void REGAL_CALL loader_glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4fv, "glProgramUniform4fv");
   if ( !driverTbl.glProgramUniform4fv ) {
      driverTbl.glProgramUniform4fv = missing_glProgramUniform4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4fv == loader_glProgramUniform4fv) {
      rCtx->dsp.emuTbl.glProgramUniform4fv = driverTbl.glProgramUniform4fv;
   }
   driverTbl.glProgramUniform4fv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform1iv" );
}

static void REGAL_CALL loader_glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1iv, "glProgramUniform1iv");
   if ( !driverTbl.glProgramUniform1iv ) {
      driverTbl.glProgramUniform1iv = missing_glProgramUniform1iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1iv == loader_glProgramUniform1iv) {
      rCtx->dsp.emuTbl.glProgramUniform1iv = driverTbl.glProgramUniform1iv;
   }
   driverTbl.glProgramUniform1iv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform2iv" );
}

static void REGAL_CALL loader_glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2iv, "glProgramUniform2iv");
   if ( !driverTbl.glProgramUniform2iv ) {
      driverTbl.glProgramUniform2iv = missing_glProgramUniform2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2iv == loader_glProgramUniform2iv) {
      rCtx->dsp.emuTbl.glProgramUniform2iv = driverTbl.glProgramUniform2iv;
   }
   driverTbl.glProgramUniform2iv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform3iv" );
}

static void REGAL_CALL loader_glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3iv, "glProgramUniform3iv");
   if ( !driverTbl.glProgramUniform3iv ) {
      driverTbl.glProgramUniform3iv = missing_glProgramUniform3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3iv == loader_glProgramUniform3iv) {
      rCtx->dsp.emuTbl.glProgramUniform3iv = driverTbl.glProgramUniform3iv;
   }
   driverTbl.glProgramUniform3iv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform4iv" );
}

static void REGAL_CALL loader_glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4iv, "glProgramUniform4iv");
   if ( !driverTbl.glProgramUniform4iv ) {
      driverTbl.glProgramUniform4iv = missing_glProgramUniform4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4iv == loader_glProgramUniform4iv) {
      rCtx->dsp.emuTbl.glProgramUniform4iv = driverTbl.glProgramUniform4iv;
   }
   driverTbl.glProgramUniform4iv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix2fv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix2fv, "glProgramUniformMatrix2fv");
   if ( !driverTbl.glProgramUniformMatrix2fv ) {
      driverTbl.glProgramUniformMatrix2fv = missing_glProgramUniformMatrix2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix2fv == loader_glProgramUniformMatrix2fv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix2fv = driverTbl.glProgramUniformMatrix2fv;
   }
   driverTbl.glProgramUniformMatrix2fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix3fv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix3fv, "glProgramUniformMatrix3fv");
   if ( !driverTbl.glProgramUniformMatrix3fv ) {
      driverTbl.glProgramUniformMatrix3fv = missing_glProgramUniformMatrix3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix3fv == loader_glProgramUniformMatrix3fv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix3fv = driverTbl.glProgramUniformMatrix3fv;
   }
   driverTbl.glProgramUniformMatrix3fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix4fv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix4fv, "glProgramUniformMatrix4fv");
   if ( !driverTbl.glProgramUniformMatrix4fv ) {
      driverTbl.glProgramUniformMatrix4fv = missing_glProgramUniformMatrix4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix4fv == loader_glProgramUniformMatrix4fv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix4fv = driverTbl.glProgramUniformMatrix4fv;
   }
   driverTbl.glProgramUniformMatrix4fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix2x3fv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix2x3fv, "glProgramUniformMatrix2x3fv");
   if ( !driverTbl.glProgramUniformMatrix2x3fv ) {
      driverTbl.glProgramUniformMatrix2x3fv = missing_glProgramUniformMatrix2x3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix2x3fv == loader_glProgramUniformMatrix2x3fv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix2x3fv = driverTbl.glProgramUniformMatrix2x3fv;
   }
   driverTbl.glProgramUniformMatrix2x3fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix3x2fv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix3x2fv, "glProgramUniformMatrix3x2fv");
   if ( !driverTbl.glProgramUniformMatrix3x2fv ) {
      driverTbl.glProgramUniformMatrix3x2fv = missing_glProgramUniformMatrix3x2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix3x2fv == loader_glProgramUniformMatrix3x2fv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix3x2fv = driverTbl.glProgramUniformMatrix3x2fv;
   }
   driverTbl.glProgramUniformMatrix3x2fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix2x4fv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix2x4fv, "glProgramUniformMatrix2x4fv");
   if ( !driverTbl.glProgramUniformMatrix2x4fv ) {
      driverTbl.glProgramUniformMatrix2x4fv = missing_glProgramUniformMatrix2x4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix2x4fv == loader_glProgramUniformMatrix2x4fv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix2x4fv = driverTbl.glProgramUniformMatrix2x4fv;
   }
   driverTbl.glProgramUniformMatrix2x4fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix4x2fv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix4x2fv, "glProgramUniformMatrix4x2fv");
   if ( !driverTbl.glProgramUniformMatrix4x2fv ) {
      driverTbl.glProgramUniformMatrix4x2fv = missing_glProgramUniformMatrix4x2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix4x2fv == loader_glProgramUniformMatrix4x2fv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix4x2fv = driverTbl.glProgramUniformMatrix4x2fv;
   }
   driverTbl.glProgramUniformMatrix4x2fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix3x4fv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix3x4fv, "glProgramUniformMatrix3x4fv");
   if ( !driverTbl.glProgramUniformMatrix3x4fv ) {
      driverTbl.glProgramUniformMatrix3x4fv = missing_glProgramUniformMatrix3x4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix3x4fv == loader_glProgramUniformMatrix3x4fv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix3x4fv = driverTbl.glProgramUniformMatrix3x4fv;
   }
   driverTbl.glProgramUniformMatrix3x4fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix4x3fv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix4x3fv, "glProgramUniformMatrix4x3fv");
   if ( !driverTbl.glProgramUniformMatrix4x3fv ) {
      driverTbl.glProgramUniformMatrix4x3fv = missing_glProgramUniformMatrix4x3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix4x3fv == loader_glProgramUniformMatrix4x3fv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix4x3fv = driverTbl.glProgramUniformMatrix4x3fv;
   }
   driverTbl.glProgramUniformMatrix4x3fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniform1ui(GLuint program, GLint location, GLuint v0)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "Called missing function glProgramUniform1ui" );
}

static void REGAL_CALL loader_glProgramUniform1ui(GLuint program, GLint location, GLuint v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1ui, "glProgramUniform1ui");
   if ( !driverTbl.glProgramUniform1ui ) {
      driverTbl.glProgramUniform1ui = missing_glProgramUniform1ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1ui == loader_glProgramUniform1ui) {
      rCtx->dsp.emuTbl.glProgramUniform1ui = driverTbl.glProgramUniform1ui;
   }
   driverTbl.glProgramUniform1ui(program, location, v0);
}

static void REGAL_CALL missing_glProgramUniform2ui(GLuint program, GLint location, GLuint x, GLuint y)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glProgramUniform2ui" );
}

static void REGAL_CALL loader_glProgramUniform2ui(GLuint program, GLint location, GLuint x, GLuint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2ui, "glProgramUniform2ui");
   if ( !driverTbl.glProgramUniform2ui ) {
      driverTbl.glProgramUniform2ui = missing_glProgramUniform2ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2ui == loader_glProgramUniform2ui) {
      rCtx->dsp.emuTbl.glProgramUniform2ui = driverTbl.glProgramUniform2ui;
   }
   driverTbl.glProgramUniform2ui(program, location, x, y);
}

static void REGAL_CALL missing_glProgramUniform3ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glProgramUniform3ui" );
}

static void REGAL_CALL loader_glProgramUniform3ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3ui, "glProgramUniform3ui");
   if ( !driverTbl.glProgramUniform3ui ) {
      driverTbl.glProgramUniform3ui = missing_glProgramUniform3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3ui == loader_glProgramUniform3ui) {
      rCtx->dsp.emuTbl.glProgramUniform3ui = driverTbl.glProgramUniform3ui;
   }
   driverTbl.glProgramUniform3ui(program, location, x, y, z);
}

static void REGAL_CALL missing_glProgramUniform4ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramUniform4ui" );
}

static void REGAL_CALL loader_glProgramUniform4ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4ui, "glProgramUniform4ui");
   if ( !driverTbl.glProgramUniform4ui ) {
      driverTbl.glProgramUniform4ui = missing_glProgramUniform4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4ui == loader_glProgramUniform4ui) {
      rCtx->dsp.emuTbl.glProgramUniform4ui = driverTbl.glProgramUniform4ui;
   }
   driverTbl.glProgramUniform4ui(program, location, x, y, z, w);
}

static void REGAL_CALL missing_glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform1uiv" );
}

static void REGAL_CALL loader_glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1uiv, "glProgramUniform1uiv");
   if ( !driverTbl.glProgramUniform1uiv ) {
      driverTbl.glProgramUniform1uiv = missing_glProgramUniform1uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1uiv == loader_glProgramUniform1uiv) {
      rCtx->dsp.emuTbl.glProgramUniform1uiv = driverTbl.glProgramUniform1uiv;
   }
   driverTbl.glProgramUniform1uiv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform2uiv" );
}

static void REGAL_CALL loader_glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2uiv, "glProgramUniform2uiv");
   if ( !driverTbl.glProgramUniform2uiv ) {
      driverTbl.glProgramUniform2uiv = missing_glProgramUniform2uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2uiv == loader_glProgramUniform2uiv) {
      rCtx->dsp.emuTbl.glProgramUniform2uiv = driverTbl.glProgramUniform2uiv;
   }
   driverTbl.glProgramUniform2uiv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform3uiv" );
}

static void REGAL_CALL loader_glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3uiv, "glProgramUniform3uiv");
   if ( !driverTbl.glProgramUniform3uiv ) {
      driverTbl.glProgramUniform3uiv = missing_glProgramUniform3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3uiv == loader_glProgramUniform3uiv) {
      rCtx->dsp.emuTbl.glProgramUniform3uiv = driverTbl.glProgramUniform3uiv;
   }
   driverTbl.glProgramUniform3uiv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform4uiv" );
}

static void REGAL_CALL loader_glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4uiv, "glProgramUniform4uiv");
   if ( !driverTbl.glProgramUniform4uiv ) {
      driverTbl.glProgramUniform4uiv = missing_glProgramUniform4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4uiv == loader_glProgramUniform4uiv) {
      rCtx->dsp.emuTbl.glProgramUniform4uiv = driverTbl.glProgramUniform4uiv;
   }
   driverTbl.glProgramUniform4uiv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform1d(GLuint program, GLint location, GLdouble x)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glProgramUniform1d" );
}

static void REGAL_CALL loader_glProgramUniform1d(GLuint program, GLint location, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1d, "glProgramUniform1d");
   if ( !driverTbl.glProgramUniform1d ) {
      driverTbl.glProgramUniform1d = missing_glProgramUniform1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1d == loader_glProgramUniform1d) {
      rCtx->dsp.emuTbl.glProgramUniform1d = driverTbl.glProgramUniform1d;
   }
   driverTbl.glProgramUniform1d(program, location, x);
}

static void REGAL_CALL missing_glProgramUniform2d(GLuint program, GLint location, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glProgramUniform2d" );
}

static void REGAL_CALL loader_glProgramUniform2d(GLuint program, GLint location, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2d, "glProgramUniform2d");
   if ( !driverTbl.glProgramUniform2d ) {
      driverTbl.glProgramUniform2d = missing_glProgramUniform2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2d == loader_glProgramUniform2d) {
      rCtx->dsp.emuTbl.glProgramUniform2d = driverTbl.glProgramUniform2d;
   }
   driverTbl.glProgramUniform2d(program, location, x, y);
}

static void REGAL_CALL missing_glProgramUniform3d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glProgramUniform3d" );
}

static void REGAL_CALL loader_glProgramUniform3d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3d, "glProgramUniform3d");
   if ( !driverTbl.glProgramUniform3d ) {
      driverTbl.glProgramUniform3d = missing_glProgramUniform3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3d == loader_glProgramUniform3d) {
      rCtx->dsp.emuTbl.glProgramUniform3d = driverTbl.glProgramUniform3d;
   }
   driverTbl.glProgramUniform3d(program, location, x, y, z);
}

static void REGAL_CALL missing_glProgramUniform4d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramUniform4d" );
}

static void REGAL_CALL loader_glProgramUniform4d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4d, "glProgramUniform4d");
   if ( !driverTbl.glProgramUniform4d ) {
      driverTbl.glProgramUniform4d = missing_glProgramUniform4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4d == loader_glProgramUniform4d) {
      rCtx->dsp.emuTbl.glProgramUniform4d = driverTbl.glProgramUniform4d;
   }
   driverTbl.glProgramUniform4d(program, location, x, y, z, w);
}

static void REGAL_CALL missing_glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform1dv" );
}

static void REGAL_CALL loader_glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1dv, "glProgramUniform1dv");
   if ( !driverTbl.glProgramUniform1dv ) {
      driverTbl.glProgramUniform1dv = missing_glProgramUniform1dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1dv == loader_glProgramUniform1dv) {
      rCtx->dsp.emuTbl.glProgramUniform1dv = driverTbl.glProgramUniform1dv;
   }
   driverTbl.glProgramUniform1dv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform2dv" );
}

static void REGAL_CALL loader_glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2dv, "glProgramUniform2dv");
   if ( !driverTbl.glProgramUniform2dv ) {
      driverTbl.glProgramUniform2dv = missing_glProgramUniform2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2dv == loader_glProgramUniform2dv) {
      rCtx->dsp.emuTbl.glProgramUniform2dv = driverTbl.glProgramUniform2dv;
   }
   driverTbl.glProgramUniform2dv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform3dv" );
}

static void REGAL_CALL loader_glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3dv, "glProgramUniform3dv");
   if ( !driverTbl.glProgramUniform3dv ) {
      driverTbl.glProgramUniform3dv = missing_glProgramUniform3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3dv == loader_glProgramUniform3dv) {
      rCtx->dsp.emuTbl.glProgramUniform3dv = driverTbl.glProgramUniform3dv;
   }
   driverTbl.glProgramUniform3dv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform4dv" );
}

static void REGAL_CALL loader_glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4dv, "glProgramUniform4dv");
   if ( !driverTbl.glProgramUniform4dv ) {
      driverTbl.glProgramUniform4dv = missing_glProgramUniform4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4dv == loader_glProgramUniform4dv) {
      rCtx->dsp.emuTbl.glProgramUniform4dv = driverTbl.glProgramUniform4dv;
   }
   driverTbl.glProgramUniform4dv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix2dv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix2dv, "glProgramUniformMatrix2dv");
   if ( !driverTbl.glProgramUniformMatrix2dv ) {
      driverTbl.glProgramUniformMatrix2dv = missing_glProgramUniformMatrix2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix2dv == loader_glProgramUniformMatrix2dv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix2dv = driverTbl.glProgramUniformMatrix2dv;
   }
   driverTbl.glProgramUniformMatrix2dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix3dv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix3dv, "glProgramUniformMatrix3dv");
   if ( !driverTbl.glProgramUniformMatrix3dv ) {
      driverTbl.glProgramUniformMatrix3dv = missing_glProgramUniformMatrix3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix3dv == loader_glProgramUniformMatrix3dv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix3dv = driverTbl.glProgramUniformMatrix3dv;
   }
   driverTbl.glProgramUniformMatrix3dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix4dv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix4dv, "glProgramUniformMatrix4dv");
   if ( !driverTbl.glProgramUniformMatrix4dv ) {
      driverTbl.glProgramUniformMatrix4dv = missing_glProgramUniformMatrix4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix4dv == loader_glProgramUniformMatrix4dv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix4dv = driverTbl.glProgramUniformMatrix4dv;
   }
   driverTbl.glProgramUniformMatrix4dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix2x3dv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix2x3dv, "glProgramUniformMatrix2x3dv");
   if ( !driverTbl.glProgramUniformMatrix2x3dv ) {
      driverTbl.glProgramUniformMatrix2x3dv = missing_glProgramUniformMatrix2x3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix2x3dv == loader_glProgramUniformMatrix2x3dv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix2x3dv = driverTbl.glProgramUniformMatrix2x3dv;
   }
   driverTbl.glProgramUniformMatrix2x3dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix2x4dv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix2x4dv, "glProgramUniformMatrix2x4dv");
   if ( !driverTbl.glProgramUniformMatrix2x4dv ) {
      driverTbl.glProgramUniformMatrix2x4dv = missing_glProgramUniformMatrix2x4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix2x4dv == loader_glProgramUniformMatrix2x4dv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix2x4dv = driverTbl.glProgramUniformMatrix2x4dv;
   }
   driverTbl.glProgramUniformMatrix2x4dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix3x2dv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix3x2dv, "glProgramUniformMatrix3x2dv");
   if ( !driverTbl.glProgramUniformMatrix3x2dv ) {
      driverTbl.glProgramUniformMatrix3x2dv = missing_glProgramUniformMatrix3x2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix3x2dv == loader_glProgramUniformMatrix3x2dv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix3x2dv = driverTbl.glProgramUniformMatrix3x2dv;
   }
   driverTbl.glProgramUniformMatrix3x2dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix3x4dv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix3x4dv, "glProgramUniformMatrix3x4dv");
   if ( !driverTbl.glProgramUniformMatrix3x4dv ) {
      driverTbl.glProgramUniformMatrix3x4dv = missing_glProgramUniformMatrix3x4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix3x4dv == loader_glProgramUniformMatrix3x4dv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix3x4dv = driverTbl.glProgramUniformMatrix3x4dv;
   }
   driverTbl.glProgramUniformMatrix3x4dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix4x2dv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix4x2dv, "glProgramUniformMatrix4x2dv");
   if ( !driverTbl.glProgramUniformMatrix4x2dv ) {
      driverTbl.glProgramUniformMatrix4x2dv = missing_glProgramUniformMatrix4x2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix4x2dv == loader_glProgramUniformMatrix4x2dv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix4x2dv = driverTbl.glProgramUniformMatrix4x2dv;
   }
   driverTbl.glProgramUniformMatrix4x2dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix4x3dv" );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix4x3dv, "glProgramUniformMatrix4x3dv");
   if ( !driverTbl.glProgramUniformMatrix4x3dv ) {
      driverTbl.glProgramUniformMatrix4x3dv = missing_glProgramUniformMatrix4x3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix4x3dv == loader_glProgramUniformMatrix4x3dv) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix4x3dv = driverTbl.glProgramUniformMatrix4x3dv;
   }
   driverTbl.glProgramUniformMatrix4x3dv(program, location, count, transpose, value);
}

// GL_ARB_multitexture

static void REGAL_CALL missing_glActiveTextureARB(GLenum texture)
{
   UNUSED_PARAMETER(texture);
   Warning( "Called missing function glActiveTextureARB" );
}

static void REGAL_CALL loader_glActiveTextureARB(GLenum texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glActiveTextureARB, "glActiveTextureARB");
   if ( !driverTbl.glActiveTextureARB ) {
      driverTbl.glActiveTextureARB = missing_glActiveTextureARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glActiveTextureARB == loader_glActiveTextureARB) {
      rCtx->dsp.emuTbl.glActiveTextureARB = driverTbl.glActiveTextureARB;
   }
   driverTbl.glActiveTextureARB(texture);
}

static void REGAL_CALL missing_glClientActiveTextureARB(GLenum texture)
{
   UNUSED_PARAMETER(texture);
   Warning( "Called missing function glClientActiveTextureARB" );
}

static void REGAL_CALL loader_glClientActiveTextureARB(GLenum texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClientActiveTextureARB, "glClientActiveTextureARB");
   if ( !driverTbl.glClientActiveTextureARB ) {
      driverTbl.glClientActiveTextureARB = missing_glClientActiveTextureARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClientActiveTextureARB == loader_glClientActiveTextureARB) {
      rCtx->dsp.emuTbl.glClientActiveTextureARB = driverTbl.glClientActiveTextureARB;
   }
   driverTbl.glClientActiveTextureARB(texture);
}

static void REGAL_CALL missing_glMultiTexCoord1dARB(GLenum target, GLdouble s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glMultiTexCoord1dARB" );
}

static void REGAL_CALL loader_glMultiTexCoord1dARB(GLenum target, GLdouble s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1dARB, "glMultiTexCoord1dARB");
   if ( !driverTbl.glMultiTexCoord1dARB ) {
      driverTbl.glMultiTexCoord1dARB = missing_glMultiTexCoord1dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1dARB == loader_glMultiTexCoord1dARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord1dARB = driverTbl.glMultiTexCoord1dARB;
   }
   driverTbl.glMultiTexCoord1dARB(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord1dvARB" );
}

static void REGAL_CALL loader_glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1dvARB, "glMultiTexCoord1dvARB");
   if ( !driverTbl.glMultiTexCoord1dvARB ) {
      driverTbl.glMultiTexCoord1dvARB = missing_glMultiTexCoord1dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1dvARB == loader_glMultiTexCoord1dvARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord1dvARB = driverTbl.glMultiTexCoord1dvARB;
   }
   driverTbl.glMultiTexCoord1dvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord1fARB(GLenum target, GLfloat s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glMultiTexCoord1fARB" );
}

static void REGAL_CALL loader_glMultiTexCoord1fARB(GLenum target, GLfloat s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1fARB, "glMultiTexCoord1fARB");
   if ( !driverTbl.glMultiTexCoord1fARB ) {
      driverTbl.glMultiTexCoord1fARB = missing_glMultiTexCoord1fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1fARB == loader_glMultiTexCoord1fARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord1fARB = driverTbl.glMultiTexCoord1fARB;
   }
   driverTbl.glMultiTexCoord1fARB(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord1fvARB" );
}

static void REGAL_CALL loader_glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1fvARB, "glMultiTexCoord1fvARB");
   if ( !driverTbl.glMultiTexCoord1fvARB ) {
      driverTbl.glMultiTexCoord1fvARB = missing_glMultiTexCoord1fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1fvARB == loader_glMultiTexCoord1fvARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord1fvARB = driverTbl.glMultiTexCoord1fvARB;
   }
   driverTbl.glMultiTexCoord1fvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord1iARB(GLenum target, GLint s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glMultiTexCoord1iARB" );
}

static void REGAL_CALL loader_glMultiTexCoord1iARB(GLenum target, GLint s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1iARB, "glMultiTexCoord1iARB");
   if ( !driverTbl.glMultiTexCoord1iARB ) {
      driverTbl.glMultiTexCoord1iARB = missing_glMultiTexCoord1iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1iARB == loader_glMultiTexCoord1iARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord1iARB = driverTbl.glMultiTexCoord1iARB;
   }
   driverTbl.glMultiTexCoord1iARB(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1ivARB(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord1ivARB" );
}

static void REGAL_CALL loader_glMultiTexCoord1ivARB(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1ivARB, "glMultiTexCoord1ivARB");
   if ( !driverTbl.glMultiTexCoord1ivARB ) {
      driverTbl.glMultiTexCoord1ivARB = missing_glMultiTexCoord1ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1ivARB == loader_glMultiTexCoord1ivARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord1ivARB = driverTbl.glMultiTexCoord1ivARB;
   }
   driverTbl.glMultiTexCoord1ivARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord1sARB(GLenum target, GLshort s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glMultiTexCoord1sARB" );
}

static void REGAL_CALL loader_glMultiTexCoord1sARB(GLenum target, GLshort s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1sARB, "glMultiTexCoord1sARB");
   if ( !driverTbl.glMultiTexCoord1sARB ) {
      driverTbl.glMultiTexCoord1sARB = missing_glMultiTexCoord1sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1sARB == loader_glMultiTexCoord1sARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord1sARB = driverTbl.glMultiTexCoord1sARB;
   }
   driverTbl.glMultiTexCoord1sARB(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1svARB(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord1svARB" );
}

static void REGAL_CALL loader_glMultiTexCoord1svARB(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1svARB, "glMultiTexCoord1svARB");
   if ( !driverTbl.glMultiTexCoord1svARB ) {
      driverTbl.glMultiTexCoord1svARB = missing_glMultiTexCoord1svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1svARB == loader_glMultiTexCoord1svARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord1svARB = driverTbl.glMultiTexCoord1svARB;
   }
   driverTbl.glMultiTexCoord1svARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "Called missing function glMultiTexCoord2dARB" );
}

static void REGAL_CALL loader_glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2dARB, "glMultiTexCoord2dARB");
   if ( !driverTbl.glMultiTexCoord2dARB ) {
      driverTbl.glMultiTexCoord2dARB = missing_glMultiTexCoord2dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2dARB == loader_glMultiTexCoord2dARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord2dARB = driverTbl.glMultiTexCoord2dARB;
   }
   driverTbl.glMultiTexCoord2dARB(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord2dvARB" );
}

static void REGAL_CALL loader_glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2dvARB, "glMultiTexCoord2dvARB");
   if ( !driverTbl.glMultiTexCoord2dvARB ) {
      driverTbl.glMultiTexCoord2dvARB = missing_glMultiTexCoord2dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2dvARB == loader_glMultiTexCoord2dvARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord2dvARB = driverTbl.glMultiTexCoord2dvARB;
   }
   driverTbl.glMultiTexCoord2dvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "Called missing function glMultiTexCoord2fARB" );
}

static void REGAL_CALL loader_glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2fARB, "glMultiTexCoord2fARB");
   if ( !driverTbl.glMultiTexCoord2fARB ) {
      driverTbl.glMultiTexCoord2fARB = missing_glMultiTexCoord2fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2fARB == loader_glMultiTexCoord2fARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord2fARB = driverTbl.glMultiTexCoord2fARB;
   }
   driverTbl.glMultiTexCoord2fARB(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord2fvARB" );
}

static void REGAL_CALL loader_glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2fvARB, "glMultiTexCoord2fvARB");
   if ( !driverTbl.glMultiTexCoord2fvARB ) {
      driverTbl.glMultiTexCoord2fvARB = missing_glMultiTexCoord2fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2fvARB == loader_glMultiTexCoord2fvARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord2fvARB = driverTbl.glMultiTexCoord2fvARB;
   }
   driverTbl.glMultiTexCoord2fvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "Called missing function glMultiTexCoord2iARB" );
}

static void REGAL_CALL loader_glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2iARB, "glMultiTexCoord2iARB");
   if ( !driverTbl.glMultiTexCoord2iARB ) {
      driverTbl.glMultiTexCoord2iARB = missing_glMultiTexCoord2iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2iARB == loader_glMultiTexCoord2iARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord2iARB = driverTbl.glMultiTexCoord2iARB;
   }
   driverTbl.glMultiTexCoord2iARB(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2ivARB(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord2ivARB" );
}

static void REGAL_CALL loader_glMultiTexCoord2ivARB(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2ivARB, "glMultiTexCoord2ivARB");
   if ( !driverTbl.glMultiTexCoord2ivARB ) {
      driverTbl.glMultiTexCoord2ivARB = missing_glMultiTexCoord2ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2ivARB == loader_glMultiTexCoord2ivARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord2ivARB = driverTbl.glMultiTexCoord2ivARB;
   }
   driverTbl.glMultiTexCoord2ivARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "Called missing function glMultiTexCoord2sARB" );
}

static void REGAL_CALL loader_glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2sARB, "glMultiTexCoord2sARB");
   if ( !driverTbl.glMultiTexCoord2sARB ) {
      driverTbl.glMultiTexCoord2sARB = missing_glMultiTexCoord2sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2sARB == loader_glMultiTexCoord2sARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord2sARB = driverTbl.glMultiTexCoord2sARB;
   }
   driverTbl.glMultiTexCoord2sARB(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2svARB(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord2svARB" );
}

static void REGAL_CALL loader_glMultiTexCoord2svARB(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2svARB, "glMultiTexCoord2svARB");
   if ( !driverTbl.glMultiTexCoord2svARB ) {
      driverTbl.glMultiTexCoord2svARB = missing_glMultiTexCoord2svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2svARB == loader_glMultiTexCoord2svARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord2svARB = driverTbl.glMultiTexCoord2svARB;
   }
   driverTbl.glMultiTexCoord2svARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "Called missing function glMultiTexCoord3dARB" );
}

static void REGAL_CALL loader_glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3dARB, "glMultiTexCoord3dARB");
   if ( !driverTbl.glMultiTexCoord3dARB ) {
      driverTbl.glMultiTexCoord3dARB = missing_glMultiTexCoord3dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3dARB == loader_glMultiTexCoord3dARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord3dARB = driverTbl.glMultiTexCoord3dARB;
   }
   driverTbl.glMultiTexCoord3dARB(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord3dvARB" );
}

static void REGAL_CALL loader_glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3dvARB, "glMultiTexCoord3dvARB");
   if ( !driverTbl.glMultiTexCoord3dvARB ) {
      driverTbl.glMultiTexCoord3dvARB = missing_glMultiTexCoord3dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3dvARB == loader_glMultiTexCoord3dvARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord3dvARB = driverTbl.glMultiTexCoord3dvARB;
   }
   driverTbl.glMultiTexCoord3dvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "Called missing function glMultiTexCoord3fARB" );
}

static void REGAL_CALL loader_glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3fARB, "glMultiTexCoord3fARB");
   if ( !driverTbl.glMultiTexCoord3fARB ) {
      driverTbl.glMultiTexCoord3fARB = missing_glMultiTexCoord3fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3fARB == loader_glMultiTexCoord3fARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord3fARB = driverTbl.glMultiTexCoord3fARB;
   }
   driverTbl.glMultiTexCoord3fARB(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord3fvARB" );
}

static void REGAL_CALL loader_glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3fvARB, "glMultiTexCoord3fvARB");
   if ( !driverTbl.glMultiTexCoord3fvARB ) {
      driverTbl.glMultiTexCoord3fvARB = missing_glMultiTexCoord3fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3fvARB == loader_glMultiTexCoord3fvARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord3fvARB = driverTbl.glMultiTexCoord3fvARB;
   }
   driverTbl.glMultiTexCoord3fvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "Called missing function glMultiTexCoord3iARB" );
}

static void REGAL_CALL loader_glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3iARB, "glMultiTexCoord3iARB");
   if ( !driverTbl.glMultiTexCoord3iARB ) {
      driverTbl.glMultiTexCoord3iARB = missing_glMultiTexCoord3iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3iARB == loader_glMultiTexCoord3iARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord3iARB = driverTbl.glMultiTexCoord3iARB;
   }
   driverTbl.glMultiTexCoord3iARB(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3ivARB(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord3ivARB" );
}

static void REGAL_CALL loader_glMultiTexCoord3ivARB(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3ivARB, "glMultiTexCoord3ivARB");
   if ( !driverTbl.glMultiTexCoord3ivARB ) {
      driverTbl.glMultiTexCoord3ivARB = missing_glMultiTexCoord3ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3ivARB == loader_glMultiTexCoord3ivARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord3ivARB = driverTbl.glMultiTexCoord3ivARB;
   }
   driverTbl.glMultiTexCoord3ivARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "Called missing function glMultiTexCoord3sARB" );
}

static void REGAL_CALL loader_glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3sARB, "glMultiTexCoord3sARB");
   if ( !driverTbl.glMultiTexCoord3sARB ) {
      driverTbl.glMultiTexCoord3sARB = missing_glMultiTexCoord3sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3sARB == loader_glMultiTexCoord3sARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord3sARB = driverTbl.glMultiTexCoord3sARB;
   }
   driverTbl.glMultiTexCoord3sARB(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3svARB(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord3svARB" );
}

static void REGAL_CALL loader_glMultiTexCoord3svARB(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3svARB, "glMultiTexCoord3svARB");
   if ( !driverTbl.glMultiTexCoord3svARB ) {
      driverTbl.glMultiTexCoord3svARB = missing_glMultiTexCoord3svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3svARB == loader_glMultiTexCoord3svARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord3svARB = driverTbl.glMultiTexCoord3svARB;
   }
   driverTbl.glMultiTexCoord3svARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "Called missing function glMultiTexCoord4dARB" );
}

static void REGAL_CALL loader_glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4dARB, "glMultiTexCoord4dARB");
   if ( !driverTbl.glMultiTexCoord4dARB ) {
      driverTbl.glMultiTexCoord4dARB = missing_glMultiTexCoord4dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4dARB == loader_glMultiTexCoord4dARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord4dARB = driverTbl.glMultiTexCoord4dARB;
   }
   driverTbl.glMultiTexCoord4dARB(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord4dvARB" );
}

static void REGAL_CALL loader_glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4dvARB, "glMultiTexCoord4dvARB");
   if ( !driverTbl.glMultiTexCoord4dvARB ) {
      driverTbl.glMultiTexCoord4dvARB = missing_glMultiTexCoord4dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4dvARB == loader_glMultiTexCoord4dvARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord4dvARB = driverTbl.glMultiTexCoord4dvARB;
   }
   driverTbl.glMultiTexCoord4dvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "Called missing function glMultiTexCoord4fARB" );
}

static void REGAL_CALL loader_glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4fARB, "glMultiTexCoord4fARB");
   if ( !driverTbl.glMultiTexCoord4fARB ) {
      driverTbl.glMultiTexCoord4fARB = missing_glMultiTexCoord4fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4fARB == loader_glMultiTexCoord4fARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord4fARB = driverTbl.glMultiTexCoord4fARB;
   }
   driverTbl.glMultiTexCoord4fARB(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord4fvARB" );
}

static void REGAL_CALL loader_glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4fvARB, "glMultiTexCoord4fvARB");
   if ( !driverTbl.glMultiTexCoord4fvARB ) {
      driverTbl.glMultiTexCoord4fvARB = missing_glMultiTexCoord4fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4fvARB == loader_glMultiTexCoord4fvARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord4fvARB = driverTbl.glMultiTexCoord4fvARB;
   }
   driverTbl.glMultiTexCoord4fvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "Called missing function glMultiTexCoord4iARB" );
}

static void REGAL_CALL loader_glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4iARB, "glMultiTexCoord4iARB");
   if ( !driverTbl.glMultiTexCoord4iARB ) {
      driverTbl.glMultiTexCoord4iARB = missing_glMultiTexCoord4iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4iARB == loader_glMultiTexCoord4iARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord4iARB = driverTbl.glMultiTexCoord4iARB;
   }
   driverTbl.glMultiTexCoord4iARB(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4ivARB(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord4ivARB" );
}

static void REGAL_CALL loader_glMultiTexCoord4ivARB(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4ivARB, "glMultiTexCoord4ivARB");
   if ( !driverTbl.glMultiTexCoord4ivARB ) {
      driverTbl.glMultiTexCoord4ivARB = missing_glMultiTexCoord4ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4ivARB == loader_glMultiTexCoord4ivARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord4ivARB = driverTbl.glMultiTexCoord4ivARB;
   }
   driverTbl.glMultiTexCoord4ivARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "Called missing function glMultiTexCoord4sARB" );
}

static void REGAL_CALL loader_glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4sARB, "glMultiTexCoord4sARB");
   if ( !driverTbl.glMultiTexCoord4sARB ) {
      driverTbl.glMultiTexCoord4sARB = missing_glMultiTexCoord4sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4sARB == loader_glMultiTexCoord4sARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord4sARB = driverTbl.glMultiTexCoord4sARB;
   }
   driverTbl.glMultiTexCoord4sARB(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4svARB(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord4svARB" );
}

static void REGAL_CALL loader_glMultiTexCoord4svARB(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4svARB, "glMultiTexCoord4svARB");
   if ( !driverTbl.glMultiTexCoord4svARB ) {
      driverTbl.glMultiTexCoord4svARB = missing_glMultiTexCoord4svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4svARB == loader_glMultiTexCoord4svARB) {
      rCtx->dsp.emuTbl.glMultiTexCoord4svARB = driverTbl.glMultiTexCoord4svARB;
   }
   driverTbl.glMultiTexCoord4svARB(target, v);
}

// GL_ARB_transpose_matrix

static void REGAL_CALL missing_glLoadTransposeMatrixfARB(const GLfloat *m)
{
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glLoadTransposeMatrixfARB" );
}

static void REGAL_CALL loader_glLoadTransposeMatrixfARB(const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLoadTransposeMatrixfARB, "glLoadTransposeMatrixfARB");
   if ( !driverTbl.glLoadTransposeMatrixfARB ) {
      driverTbl.glLoadTransposeMatrixfARB = missing_glLoadTransposeMatrixfARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLoadTransposeMatrixfARB == loader_glLoadTransposeMatrixfARB) {
      rCtx->dsp.emuTbl.glLoadTransposeMatrixfARB = driverTbl.glLoadTransposeMatrixfARB;
   }
   driverTbl.glLoadTransposeMatrixfARB(m);
}

static void REGAL_CALL missing_glLoadTransposeMatrixdARB(const GLdouble *m)
{
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glLoadTransposeMatrixdARB" );
}

static void REGAL_CALL loader_glLoadTransposeMatrixdARB(const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLoadTransposeMatrixdARB, "glLoadTransposeMatrixdARB");
   if ( !driverTbl.glLoadTransposeMatrixdARB ) {
      driverTbl.glLoadTransposeMatrixdARB = missing_glLoadTransposeMatrixdARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLoadTransposeMatrixdARB == loader_glLoadTransposeMatrixdARB) {
      rCtx->dsp.emuTbl.glLoadTransposeMatrixdARB = driverTbl.glLoadTransposeMatrixdARB;
   }
   driverTbl.glLoadTransposeMatrixdARB(m);
}

static void REGAL_CALL missing_glMultTransposeMatrixfARB(const GLfloat *m)
{
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glMultTransposeMatrixfARB" );
}

static void REGAL_CALL loader_glMultTransposeMatrixfARB(const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultTransposeMatrixfARB, "glMultTransposeMatrixfARB");
   if ( !driverTbl.glMultTransposeMatrixfARB ) {
      driverTbl.glMultTransposeMatrixfARB = missing_glMultTransposeMatrixfARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultTransposeMatrixfARB == loader_glMultTransposeMatrixfARB) {
      rCtx->dsp.emuTbl.glMultTransposeMatrixfARB = driverTbl.glMultTransposeMatrixfARB;
   }
   driverTbl.glMultTransposeMatrixfARB(m);
}

static void REGAL_CALL missing_glMultTransposeMatrixdARB(const GLdouble *m)
{
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glMultTransposeMatrixdARB" );
}

static void REGAL_CALL loader_glMultTransposeMatrixdARB(const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultTransposeMatrixdARB, "glMultTransposeMatrixdARB");
   if ( !driverTbl.glMultTransposeMatrixdARB ) {
      driverTbl.glMultTransposeMatrixdARB = missing_glMultTransposeMatrixdARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultTransposeMatrixdARB == loader_glMultTransposeMatrixdARB) {
      rCtx->dsp.emuTbl.glMultTransposeMatrixdARB = driverTbl.glMultTransposeMatrixdARB;
   }
   driverTbl.glMultTransposeMatrixdARB(m);
}

// GL_ARB_multisample

static void REGAL_CALL missing_glSampleCoverageARB(GLclampf value, GLboolean invert)
{
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(invert);
   Warning( "Called missing function glSampleCoverageARB" );
}

static void REGAL_CALL loader_glSampleCoverageARB(GLclampf value, GLboolean invert)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSampleCoverageARB, "glSampleCoverageARB");
   if ( !driverTbl.glSampleCoverageARB ) {
      driverTbl.glSampleCoverageARB = missing_glSampleCoverageARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSampleCoverageARB == loader_glSampleCoverageARB) {
      rCtx->dsp.emuTbl.glSampleCoverageARB = driverTbl.glSampleCoverageARB;
   }
   driverTbl.glSampleCoverageARB(value, invert);
}

// GL_ARB_texture_compression

static void REGAL_CALL missing_glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedTexImage3DARB" );
}

static void REGAL_CALL loader_glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTexImage3DARB, "glCompressedTexImage3DARB");
   if ( !driverTbl.glCompressedTexImage3DARB ) {
      driverTbl.glCompressedTexImage3DARB = missing_glCompressedTexImage3DARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTexImage3DARB == loader_glCompressedTexImage3DARB) {
      rCtx->dsp.emuTbl.glCompressedTexImage3DARB = driverTbl.glCompressedTexImage3DARB;
   }
   driverTbl.glCompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedTexImage2DARB" );
}

static void REGAL_CALL loader_glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTexImage2DARB, "glCompressedTexImage2DARB");
   if ( !driverTbl.glCompressedTexImage2DARB ) {
      driverTbl.glCompressedTexImage2DARB = missing_glCompressedTexImage2DARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTexImage2DARB == loader_glCompressedTexImage2DARB) {
      rCtx->dsp.emuTbl.glCompressedTexImage2DARB = driverTbl.glCompressedTexImage2DARB;
   }
   driverTbl.glCompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedTexImage1DARB" );
}

static void REGAL_CALL loader_glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTexImage1DARB, "glCompressedTexImage1DARB");
   if ( !driverTbl.glCompressedTexImage1DARB ) {
      driverTbl.glCompressedTexImage1DARB = missing_glCompressedTexImage1DARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTexImage1DARB == loader_glCompressedTexImage1DARB) {
      rCtx->dsp.emuTbl.glCompressedTexImage1DARB = driverTbl.glCompressedTexImage1DARB;
   }
   driverTbl.glCompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedTexSubImage3DARB" );
}

static void REGAL_CALL loader_glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTexSubImage3DARB, "glCompressedTexSubImage3DARB");
   if ( !driverTbl.glCompressedTexSubImage3DARB ) {
      driverTbl.glCompressedTexSubImage3DARB = missing_glCompressedTexSubImage3DARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTexSubImage3DARB == loader_glCompressedTexSubImage3DARB) {
      rCtx->dsp.emuTbl.glCompressedTexSubImage3DARB = driverTbl.glCompressedTexSubImage3DARB;
   }
   driverTbl.glCompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedTexSubImage2DARB" );
}

static void REGAL_CALL loader_glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTexSubImage2DARB, "glCompressedTexSubImage2DARB");
   if ( !driverTbl.glCompressedTexSubImage2DARB ) {
      driverTbl.glCompressedTexSubImage2DARB = missing_glCompressedTexSubImage2DARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTexSubImage2DARB == loader_glCompressedTexSubImage2DARB) {
      rCtx->dsp.emuTbl.glCompressedTexSubImage2DARB = driverTbl.glCompressedTexSubImage2DARB;
   }
   driverTbl.glCompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedTexSubImage1DARB" );
}

static void REGAL_CALL loader_glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTexSubImage1DARB, "glCompressedTexSubImage1DARB");
   if ( !driverTbl.glCompressedTexSubImage1DARB ) {
      driverTbl.glCompressedTexSubImage1DARB = missing_glCompressedTexSubImage1DARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTexSubImage1DARB == loader_glCompressedTexSubImage1DARB) {
      rCtx->dsp.emuTbl.glCompressedTexSubImage1DARB = driverTbl.glCompressedTexSubImage1DARB;
   }
   driverTbl.glCompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data);
}

static void REGAL_CALL missing_glGetCompressedTexImageARB(GLenum target, GLint lod, GLvoid *img)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(lod);
   UNUSED_PARAMETER(img);
   Warning( "Called missing function glGetCompressedTexImageARB" );
}

static void REGAL_CALL loader_glGetCompressedTexImageARB(GLenum target, GLint lod, GLvoid *img)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetCompressedTexImageARB, "glGetCompressedTexImageARB");
   if ( !driverTbl.glGetCompressedTexImageARB ) {
      driverTbl.glGetCompressedTexImageARB = missing_glGetCompressedTexImageARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetCompressedTexImageARB == loader_glGetCompressedTexImageARB) {
      rCtx->dsp.emuTbl.glGetCompressedTexImageARB = driverTbl.glGetCompressedTexImageARB;
   }
   driverTbl.glGetCompressedTexImageARB(target, lod, img);
}

// GL_ARB_point_parameters

static void REGAL_CALL missing_glPointParameterfARB(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPointParameterfARB" );
}

static void REGAL_CALL loader_glPointParameterfARB(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPointParameterfARB, "glPointParameterfARB");
   if ( !driverTbl.glPointParameterfARB ) {
      driverTbl.glPointParameterfARB = missing_glPointParameterfARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPointParameterfARB == loader_glPointParameterfARB) {
      rCtx->dsp.emuTbl.glPointParameterfARB = driverTbl.glPointParameterfARB;
   }
   driverTbl.glPointParameterfARB(pname, param);
}

static void REGAL_CALL missing_glPointParameterfvARB(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glPointParameterfvARB" );
}

static void REGAL_CALL loader_glPointParameterfvARB(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPointParameterfvARB, "glPointParameterfvARB");
   if ( !driverTbl.glPointParameterfvARB ) {
      driverTbl.glPointParameterfvARB = missing_glPointParameterfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPointParameterfvARB == loader_glPointParameterfvARB) {
      rCtx->dsp.emuTbl.glPointParameterfvARB = driverTbl.glPointParameterfvARB;
   }
   driverTbl.glPointParameterfvARB(pname, params);
}

// GL_ARB_vertex_blend

static void REGAL_CALL missing_glWeightbvARB(GLint size, GLbyte *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "Called missing function glWeightbvARB" );
}

static void REGAL_CALL loader_glWeightbvARB(GLint size, GLbyte *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWeightbvARB, "glWeightbvARB");
   if ( !driverTbl.glWeightbvARB ) {
      driverTbl.glWeightbvARB = missing_glWeightbvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWeightbvARB == loader_glWeightbvARB) {
      rCtx->dsp.emuTbl.glWeightbvARB = driverTbl.glWeightbvARB;
   }
   driverTbl.glWeightbvARB(size, weights);
}

static void REGAL_CALL missing_glWeightsvARB(GLint size, GLshort *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "Called missing function glWeightsvARB" );
}

static void REGAL_CALL loader_glWeightsvARB(GLint size, GLshort *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWeightsvARB, "glWeightsvARB");
   if ( !driverTbl.glWeightsvARB ) {
      driverTbl.glWeightsvARB = missing_glWeightsvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWeightsvARB == loader_glWeightsvARB) {
      rCtx->dsp.emuTbl.glWeightsvARB = driverTbl.glWeightsvARB;
   }
   driverTbl.glWeightsvARB(size, weights);
}

static void REGAL_CALL missing_glWeightivARB(GLint size, GLint *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "Called missing function glWeightivARB" );
}

static void REGAL_CALL loader_glWeightivARB(GLint size, GLint *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWeightivARB, "glWeightivARB");
   if ( !driverTbl.glWeightivARB ) {
      driverTbl.glWeightivARB = missing_glWeightivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWeightivARB == loader_glWeightivARB) {
      rCtx->dsp.emuTbl.glWeightivARB = driverTbl.glWeightivARB;
   }
   driverTbl.glWeightivARB(size, weights);
}

static void REGAL_CALL missing_glWeightfvARB(GLint size, GLfloat *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "Called missing function glWeightfvARB" );
}

static void REGAL_CALL loader_glWeightfvARB(GLint size, GLfloat *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWeightfvARB, "glWeightfvARB");
   if ( !driverTbl.glWeightfvARB ) {
      driverTbl.glWeightfvARB = missing_glWeightfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWeightfvARB == loader_glWeightfvARB) {
      rCtx->dsp.emuTbl.glWeightfvARB = driverTbl.glWeightfvARB;
   }
   driverTbl.glWeightfvARB(size, weights);
}

static void REGAL_CALL missing_glWeightdvARB(GLint size, GLdouble *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "Called missing function glWeightdvARB" );
}

static void REGAL_CALL loader_glWeightdvARB(GLint size, GLdouble *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWeightdvARB, "glWeightdvARB");
   if ( !driverTbl.glWeightdvARB ) {
      driverTbl.glWeightdvARB = missing_glWeightdvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWeightdvARB == loader_glWeightdvARB) {
      rCtx->dsp.emuTbl.glWeightdvARB = driverTbl.glWeightdvARB;
   }
   driverTbl.glWeightdvARB(size, weights);
}

static void REGAL_CALL missing_glWeightubvARB(GLint size, GLubyte *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "Called missing function glWeightubvARB" );
}

static void REGAL_CALL loader_glWeightubvARB(GLint size, GLubyte *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWeightubvARB, "glWeightubvARB");
   if ( !driverTbl.glWeightubvARB ) {
      driverTbl.glWeightubvARB = missing_glWeightubvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWeightubvARB == loader_glWeightubvARB) {
      rCtx->dsp.emuTbl.glWeightubvARB = driverTbl.glWeightubvARB;
   }
   driverTbl.glWeightubvARB(size, weights);
}

static void REGAL_CALL missing_glWeightusvARB(GLint size, GLushort *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "Called missing function glWeightusvARB" );
}

static void REGAL_CALL loader_glWeightusvARB(GLint size, GLushort *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWeightusvARB, "glWeightusvARB");
   if ( !driverTbl.glWeightusvARB ) {
      driverTbl.glWeightusvARB = missing_glWeightusvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWeightusvARB == loader_glWeightusvARB) {
      rCtx->dsp.emuTbl.glWeightusvARB = driverTbl.glWeightusvARB;
   }
   driverTbl.glWeightusvARB(size, weights);
}

static void REGAL_CALL missing_glWeightuivARB(GLint size, GLuint *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "Called missing function glWeightuivARB" );
}

static void REGAL_CALL loader_glWeightuivARB(GLint size, GLuint *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWeightuivARB, "glWeightuivARB");
   if ( !driverTbl.glWeightuivARB ) {
      driverTbl.glWeightuivARB = missing_glWeightuivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWeightuivARB == loader_glWeightuivARB) {
      rCtx->dsp.emuTbl.glWeightuivARB = driverTbl.glWeightuivARB;
   }
   driverTbl.glWeightuivARB(size, weights);
}

static void REGAL_CALL missing_glWeightPointerARB(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glWeightPointerARB" );
}

static void REGAL_CALL loader_glWeightPointerARB(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWeightPointerARB, "glWeightPointerARB");
   if ( !driverTbl.glWeightPointerARB ) {
      driverTbl.glWeightPointerARB = missing_glWeightPointerARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWeightPointerARB == loader_glWeightPointerARB) {
      rCtx->dsp.emuTbl.glWeightPointerARB = driverTbl.glWeightPointerARB;
   }
   driverTbl.glWeightPointerARB(size, type, stride, pointer);
}

static void REGAL_CALL missing_glVertexBlendARB(GLint count)
{
   UNUSED_PARAMETER(count);
   Warning( "Called missing function glVertexBlendARB" );
}

static void REGAL_CALL loader_glVertexBlendARB(GLint count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexBlendARB, "glVertexBlendARB");
   if ( !driverTbl.glVertexBlendARB ) {
      driverTbl.glVertexBlendARB = missing_glVertexBlendARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexBlendARB == loader_glVertexBlendARB) {
      rCtx->dsp.emuTbl.glVertexBlendARB = driverTbl.glVertexBlendARB;
   }
   driverTbl.glVertexBlendARB(count);
}

// GL_ARB_matrix_palette

static void REGAL_CALL missing_glCurrentPaletteMatrixARB(GLint index)
{
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glCurrentPaletteMatrixARB" );
}

static void REGAL_CALL loader_glCurrentPaletteMatrixARB(GLint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCurrentPaletteMatrixARB, "glCurrentPaletteMatrixARB");
   if ( !driverTbl.glCurrentPaletteMatrixARB ) {
      driverTbl.glCurrentPaletteMatrixARB = missing_glCurrentPaletteMatrixARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCurrentPaletteMatrixARB == loader_glCurrentPaletteMatrixARB) {
      rCtx->dsp.emuTbl.glCurrentPaletteMatrixARB = driverTbl.glCurrentPaletteMatrixARB;
   }
   driverTbl.glCurrentPaletteMatrixARB(index);
}

static void REGAL_CALL missing_glMatrixIndexubvARB(GLint size, GLubyte *indices)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(indices);
   Warning( "Called missing function glMatrixIndexubvARB" );
}

static void REGAL_CALL loader_glMatrixIndexubvARB(GLint size, GLubyte *indices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixIndexubvARB, "glMatrixIndexubvARB");
   if ( !driverTbl.glMatrixIndexubvARB ) {
      driverTbl.glMatrixIndexubvARB = missing_glMatrixIndexubvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixIndexubvARB == loader_glMatrixIndexubvARB) {
      rCtx->dsp.emuTbl.glMatrixIndexubvARB = driverTbl.glMatrixIndexubvARB;
   }
   driverTbl.glMatrixIndexubvARB(size, indices);
}

static void REGAL_CALL missing_glMatrixIndexusvARB(GLint size, GLushort *indices)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(indices);
   Warning( "Called missing function glMatrixIndexusvARB" );
}

static void REGAL_CALL loader_glMatrixIndexusvARB(GLint size, GLushort *indices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixIndexusvARB, "glMatrixIndexusvARB");
   if ( !driverTbl.glMatrixIndexusvARB ) {
      driverTbl.glMatrixIndexusvARB = missing_glMatrixIndexusvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixIndexusvARB == loader_glMatrixIndexusvARB) {
      rCtx->dsp.emuTbl.glMatrixIndexusvARB = driverTbl.glMatrixIndexusvARB;
   }
   driverTbl.glMatrixIndexusvARB(size, indices);
}

static void REGAL_CALL missing_glMatrixIndexuivARB(GLint size, GLuint *indices)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(indices);
   Warning( "Called missing function glMatrixIndexuivARB" );
}

static void REGAL_CALL loader_glMatrixIndexuivARB(GLint size, GLuint *indices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixIndexuivARB, "glMatrixIndexuivARB");
   if ( !driverTbl.glMatrixIndexuivARB ) {
      driverTbl.glMatrixIndexuivARB = missing_glMatrixIndexuivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixIndexuivARB == loader_glMatrixIndexuivARB) {
      rCtx->dsp.emuTbl.glMatrixIndexuivARB = driverTbl.glMatrixIndexuivARB;
   }
   driverTbl.glMatrixIndexuivARB(size, indices);
}

static void REGAL_CALL missing_glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glMatrixIndexPointerARB" );
}

static void REGAL_CALL loader_glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixIndexPointerARB, "glMatrixIndexPointerARB");
   if ( !driverTbl.glMatrixIndexPointerARB ) {
      driverTbl.glMatrixIndexPointerARB = missing_glMatrixIndexPointerARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixIndexPointerARB == loader_glMatrixIndexPointerARB) {
      rCtx->dsp.emuTbl.glMatrixIndexPointerARB = driverTbl.glMatrixIndexPointerARB;
   }
   driverTbl.glMatrixIndexPointerARB(size, type, stride, pointer);
}

// GL_ARB_window_pos

static void REGAL_CALL missing_glWindowPos2dARB(GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glWindowPos2dARB" );
}

static void REGAL_CALL loader_glWindowPos2dARB(GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2dARB, "glWindowPos2dARB");
   if ( !driverTbl.glWindowPos2dARB ) {
      driverTbl.glWindowPos2dARB = missing_glWindowPos2dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2dARB == loader_glWindowPos2dARB) {
      rCtx->dsp.emuTbl.glWindowPos2dARB = driverTbl.glWindowPos2dARB;
   }
   driverTbl.glWindowPos2dARB(x, y);
}

static void REGAL_CALL missing_glWindowPos2dvARB(const GLdouble *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos2dvARB" );
}

static void REGAL_CALL loader_glWindowPos2dvARB(const GLdouble *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2dvARB, "glWindowPos2dvARB");
   if ( !driverTbl.glWindowPos2dvARB ) {
      driverTbl.glWindowPos2dvARB = missing_glWindowPos2dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2dvARB == loader_glWindowPos2dvARB) {
      rCtx->dsp.emuTbl.glWindowPos2dvARB = driverTbl.glWindowPos2dvARB;
   }
   driverTbl.glWindowPos2dvARB(p);
}

static void REGAL_CALL missing_glWindowPos2fARB(GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glWindowPos2fARB" );
}

static void REGAL_CALL loader_glWindowPos2fARB(GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2fARB, "glWindowPos2fARB");
   if ( !driverTbl.glWindowPos2fARB ) {
      driverTbl.glWindowPos2fARB = missing_glWindowPos2fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2fARB == loader_glWindowPos2fARB) {
      rCtx->dsp.emuTbl.glWindowPos2fARB = driverTbl.glWindowPos2fARB;
   }
   driverTbl.glWindowPos2fARB(x, y);
}

static void REGAL_CALL missing_glWindowPos2fvARB(const GLfloat *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos2fvARB" );
}

static void REGAL_CALL loader_glWindowPos2fvARB(const GLfloat *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2fvARB, "glWindowPos2fvARB");
   if ( !driverTbl.glWindowPos2fvARB ) {
      driverTbl.glWindowPos2fvARB = missing_glWindowPos2fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2fvARB == loader_glWindowPos2fvARB) {
      rCtx->dsp.emuTbl.glWindowPos2fvARB = driverTbl.glWindowPos2fvARB;
   }
   driverTbl.glWindowPos2fvARB(p);
}

static void REGAL_CALL missing_glWindowPos2iARB(GLint x, GLint y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glWindowPos2iARB" );
}

static void REGAL_CALL loader_glWindowPos2iARB(GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2iARB, "glWindowPos2iARB");
   if ( !driverTbl.glWindowPos2iARB ) {
      driverTbl.glWindowPos2iARB = missing_glWindowPos2iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2iARB == loader_glWindowPos2iARB) {
      rCtx->dsp.emuTbl.glWindowPos2iARB = driverTbl.glWindowPos2iARB;
   }
   driverTbl.glWindowPos2iARB(x, y);
}

static void REGAL_CALL missing_glWindowPos2ivARB(const GLint *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos2ivARB" );
}

static void REGAL_CALL loader_glWindowPos2ivARB(const GLint *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2ivARB, "glWindowPos2ivARB");
   if ( !driverTbl.glWindowPos2ivARB ) {
      driverTbl.glWindowPos2ivARB = missing_glWindowPos2ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2ivARB == loader_glWindowPos2ivARB) {
      rCtx->dsp.emuTbl.glWindowPos2ivARB = driverTbl.glWindowPos2ivARB;
   }
   driverTbl.glWindowPos2ivARB(p);
}

static void REGAL_CALL missing_glWindowPos2sARB(GLshort x, GLshort y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glWindowPos2sARB" );
}

static void REGAL_CALL loader_glWindowPos2sARB(GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2sARB, "glWindowPos2sARB");
   if ( !driverTbl.glWindowPos2sARB ) {
      driverTbl.glWindowPos2sARB = missing_glWindowPos2sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2sARB == loader_glWindowPos2sARB) {
      rCtx->dsp.emuTbl.glWindowPos2sARB = driverTbl.glWindowPos2sARB;
   }
   driverTbl.glWindowPos2sARB(x, y);
}

static void REGAL_CALL missing_glWindowPos2svARB(const GLshort *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos2svARB" );
}

static void REGAL_CALL loader_glWindowPos2svARB(const GLshort *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2svARB, "glWindowPos2svARB");
   if ( !driverTbl.glWindowPos2svARB ) {
      driverTbl.glWindowPos2svARB = missing_glWindowPos2svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2svARB == loader_glWindowPos2svARB) {
      rCtx->dsp.emuTbl.glWindowPos2svARB = driverTbl.glWindowPos2svARB;
   }
   driverTbl.glWindowPos2svARB(p);
}

static void REGAL_CALL missing_glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glWindowPos3dARB" );
}

static void REGAL_CALL loader_glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3dARB, "glWindowPos3dARB");
   if ( !driverTbl.glWindowPos3dARB ) {
      driverTbl.glWindowPos3dARB = missing_glWindowPos3dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3dARB == loader_glWindowPos3dARB) {
      rCtx->dsp.emuTbl.glWindowPos3dARB = driverTbl.glWindowPos3dARB;
   }
   driverTbl.glWindowPos3dARB(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3dvARB(const GLdouble *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos3dvARB" );
}

static void REGAL_CALL loader_glWindowPos3dvARB(const GLdouble *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3dvARB, "glWindowPos3dvARB");
   if ( !driverTbl.glWindowPos3dvARB ) {
      driverTbl.glWindowPos3dvARB = missing_glWindowPos3dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3dvARB == loader_glWindowPos3dvARB) {
      rCtx->dsp.emuTbl.glWindowPos3dvARB = driverTbl.glWindowPos3dvARB;
   }
   driverTbl.glWindowPos3dvARB(p);
}

static void REGAL_CALL missing_glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glWindowPos3fARB" );
}

static void REGAL_CALL loader_glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3fARB, "glWindowPos3fARB");
   if ( !driverTbl.glWindowPos3fARB ) {
      driverTbl.glWindowPos3fARB = missing_glWindowPos3fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3fARB == loader_glWindowPos3fARB) {
      rCtx->dsp.emuTbl.glWindowPos3fARB = driverTbl.glWindowPos3fARB;
   }
   driverTbl.glWindowPos3fARB(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3fvARB(const GLfloat *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos3fvARB" );
}

static void REGAL_CALL loader_glWindowPos3fvARB(const GLfloat *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3fvARB, "glWindowPos3fvARB");
   if ( !driverTbl.glWindowPos3fvARB ) {
      driverTbl.glWindowPos3fvARB = missing_glWindowPos3fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3fvARB == loader_glWindowPos3fvARB) {
      rCtx->dsp.emuTbl.glWindowPos3fvARB = driverTbl.glWindowPos3fvARB;
   }
   driverTbl.glWindowPos3fvARB(p);
}

static void REGAL_CALL missing_glWindowPos3iARB(GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glWindowPos3iARB" );
}

static void REGAL_CALL loader_glWindowPos3iARB(GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3iARB, "glWindowPos3iARB");
   if ( !driverTbl.glWindowPos3iARB ) {
      driverTbl.glWindowPos3iARB = missing_glWindowPos3iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3iARB == loader_glWindowPos3iARB) {
      rCtx->dsp.emuTbl.glWindowPos3iARB = driverTbl.glWindowPos3iARB;
   }
   driverTbl.glWindowPos3iARB(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3ivARB(const GLint *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos3ivARB" );
}

static void REGAL_CALL loader_glWindowPos3ivARB(const GLint *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3ivARB, "glWindowPos3ivARB");
   if ( !driverTbl.glWindowPos3ivARB ) {
      driverTbl.glWindowPos3ivARB = missing_glWindowPos3ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3ivARB == loader_glWindowPos3ivARB) {
      rCtx->dsp.emuTbl.glWindowPos3ivARB = driverTbl.glWindowPos3ivARB;
   }
   driverTbl.glWindowPos3ivARB(p);
}

static void REGAL_CALL missing_glWindowPos3sARB(GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glWindowPos3sARB" );
}

static void REGAL_CALL loader_glWindowPos3sARB(GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3sARB, "glWindowPos3sARB");
   if ( !driverTbl.glWindowPos3sARB ) {
      driverTbl.glWindowPos3sARB = missing_glWindowPos3sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3sARB == loader_glWindowPos3sARB) {
      rCtx->dsp.emuTbl.glWindowPos3sARB = driverTbl.glWindowPos3sARB;
   }
   driverTbl.glWindowPos3sARB(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3svARB(const GLshort *p)
{
   UNUSED_PARAMETER(p);
   Warning( "Called missing function glWindowPos3svARB" );
}

static void REGAL_CALL loader_glWindowPos3svARB(const GLshort *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3svARB, "glWindowPos3svARB");
   if ( !driverTbl.glWindowPos3svARB ) {
      driverTbl.glWindowPos3svARB = missing_glWindowPos3svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3svARB == loader_glWindowPos3svARB) {
      rCtx->dsp.emuTbl.glWindowPos3svARB = driverTbl.glWindowPos3svARB;
   }
   driverTbl.glWindowPos3svARB(p);
}

// GL_ARB_vertex_program

static void REGAL_CALL missing_glVertexAttrib1dARB(GLuint index, GLdouble x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttrib1dARB" );
}

static void REGAL_CALL loader_glVertexAttrib1dARB(GLuint index, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1dARB, "glVertexAttrib1dARB");
   if ( !driverTbl.glVertexAttrib1dARB ) {
      driverTbl.glVertexAttrib1dARB = missing_glVertexAttrib1dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1dARB == loader_glVertexAttrib1dARB) {
      rCtx->dsp.emuTbl.glVertexAttrib1dARB = driverTbl.glVertexAttrib1dARB;
   }
   driverTbl.glVertexAttrib1dARB(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1dvARB(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib1dvARB" );
}

static void REGAL_CALL loader_glVertexAttrib1dvARB(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1dvARB, "glVertexAttrib1dvARB");
   if ( !driverTbl.glVertexAttrib1dvARB ) {
      driverTbl.glVertexAttrib1dvARB = missing_glVertexAttrib1dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1dvARB == loader_glVertexAttrib1dvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib1dvARB = driverTbl.glVertexAttrib1dvARB;
   }
   driverTbl.glVertexAttrib1dvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib1fARB(GLuint index, GLfloat x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttrib1fARB" );
}

static void REGAL_CALL loader_glVertexAttrib1fARB(GLuint index, GLfloat x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1fARB, "glVertexAttrib1fARB");
   if ( !driverTbl.glVertexAttrib1fARB ) {
      driverTbl.glVertexAttrib1fARB = missing_glVertexAttrib1fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1fARB == loader_glVertexAttrib1fARB) {
      rCtx->dsp.emuTbl.glVertexAttrib1fARB = driverTbl.glVertexAttrib1fARB;
   }
   driverTbl.glVertexAttrib1fARB(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1fvARB(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib1fvARB" );
}

static void REGAL_CALL loader_glVertexAttrib1fvARB(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1fvARB, "glVertexAttrib1fvARB");
   if ( !driverTbl.glVertexAttrib1fvARB ) {
      driverTbl.glVertexAttrib1fvARB = missing_glVertexAttrib1fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1fvARB == loader_glVertexAttrib1fvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib1fvARB = driverTbl.glVertexAttrib1fvARB;
   }
   driverTbl.glVertexAttrib1fvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib1sARB(GLuint index, GLshort x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttrib1sARB" );
}

static void REGAL_CALL loader_glVertexAttrib1sARB(GLuint index, GLshort x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1sARB, "glVertexAttrib1sARB");
   if ( !driverTbl.glVertexAttrib1sARB ) {
      driverTbl.glVertexAttrib1sARB = missing_glVertexAttrib1sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1sARB == loader_glVertexAttrib1sARB) {
      rCtx->dsp.emuTbl.glVertexAttrib1sARB = driverTbl.glVertexAttrib1sARB;
   }
   driverTbl.glVertexAttrib1sARB(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1svARB(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib1svARB" );
}

static void REGAL_CALL loader_glVertexAttrib1svARB(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1svARB, "glVertexAttrib1svARB");
   if ( !driverTbl.glVertexAttrib1svARB ) {
      driverTbl.glVertexAttrib1svARB = missing_glVertexAttrib1svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1svARB == loader_glVertexAttrib1svARB) {
      rCtx->dsp.emuTbl.glVertexAttrib1svARB = driverTbl.glVertexAttrib1svARB;
   }
   driverTbl.glVertexAttrib1svARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttrib2dARB" );
}

static void REGAL_CALL loader_glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2dARB, "glVertexAttrib2dARB");
   if ( !driverTbl.glVertexAttrib2dARB ) {
      driverTbl.glVertexAttrib2dARB = missing_glVertexAttrib2dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2dARB == loader_glVertexAttrib2dARB) {
      rCtx->dsp.emuTbl.glVertexAttrib2dARB = driverTbl.glVertexAttrib2dARB;
   }
   driverTbl.glVertexAttrib2dARB(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2dvARB(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib2dvARB" );
}

static void REGAL_CALL loader_glVertexAttrib2dvARB(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2dvARB, "glVertexAttrib2dvARB");
   if ( !driverTbl.glVertexAttrib2dvARB ) {
      driverTbl.glVertexAttrib2dvARB = missing_glVertexAttrib2dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2dvARB == loader_glVertexAttrib2dvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib2dvARB = driverTbl.glVertexAttrib2dvARB;
   }
   driverTbl.glVertexAttrib2dvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttrib2fARB" );
}

static void REGAL_CALL loader_glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2fARB, "glVertexAttrib2fARB");
   if ( !driverTbl.glVertexAttrib2fARB ) {
      driverTbl.glVertexAttrib2fARB = missing_glVertexAttrib2fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2fARB == loader_glVertexAttrib2fARB) {
      rCtx->dsp.emuTbl.glVertexAttrib2fARB = driverTbl.glVertexAttrib2fARB;
   }
   driverTbl.glVertexAttrib2fARB(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2fvARB(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib2fvARB" );
}

static void REGAL_CALL loader_glVertexAttrib2fvARB(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2fvARB, "glVertexAttrib2fvARB");
   if ( !driverTbl.glVertexAttrib2fvARB ) {
      driverTbl.glVertexAttrib2fvARB = missing_glVertexAttrib2fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2fvARB == loader_glVertexAttrib2fvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib2fvARB = driverTbl.glVertexAttrib2fvARB;
   }
   driverTbl.glVertexAttrib2fvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttrib2sARB" );
}

static void REGAL_CALL loader_glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2sARB, "glVertexAttrib2sARB");
   if ( !driverTbl.glVertexAttrib2sARB ) {
      driverTbl.glVertexAttrib2sARB = missing_glVertexAttrib2sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2sARB == loader_glVertexAttrib2sARB) {
      rCtx->dsp.emuTbl.glVertexAttrib2sARB = driverTbl.glVertexAttrib2sARB;
   }
   driverTbl.glVertexAttrib2sARB(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2svARB(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib2svARB" );
}

static void REGAL_CALL loader_glVertexAttrib2svARB(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2svARB, "glVertexAttrib2svARB");
   if ( !driverTbl.glVertexAttrib2svARB ) {
      driverTbl.glVertexAttrib2svARB = missing_glVertexAttrib2svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2svARB == loader_glVertexAttrib2svARB) {
      rCtx->dsp.emuTbl.glVertexAttrib2svARB = driverTbl.glVertexAttrib2svARB;
   }
   driverTbl.glVertexAttrib2svARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttrib3dARB" );
}

static void REGAL_CALL loader_glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3dARB, "glVertexAttrib3dARB");
   if ( !driverTbl.glVertexAttrib3dARB ) {
      driverTbl.glVertexAttrib3dARB = missing_glVertexAttrib3dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3dARB == loader_glVertexAttrib3dARB) {
      rCtx->dsp.emuTbl.glVertexAttrib3dARB = driverTbl.glVertexAttrib3dARB;
   }
   driverTbl.glVertexAttrib3dARB(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3dvARB(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib3dvARB" );
}

static void REGAL_CALL loader_glVertexAttrib3dvARB(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3dvARB, "glVertexAttrib3dvARB");
   if ( !driverTbl.glVertexAttrib3dvARB ) {
      driverTbl.glVertexAttrib3dvARB = missing_glVertexAttrib3dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3dvARB == loader_glVertexAttrib3dvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib3dvARB = driverTbl.glVertexAttrib3dvARB;
   }
   driverTbl.glVertexAttrib3dvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttrib3fARB" );
}

static void REGAL_CALL loader_glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3fARB, "glVertexAttrib3fARB");
   if ( !driverTbl.glVertexAttrib3fARB ) {
      driverTbl.glVertexAttrib3fARB = missing_glVertexAttrib3fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3fARB == loader_glVertexAttrib3fARB) {
      rCtx->dsp.emuTbl.glVertexAttrib3fARB = driverTbl.glVertexAttrib3fARB;
   }
   driverTbl.glVertexAttrib3fARB(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3fvARB(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib3fvARB" );
}

static void REGAL_CALL loader_glVertexAttrib3fvARB(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3fvARB, "glVertexAttrib3fvARB");
   if ( !driverTbl.glVertexAttrib3fvARB ) {
      driverTbl.glVertexAttrib3fvARB = missing_glVertexAttrib3fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3fvARB == loader_glVertexAttrib3fvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib3fvARB = driverTbl.glVertexAttrib3fvARB;
   }
   driverTbl.glVertexAttrib3fvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttrib3sARB" );
}

static void REGAL_CALL loader_glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3sARB, "glVertexAttrib3sARB");
   if ( !driverTbl.glVertexAttrib3sARB ) {
      driverTbl.glVertexAttrib3sARB = missing_glVertexAttrib3sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3sARB == loader_glVertexAttrib3sARB) {
      rCtx->dsp.emuTbl.glVertexAttrib3sARB = driverTbl.glVertexAttrib3sARB;
   }
   driverTbl.glVertexAttrib3sARB(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3svARB(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib3svARB" );
}

static void REGAL_CALL loader_glVertexAttrib3svARB(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3svARB, "glVertexAttrib3svARB");
   if ( !driverTbl.glVertexAttrib3svARB ) {
      driverTbl.glVertexAttrib3svARB = missing_glVertexAttrib3svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3svARB == loader_glVertexAttrib3svARB) {
      rCtx->dsp.emuTbl.glVertexAttrib3svARB = driverTbl.glVertexAttrib3svARB;
   }
   driverTbl.glVertexAttrib3svARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4NbvARB" );
}

static void REGAL_CALL loader_glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4NbvARB, "glVertexAttrib4NbvARB");
   if ( !driverTbl.glVertexAttrib4NbvARB ) {
      driverTbl.glVertexAttrib4NbvARB = missing_glVertexAttrib4NbvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4NbvARB == loader_glVertexAttrib4NbvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4NbvARB = driverTbl.glVertexAttrib4NbvARB;
   }
   driverTbl.glVertexAttrib4NbvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4NivARB(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4NivARB" );
}

static void REGAL_CALL loader_glVertexAttrib4NivARB(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4NivARB, "glVertexAttrib4NivARB");
   if ( !driverTbl.glVertexAttrib4NivARB ) {
      driverTbl.glVertexAttrib4NivARB = missing_glVertexAttrib4NivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4NivARB == loader_glVertexAttrib4NivARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4NivARB = driverTbl.glVertexAttrib4NivARB;
   }
   driverTbl.glVertexAttrib4NivARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4NsvARB(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4NsvARB" );
}

static void REGAL_CALL loader_glVertexAttrib4NsvARB(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4NsvARB, "glVertexAttrib4NsvARB");
   if ( !driverTbl.glVertexAttrib4NsvARB ) {
      driverTbl.glVertexAttrib4NsvARB = missing_glVertexAttrib4NsvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4NsvARB == loader_glVertexAttrib4NsvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4NsvARB = driverTbl.glVertexAttrib4NsvARB;
   }
   driverTbl.glVertexAttrib4NsvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttrib4NubARB" );
}

static void REGAL_CALL loader_glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4NubARB, "glVertexAttrib4NubARB");
   if ( !driverTbl.glVertexAttrib4NubARB ) {
      driverTbl.glVertexAttrib4NubARB = missing_glVertexAttrib4NubARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4NubARB == loader_glVertexAttrib4NubARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4NubARB = driverTbl.glVertexAttrib4NubARB;
   }
   driverTbl.glVertexAttrib4NubARB(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4NubvARB" );
}

static void REGAL_CALL loader_glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4NubvARB, "glVertexAttrib4NubvARB");
   if ( !driverTbl.glVertexAttrib4NubvARB ) {
      driverTbl.glVertexAttrib4NubvARB = missing_glVertexAttrib4NubvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4NubvARB == loader_glVertexAttrib4NubvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4NubvARB = driverTbl.glVertexAttrib4NubvARB;
   }
   driverTbl.glVertexAttrib4NubvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4NuivARB(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4NuivARB" );
}

static void REGAL_CALL loader_glVertexAttrib4NuivARB(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4NuivARB, "glVertexAttrib4NuivARB");
   if ( !driverTbl.glVertexAttrib4NuivARB ) {
      driverTbl.glVertexAttrib4NuivARB = missing_glVertexAttrib4NuivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4NuivARB == loader_glVertexAttrib4NuivARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4NuivARB = driverTbl.glVertexAttrib4NuivARB;
   }
   driverTbl.glVertexAttrib4NuivARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4NusvARB(GLuint index, const GLushort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4NusvARB" );
}

static void REGAL_CALL loader_glVertexAttrib4NusvARB(GLuint index, const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4NusvARB, "glVertexAttrib4NusvARB");
   if ( !driverTbl.glVertexAttrib4NusvARB ) {
      driverTbl.glVertexAttrib4NusvARB = missing_glVertexAttrib4NusvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4NusvARB == loader_glVertexAttrib4NusvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4NusvARB = driverTbl.glVertexAttrib4NusvARB;
   }
   driverTbl.glVertexAttrib4NusvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4bvARB" );
}

static void REGAL_CALL loader_glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4bvARB, "glVertexAttrib4bvARB");
   if ( !driverTbl.glVertexAttrib4bvARB ) {
      driverTbl.glVertexAttrib4bvARB = missing_glVertexAttrib4bvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4bvARB == loader_glVertexAttrib4bvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4bvARB = driverTbl.glVertexAttrib4bvARB;
   }
   driverTbl.glVertexAttrib4bvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttrib4dARB" );
}

static void REGAL_CALL loader_glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4dARB, "glVertexAttrib4dARB");
   if ( !driverTbl.glVertexAttrib4dARB ) {
      driverTbl.glVertexAttrib4dARB = missing_glVertexAttrib4dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4dARB == loader_glVertexAttrib4dARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4dARB = driverTbl.glVertexAttrib4dARB;
   }
   driverTbl.glVertexAttrib4dARB(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4dvARB(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4dvARB" );
}

static void REGAL_CALL loader_glVertexAttrib4dvARB(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4dvARB, "glVertexAttrib4dvARB");
   if ( !driverTbl.glVertexAttrib4dvARB ) {
      driverTbl.glVertexAttrib4dvARB = missing_glVertexAttrib4dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4dvARB == loader_glVertexAttrib4dvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4dvARB = driverTbl.glVertexAttrib4dvARB;
   }
   driverTbl.glVertexAttrib4dvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttrib4fARB" );
}

static void REGAL_CALL loader_glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4fARB, "glVertexAttrib4fARB");
   if ( !driverTbl.glVertexAttrib4fARB ) {
      driverTbl.glVertexAttrib4fARB = missing_glVertexAttrib4fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4fARB == loader_glVertexAttrib4fARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4fARB = driverTbl.glVertexAttrib4fARB;
   }
   driverTbl.glVertexAttrib4fARB(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4fvARB(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4fvARB" );
}

static void REGAL_CALL loader_glVertexAttrib4fvARB(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4fvARB, "glVertexAttrib4fvARB");
   if ( !driverTbl.glVertexAttrib4fvARB ) {
      driverTbl.glVertexAttrib4fvARB = missing_glVertexAttrib4fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4fvARB == loader_glVertexAttrib4fvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4fvARB = driverTbl.glVertexAttrib4fvARB;
   }
   driverTbl.glVertexAttrib4fvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4ivARB(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4ivARB" );
}

static void REGAL_CALL loader_glVertexAttrib4ivARB(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4ivARB, "glVertexAttrib4ivARB");
   if ( !driverTbl.glVertexAttrib4ivARB ) {
      driverTbl.glVertexAttrib4ivARB = missing_glVertexAttrib4ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4ivARB == loader_glVertexAttrib4ivARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4ivARB = driverTbl.glVertexAttrib4ivARB;
   }
   driverTbl.glVertexAttrib4ivARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttrib4sARB" );
}

static void REGAL_CALL loader_glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4sARB, "glVertexAttrib4sARB");
   if ( !driverTbl.glVertexAttrib4sARB ) {
      driverTbl.glVertexAttrib4sARB = missing_glVertexAttrib4sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4sARB == loader_glVertexAttrib4sARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4sARB = driverTbl.glVertexAttrib4sARB;
   }
   driverTbl.glVertexAttrib4sARB(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4svARB(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4svARB" );
}

static void REGAL_CALL loader_glVertexAttrib4svARB(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4svARB, "glVertexAttrib4svARB");
   if ( !driverTbl.glVertexAttrib4svARB ) {
      driverTbl.glVertexAttrib4svARB = missing_glVertexAttrib4svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4svARB == loader_glVertexAttrib4svARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4svARB = driverTbl.glVertexAttrib4svARB;
   }
   driverTbl.glVertexAttrib4svARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4ubvARB" );
}

static void REGAL_CALL loader_glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4ubvARB, "glVertexAttrib4ubvARB");
   if ( !driverTbl.glVertexAttrib4ubvARB ) {
      driverTbl.glVertexAttrib4ubvARB = missing_glVertexAttrib4ubvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4ubvARB == loader_glVertexAttrib4ubvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4ubvARB = driverTbl.glVertexAttrib4ubvARB;
   }
   driverTbl.glVertexAttrib4ubvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4uivARB(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4uivARB" );
}

static void REGAL_CALL loader_glVertexAttrib4uivARB(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4uivARB, "glVertexAttrib4uivARB");
   if ( !driverTbl.glVertexAttrib4uivARB ) {
      driverTbl.glVertexAttrib4uivARB = missing_glVertexAttrib4uivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4uivARB == loader_glVertexAttrib4uivARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4uivARB = driverTbl.glVertexAttrib4uivARB;
   }
   driverTbl.glVertexAttrib4uivARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4usvARB(GLuint index, const GLushort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4usvARB" );
}

static void REGAL_CALL loader_glVertexAttrib4usvARB(GLuint index, const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4usvARB, "glVertexAttrib4usvARB");
   if ( !driverTbl.glVertexAttrib4usvARB ) {
      driverTbl.glVertexAttrib4usvARB = missing_glVertexAttrib4usvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4usvARB == loader_glVertexAttrib4usvARB) {
      rCtx->dsp.emuTbl.glVertexAttrib4usvARB = driverTbl.glVertexAttrib4usvARB;
   }
   driverTbl.glVertexAttrib4usvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glVertexAttribPointerARB" );
}

static void REGAL_CALL loader_glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribPointerARB, "glVertexAttribPointerARB");
   if ( !driverTbl.glVertexAttribPointerARB ) {
      driverTbl.glVertexAttribPointerARB = missing_glVertexAttribPointerARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribPointerARB == loader_glVertexAttribPointerARB) {
      rCtx->dsp.emuTbl.glVertexAttribPointerARB = driverTbl.glVertexAttribPointerARB;
   }
   driverTbl.glVertexAttribPointerARB(index, size, type, normalized, stride, pointer);
}

static void REGAL_CALL missing_glEnableVertexAttribArrayARB(GLuint index)
{
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glEnableVertexAttribArrayARB" );
}

static void REGAL_CALL loader_glEnableVertexAttribArrayARB(GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEnableVertexAttribArrayARB, "glEnableVertexAttribArrayARB");
   if ( !driverTbl.glEnableVertexAttribArrayARB ) {
      driverTbl.glEnableVertexAttribArrayARB = missing_glEnableVertexAttribArrayARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEnableVertexAttribArrayARB == loader_glEnableVertexAttribArrayARB) {
      rCtx->dsp.emuTbl.glEnableVertexAttribArrayARB = driverTbl.glEnableVertexAttribArrayARB;
   }
   driverTbl.glEnableVertexAttribArrayARB(index);
}

static void REGAL_CALL missing_glDisableVertexAttribArrayARB(GLuint index)
{
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glDisableVertexAttribArrayARB" );
}

static void REGAL_CALL loader_glDisableVertexAttribArrayARB(GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDisableVertexAttribArrayARB, "glDisableVertexAttribArrayARB");
   if ( !driverTbl.glDisableVertexAttribArrayARB ) {
      driverTbl.glDisableVertexAttribArrayARB = missing_glDisableVertexAttribArrayARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDisableVertexAttribArrayARB == loader_glDisableVertexAttribArrayARB) {
      rCtx->dsp.emuTbl.glDisableVertexAttribArrayARB = driverTbl.glDisableVertexAttribArrayARB;
   }
   driverTbl.glDisableVertexAttribArrayARB(index);
}

static void REGAL_CALL missing_glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(string);
   Warning( "Called missing function glProgramStringARB" );
}

static void REGAL_CALL loader_glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramStringARB, "glProgramStringARB");
   if ( !driverTbl.glProgramStringARB ) {
      driverTbl.glProgramStringARB = missing_glProgramStringARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramStringARB == loader_glProgramStringARB) {
      rCtx->dsp.emuTbl.glProgramStringARB = driverTbl.glProgramStringARB;
   }
   driverTbl.glProgramStringARB(target, format, len, string);
}

static void REGAL_CALL missing_glBindProgramARB(GLenum target, GLuint program)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(program);
   Warning( "Called missing function glBindProgramARB" );
}

static void REGAL_CALL loader_glBindProgramARB(GLenum target, GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindProgramARB, "glBindProgramARB");
   if ( !driverTbl.glBindProgramARB ) {
      driverTbl.glBindProgramARB = missing_glBindProgramARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindProgramARB == loader_glBindProgramARB) {
      rCtx->dsp.emuTbl.glBindProgramARB = driverTbl.glBindProgramARB;
   }
   driverTbl.glBindProgramARB(target, program);
}

static void REGAL_CALL missing_glDeleteProgramsARB(GLsizei n, const GLuint *programs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(programs);
   Warning( "Called missing function glDeleteProgramsARB" );
}

static void REGAL_CALL loader_glDeleteProgramsARB(GLsizei n, const GLuint *programs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteProgramsARB, "glDeleteProgramsARB");
   if ( !driverTbl.glDeleteProgramsARB ) {
      driverTbl.glDeleteProgramsARB = missing_glDeleteProgramsARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteProgramsARB == loader_glDeleteProgramsARB) {
      rCtx->dsp.emuTbl.glDeleteProgramsARB = driverTbl.glDeleteProgramsARB;
   }
   driverTbl.glDeleteProgramsARB(n, programs);
}

static void REGAL_CALL missing_glGenProgramsARB(GLsizei n, GLuint *programs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(programs);
   Warning( "Called missing function glGenProgramsARB" );
}

static void REGAL_CALL loader_glGenProgramsARB(GLsizei n, GLuint *programs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenProgramsARB, "glGenProgramsARB");
   if ( !driverTbl.glGenProgramsARB ) {
      driverTbl.glGenProgramsARB = missing_glGenProgramsARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenProgramsARB == loader_glGenProgramsARB) {
      rCtx->dsp.emuTbl.glGenProgramsARB = driverTbl.glGenProgramsARB;
   }
   driverTbl.glGenProgramsARB(n, programs);
}

static void REGAL_CALL missing_glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramEnvParameter4dARB" );
}

static void REGAL_CALL loader_glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramEnvParameter4dARB, "glProgramEnvParameter4dARB");
   if ( !driverTbl.glProgramEnvParameter4dARB ) {
      driverTbl.glProgramEnvParameter4dARB = missing_glProgramEnvParameter4dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramEnvParameter4dARB == loader_glProgramEnvParameter4dARB) {
      rCtx->dsp.emuTbl.glProgramEnvParameter4dARB = driverTbl.glProgramEnvParameter4dARB;
   }
   driverTbl.glProgramEnvParameter4dARB(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramEnvParameter4dvARB" );
}

static void REGAL_CALL loader_glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramEnvParameter4dvARB, "glProgramEnvParameter4dvARB");
   if ( !driverTbl.glProgramEnvParameter4dvARB ) {
      driverTbl.glProgramEnvParameter4dvARB = missing_glProgramEnvParameter4dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramEnvParameter4dvARB == loader_glProgramEnvParameter4dvARB) {
      rCtx->dsp.emuTbl.glProgramEnvParameter4dvARB = driverTbl.glProgramEnvParameter4dvARB;
   }
   driverTbl.glProgramEnvParameter4dvARB(target, index, params);
}

static void REGAL_CALL missing_glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramEnvParameter4fARB" );
}

static void REGAL_CALL loader_glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramEnvParameter4fARB, "glProgramEnvParameter4fARB");
   if ( !driverTbl.glProgramEnvParameter4fARB ) {
      driverTbl.glProgramEnvParameter4fARB = missing_glProgramEnvParameter4fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramEnvParameter4fARB == loader_glProgramEnvParameter4fARB) {
      rCtx->dsp.emuTbl.glProgramEnvParameter4fARB = driverTbl.glProgramEnvParameter4fARB;
   }
   driverTbl.glProgramEnvParameter4fARB(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramEnvParameter4fvARB" );
}

static void REGAL_CALL loader_glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramEnvParameter4fvARB, "glProgramEnvParameter4fvARB");
   if ( !driverTbl.glProgramEnvParameter4fvARB ) {
      driverTbl.glProgramEnvParameter4fvARB = missing_glProgramEnvParameter4fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramEnvParameter4fvARB == loader_glProgramEnvParameter4fvARB) {
      rCtx->dsp.emuTbl.glProgramEnvParameter4fvARB = driverTbl.glProgramEnvParameter4fvARB;
   }
   driverTbl.glProgramEnvParameter4fvARB(target, index, params);
}

static void REGAL_CALL missing_glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramLocalParameter4dARB" );
}

static void REGAL_CALL loader_glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramLocalParameter4dARB, "glProgramLocalParameter4dARB");
   if ( !driverTbl.glProgramLocalParameter4dARB ) {
      driverTbl.glProgramLocalParameter4dARB = missing_glProgramLocalParameter4dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramLocalParameter4dARB == loader_glProgramLocalParameter4dARB) {
      rCtx->dsp.emuTbl.glProgramLocalParameter4dARB = driverTbl.glProgramLocalParameter4dARB;
   }
   driverTbl.glProgramLocalParameter4dARB(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramLocalParameter4dvARB" );
}

static void REGAL_CALL loader_glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramLocalParameter4dvARB, "glProgramLocalParameter4dvARB");
   if ( !driverTbl.glProgramLocalParameter4dvARB ) {
      driverTbl.glProgramLocalParameter4dvARB = missing_glProgramLocalParameter4dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramLocalParameter4dvARB == loader_glProgramLocalParameter4dvARB) {
      rCtx->dsp.emuTbl.glProgramLocalParameter4dvARB = driverTbl.glProgramLocalParameter4dvARB;
   }
   driverTbl.glProgramLocalParameter4dvARB(target, index, params);
}

static void REGAL_CALL missing_glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramLocalParameter4fARB" );
}

static void REGAL_CALL loader_glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramLocalParameter4fARB, "glProgramLocalParameter4fARB");
   if ( !driverTbl.glProgramLocalParameter4fARB ) {
      driverTbl.glProgramLocalParameter4fARB = missing_glProgramLocalParameter4fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramLocalParameter4fARB == loader_glProgramLocalParameter4fARB) {
      rCtx->dsp.emuTbl.glProgramLocalParameter4fARB = driverTbl.glProgramLocalParameter4fARB;
   }
   driverTbl.glProgramLocalParameter4fARB(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramLocalParameter4fvARB" );
}

static void REGAL_CALL loader_glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramLocalParameter4fvARB, "glProgramLocalParameter4fvARB");
   if ( !driverTbl.glProgramLocalParameter4fvARB ) {
      driverTbl.glProgramLocalParameter4fvARB = missing_glProgramLocalParameter4fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramLocalParameter4fvARB == loader_glProgramLocalParameter4fvARB) {
      rCtx->dsp.emuTbl.glProgramLocalParameter4fvARB = driverTbl.glProgramLocalParameter4fvARB;
   }
   driverTbl.glProgramLocalParameter4fvARB(target, index, params);
}

static void REGAL_CALL missing_glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramEnvParameterdvARB" );
}

static void REGAL_CALL loader_glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramEnvParameterdvARB, "glGetProgramEnvParameterdvARB");
   if ( !driverTbl.glGetProgramEnvParameterdvARB ) {
      driverTbl.glGetProgramEnvParameterdvARB = missing_glGetProgramEnvParameterdvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramEnvParameterdvARB == loader_glGetProgramEnvParameterdvARB) {
      rCtx->dsp.emuTbl.glGetProgramEnvParameterdvARB = driverTbl.glGetProgramEnvParameterdvARB;
   }
   driverTbl.glGetProgramEnvParameterdvARB(target, index, params);
}

static void REGAL_CALL missing_glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramEnvParameterfvARB" );
}

static void REGAL_CALL loader_glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramEnvParameterfvARB, "glGetProgramEnvParameterfvARB");
   if ( !driverTbl.glGetProgramEnvParameterfvARB ) {
      driverTbl.glGetProgramEnvParameterfvARB = missing_glGetProgramEnvParameterfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramEnvParameterfvARB == loader_glGetProgramEnvParameterfvARB) {
      rCtx->dsp.emuTbl.glGetProgramEnvParameterfvARB = driverTbl.glGetProgramEnvParameterfvARB;
   }
   driverTbl.glGetProgramEnvParameterfvARB(target, index, params);
}

static void REGAL_CALL missing_glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramLocalParameterdvARB" );
}

static void REGAL_CALL loader_glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramLocalParameterdvARB, "glGetProgramLocalParameterdvARB");
   if ( !driverTbl.glGetProgramLocalParameterdvARB ) {
      driverTbl.glGetProgramLocalParameterdvARB = missing_glGetProgramLocalParameterdvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramLocalParameterdvARB == loader_glGetProgramLocalParameterdvARB) {
      rCtx->dsp.emuTbl.glGetProgramLocalParameterdvARB = driverTbl.glGetProgramLocalParameterdvARB;
   }
   driverTbl.glGetProgramLocalParameterdvARB(target, index, params);
}

static void REGAL_CALL missing_glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramLocalParameterfvARB" );
}

static void REGAL_CALL loader_glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramLocalParameterfvARB, "glGetProgramLocalParameterfvARB");
   if ( !driverTbl.glGetProgramLocalParameterfvARB ) {
      driverTbl.glGetProgramLocalParameterfvARB = missing_glGetProgramLocalParameterfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramLocalParameterfvARB == loader_glGetProgramLocalParameterfvARB) {
      rCtx->dsp.emuTbl.glGetProgramLocalParameterfvARB = driverTbl.glGetProgramLocalParameterfvARB;
   }
   driverTbl.glGetProgramLocalParameterfvARB(target, index, params);
}

static void REGAL_CALL missing_glGetProgramivARB(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramivARB" );
}

static void REGAL_CALL loader_glGetProgramivARB(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramivARB, "glGetProgramivARB");
   if ( !driverTbl.glGetProgramivARB ) {
      driverTbl.glGetProgramivARB = missing_glGetProgramivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramivARB == loader_glGetProgramivARB) {
      rCtx->dsp.emuTbl.glGetProgramivARB = driverTbl.glGetProgramivARB;
   }
   driverTbl.glGetProgramivARB(target, pname, params);
}

static void REGAL_CALL missing_glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(string);
   Warning( "Called missing function glGetProgramStringARB" );
}

static void REGAL_CALL loader_glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramStringARB, "glGetProgramStringARB");
   if ( !driverTbl.glGetProgramStringARB ) {
      driverTbl.glGetProgramStringARB = missing_glGetProgramStringARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramStringARB == loader_glGetProgramStringARB) {
      rCtx->dsp.emuTbl.glGetProgramStringARB = driverTbl.glGetProgramStringARB;
   }
   driverTbl.glGetProgramStringARB(target, pname, string);
}

static void REGAL_CALL missing_glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribdvARB" );
}

static void REGAL_CALL loader_glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribdvARB, "glGetVertexAttribdvARB");
   if ( !driverTbl.glGetVertexAttribdvARB ) {
      driverTbl.glGetVertexAttribdvARB = missing_glGetVertexAttribdvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribdvARB == loader_glGetVertexAttribdvARB) {
      rCtx->dsp.emuTbl.glGetVertexAttribdvARB = driverTbl.glGetVertexAttribdvARB;
   }
   driverTbl.glGetVertexAttribdvARB(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribfvARB" );
}

static void REGAL_CALL loader_glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribfvARB, "glGetVertexAttribfvARB");
   if ( !driverTbl.glGetVertexAttribfvARB ) {
      driverTbl.glGetVertexAttribfvARB = missing_glGetVertexAttribfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribfvARB == loader_glGetVertexAttribfvARB) {
      rCtx->dsp.emuTbl.glGetVertexAttribfvARB = driverTbl.glGetVertexAttribfvARB;
   }
   driverTbl.glGetVertexAttribfvARB(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribivARB" );
}

static void REGAL_CALL loader_glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribivARB, "glGetVertexAttribivARB");
   if ( !driverTbl.glGetVertexAttribivARB ) {
      driverTbl.glGetVertexAttribivARB = missing_glGetVertexAttribivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribivARB == loader_glGetVertexAttribivARB) {
      rCtx->dsp.emuTbl.glGetVertexAttribivARB = driverTbl.glGetVertexAttribivARB;
   }
   driverTbl.glGetVertexAttribivARB(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glGetVertexAttribPointervARB" );
}

static void REGAL_CALL loader_glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribPointervARB, "glGetVertexAttribPointervARB");
   if ( !driverTbl.glGetVertexAttribPointervARB ) {
      driverTbl.glGetVertexAttribPointervARB = missing_glGetVertexAttribPointervARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribPointervARB == loader_glGetVertexAttribPointervARB) {
      rCtx->dsp.emuTbl.glGetVertexAttribPointervARB = driverTbl.glGetVertexAttribPointervARB;
   }
   driverTbl.glGetVertexAttribPointervARB(index, pname, pointer);
}

static GLboolean REGAL_CALL missing_glIsProgramARB(GLuint program)
{
   UNUSED_PARAMETER(program);
   Warning( "Called missing function glIsProgramARB" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsProgramARB(GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsProgramARB, "glIsProgramARB");
   if ( !driverTbl.glIsProgramARB ) {
      driverTbl.glIsProgramARB = missing_glIsProgramARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsProgramARB == loader_glIsProgramARB) {
      rCtx->dsp.emuTbl.glIsProgramARB = driverTbl.glIsProgramARB;
   }
   return driverTbl.glIsProgramARB(program);
}

// GL_ARB_vertex_buffer_object

static void REGAL_CALL missing_glBindBufferARB(GLenum target, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glBindBufferARB" );
}

static void REGAL_CALL loader_glBindBufferARB(GLenum target, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindBufferARB, "glBindBufferARB");
   if ( !driverTbl.glBindBufferARB ) {
      driverTbl.glBindBufferARB = missing_glBindBufferARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindBufferARB == loader_glBindBufferARB) {
      rCtx->dsp.emuTbl.glBindBufferARB = driverTbl.glBindBufferARB;
   }
   driverTbl.glBindBufferARB(target, buffer);
}

static void REGAL_CALL missing_glDeleteBuffersARB(GLsizei n, const GLuint *buffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(buffers);
   Warning( "Called missing function glDeleteBuffersARB" );
}

static void REGAL_CALL loader_glDeleteBuffersARB(GLsizei n, const GLuint *buffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteBuffersARB, "glDeleteBuffersARB");
   if ( !driverTbl.glDeleteBuffersARB ) {
      driverTbl.glDeleteBuffersARB = missing_glDeleteBuffersARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteBuffersARB == loader_glDeleteBuffersARB) {
      rCtx->dsp.emuTbl.glDeleteBuffersARB = driverTbl.glDeleteBuffersARB;
   }
   driverTbl.glDeleteBuffersARB(n, buffers);
}

static void REGAL_CALL missing_glGenBuffersARB(GLsizei n, GLuint *buffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(buffers);
   Warning( "Called missing function glGenBuffersARB" );
}

static void REGAL_CALL loader_glGenBuffersARB(GLsizei n, GLuint *buffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenBuffersARB, "glGenBuffersARB");
   if ( !driverTbl.glGenBuffersARB ) {
      driverTbl.glGenBuffersARB = missing_glGenBuffersARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenBuffersARB == loader_glGenBuffersARB) {
      rCtx->dsp.emuTbl.glGenBuffersARB = driverTbl.glGenBuffersARB;
   }
   driverTbl.glGenBuffersARB(n, buffers);
}

static GLboolean REGAL_CALL missing_glIsBufferARB(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glIsBufferARB" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsBufferARB(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsBufferARB, "glIsBufferARB");
   if ( !driverTbl.glIsBufferARB ) {
      driverTbl.glIsBufferARB = missing_glIsBufferARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsBufferARB == loader_glIsBufferARB) {
      rCtx->dsp.emuTbl.glIsBufferARB = driverTbl.glIsBufferARB;
   }
   return driverTbl.glIsBufferARB(buffer);
}

static void REGAL_CALL missing_glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   UNUSED_PARAMETER(usage);
   Warning( "Called missing function glBufferDataARB" );
}

static void REGAL_CALL loader_glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBufferDataARB, "glBufferDataARB");
   if ( !driverTbl.glBufferDataARB ) {
      driverTbl.glBufferDataARB = missing_glBufferDataARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBufferDataARB == loader_glBufferDataARB) {
      rCtx->dsp.emuTbl.glBufferDataARB = driverTbl.glBufferDataARB;
   }
   driverTbl.glBufferDataARB(target, size, data, usage);
}

static void REGAL_CALL missing_glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glBufferSubDataARB" );
}

static void REGAL_CALL loader_glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBufferSubDataARB, "glBufferSubDataARB");
   if ( !driverTbl.glBufferSubDataARB ) {
      driverTbl.glBufferSubDataARB = missing_glBufferSubDataARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBufferSubDataARB == loader_glBufferSubDataARB) {
      rCtx->dsp.emuTbl.glBufferSubDataARB = driverTbl.glBufferSubDataARB;
   }
   driverTbl.glBufferSubDataARB(target, offset, size, data);
}

static void REGAL_CALL missing_glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetBufferSubDataARB" );
}

static void REGAL_CALL loader_glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetBufferSubDataARB, "glGetBufferSubDataARB");
   if ( !driverTbl.glGetBufferSubDataARB ) {
      driverTbl.glGetBufferSubDataARB = missing_glGetBufferSubDataARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetBufferSubDataARB == loader_glGetBufferSubDataARB) {
      rCtx->dsp.emuTbl.glGetBufferSubDataARB = driverTbl.glGetBufferSubDataARB;
   }
   driverTbl.glGetBufferSubDataARB(target, offset, size, data);
}

static GLvoid *REGAL_CALL missing_glMapBufferARB(GLenum target, GLenum access)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(access);
   Warning( "Called missing function glMapBufferARB" );
  GLvoid * ret = NULL;
  return ret;
}

static GLvoid *REGAL_CALL loader_glMapBufferARB(GLenum target, GLenum access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapBufferARB, "glMapBufferARB");
   if ( !driverTbl.glMapBufferARB ) {
      driverTbl.glMapBufferARB = missing_glMapBufferARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapBufferARB == loader_glMapBufferARB) {
      rCtx->dsp.emuTbl.glMapBufferARB = driverTbl.glMapBufferARB;
   }
   return driverTbl.glMapBufferARB(target, access);
}

static GLboolean REGAL_CALL missing_glUnmapBufferARB(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glUnmapBufferARB" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glUnmapBufferARB(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUnmapBufferARB, "glUnmapBufferARB");
   if ( !driverTbl.glUnmapBufferARB ) {
      driverTbl.glUnmapBufferARB = missing_glUnmapBufferARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUnmapBufferARB == loader_glUnmapBufferARB) {
      rCtx->dsp.emuTbl.glUnmapBufferARB = driverTbl.glUnmapBufferARB;
   }
   return driverTbl.glUnmapBufferARB(target);
}

static void REGAL_CALL missing_glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetBufferParameterivARB" );
}

static void REGAL_CALL loader_glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetBufferParameterivARB, "glGetBufferParameterivARB");
   if ( !driverTbl.glGetBufferParameterivARB ) {
      driverTbl.glGetBufferParameterivARB = missing_glGetBufferParameterivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetBufferParameterivARB == loader_glGetBufferParameterivARB) {
      rCtx->dsp.emuTbl.glGetBufferParameterivARB = driverTbl.glGetBufferParameterivARB;
   }
   driverTbl.glGetBufferParameterivARB(target, pname, params);
}

static void REGAL_CALL missing_glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetBufferPointervARB" );
}

static void REGAL_CALL loader_glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetBufferPointervARB, "glGetBufferPointervARB");
   if ( !driverTbl.glGetBufferPointervARB ) {
      driverTbl.glGetBufferPointervARB = missing_glGetBufferPointervARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetBufferPointervARB == loader_glGetBufferPointervARB) {
      rCtx->dsp.emuTbl.glGetBufferPointervARB = driverTbl.glGetBufferPointervARB;
   }
   driverTbl.glGetBufferPointervARB(target, pname, params);
}

// GL_ARB_occlusion_query

static void REGAL_CALL missing_glGenQueriesARB(GLsizei n, GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "Called missing function glGenQueriesARB" );
}

static void REGAL_CALL loader_glGenQueriesARB(GLsizei n, GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenQueriesARB, "glGenQueriesARB");
   if ( !driverTbl.glGenQueriesARB ) {
      driverTbl.glGenQueriesARB = missing_glGenQueriesARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenQueriesARB == loader_glGenQueriesARB) {
      rCtx->dsp.emuTbl.glGenQueriesARB = driverTbl.glGenQueriesARB;
   }
   driverTbl.glGenQueriesARB(n, ids);
}

static void REGAL_CALL missing_glDeleteQueriesARB(GLsizei n, const GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "Called missing function glDeleteQueriesARB" );
}

static void REGAL_CALL loader_glDeleteQueriesARB(GLsizei n, const GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteQueriesARB, "glDeleteQueriesARB");
   if ( !driverTbl.glDeleteQueriesARB ) {
      driverTbl.glDeleteQueriesARB = missing_glDeleteQueriesARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteQueriesARB == loader_glDeleteQueriesARB) {
      rCtx->dsp.emuTbl.glDeleteQueriesARB = driverTbl.glDeleteQueriesARB;
   }
   driverTbl.glDeleteQueriesARB(n, ids);
}

static GLboolean REGAL_CALL missing_glIsQueryARB(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glIsQueryARB" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsQueryARB(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsQueryARB, "glIsQueryARB");
   if ( !driverTbl.glIsQueryARB ) {
      driverTbl.glIsQueryARB = missing_glIsQueryARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsQueryARB == loader_glIsQueryARB) {
      rCtx->dsp.emuTbl.glIsQueryARB = driverTbl.glIsQueryARB;
   }
   return driverTbl.glIsQueryARB(id);
}

static void REGAL_CALL missing_glBeginQueryARB(GLenum target, GLuint id)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glBeginQueryARB" );
}

static void REGAL_CALL loader_glBeginQueryARB(GLenum target, GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBeginQueryARB, "glBeginQueryARB");
   if ( !driverTbl.glBeginQueryARB ) {
      driverTbl.glBeginQueryARB = missing_glBeginQueryARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBeginQueryARB == loader_glBeginQueryARB) {
      rCtx->dsp.emuTbl.glBeginQueryARB = driverTbl.glBeginQueryARB;
   }
   driverTbl.glBeginQueryARB(target, id);
}

static void REGAL_CALL missing_glEndQueryARB(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glEndQueryARB" );
}

static void REGAL_CALL loader_glEndQueryARB(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndQueryARB, "glEndQueryARB");
   if ( !driverTbl.glEndQueryARB ) {
      driverTbl.glEndQueryARB = missing_glEndQueryARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndQueryARB == loader_glEndQueryARB) {
      rCtx->dsp.emuTbl.glEndQueryARB = driverTbl.glEndQueryARB;
   }
   driverTbl.glEndQueryARB(target);
}

static void REGAL_CALL missing_glGetQueryivARB(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetQueryivARB" );
}

static void REGAL_CALL loader_glGetQueryivARB(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetQueryivARB, "glGetQueryivARB");
   if ( !driverTbl.glGetQueryivARB ) {
      driverTbl.glGetQueryivARB = missing_glGetQueryivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetQueryivARB == loader_glGetQueryivARB) {
      rCtx->dsp.emuTbl.glGetQueryivARB = driverTbl.glGetQueryivARB;
   }
   driverTbl.glGetQueryivARB(target, pname, params);
}

static void REGAL_CALL missing_glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetQueryObjectivARB" );
}

static void REGAL_CALL loader_glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetQueryObjectivARB, "glGetQueryObjectivARB");
   if ( !driverTbl.glGetQueryObjectivARB ) {
      driverTbl.glGetQueryObjectivARB = missing_glGetQueryObjectivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetQueryObjectivARB == loader_glGetQueryObjectivARB) {
      rCtx->dsp.emuTbl.glGetQueryObjectivARB = driverTbl.glGetQueryObjectivARB;
   }
   driverTbl.glGetQueryObjectivARB(id, pname, params);
}

static void REGAL_CALL missing_glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetQueryObjectuivARB" );
}

static void REGAL_CALL loader_glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetQueryObjectuivARB, "glGetQueryObjectuivARB");
   if ( !driverTbl.glGetQueryObjectuivARB ) {
      driverTbl.glGetQueryObjectuivARB = missing_glGetQueryObjectuivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetQueryObjectuivARB == loader_glGetQueryObjectuivARB) {
      rCtx->dsp.emuTbl.glGetQueryObjectuivARB = driverTbl.glGetQueryObjectuivARB;
   }
   driverTbl.glGetQueryObjectuivARB(id, pname, params);
}

// GL_ARB_shader_objects

static void REGAL_CALL missing_glDeleteObjectARB(GLhandleARB obj)
{
   UNUSED_PARAMETER(obj);
   Warning( "Called missing function glDeleteObjectARB" );
}

static void REGAL_CALL loader_glDeleteObjectARB(GLhandleARB obj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteObjectARB, "glDeleteObjectARB");
   if ( !driverTbl.glDeleteObjectARB ) {
      driverTbl.glDeleteObjectARB = missing_glDeleteObjectARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteObjectARB == loader_glDeleteObjectARB) {
      rCtx->dsp.emuTbl.glDeleteObjectARB = driverTbl.glDeleteObjectARB;
   }
   driverTbl.glDeleteObjectARB(obj);
}

static GLhandleARB REGAL_CALL missing_glGetHandleARB(GLenum pname)
{
   UNUSED_PARAMETER(pname);
   Warning( "Called missing function glGetHandleARB" );
  GLhandleARB  ret = (GLhandleARB )0;
  return ret;
}

static GLhandleARB REGAL_CALL loader_glGetHandleARB(GLenum pname)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetHandleARB, "glGetHandleARB");
   if ( !driverTbl.glGetHandleARB ) {
      driverTbl.glGetHandleARB = missing_glGetHandleARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetHandleARB == loader_glGetHandleARB) {
      rCtx->dsp.emuTbl.glGetHandleARB = driverTbl.glGetHandleARB;
   }
   return driverTbl.glGetHandleARB(pname);
}

static void REGAL_CALL missing_glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj)
{
   UNUSED_PARAMETER(containerObj);
   UNUSED_PARAMETER(attachedObj);
   Warning( "Called missing function glDetachObjectARB" );
}

static void REGAL_CALL loader_glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDetachObjectARB, "glDetachObjectARB");
   if ( !driverTbl.glDetachObjectARB ) {
      driverTbl.glDetachObjectARB = missing_glDetachObjectARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDetachObjectARB == loader_glDetachObjectARB) {
      rCtx->dsp.emuTbl.glDetachObjectARB = driverTbl.glDetachObjectARB;
   }
   driverTbl.glDetachObjectARB(containerObj, attachedObj);
}

static GLhandleARB REGAL_CALL missing_glCreateShaderObjectARB(GLenum shaderType)
{
   UNUSED_PARAMETER(shaderType);
   Warning( "Called missing function glCreateShaderObjectARB" );
  GLhandleARB  ret = (GLhandleARB )0;
  return ret;
}

static GLhandleARB REGAL_CALL loader_glCreateShaderObjectARB(GLenum shaderType)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCreateShaderObjectARB, "glCreateShaderObjectARB");
   if ( !driverTbl.glCreateShaderObjectARB ) {
      driverTbl.glCreateShaderObjectARB = missing_glCreateShaderObjectARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCreateShaderObjectARB == loader_glCreateShaderObjectARB) {
      rCtx->dsp.emuTbl.glCreateShaderObjectARB = driverTbl.glCreateShaderObjectARB;
   }
   return driverTbl.glCreateShaderObjectARB(shaderType);
}

static void REGAL_CALL missing_glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length)
{
   UNUSED_PARAMETER(shaderObj);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(string);
   UNUSED_PARAMETER(length);
   Warning( "Called missing function glShaderSourceARB" );
}

static void REGAL_CALL loader_glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glShaderSourceARB, "glShaderSourceARB");
   if ( !driverTbl.glShaderSourceARB ) {
      driverTbl.glShaderSourceARB = missing_glShaderSourceARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glShaderSourceARB == loader_glShaderSourceARB) {
      rCtx->dsp.emuTbl.glShaderSourceARB = driverTbl.glShaderSourceARB;
   }
   driverTbl.glShaderSourceARB(shaderObj, count, string, length);
}

static void REGAL_CALL missing_glCompileShaderARB(GLhandleARB shaderObj)
{
   UNUSED_PARAMETER(shaderObj);
   Warning( "Called missing function glCompileShaderARB" );
}

static void REGAL_CALL loader_glCompileShaderARB(GLhandleARB shaderObj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompileShaderARB, "glCompileShaderARB");
   if ( !driverTbl.glCompileShaderARB ) {
      driverTbl.glCompileShaderARB = missing_glCompileShaderARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompileShaderARB == loader_glCompileShaderARB) {
      rCtx->dsp.emuTbl.glCompileShaderARB = driverTbl.glCompileShaderARB;
   }
   driverTbl.glCompileShaderARB(shaderObj);
}

static GLhandleARB REGAL_CALL missing_glCreateProgramObjectARB(void)
{
   Warning( "Called missing function glCreateProgramObjectARB" );
  GLhandleARB  ret = (GLhandleARB )0;
  return ret;
}

static GLhandleARB REGAL_CALL loader_glCreateProgramObjectARB(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCreateProgramObjectARB, "glCreateProgramObjectARB");
   if ( !driverTbl.glCreateProgramObjectARB ) {
      driverTbl.glCreateProgramObjectARB = missing_glCreateProgramObjectARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCreateProgramObjectARB == loader_glCreateProgramObjectARB) {
      rCtx->dsp.emuTbl.glCreateProgramObjectARB = driverTbl.glCreateProgramObjectARB;
   }
   return driverTbl.glCreateProgramObjectARB();
}

static void REGAL_CALL missing_glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj)
{
   UNUSED_PARAMETER(containerObj);
   UNUSED_PARAMETER(obj);
   Warning( "Called missing function glAttachObjectARB" );
}

static void REGAL_CALL loader_glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glAttachObjectARB, "glAttachObjectARB");
   if ( !driverTbl.glAttachObjectARB ) {
      driverTbl.glAttachObjectARB = missing_glAttachObjectARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glAttachObjectARB == loader_glAttachObjectARB) {
      rCtx->dsp.emuTbl.glAttachObjectARB = driverTbl.glAttachObjectARB;
   }
   driverTbl.glAttachObjectARB(containerObj, obj);
}

static void REGAL_CALL missing_glLinkProgramARB(GLhandleARB programObj)
{
   UNUSED_PARAMETER(programObj);
   Warning( "Called missing function glLinkProgramARB" );
}

static void REGAL_CALL loader_glLinkProgramARB(GLhandleARB programObj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLinkProgramARB, "glLinkProgramARB");
   if ( !driverTbl.glLinkProgramARB ) {
      driverTbl.glLinkProgramARB = missing_glLinkProgramARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLinkProgramARB == loader_glLinkProgramARB) {
      rCtx->dsp.emuTbl.glLinkProgramARB = driverTbl.glLinkProgramARB;
   }
   driverTbl.glLinkProgramARB(programObj);
}

static void REGAL_CALL missing_glUseProgramObjectARB(GLhandleARB programObj)
{
   UNUSED_PARAMETER(programObj);
   Warning( "Called missing function glUseProgramObjectARB" );
}

static void REGAL_CALL loader_glUseProgramObjectARB(GLhandleARB programObj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUseProgramObjectARB, "glUseProgramObjectARB");
   if ( !driverTbl.glUseProgramObjectARB ) {
      driverTbl.glUseProgramObjectARB = missing_glUseProgramObjectARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUseProgramObjectARB == loader_glUseProgramObjectARB) {
      rCtx->dsp.emuTbl.glUseProgramObjectARB = driverTbl.glUseProgramObjectARB;
   }
   driverTbl.glUseProgramObjectARB(programObj);
}

static void REGAL_CALL missing_glValidateProgramARB(GLhandleARB programObj)
{
   UNUSED_PARAMETER(programObj);
   Warning( "Called missing function glValidateProgramARB" );
}

static void REGAL_CALL loader_glValidateProgramARB(GLhandleARB programObj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glValidateProgramARB, "glValidateProgramARB");
   if ( !driverTbl.glValidateProgramARB ) {
      driverTbl.glValidateProgramARB = missing_glValidateProgramARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glValidateProgramARB == loader_glValidateProgramARB) {
      rCtx->dsp.emuTbl.glValidateProgramARB = driverTbl.glValidateProgramARB;
   }
   driverTbl.glValidateProgramARB(programObj);
}

static void REGAL_CALL missing_glUniform1fARB(GLint location, GLfloat v0)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "Called missing function glUniform1fARB" );
}

static void REGAL_CALL loader_glUniform1fARB(GLint location, GLfloat v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1fARB, "glUniform1fARB");
   if ( !driverTbl.glUniform1fARB ) {
      driverTbl.glUniform1fARB = missing_glUniform1fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1fARB == loader_glUniform1fARB) {
      rCtx->dsp.emuTbl.glUniform1fARB = driverTbl.glUniform1fARB;
   }
   driverTbl.glUniform1fARB(location, v0);
}

static void REGAL_CALL missing_glUniform2fARB(GLint location, GLfloat v0, GLfloat v1)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "Called missing function glUniform2fARB" );
}

static void REGAL_CALL loader_glUniform2fARB(GLint location, GLfloat v0, GLfloat v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2fARB, "glUniform2fARB");
   if ( !driverTbl.glUniform2fARB ) {
      driverTbl.glUniform2fARB = missing_glUniform2fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2fARB == loader_glUniform2fARB) {
      rCtx->dsp.emuTbl.glUniform2fARB = driverTbl.glUniform2fARB;
   }
   driverTbl.glUniform2fARB(location, v0, v1);
}

static void REGAL_CALL missing_glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glUniform3fARB" );
}

static void REGAL_CALL loader_glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3fARB, "glUniform3fARB");
   if ( !driverTbl.glUniform3fARB ) {
      driverTbl.glUniform3fARB = missing_glUniform3fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3fARB == loader_glUniform3fARB) {
      rCtx->dsp.emuTbl.glUniform3fARB = driverTbl.glUniform3fARB;
   }
   driverTbl.glUniform3fARB(location, v0, v1, v2);
}

static void REGAL_CALL missing_glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "Called missing function glUniform4fARB" );
}

static void REGAL_CALL loader_glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4fARB, "glUniform4fARB");
   if ( !driverTbl.glUniform4fARB ) {
      driverTbl.glUniform4fARB = missing_glUniform4fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4fARB == loader_glUniform4fARB) {
      rCtx->dsp.emuTbl.glUniform4fARB = driverTbl.glUniform4fARB;
   }
   driverTbl.glUniform4fARB(location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glUniform1iARB(GLint location, GLint v0)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "Called missing function glUniform1iARB" );
}

static void REGAL_CALL loader_glUniform1iARB(GLint location, GLint v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1iARB, "glUniform1iARB");
   if ( !driverTbl.glUniform1iARB ) {
      driverTbl.glUniform1iARB = missing_glUniform1iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1iARB == loader_glUniform1iARB) {
      rCtx->dsp.emuTbl.glUniform1iARB = driverTbl.glUniform1iARB;
   }
   driverTbl.glUniform1iARB(location, v0);
}

static void REGAL_CALL missing_glUniform2iARB(GLint location, GLint v0, GLint v1)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "Called missing function glUniform2iARB" );
}

static void REGAL_CALL loader_glUniform2iARB(GLint location, GLint v0, GLint v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2iARB, "glUniform2iARB");
   if ( !driverTbl.glUniform2iARB ) {
      driverTbl.glUniform2iARB = missing_glUniform2iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2iARB == loader_glUniform2iARB) {
      rCtx->dsp.emuTbl.glUniform2iARB = driverTbl.glUniform2iARB;
   }
   driverTbl.glUniform2iARB(location, v0, v1);
}

static void REGAL_CALL missing_glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glUniform3iARB" );
}

static void REGAL_CALL loader_glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3iARB, "glUniform3iARB");
   if ( !driverTbl.glUniform3iARB ) {
      driverTbl.glUniform3iARB = missing_glUniform3iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3iARB == loader_glUniform3iARB) {
      rCtx->dsp.emuTbl.glUniform3iARB = driverTbl.glUniform3iARB;
   }
   driverTbl.glUniform3iARB(location, v0, v1, v2);
}

static void REGAL_CALL missing_glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "Called missing function glUniform4iARB" );
}

static void REGAL_CALL loader_glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4iARB, "glUniform4iARB");
   if ( !driverTbl.glUniform4iARB ) {
      driverTbl.glUniform4iARB = missing_glUniform4iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4iARB == loader_glUniform4iARB) {
      rCtx->dsp.emuTbl.glUniform4iARB = driverTbl.glUniform4iARB;
   }
   driverTbl.glUniform4iARB(location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform1fvARB" );
}

static void REGAL_CALL loader_glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1fvARB, "glUniform1fvARB");
   if ( !driverTbl.glUniform1fvARB ) {
      driverTbl.glUniform1fvARB = missing_glUniform1fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1fvARB == loader_glUniform1fvARB) {
      rCtx->dsp.emuTbl.glUniform1fvARB = driverTbl.glUniform1fvARB;
   }
   driverTbl.glUniform1fvARB(location, count, value);
}

static void REGAL_CALL missing_glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform2fvARB" );
}

static void REGAL_CALL loader_glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2fvARB, "glUniform2fvARB");
   if ( !driverTbl.glUniform2fvARB ) {
      driverTbl.glUniform2fvARB = missing_glUniform2fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2fvARB == loader_glUniform2fvARB) {
      rCtx->dsp.emuTbl.glUniform2fvARB = driverTbl.glUniform2fvARB;
   }
   driverTbl.glUniform2fvARB(location, count, value);
}

static void REGAL_CALL missing_glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform3fvARB" );
}

static void REGAL_CALL loader_glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3fvARB, "glUniform3fvARB");
   if ( !driverTbl.glUniform3fvARB ) {
      driverTbl.glUniform3fvARB = missing_glUniform3fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3fvARB == loader_glUniform3fvARB) {
      rCtx->dsp.emuTbl.glUniform3fvARB = driverTbl.glUniform3fvARB;
   }
   driverTbl.glUniform3fvARB(location, count, value);
}

static void REGAL_CALL missing_glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform4fvARB" );
}

static void REGAL_CALL loader_glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4fvARB, "glUniform4fvARB");
   if ( !driverTbl.glUniform4fvARB ) {
      driverTbl.glUniform4fvARB = missing_glUniform4fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4fvARB == loader_glUniform4fvARB) {
      rCtx->dsp.emuTbl.glUniform4fvARB = driverTbl.glUniform4fvARB;
   }
   driverTbl.glUniform4fvARB(location, count, value);
}

static void REGAL_CALL missing_glUniform1ivARB(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform1ivARB" );
}

static void REGAL_CALL loader_glUniform1ivARB(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1ivARB, "glUniform1ivARB");
   if ( !driverTbl.glUniform1ivARB ) {
      driverTbl.glUniform1ivARB = missing_glUniform1ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1ivARB == loader_glUniform1ivARB) {
      rCtx->dsp.emuTbl.glUniform1ivARB = driverTbl.glUniform1ivARB;
   }
   driverTbl.glUniform1ivARB(location, count, value);
}

static void REGAL_CALL missing_glUniform2ivARB(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform2ivARB" );
}

static void REGAL_CALL loader_glUniform2ivARB(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2ivARB, "glUniform2ivARB");
   if ( !driverTbl.glUniform2ivARB ) {
      driverTbl.glUniform2ivARB = missing_glUniform2ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2ivARB == loader_glUniform2ivARB) {
      rCtx->dsp.emuTbl.glUniform2ivARB = driverTbl.glUniform2ivARB;
   }
   driverTbl.glUniform2ivARB(location, count, value);
}

static void REGAL_CALL missing_glUniform3ivARB(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform3ivARB" );
}

static void REGAL_CALL loader_glUniform3ivARB(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3ivARB, "glUniform3ivARB");
   if ( !driverTbl.glUniform3ivARB ) {
      driverTbl.glUniform3ivARB = missing_glUniform3ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3ivARB == loader_glUniform3ivARB) {
      rCtx->dsp.emuTbl.glUniform3ivARB = driverTbl.glUniform3ivARB;
   }
   driverTbl.glUniform3ivARB(location, count, value);
}

static void REGAL_CALL missing_glUniform4ivARB(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform4ivARB" );
}

static void REGAL_CALL loader_glUniform4ivARB(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4ivARB, "glUniform4ivARB");
   if ( !driverTbl.glUniform4ivARB ) {
      driverTbl.glUniform4ivARB = missing_glUniform4ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4ivARB == loader_glUniform4ivARB) {
      rCtx->dsp.emuTbl.glUniform4ivARB = driverTbl.glUniform4ivARB;
   }
   driverTbl.glUniform4ivARB(location, count, value);
}

static void REGAL_CALL missing_glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix2fvARB" );
}

static void REGAL_CALL loader_glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix2fvARB, "glUniformMatrix2fvARB");
   if ( !driverTbl.glUniformMatrix2fvARB ) {
      driverTbl.glUniformMatrix2fvARB = missing_glUniformMatrix2fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix2fvARB == loader_glUniformMatrix2fvARB) {
      rCtx->dsp.emuTbl.glUniformMatrix2fvARB = driverTbl.glUniformMatrix2fvARB;
   }
   driverTbl.glUniformMatrix2fvARB(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix3fvARB" );
}

static void REGAL_CALL loader_glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix3fvARB, "glUniformMatrix3fvARB");
   if ( !driverTbl.glUniformMatrix3fvARB ) {
      driverTbl.glUniformMatrix3fvARB = missing_glUniformMatrix3fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix3fvARB == loader_glUniformMatrix3fvARB) {
      rCtx->dsp.emuTbl.glUniformMatrix3fvARB = driverTbl.glUniformMatrix3fvARB;
   }
   driverTbl.glUniformMatrix3fvARB(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformMatrix4fvARB" );
}

static void REGAL_CALL loader_glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformMatrix4fvARB, "glUniformMatrix4fvARB");
   if ( !driverTbl.glUniformMatrix4fvARB ) {
      driverTbl.glUniformMatrix4fvARB = missing_glUniformMatrix4fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformMatrix4fvARB == loader_glUniformMatrix4fvARB) {
      rCtx->dsp.emuTbl.glUniformMatrix4fvARB = driverTbl.glUniformMatrix4fvARB;
   }
   driverTbl.glUniformMatrix4fvARB(location, count, transpose, value);
}

static void REGAL_CALL missing_glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(obj);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetObjectParameterfvARB" );
}

static void REGAL_CALL loader_glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetObjectParameterfvARB, "glGetObjectParameterfvARB");
   if ( !driverTbl.glGetObjectParameterfvARB ) {
      driverTbl.glGetObjectParameterfvARB = missing_glGetObjectParameterfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetObjectParameterfvARB == loader_glGetObjectParameterfvARB) {
      rCtx->dsp.emuTbl.glGetObjectParameterfvARB = driverTbl.glGetObjectParameterfvARB;
   }
   driverTbl.glGetObjectParameterfvARB(obj, pname, params);
}

static void REGAL_CALL missing_glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(obj);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetObjectParameterivARB" );
}

static void REGAL_CALL loader_glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetObjectParameterivARB, "glGetObjectParameterivARB");
   if ( !driverTbl.glGetObjectParameterivARB ) {
      driverTbl.glGetObjectParameterivARB = missing_glGetObjectParameterivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetObjectParameterivARB == loader_glGetObjectParameterivARB) {
      rCtx->dsp.emuTbl.glGetObjectParameterivARB = driverTbl.glGetObjectParameterivARB;
   }
   driverTbl.glGetObjectParameterivARB(obj, pname, params);
}

static void REGAL_CALL missing_glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
{
   UNUSED_PARAMETER(obj);
   UNUSED_PARAMETER(maxLength);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(infoLog);
   Warning( "Called missing function glGetInfoLogARB" );
}

static void REGAL_CALL loader_glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetInfoLogARB, "glGetInfoLogARB");
   if ( !driverTbl.glGetInfoLogARB ) {
      driverTbl.glGetInfoLogARB = missing_glGetInfoLogARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetInfoLogARB == loader_glGetInfoLogARB) {
      rCtx->dsp.emuTbl.glGetInfoLogARB = driverTbl.glGetInfoLogARB;
   }
   driverTbl.glGetInfoLogARB(obj, maxLength, length, infoLog);
}

static void REGAL_CALL missing_glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj)
{
   UNUSED_PARAMETER(containerObj);
   UNUSED_PARAMETER(maxCount);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(obj);
   Warning( "Called missing function glGetAttachedObjectsARB" );
}

static void REGAL_CALL loader_glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetAttachedObjectsARB, "glGetAttachedObjectsARB");
   if ( !driverTbl.glGetAttachedObjectsARB ) {
      driverTbl.glGetAttachedObjectsARB = missing_glGetAttachedObjectsARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetAttachedObjectsARB == loader_glGetAttachedObjectsARB) {
      rCtx->dsp.emuTbl.glGetAttachedObjectsARB = driverTbl.glGetAttachedObjectsARB;
   }
   driverTbl.glGetAttachedObjectsARB(containerObj, maxCount, count, obj);
}

static GLint REGAL_CALL missing_glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
   UNUSED_PARAMETER(programObj);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetUniformLocationARB" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformLocationARB, "glGetUniformLocationARB");
   if ( !driverTbl.glGetUniformLocationARB ) {
      driverTbl.glGetUniformLocationARB = missing_glGetUniformLocationARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformLocationARB == loader_glGetUniformLocationARB) {
      rCtx->dsp.emuTbl.glGetUniformLocationARB = driverTbl.glGetUniformLocationARB;
   }
   return driverTbl.glGetUniformLocationARB(programObj, name);
}

static void REGAL_CALL missing_glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
{
   UNUSED_PARAMETER(programObj);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(maxLength);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetActiveUniformARB" );
}

static void REGAL_CALL loader_glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetActiveUniformARB, "glGetActiveUniformARB");
   if ( !driverTbl.glGetActiveUniformARB ) {
      driverTbl.glGetActiveUniformARB = missing_glGetActiveUniformARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetActiveUniformARB == loader_glGetActiveUniformARB) {
      rCtx->dsp.emuTbl.glGetActiveUniformARB = driverTbl.glGetActiveUniformARB;
   }
   driverTbl.glGetActiveUniformARB(programObj, index, maxLength, length, size, type, name);
}

static void REGAL_CALL missing_glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params)
{
   UNUSED_PARAMETER(programObj);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetUniformfvARB" );
}

static void REGAL_CALL loader_glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformfvARB, "glGetUniformfvARB");
   if ( !driverTbl.glGetUniformfvARB ) {
      driverTbl.glGetUniformfvARB = missing_glGetUniformfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformfvARB == loader_glGetUniformfvARB) {
      rCtx->dsp.emuTbl.glGetUniformfvARB = driverTbl.glGetUniformfvARB;
   }
   driverTbl.glGetUniformfvARB(programObj, location, params);
}

static void REGAL_CALL missing_glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params)
{
   UNUSED_PARAMETER(programObj);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetUniformivARB" );
}

static void REGAL_CALL loader_glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformivARB, "glGetUniformivARB");
   if ( !driverTbl.glGetUniformivARB ) {
      driverTbl.glGetUniformivARB = missing_glGetUniformivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformivARB == loader_glGetUniformivARB) {
      rCtx->dsp.emuTbl.glGetUniformivARB = driverTbl.glGetUniformivARB;
   }
   driverTbl.glGetUniformivARB(programObj, location, params);
}

static void REGAL_CALL missing_glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source)
{
   UNUSED_PARAMETER(obj);
   UNUSED_PARAMETER(maxLength);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(source);
   Warning( "Called missing function glGetShaderSourceARB" );
}

static void REGAL_CALL loader_glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetShaderSourceARB, "glGetShaderSourceARB");
   if ( !driverTbl.glGetShaderSourceARB ) {
      driverTbl.glGetShaderSourceARB = missing_glGetShaderSourceARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetShaderSourceARB == loader_glGetShaderSourceARB) {
      rCtx->dsp.emuTbl.glGetShaderSourceARB = driverTbl.glGetShaderSourceARB;
   }
   driverTbl.glGetShaderSourceARB(obj, maxLength, length, source);
}

// GL_ARB_vertex_shader

static void REGAL_CALL missing_glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name)
{
   UNUSED_PARAMETER(programObj);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glBindAttribLocationARB" );
}

static void REGAL_CALL loader_glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindAttribLocationARB, "glBindAttribLocationARB");
   if ( !driverTbl.glBindAttribLocationARB ) {
      driverTbl.glBindAttribLocationARB = missing_glBindAttribLocationARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindAttribLocationARB == loader_glBindAttribLocationARB) {
      rCtx->dsp.emuTbl.glBindAttribLocationARB = driverTbl.glBindAttribLocationARB;
   }
   driverTbl.glBindAttribLocationARB(programObj, index, name);
}

static void REGAL_CALL missing_glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
{
   UNUSED_PARAMETER(programObj);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(maxLength);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetActiveAttribARB" );
}

static void REGAL_CALL loader_glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetActiveAttribARB, "glGetActiveAttribARB");
   if ( !driverTbl.glGetActiveAttribARB ) {
      driverTbl.glGetActiveAttribARB = missing_glGetActiveAttribARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetActiveAttribARB == loader_glGetActiveAttribARB) {
      rCtx->dsp.emuTbl.glGetActiveAttribARB = driverTbl.glGetActiveAttribARB;
   }
   driverTbl.glGetActiveAttribARB(programObj, index, maxLength, length, size, type, name);
}

static GLint REGAL_CALL missing_glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
   UNUSED_PARAMETER(programObj);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetAttribLocationARB" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetAttribLocationARB, "glGetAttribLocationARB");
   if ( !driverTbl.glGetAttribLocationARB ) {
      driverTbl.glGetAttribLocationARB = missing_glGetAttribLocationARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetAttribLocationARB == loader_glGetAttribLocationARB) {
      rCtx->dsp.emuTbl.glGetAttribLocationARB = driverTbl.glGetAttribLocationARB;
   }
   return driverTbl.glGetAttribLocationARB(programObj, name);
}

// GL_ARB_draw_buffers

static void REGAL_CALL missing_glDrawBuffersARB(GLsizei n, const GLenum *bufs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(bufs);
   Warning( "Called missing function glDrawBuffersARB" );
}

static void REGAL_CALL loader_glDrawBuffersARB(GLsizei n, const GLenum *bufs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawBuffersARB, "glDrawBuffersARB");
   if ( !driverTbl.glDrawBuffersARB ) {
      driverTbl.glDrawBuffersARB = missing_glDrawBuffersARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawBuffersARB == loader_glDrawBuffersARB) {
      rCtx->dsp.emuTbl.glDrawBuffersARB = driverTbl.glDrawBuffersARB;
   }
   driverTbl.glDrawBuffersARB(n, bufs);
}

// GL_ARB_color_buffer_float

static void REGAL_CALL missing_glClampColorARB(GLenum target, GLenum clamp)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(clamp);
   Warning( "Called missing function glClampColorARB" );
}

static void REGAL_CALL loader_glClampColorARB(GLenum target, GLenum clamp)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClampColorARB, "glClampColorARB");
   if ( !driverTbl.glClampColorARB ) {
      driverTbl.glClampColorARB = missing_glClampColorARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClampColorARB == loader_glClampColorARB) {
      rCtx->dsp.emuTbl.glClampColorARB = driverTbl.glClampColorARB;
   }
   driverTbl.glClampColorARB(target, clamp);
}

// GL_ARB_draw_instanced

static void REGAL_CALL missing_glDrawArraysInstancedARB(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   Warning( "Called missing function glDrawArraysInstancedARB" );
}

static void REGAL_CALL loader_glDrawArraysInstancedARB(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawArraysInstancedARB, "glDrawArraysInstancedARB");
   if ( !driverTbl.glDrawArraysInstancedARB ) {
      driverTbl.glDrawArraysInstancedARB = missing_glDrawArraysInstancedARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawArraysInstancedARB == loader_glDrawArraysInstancedARB) {
      rCtx->dsp.emuTbl.glDrawArraysInstancedARB = driverTbl.glDrawArraysInstancedARB;
   }
   driverTbl.glDrawArraysInstancedARB(mode, start, count, primcount);
}

static void REGAL_CALL missing_glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   Warning( "Called missing function glDrawElementsInstancedARB" );
}

static void REGAL_CALL loader_glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawElementsInstancedARB, "glDrawElementsInstancedARB");
   if ( !driverTbl.glDrawElementsInstancedARB ) {
      driverTbl.glDrawElementsInstancedARB = missing_glDrawElementsInstancedARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawElementsInstancedARB == loader_glDrawElementsInstancedARB) {
      rCtx->dsp.emuTbl.glDrawElementsInstancedARB = driverTbl.glDrawElementsInstancedARB;
   }
   driverTbl.glDrawElementsInstancedARB(mode, count, type, indices, primcount);
}

// GL_ARB_framebuffer_object

static GLboolean REGAL_CALL missing_glIsRenderbuffer(GLuint renderbuffer)
{
   UNUSED_PARAMETER(renderbuffer);
   Warning( "Called missing function glIsRenderbuffer" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsRenderbuffer(GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsRenderbuffer, "glIsRenderbuffer");
   if ( !driverTbl.glIsRenderbuffer ) {
      driverTbl.glIsRenderbuffer = missing_glIsRenderbuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsRenderbuffer == loader_glIsRenderbuffer) {
      rCtx->dsp.emuTbl.glIsRenderbuffer = driverTbl.glIsRenderbuffer;
   }
   return driverTbl.glIsRenderbuffer(renderbuffer);
}

static void REGAL_CALL missing_glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "Called missing function glBindRenderbuffer" );
}

static void REGAL_CALL loader_glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindRenderbuffer, "glBindRenderbuffer");
   if ( !driverTbl.glBindRenderbuffer ) {
      driverTbl.glBindRenderbuffer = missing_glBindRenderbuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindRenderbuffer == loader_glBindRenderbuffer) {
      rCtx->dsp.emuTbl.glBindRenderbuffer = driverTbl.glBindRenderbuffer;
   }
   driverTbl.glBindRenderbuffer(target, renderbuffer);
}

static void REGAL_CALL missing_glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(renderbuffers);
   Warning( "Called missing function glDeleteRenderbuffers" );
}

static void REGAL_CALL loader_glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteRenderbuffers, "glDeleteRenderbuffers");
   if ( !driverTbl.glDeleteRenderbuffers ) {
      driverTbl.glDeleteRenderbuffers = missing_glDeleteRenderbuffers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteRenderbuffers == loader_glDeleteRenderbuffers) {
      rCtx->dsp.emuTbl.glDeleteRenderbuffers = driverTbl.glDeleteRenderbuffers;
   }
   driverTbl.glDeleteRenderbuffers(n, renderbuffers);
}

static void REGAL_CALL missing_glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(renderbuffers);
   Warning( "Called missing function glGenRenderbuffers" );
}

static void REGAL_CALL loader_glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenRenderbuffers, "glGenRenderbuffers");
   if ( !driverTbl.glGenRenderbuffers ) {
      driverTbl.glGenRenderbuffers = missing_glGenRenderbuffers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenRenderbuffers == loader_glGenRenderbuffers) {
      rCtx->dsp.emuTbl.glGenRenderbuffers = driverTbl.glGenRenderbuffers;
   }
   driverTbl.glGenRenderbuffers(n, renderbuffers);
}

static void REGAL_CALL missing_glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glRenderbufferStorage" );
}

static void REGAL_CALL loader_glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRenderbufferStorage, "glRenderbufferStorage");
   if ( !driverTbl.glRenderbufferStorage ) {
      driverTbl.glRenderbufferStorage = missing_glRenderbufferStorage;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRenderbufferStorage == loader_glRenderbufferStorage) {
      rCtx->dsp.emuTbl.glRenderbufferStorage = driverTbl.glRenderbufferStorage;
   }
   driverTbl.glRenderbufferStorage(target, internalformat, width, height);
}

static void REGAL_CALL missing_glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetRenderbufferParameteriv" );
}

static void REGAL_CALL loader_glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetRenderbufferParameteriv, "glGetRenderbufferParameteriv");
   if ( !driverTbl.glGetRenderbufferParameteriv ) {
      driverTbl.glGetRenderbufferParameteriv = missing_glGetRenderbufferParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetRenderbufferParameteriv == loader_glGetRenderbufferParameteriv) {
      rCtx->dsp.emuTbl.glGetRenderbufferParameteriv = driverTbl.glGetRenderbufferParameteriv;
   }
   driverTbl.glGetRenderbufferParameteriv(target, pname, params);
}

static GLboolean REGAL_CALL missing_glIsFramebuffer(GLuint framebuffer)
{
   UNUSED_PARAMETER(framebuffer);
   Warning( "Called missing function glIsFramebuffer" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsFramebuffer(GLuint framebuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsFramebuffer, "glIsFramebuffer");
   if ( !driverTbl.glIsFramebuffer ) {
      driverTbl.glIsFramebuffer = missing_glIsFramebuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsFramebuffer == loader_glIsFramebuffer) {
      rCtx->dsp.emuTbl.glIsFramebuffer = driverTbl.glIsFramebuffer;
   }
   return driverTbl.glIsFramebuffer(framebuffer);
}

static void REGAL_CALL missing_glBindFramebuffer(GLenum target, GLuint framebuffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(framebuffer);
   Warning( "Called missing function glBindFramebuffer" );
}

static void REGAL_CALL loader_glBindFramebuffer(GLenum target, GLuint framebuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindFramebuffer, "glBindFramebuffer");
   if ( !driverTbl.glBindFramebuffer ) {
      driverTbl.glBindFramebuffer = missing_glBindFramebuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindFramebuffer == loader_glBindFramebuffer) {
      rCtx->dsp.emuTbl.glBindFramebuffer = driverTbl.glBindFramebuffer;
   }
   driverTbl.glBindFramebuffer(target, framebuffer);
}

static void REGAL_CALL missing_glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(framebuffers);
   Warning( "Called missing function glDeleteFramebuffers" );
}

static void REGAL_CALL loader_glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteFramebuffers, "glDeleteFramebuffers");
   if ( !driverTbl.glDeleteFramebuffers ) {
      driverTbl.glDeleteFramebuffers = missing_glDeleteFramebuffers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteFramebuffers == loader_glDeleteFramebuffers) {
      rCtx->dsp.emuTbl.glDeleteFramebuffers = driverTbl.glDeleteFramebuffers;
   }
   driverTbl.glDeleteFramebuffers(n, framebuffers);
}

static void REGAL_CALL missing_glGenFramebuffers(GLsizei n, GLuint *framebuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(framebuffers);
   Warning( "Called missing function glGenFramebuffers" );
}

static void REGAL_CALL loader_glGenFramebuffers(GLsizei n, GLuint *framebuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenFramebuffers, "glGenFramebuffers");
   if ( !driverTbl.glGenFramebuffers ) {
      driverTbl.glGenFramebuffers = missing_glGenFramebuffers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenFramebuffers == loader_glGenFramebuffers) {
      rCtx->dsp.emuTbl.glGenFramebuffers = driverTbl.glGenFramebuffers;
   }
   driverTbl.glGenFramebuffers(n, framebuffers);
}

static GLenum REGAL_CALL missing_glCheckFramebufferStatus(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glCheckFramebufferStatus" );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glCheckFramebufferStatus(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCheckFramebufferStatus, "glCheckFramebufferStatus");
   if ( !driverTbl.glCheckFramebufferStatus ) {
      driverTbl.glCheckFramebufferStatus = missing_glCheckFramebufferStatus;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCheckFramebufferStatus == loader_glCheckFramebufferStatus) {
      rCtx->dsp.emuTbl.glCheckFramebufferStatus = driverTbl.glCheckFramebufferStatus;
   }
   return driverTbl.glCheckFramebufferStatus(target);
}

static void REGAL_CALL missing_glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "Called missing function glFramebufferTexture1D" );
}

static void REGAL_CALL loader_glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTexture1D, "glFramebufferTexture1D");
   if ( !driverTbl.glFramebufferTexture1D ) {
      driverTbl.glFramebufferTexture1D = missing_glFramebufferTexture1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTexture1D == loader_glFramebufferTexture1D) {
      rCtx->dsp.emuTbl.glFramebufferTexture1D = driverTbl.glFramebufferTexture1D;
   }
   driverTbl.glFramebufferTexture1D(target, attachment, textarget, texture, level);
}

static void REGAL_CALL missing_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "Called missing function glFramebufferTexture2D" );
}

static void REGAL_CALL loader_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTexture2D, "glFramebufferTexture2D");
   if ( !driverTbl.glFramebufferTexture2D ) {
      driverTbl.glFramebufferTexture2D = missing_glFramebufferTexture2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTexture2D == loader_glFramebufferTexture2D) {
      rCtx->dsp.emuTbl.glFramebufferTexture2D = driverTbl.glFramebufferTexture2D;
   }
   driverTbl.glFramebufferTexture2D(target, attachment, textarget, texture, level);
}

static void REGAL_CALL missing_glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layer);
   Warning( "Called missing function glFramebufferTexture3D" );
}

static void REGAL_CALL loader_glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTexture3D, "glFramebufferTexture3D");
   if ( !driverTbl.glFramebufferTexture3D ) {
      driverTbl.glFramebufferTexture3D = missing_glFramebufferTexture3D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTexture3D == loader_glFramebufferTexture3D) {
      rCtx->dsp.emuTbl.glFramebufferTexture3D = driverTbl.glFramebufferTexture3D;
   }
   driverTbl.glFramebufferTexture3D(target, attachment, textarget, texture, level, layer);
}

static void REGAL_CALL missing_glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(renderbuffertarget);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "Called missing function glFramebufferRenderbuffer" );
}

static void REGAL_CALL loader_glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferRenderbuffer, "glFramebufferRenderbuffer");
   if ( !driverTbl.glFramebufferRenderbuffer ) {
      driverTbl.glFramebufferRenderbuffer = missing_glFramebufferRenderbuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferRenderbuffer == loader_glFramebufferRenderbuffer) {
      rCtx->dsp.emuTbl.glFramebufferRenderbuffer = driverTbl.glFramebufferRenderbuffer;
   }
   driverTbl.glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
}

static void REGAL_CALL missing_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFramebufferAttachmentParameteriv" );
}

static void REGAL_CALL loader_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFramebufferAttachmentParameteriv, "glGetFramebufferAttachmentParameteriv");
   if ( !driverTbl.glGetFramebufferAttachmentParameteriv ) {
      driverTbl.glGetFramebufferAttachmentParameteriv = missing_glGetFramebufferAttachmentParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFramebufferAttachmentParameteriv == loader_glGetFramebufferAttachmentParameteriv) {
      rCtx->dsp.emuTbl.glGetFramebufferAttachmentParameteriv = driverTbl.glGetFramebufferAttachmentParameteriv;
   }
   driverTbl.glGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
}

static void REGAL_CALL missing_glGenerateMipmap(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glGenerateMipmap" );
}

static void REGAL_CALL loader_glGenerateMipmap(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenerateMipmap, "glGenerateMipmap");
   if ( !driverTbl.glGenerateMipmap ) {
      driverTbl.glGenerateMipmap = missing_glGenerateMipmap;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenerateMipmap == loader_glGenerateMipmap) {
      rCtx->dsp.emuTbl.glGenerateMipmap = driverTbl.glGenerateMipmap;
   }
   driverTbl.glGenerateMipmap(target);
}

static void REGAL_CALL missing_glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
   UNUSED_PARAMETER(srcX0);
   UNUSED_PARAMETER(srcY0);
   UNUSED_PARAMETER(srcX1);
   UNUSED_PARAMETER(srcY1);
   UNUSED_PARAMETER(dstX0);
   UNUSED_PARAMETER(dstY0);
   UNUSED_PARAMETER(dstX1);
   UNUSED_PARAMETER(dstY1);
   UNUSED_PARAMETER(mask);
   UNUSED_PARAMETER(filter);
   Warning( "Called missing function glBlitFramebuffer" );
}

static void REGAL_CALL loader_glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlitFramebuffer, "glBlitFramebuffer");
   if ( !driverTbl.glBlitFramebuffer ) {
      driverTbl.glBlitFramebuffer = missing_glBlitFramebuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlitFramebuffer == loader_glBlitFramebuffer) {
      rCtx->dsp.emuTbl.glBlitFramebuffer = driverTbl.glBlitFramebuffer;
   }
   driverTbl.glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

static void REGAL_CALL missing_glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glRenderbufferStorageMultisample" );
}

static void REGAL_CALL loader_glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRenderbufferStorageMultisample, "glRenderbufferStorageMultisample");
   if ( !driverTbl.glRenderbufferStorageMultisample ) {
      driverTbl.glRenderbufferStorageMultisample = missing_glRenderbufferStorageMultisample;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRenderbufferStorageMultisample == loader_glRenderbufferStorageMultisample) {
      rCtx->dsp.emuTbl.glRenderbufferStorageMultisample = driverTbl.glRenderbufferStorageMultisample;
   }
   driverTbl.glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
}

static void REGAL_CALL missing_glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layer);
   Warning( "Called missing function glFramebufferTextureLayer" );
}

static void REGAL_CALL loader_glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTextureLayer, "glFramebufferTextureLayer");
   if ( !driverTbl.glFramebufferTextureLayer ) {
      driverTbl.glFramebufferTextureLayer = missing_glFramebufferTextureLayer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTextureLayer == loader_glFramebufferTextureLayer) {
      rCtx->dsp.emuTbl.glFramebufferTextureLayer = driverTbl.glFramebufferTextureLayer;
   }
   driverTbl.glFramebufferTextureLayer(target, attachment, texture, level, layer);
}

// GL_ARB_geometry_shader4

static void REGAL_CALL missing_glProgramParameteriARB(GLuint program, GLenum pname, GLint value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramParameteriARB" );
}

static void REGAL_CALL loader_glProgramParameteriARB(GLuint program, GLenum pname, GLint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramParameteriARB, "glProgramParameteriARB");
   if ( !driverTbl.glProgramParameteriARB ) {
      driverTbl.glProgramParameteriARB = missing_glProgramParameteriARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramParameteriARB == loader_glProgramParameteriARB) {
      rCtx->dsp.emuTbl.glProgramParameteriARB = driverTbl.glProgramParameteriARB;
   }
   driverTbl.glProgramParameteriARB(program, pname, value);
}

static void REGAL_CALL missing_glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "Called missing function glFramebufferTextureARB" );
}

static void REGAL_CALL loader_glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTextureARB, "glFramebufferTextureARB");
   if ( !driverTbl.glFramebufferTextureARB ) {
      driverTbl.glFramebufferTextureARB = missing_glFramebufferTextureARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTextureARB == loader_glFramebufferTextureARB) {
      rCtx->dsp.emuTbl.glFramebufferTextureARB = driverTbl.glFramebufferTextureARB;
   }
   driverTbl.glFramebufferTextureARB(target, attachment, texture, level);
}

static void REGAL_CALL missing_glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layer);
   Warning( "Called missing function glFramebufferTextureLayerARB" );
}

static void REGAL_CALL loader_glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTextureLayerARB, "glFramebufferTextureLayerARB");
   if ( !driverTbl.glFramebufferTextureLayerARB ) {
      driverTbl.glFramebufferTextureLayerARB = missing_glFramebufferTextureLayerARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTextureLayerARB == loader_glFramebufferTextureLayerARB) {
      rCtx->dsp.emuTbl.glFramebufferTextureLayerARB = driverTbl.glFramebufferTextureLayerARB;
   }
   driverTbl.glFramebufferTextureLayerARB(target, attachment, texture, level, layer);
}

static void REGAL_CALL missing_glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(face);
   Warning( "Called missing function glFramebufferTextureFaceARB" );
}

static void REGAL_CALL loader_glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTextureFaceARB, "glFramebufferTextureFaceARB");
   if ( !driverTbl.glFramebufferTextureFaceARB ) {
      driverTbl.glFramebufferTextureFaceARB = missing_glFramebufferTextureFaceARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTextureFaceARB == loader_glFramebufferTextureFaceARB) {
      rCtx->dsp.emuTbl.glFramebufferTextureFaceARB = driverTbl.glFramebufferTextureFaceARB;
   }
   driverTbl.glFramebufferTextureFaceARB(target, attachment, texture, level, face);
}

// GL_ARB_instanced_arrays

static void REGAL_CALL missing_glVertexAttribDivisorARB(GLuint index, GLuint divisor)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(divisor);
   Warning( "Called missing function glVertexAttribDivisorARB" );
}

static void REGAL_CALL loader_glVertexAttribDivisorARB(GLuint index, GLuint divisor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribDivisorARB, "glVertexAttribDivisorARB");
   if ( !driverTbl.glVertexAttribDivisorARB ) {
      driverTbl.glVertexAttribDivisorARB = missing_glVertexAttribDivisorARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribDivisorARB == loader_glVertexAttribDivisorARB) {
      rCtx->dsp.emuTbl.glVertexAttribDivisorARB = driverTbl.glVertexAttribDivisorARB;
   }
   driverTbl.glVertexAttribDivisorARB(index, divisor);
}

// GL_ARB_map_buffer_range

static GLvoid *REGAL_CALL missing_glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(access);
   Warning( "Called missing function glMapBufferRange" );
  GLvoid * ret = NULL;
  return ret;
}

static GLvoid *REGAL_CALL loader_glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapBufferRange, "glMapBufferRange");
   if ( !driverTbl.glMapBufferRange ) {
      driverTbl.glMapBufferRange = missing_glMapBufferRange;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapBufferRange == loader_glMapBufferRange) {
      rCtx->dsp.emuTbl.glMapBufferRange = driverTbl.glMapBufferRange;
   }
   return driverTbl.glMapBufferRange(target, offset, length, access);
}

static void REGAL_CALL missing_glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(length);
   Warning( "Called missing function glFlushMappedBufferRange" );
}

static void REGAL_CALL loader_glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFlushMappedBufferRange, "glFlushMappedBufferRange");
   if ( !driverTbl.glFlushMappedBufferRange ) {
      driverTbl.glFlushMappedBufferRange = missing_glFlushMappedBufferRange;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFlushMappedBufferRange == loader_glFlushMappedBufferRange) {
      rCtx->dsp.emuTbl.glFlushMappedBufferRange = driverTbl.glFlushMappedBufferRange;
   }
   driverTbl.glFlushMappedBufferRange(target, offset, length);
}

// GL_ARB_texture_buffer_object

static void REGAL_CALL missing_glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glTexBufferARB" );
}

static void REGAL_CALL loader_glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexBufferARB, "glTexBufferARB");
   if ( !driverTbl.glTexBufferARB ) {
      driverTbl.glTexBufferARB = missing_glTexBufferARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexBufferARB == loader_glTexBufferARB) {
      rCtx->dsp.emuTbl.glTexBufferARB = driverTbl.glTexBufferARB;
   }
   driverTbl.glTexBufferARB(target, internalformat, buffer);
}

// GL_ARB_vertex_array_object

static void REGAL_CALL missing_glBindVertexArray(GLuint array)
{
   UNUSED_PARAMETER(array);
   Warning( "Called missing function glBindVertexArray" );
}

static void REGAL_CALL loader_glBindVertexArray(GLuint array)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindVertexArray, "glBindVertexArray");
   if ( !driverTbl.glBindVertexArray ) {
      driverTbl.glBindVertexArray = missing_glBindVertexArray;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindVertexArray == loader_glBindVertexArray) {
      rCtx->dsp.emuTbl.glBindVertexArray = driverTbl.glBindVertexArray;
   }
   driverTbl.glBindVertexArray(array);
}

static void REGAL_CALL missing_glDeleteVertexArrays(GLsizei n, const GLuint *arrays)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(arrays);
   Warning( "Called missing function glDeleteVertexArrays" );
}

static void REGAL_CALL loader_glDeleteVertexArrays(GLsizei n, const GLuint *arrays)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteVertexArrays, "glDeleteVertexArrays");
   if ( !driverTbl.glDeleteVertexArrays ) {
      driverTbl.glDeleteVertexArrays = missing_glDeleteVertexArrays;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteVertexArrays == loader_glDeleteVertexArrays) {
      rCtx->dsp.emuTbl.glDeleteVertexArrays = driverTbl.glDeleteVertexArrays;
   }
   driverTbl.glDeleteVertexArrays(n, arrays);
}

static void REGAL_CALL missing_glGenVertexArrays(GLsizei n, GLuint *arrays)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(arrays);
   Warning( "Called missing function glGenVertexArrays" );
}

static void REGAL_CALL loader_glGenVertexArrays(GLsizei n, GLuint *arrays)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenVertexArrays, "glGenVertexArrays");
   if ( !driverTbl.glGenVertexArrays ) {
      driverTbl.glGenVertexArrays = missing_glGenVertexArrays;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenVertexArrays == loader_glGenVertexArrays) {
      rCtx->dsp.emuTbl.glGenVertexArrays = driverTbl.glGenVertexArrays;
   }
   driverTbl.glGenVertexArrays(n, arrays);
}

static GLboolean REGAL_CALL missing_glIsVertexArray(GLuint array)
{
   UNUSED_PARAMETER(array);
   Warning( "Called missing function glIsVertexArray" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsVertexArray(GLuint array)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsVertexArray, "glIsVertexArray");
   if ( !driverTbl.glIsVertexArray ) {
      driverTbl.glIsVertexArray = missing_glIsVertexArray;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsVertexArray == loader_glIsVertexArray) {
      rCtx->dsp.emuTbl.glIsVertexArray = driverTbl.glIsVertexArray;
   }
   return driverTbl.glIsVertexArray(array);
}

// GL_ARB_uniform_buffer_object

static void REGAL_CALL missing_glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(uniformCount);
   UNUSED_PARAMETER(uniformNames);
   UNUSED_PARAMETER(uniformIndices);
   Warning( "Called missing function glGetUniformIndices" );
}

static void REGAL_CALL loader_glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformIndices, "glGetUniformIndices");
   if ( !driverTbl.glGetUniformIndices ) {
      driverTbl.glGetUniformIndices = missing_glGetUniformIndices;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformIndices == loader_glGetUniformIndices) {
      rCtx->dsp.emuTbl.glGetUniformIndices = driverTbl.glGetUniformIndices;
   }
   driverTbl.glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices);
}

static void REGAL_CALL missing_glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(uniformCount);
   UNUSED_PARAMETER(uniformIndices);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetActiveUniformsiv" );
}

static void REGAL_CALL loader_glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetActiveUniformsiv, "glGetActiveUniformsiv");
   if ( !driverTbl.glGetActiveUniformsiv ) {
      driverTbl.glGetActiveUniformsiv = missing_glGetActiveUniformsiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetActiveUniformsiv == loader_glGetActiveUniformsiv) {
      rCtx->dsp.emuTbl.glGetActiveUniformsiv = driverTbl.glGetActiveUniformsiv;
   }
   driverTbl.glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);
}

static void REGAL_CALL missing_glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(uniformIndex);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(uniformName);
   Warning( "Called missing function glGetActiveUniformName" );
}

static void REGAL_CALL loader_glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetActiveUniformName, "glGetActiveUniformName");
   if ( !driverTbl.glGetActiveUniformName ) {
      driverTbl.glGetActiveUniformName = missing_glGetActiveUniformName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetActiveUniformName == loader_glGetActiveUniformName) {
      rCtx->dsp.emuTbl.glGetActiveUniformName = driverTbl.glGetActiveUniformName;
   }
   driverTbl.glGetActiveUniformName(program, uniformIndex, bufSize, length, uniformName);
}

static GLuint REGAL_CALL missing_glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(uniformBlockName);
   Warning( "Called missing function glGetUniformBlockIndex" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformBlockIndex, "glGetUniformBlockIndex");
   if ( !driverTbl.glGetUniformBlockIndex ) {
      driverTbl.glGetUniformBlockIndex = missing_glGetUniformBlockIndex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformBlockIndex == loader_glGetUniformBlockIndex) {
      rCtx->dsp.emuTbl.glGetUniformBlockIndex = driverTbl.glGetUniformBlockIndex;
   }
   return driverTbl.glGetUniformBlockIndex(program, uniformBlockName);
}

static void REGAL_CALL missing_glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(uniformBlockIndex);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetActiveUniformBlockiv" );
}

static void REGAL_CALL loader_glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetActiveUniformBlockiv, "glGetActiveUniformBlockiv");
   if ( !driverTbl.glGetActiveUniformBlockiv ) {
      driverTbl.glGetActiveUniformBlockiv = missing_glGetActiveUniformBlockiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetActiveUniformBlockiv == loader_glGetActiveUniformBlockiv) {
      rCtx->dsp.emuTbl.glGetActiveUniformBlockiv = driverTbl.glGetActiveUniformBlockiv;
   }
   driverTbl.glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
}

static void REGAL_CALL missing_glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(uniformBlockIndex);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(uniformBlockName);
   Warning( "Called missing function glGetActiveUniformBlockName" );
}

static void REGAL_CALL loader_glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetActiveUniformBlockName, "glGetActiveUniformBlockName");
   if ( !driverTbl.glGetActiveUniformBlockName ) {
      driverTbl.glGetActiveUniformBlockName = missing_glGetActiveUniformBlockName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetActiveUniformBlockName == loader_glGetActiveUniformBlockName) {
      rCtx->dsp.emuTbl.glGetActiveUniformBlockName = driverTbl.glGetActiveUniformBlockName;
   }
   driverTbl.glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);
}

static void REGAL_CALL missing_glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(uniformBlockIndex);
   UNUSED_PARAMETER(uniformBlockBinding);
   Warning( "Called missing function glUniformBlockBinding" );
}

static void REGAL_CALL loader_glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformBlockBinding, "glUniformBlockBinding");
   if ( !driverTbl.glUniformBlockBinding ) {
      driverTbl.glUniformBlockBinding = missing_glUniformBlockBinding;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformBlockBinding == loader_glUniformBlockBinding) {
      rCtx->dsp.emuTbl.glUniformBlockBinding = driverTbl.glUniformBlockBinding;
   }
   driverTbl.glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
}

// GL_ARB_copy_buffer

static void REGAL_CALL missing_glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
{
   UNUSED_PARAMETER(readtarget);
   UNUSED_PARAMETER(writetarget);
   UNUSED_PARAMETER(readoffset);
   UNUSED_PARAMETER(writeoffset);
   UNUSED_PARAMETER(size);
   Warning( "Called missing function glCopyBufferSubData" );
}

static void REGAL_CALL loader_glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyBufferSubData, "glCopyBufferSubData");
   if ( !driverTbl.glCopyBufferSubData ) {
      driverTbl.glCopyBufferSubData = missing_glCopyBufferSubData;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyBufferSubData == loader_glCopyBufferSubData) {
      rCtx->dsp.emuTbl.glCopyBufferSubData = driverTbl.glCopyBufferSubData;
   }
   driverTbl.glCopyBufferSubData(readtarget, writetarget, readoffset, writeoffset, size);
}

// GL_ARB_draw_elements_base_vertex

static void REGAL_CALL missing_glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, GLvoid *indices, GLint basevertex)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(basevertex);
   Warning( "Called missing function glDrawElementsBaseVertex" );
}

static void REGAL_CALL loader_glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, GLvoid *indices, GLint basevertex)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawElementsBaseVertex, "glDrawElementsBaseVertex");
   if ( !driverTbl.glDrawElementsBaseVertex ) {
      driverTbl.glDrawElementsBaseVertex = missing_glDrawElementsBaseVertex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawElementsBaseVertex == loader_glDrawElementsBaseVertex) {
      rCtx->dsp.emuTbl.glDrawElementsBaseVertex = driverTbl.glDrawElementsBaseVertex;
   }
   driverTbl.glDrawElementsBaseVertex(mode, count, type, indices, basevertex);
}

static void REGAL_CALL missing_glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLvoid *indices, GLint basevertex)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(end);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(basevertex);
   Warning( "Called missing function glDrawRangeElementsBaseVertex" );
}

static void REGAL_CALL loader_glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLvoid *indices, GLint basevertex)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawRangeElementsBaseVertex, "glDrawRangeElementsBaseVertex");
   if ( !driverTbl.glDrawRangeElementsBaseVertex ) {
      driverTbl.glDrawRangeElementsBaseVertex = missing_glDrawRangeElementsBaseVertex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawRangeElementsBaseVertex == loader_glDrawRangeElementsBaseVertex) {
      rCtx->dsp.emuTbl.glDrawRangeElementsBaseVertex = driverTbl.glDrawRangeElementsBaseVertex;
   }
   driverTbl.glDrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
}

static void REGAL_CALL missing_glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(basevertex);
   Warning( "Called missing function glDrawElementsInstancedBaseVertex" );
}

static void REGAL_CALL loader_glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawElementsInstancedBaseVertex, "glDrawElementsInstancedBaseVertex");
   if ( !driverTbl.glDrawElementsInstancedBaseVertex ) {
      driverTbl.glDrawElementsInstancedBaseVertex = missing_glDrawElementsInstancedBaseVertex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawElementsInstancedBaseVertex == loader_glDrawElementsInstancedBaseVertex) {
      rCtx->dsp.emuTbl.glDrawElementsInstancedBaseVertex = driverTbl.glDrawElementsInstancedBaseVertex;
   }
   driverTbl.glDrawElementsInstancedBaseVertex(mode, count, type, indices, primcount, basevertex);
}

static void REGAL_CALL missing_glMultiDrawElementsBaseVertex(GLenum mode, GLsizei *count, GLenum type, GLvoid **indices, GLsizei primcount, GLint *basevertex)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(basevertex);
   Warning( "Called missing function glMultiDrawElementsBaseVertex" );
}

static void REGAL_CALL loader_glMultiDrawElementsBaseVertex(GLenum mode, GLsizei *count, GLenum type, GLvoid **indices, GLsizei primcount, GLint *basevertex)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiDrawElementsBaseVertex, "glMultiDrawElementsBaseVertex");
   if ( !driverTbl.glMultiDrawElementsBaseVertex ) {
      driverTbl.glMultiDrawElementsBaseVertex = missing_glMultiDrawElementsBaseVertex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiDrawElementsBaseVertex == loader_glMultiDrawElementsBaseVertex) {
      rCtx->dsp.emuTbl.glMultiDrawElementsBaseVertex = driverTbl.glMultiDrawElementsBaseVertex;
   }
   driverTbl.glMultiDrawElementsBaseVertex(mode, count, type, indices, primcount, basevertex);
}

// GL_ARB_provoking_vertex

static void REGAL_CALL missing_glProvokingVertex(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glProvokingVertex" );
}

static void REGAL_CALL loader_glProvokingVertex(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProvokingVertex, "glProvokingVertex");
   if ( !driverTbl.glProvokingVertex ) {
      driverTbl.glProvokingVertex = missing_glProvokingVertex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProvokingVertex == loader_glProvokingVertex) {
      rCtx->dsp.emuTbl.glProvokingVertex = driverTbl.glProvokingVertex;
   }
   driverTbl.glProvokingVertex(mode);
}

// GL_ARB_sync

static GLsync REGAL_CALL missing_glFenceSync(GLenum condition, GLbitfield flags)
{
   UNUSED_PARAMETER(condition);
   UNUSED_PARAMETER(flags);
   Warning( "Called missing function glFenceSync" );
  GLsync  ret = (GLsync )0;
  return ret;
}

static GLsync REGAL_CALL loader_glFenceSync(GLenum condition, GLbitfield flags)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFenceSync, "glFenceSync");
   if ( !driverTbl.glFenceSync ) {
      driverTbl.glFenceSync = missing_glFenceSync;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFenceSync == loader_glFenceSync) {
      rCtx->dsp.emuTbl.glFenceSync = driverTbl.glFenceSync;
   }
   return driverTbl.glFenceSync(condition, flags);
}

static GLboolean REGAL_CALL missing_glIsSync(GLsync sync)
{
   UNUSED_PARAMETER(sync);
   Warning( "Called missing function glIsSync" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsSync(GLsync sync)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsSync, "glIsSync");
   if ( !driverTbl.glIsSync ) {
      driverTbl.glIsSync = missing_glIsSync;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsSync == loader_glIsSync) {
      rCtx->dsp.emuTbl.glIsSync = driverTbl.glIsSync;
   }
   return driverTbl.glIsSync(sync);
}

static void REGAL_CALL missing_glDeleteSync(GLsync sync)
{
   UNUSED_PARAMETER(sync);
   Warning( "Called missing function glDeleteSync" );
}

static void REGAL_CALL loader_glDeleteSync(GLsync sync)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteSync, "glDeleteSync");
   if ( !driverTbl.glDeleteSync ) {
      driverTbl.glDeleteSync = missing_glDeleteSync;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteSync == loader_glDeleteSync) {
      rCtx->dsp.emuTbl.glDeleteSync = driverTbl.glDeleteSync;
   }
   driverTbl.glDeleteSync(sync);
}

static GLenum REGAL_CALL missing_glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
   UNUSED_PARAMETER(sync);
   UNUSED_PARAMETER(flags);
   UNUSED_PARAMETER(timeout);
   Warning( "Called missing function glClientWaitSync" );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClientWaitSync, "glClientWaitSync");
   if ( !driverTbl.glClientWaitSync ) {
      driverTbl.glClientWaitSync = missing_glClientWaitSync;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClientWaitSync == loader_glClientWaitSync) {
      rCtx->dsp.emuTbl.glClientWaitSync = driverTbl.glClientWaitSync;
   }
   return driverTbl.glClientWaitSync(sync, flags, timeout);
}

static void REGAL_CALL missing_glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
   UNUSED_PARAMETER(sync);
   UNUSED_PARAMETER(flags);
   UNUSED_PARAMETER(timeout);
   Warning( "Called missing function glWaitSync" );
}

static void REGAL_CALL loader_glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWaitSync, "glWaitSync");
   if ( !driverTbl.glWaitSync ) {
      driverTbl.glWaitSync = missing_glWaitSync;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWaitSync == loader_glWaitSync) {
      rCtx->dsp.emuTbl.glWaitSync = driverTbl.glWaitSync;
   }
   driverTbl.glWaitSync(sync, flags, timeout);
}

static void REGAL_CALL missing_glGetInteger64v(GLenum pname, GLint64 *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetInteger64v" );
}

static void REGAL_CALL loader_glGetInteger64v(GLenum pname, GLint64 *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetInteger64v, "glGetInteger64v");
   if ( !driverTbl.glGetInteger64v ) {
      driverTbl.glGetInteger64v = missing_glGetInteger64v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetInteger64v == loader_glGetInteger64v) {
      rCtx->dsp.emuTbl.glGetInteger64v = driverTbl.glGetInteger64v;
   }
   driverTbl.glGetInteger64v(pname, params);
}

static void REGAL_CALL missing_glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
   UNUSED_PARAMETER(sync);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetSynciv" );
}

static void REGAL_CALL loader_glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetSynciv, "glGetSynciv");
   if ( !driverTbl.glGetSynciv ) {
      driverTbl.glGetSynciv = missing_glGetSynciv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetSynciv == loader_glGetSynciv) {
      rCtx->dsp.emuTbl.glGetSynciv = driverTbl.glGetSynciv;
   }
   driverTbl.glGetSynciv(sync, pname, bufSize, length, values);
}

// GL_ARB_texture_multisample

static void REGAL_CALL missing_glTexImage2DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(fixedsamplelocations);
   Warning( "Called missing function glTexImage2DMultisample" );
}

static void REGAL_CALL loader_glTexImage2DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexImage2DMultisample, "glTexImage2DMultisample");
   if ( !driverTbl.glTexImage2DMultisample ) {
      driverTbl.glTexImage2DMultisample = missing_glTexImage2DMultisample;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexImage2DMultisample == loader_glTexImage2DMultisample) {
      rCtx->dsp.emuTbl.glTexImage2DMultisample = driverTbl.glTexImage2DMultisample;
   }
   driverTbl.glTexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
}

static void REGAL_CALL missing_glTexImage3DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(fixedsamplelocations);
   Warning( "Called missing function glTexImage3DMultisample" );
}

static void REGAL_CALL loader_glTexImage3DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexImage3DMultisample, "glTexImage3DMultisample");
   if ( !driverTbl.glTexImage3DMultisample ) {
      driverTbl.glTexImage3DMultisample = missing_glTexImage3DMultisample;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexImage3DMultisample == loader_glTexImage3DMultisample) {
      rCtx->dsp.emuTbl.glTexImage3DMultisample = driverTbl.glTexImage3DMultisample;
   }
   driverTbl.glTexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

static void REGAL_CALL missing_glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(val);
   Warning( "Called missing function glGetMultisamplefv" );
}

static void REGAL_CALL loader_glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMultisamplefv, "glGetMultisamplefv");
   if ( !driverTbl.glGetMultisamplefv ) {
      driverTbl.glGetMultisamplefv = missing_glGetMultisamplefv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMultisamplefv == loader_glGetMultisamplefv) {
      rCtx->dsp.emuTbl.glGetMultisamplefv = driverTbl.glGetMultisamplefv;
   }
   driverTbl.glGetMultisamplefv(pname, index, val);
}

static void REGAL_CALL missing_glSampleMaski(GLuint index, GLbitfield mask)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glSampleMaski" );
}

static void REGAL_CALL loader_glSampleMaski(GLuint index, GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSampleMaski, "glSampleMaski");
   if ( !driverTbl.glSampleMaski ) {
      driverTbl.glSampleMaski = missing_glSampleMaski;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSampleMaski == loader_glSampleMaski) {
      rCtx->dsp.emuTbl.glSampleMaski = driverTbl.glSampleMaski;
   }
   driverTbl.glSampleMaski(index, mask);
}

// GL_ARB_draw_buffers_blend

static void REGAL_CALL missing_glBlendEquationiARB(GLuint buf, GLenum mode)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glBlendEquationiARB" );
}

static void REGAL_CALL loader_glBlendEquationiARB(GLuint buf, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendEquationiARB, "glBlendEquationiARB");
   if ( !driverTbl.glBlendEquationiARB ) {
      driverTbl.glBlendEquationiARB = missing_glBlendEquationiARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendEquationiARB == loader_glBlendEquationiARB) {
      rCtx->dsp.emuTbl.glBlendEquationiARB = driverTbl.glBlendEquationiARB;
   }
   driverTbl.glBlendEquationiARB(buf, mode);
}

static void REGAL_CALL missing_glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(modeRGB);
   UNUSED_PARAMETER(modeAlpha);
   Warning( "Called missing function glBlendEquationSeparateiARB" );
}

static void REGAL_CALL loader_glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendEquationSeparateiARB, "glBlendEquationSeparateiARB");
   if ( !driverTbl.glBlendEquationSeparateiARB ) {
      driverTbl.glBlendEquationSeparateiARB = missing_glBlendEquationSeparateiARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendEquationSeparateiARB == loader_glBlendEquationSeparateiARB) {
      rCtx->dsp.emuTbl.glBlendEquationSeparateiARB = driverTbl.glBlendEquationSeparateiARB;
   }
   driverTbl.glBlendEquationSeparateiARB(buf, modeRGB, modeAlpha);
}

static void REGAL_CALL missing_glBlendFunciARB(GLuint buf, GLenum src, GLenum dst)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(src);
   UNUSED_PARAMETER(dst);
   Warning( "Called missing function glBlendFunciARB" );
}

static void REGAL_CALL loader_glBlendFunciARB(GLuint buf, GLenum src, GLenum dst)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendFunciARB, "glBlendFunciARB");
   if ( !driverTbl.glBlendFunciARB ) {
      driverTbl.glBlendFunciARB = missing_glBlendFunciARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendFunciARB == loader_glBlendFunciARB) {
      rCtx->dsp.emuTbl.glBlendFunciARB = driverTbl.glBlendFunciARB;
   }
   driverTbl.glBlendFunciARB(buf, src, dst);
}

static void REGAL_CALL missing_glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(srcRGB);
   UNUSED_PARAMETER(dstRGB);
   UNUSED_PARAMETER(srcAlpha);
   UNUSED_PARAMETER(dstAlpha);
   Warning( "Called missing function glBlendFuncSeparateiARB" );
}

static void REGAL_CALL loader_glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendFuncSeparateiARB, "glBlendFuncSeparateiARB");
   if ( !driverTbl.glBlendFuncSeparateiARB ) {
      driverTbl.glBlendFuncSeparateiARB = missing_glBlendFuncSeparateiARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendFuncSeparateiARB == loader_glBlendFuncSeparateiARB) {
      rCtx->dsp.emuTbl.glBlendFuncSeparateiARB = driverTbl.glBlendFuncSeparateiARB;
   }
   driverTbl.glBlendFuncSeparateiARB(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

// GL_ARB_sample_shading

static void REGAL_CALL missing_glMinSampleShadingARB(GLclampf value)
{
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glMinSampleShadingARB" );
}

static void REGAL_CALL loader_glMinSampleShadingARB(GLclampf value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMinSampleShadingARB, "glMinSampleShadingARB");
   if ( !driverTbl.glMinSampleShadingARB ) {
      driverTbl.glMinSampleShadingARB = missing_glMinSampleShadingARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMinSampleShadingARB == loader_glMinSampleShadingARB) {
      rCtx->dsp.emuTbl.glMinSampleShadingARB = driverTbl.glMinSampleShadingARB;
   }
   driverTbl.glMinSampleShadingARB(value);
}

// GL_ARB_shading_language_include

static void REGAL_CALL missing_glNamedStringARB(GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(namelen);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(stringlen);
   UNUSED_PARAMETER(string);
   Warning( "Called missing function glNamedStringARB" );
}

static void REGAL_CALL loader_glNamedStringARB(GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedStringARB, "glNamedStringARB");
   if ( !driverTbl.glNamedStringARB ) {
      driverTbl.glNamedStringARB = missing_glNamedStringARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedStringARB == loader_glNamedStringARB) {
      rCtx->dsp.emuTbl.glNamedStringARB = driverTbl.glNamedStringARB;
   }
   driverTbl.glNamedStringARB(type, namelen, name, stringlen, string);
}

static void REGAL_CALL missing_glDeleteNamedStringARB(GLint namelen, const GLchar *name)
{
   UNUSED_PARAMETER(namelen);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glDeleteNamedStringARB" );
}

static void REGAL_CALL loader_glDeleteNamedStringARB(GLint namelen, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteNamedStringARB, "glDeleteNamedStringARB");
   if ( !driverTbl.glDeleteNamedStringARB ) {
      driverTbl.glDeleteNamedStringARB = missing_glDeleteNamedStringARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteNamedStringARB == loader_glDeleteNamedStringARB) {
      rCtx->dsp.emuTbl.glDeleteNamedStringARB = driverTbl.glDeleteNamedStringARB;
   }
   driverTbl.glDeleteNamedStringARB(namelen, name);
}

static void REGAL_CALL missing_glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar **path, const GLint *length)
{
   UNUSED_PARAMETER(shader);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(length);
   Warning( "Called missing function glCompileShaderIncludeARB" );
}

static void REGAL_CALL loader_glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar **path, const GLint *length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompileShaderIncludeARB, "glCompileShaderIncludeARB");
   if ( !driverTbl.glCompileShaderIncludeARB ) {
      driverTbl.glCompileShaderIncludeARB = missing_glCompileShaderIncludeARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompileShaderIncludeARB == loader_glCompileShaderIncludeARB) {
      rCtx->dsp.emuTbl.glCompileShaderIncludeARB = driverTbl.glCompileShaderIncludeARB;
   }
   driverTbl.glCompileShaderIncludeARB(shader, count, path, length);
}

static GLboolean REGAL_CALL missing_glIsNamedStringARB(GLint namelen, const GLchar *name)
{
   UNUSED_PARAMETER(namelen);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glIsNamedStringARB" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsNamedStringARB(GLint namelen, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsNamedStringARB, "glIsNamedStringARB");
   if ( !driverTbl.glIsNamedStringARB ) {
      driverTbl.glIsNamedStringARB = missing_glIsNamedStringARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsNamedStringARB == loader_glIsNamedStringARB) {
      rCtx->dsp.emuTbl.glIsNamedStringARB = driverTbl.glIsNamedStringARB;
   }
   return driverTbl.glIsNamedStringARB(namelen, name);
}

static void REGAL_CALL missing_glGetNamedStringARB(GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string)
{
   UNUSED_PARAMETER(namelen);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(stringlen);
   UNUSED_PARAMETER(string);
   Warning( "Called missing function glGetNamedStringARB" );
}

static void REGAL_CALL loader_glGetNamedStringARB(GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetNamedStringARB, "glGetNamedStringARB");
   if ( !driverTbl.glGetNamedStringARB ) {
      driverTbl.glGetNamedStringARB = missing_glGetNamedStringARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetNamedStringARB == loader_glGetNamedStringARB) {
      rCtx->dsp.emuTbl.glGetNamedStringARB = driverTbl.glGetNamedStringARB;
   }
   driverTbl.glGetNamedStringARB(namelen, name, bufSize, stringlen, string);
}

static void REGAL_CALL missing_glGetNamedStringivARB(GLint namelen, const GLchar *name, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(namelen);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetNamedStringivARB" );
}

static void REGAL_CALL loader_glGetNamedStringivARB(GLint namelen, const GLchar *name, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetNamedStringivARB, "glGetNamedStringivARB");
   if ( !driverTbl.glGetNamedStringivARB ) {
      driverTbl.glGetNamedStringivARB = missing_glGetNamedStringivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetNamedStringivARB == loader_glGetNamedStringivARB) {
      rCtx->dsp.emuTbl.glGetNamedStringivARB = driverTbl.glGetNamedStringivARB;
   }
   driverTbl.glGetNamedStringivARB(namelen, name, pname, params);
}

// GL_ARB_debug_output

static void REGAL_CALL missing_glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
   UNUSED_PARAMETER(source);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(severity);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(ids);
   UNUSED_PARAMETER(enabled);
   Warning( "Called missing function glDebugMessageControlARB" );
}

static void REGAL_CALL loader_glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDebugMessageControlARB, "glDebugMessageControlARB");
   if ( !driverTbl.glDebugMessageControlARB ) {
      driverTbl.glDebugMessageControlARB = missing_glDebugMessageControlARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDebugMessageControlARB == loader_glDebugMessageControlARB) {
      rCtx->dsp.emuTbl.glDebugMessageControlARB = driverTbl.glDebugMessageControlARB;
   }
   driverTbl.glDebugMessageControlARB(source, type, severity, count, ids, enabled);
}

static void REGAL_CALL missing_glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
{
   UNUSED_PARAMETER(source);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(severity);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(buf);
   Warning( "Called missing function glDebugMessageInsertARB" );
}

static void REGAL_CALL loader_glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDebugMessageInsertARB, "glDebugMessageInsertARB");
   if ( !driverTbl.glDebugMessageInsertARB ) {
      driverTbl.glDebugMessageInsertARB = missing_glDebugMessageInsertARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDebugMessageInsertARB == loader_glDebugMessageInsertARB) {
      rCtx->dsp.emuTbl.glDebugMessageInsertARB = driverTbl.glDebugMessageInsertARB;
   }
   driverTbl.glDebugMessageInsertARB(source, type, id, severity, length, buf);
}

static void REGAL_CALL missing_glDebugMessageCallbackARB(GLDEBUGPROCARB callback, GLvoid *userParam)
{
   UNUSED_PARAMETER(callback);
   UNUSED_PARAMETER(userParam);
   Warning( "Called missing function glDebugMessageCallbackARB" );
}

static void REGAL_CALL loader_glDebugMessageCallbackARB(GLDEBUGPROCARB callback, GLvoid *userParam)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDebugMessageCallbackARB, "glDebugMessageCallbackARB");
   if ( !driverTbl.glDebugMessageCallbackARB ) {
      driverTbl.glDebugMessageCallbackARB = missing_glDebugMessageCallbackARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDebugMessageCallbackARB == loader_glDebugMessageCallbackARB) {
      rCtx->dsp.emuTbl.glDebugMessageCallbackARB = driverTbl.glDebugMessageCallbackARB;
   }
   driverTbl.glDebugMessageCallbackARB(callback, userParam);
}

static GLuint REGAL_CALL missing_glGetDebugMessageLogARB(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
{
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(bufsize);
   UNUSED_PARAMETER(sources);
   UNUSED_PARAMETER(types);
   UNUSED_PARAMETER(ids);
   UNUSED_PARAMETER(severities);
   UNUSED_PARAMETER(lengths);
   UNUSED_PARAMETER(messageLog);
   Warning( "Called missing function glGetDebugMessageLogARB" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGetDebugMessageLogARB(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetDebugMessageLogARB, "glGetDebugMessageLogARB");
   if ( !driverTbl.glGetDebugMessageLogARB ) {
      driverTbl.glGetDebugMessageLogARB = missing_glGetDebugMessageLogARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetDebugMessageLogARB == loader_glGetDebugMessageLogARB) {
      rCtx->dsp.emuTbl.glGetDebugMessageLogARB = driverTbl.glGetDebugMessageLogARB;
   }
   return driverTbl.glGetDebugMessageLogARB(count, bufsize, sources, types, ids, severities, lengths, messageLog);
}

// GL_ARB_robustness

static GLenum REGAL_CALL missing_glGetGraphicsResetStatusARB(void)
{
   Warning( "Called missing function glGetGraphicsResetStatusARB" );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glGetGraphicsResetStatusARB(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetGraphicsResetStatusARB, "glGetGraphicsResetStatusARB");
   if ( !driverTbl.glGetGraphicsResetStatusARB ) {
      driverTbl.glGetGraphicsResetStatusARB = missing_glGetGraphicsResetStatusARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetGraphicsResetStatusARB == loader_glGetGraphicsResetStatusARB) {
      rCtx->dsp.emuTbl.glGetGraphicsResetStatusARB = driverTbl.glGetGraphicsResetStatusARB;
   }
   return driverTbl.glGetGraphicsResetStatusARB();
}

static void REGAL_CALL missing_glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(query);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glGetnMapdvARB" );
}

static void REGAL_CALL loader_glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnMapdvARB, "glGetnMapdvARB");
   if ( !driverTbl.glGetnMapdvARB ) {
      driverTbl.glGetnMapdvARB = missing_glGetnMapdvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnMapdvARB == loader_glGetnMapdvARB) {
      rCtx->dsp.emuTbl.glGetnMapdvARB = driverTbl.glGetnMapdvARB;
   }
   driverTbl.glGetnMapdvARB(target, query, bufSize, v);
}

static void REGAL_CALL missing_glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(query);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glGetnMapfvARB" );
}

static void REGAL_CALL loader_glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnMapfvARB, "glGetnMapfvARB");
   if ( !driverTbl.glGetnMapfvARB ) {
      driverTbl.glGetnMapfvARB = missing_glGetnMapfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnMapfvARB == loader_glGetnMapfvARB) {
      rCtx->dsp.emuTbl.glGetnMapfvARB = driverTbl.glGetnMapfvARB;
   }
   driverTbl.glGetnMapfvARB(target, query, bufSize, v);
}

static void REGAL_CALL missing_glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(query);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glGetnMapivARB" );
}

static void REGAL_CALL loader_glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnMapivARB, "glGetnMapivARB");
   if ( !driverTbl.glGetnMapivARB ) {
      driverTbl.glGetnMapivARB = missing_glGetnMapivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnMapivARB == loader_glGetnMapivARB) {
      rCtx->dsp.emuTbl.glGetnMapivARB = driverTbl.glGetnMapivARB;
   }
   driverTbl.glGetnMapivARB(target, query, bufSize, v);
}

static void REGAL_CALL missing_glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetnPixelMapfvARB" );
}

static void REGAL_CALL loader_glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnPixelMapfvARB, "glGetnPixelMapfvARB");
   if ( !driverTbl.glGetnPixelMapfvARB ) {
      driverTbl.glGetnPixelMapfvARB = missing_glGetnPixelMapfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnPixelMapfvARB == loader_glGetnPixelMapfvARB) {
      rCtx->dsp.emuTbl.glGetnPixelMapfvARB = driverTbl.glGetnPixelMapfvARB;
   }
   driverTbl.glGetnPixelMapfvARB(map, bufSize, values);
}

static void REGAL_CALL missing_glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetnPixelMapuivARB" );
}

static void REGAL_CALL loader_glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnPixelMapuivARB, "glGetnPixelMapuivARB");
   if ( !driverTbl.glGetnPixelMapuivARB ) {
      driverTbl.glGetnPixelMapuivARB = missing_glGetnPixelMapuivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnPixelMapuivARB == loader_glGetnPixelMapuivARB) {
      rCtx->dsp.emuTbl.glGetnPixelMapuivARB = driverTbl.glGetnPixelMapuivARB;
   }
   driverTbl.glGetnPixelMapuivARB(map, bufSize, values);
}

static void REGAL_CALL missing_glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetnPixelMapusvARB" );
}

static void REGAL_CALL loader_glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnPixelMapusvARB, "glGetnPixelMapusvARB");
   if ( !driverTbl.glGetnPixelMapusvARB ) {
      driverTbl.glGetnPixelMapusvARB = missing_glGetnPixelMapusvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnPixelMapusvARB == loader_glGetnPixelMapusvARB) {
      rCtx->dsp.emuTbl.glGetnPixelMapusvARB = driverTbl.glGetnPixelMapusvARB;
   }
   driverTbl.glGetnPixelMapusvARB(map, bufSize, values);
}

static void REGAL_CALL missing_glGetnPolygonStippleARB(GLsizei bufSize, GLubyte *pattern)
{
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(pattern);
   Warning( "Called missing function glGetnPolygonStippleARB" );
}

static void REGAL_CALL loader_glGetnPolygonStippleARB(GLsizei bufSize, GLubyte *pattern)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnPolygonStippleARB, "glGetnPolygonStippleARB");
   if ( !driverTbl.glGetnPolygonStippleARB ) {
      driverTbl.glGetnPolygonStippleARB = missing_glGetnPolygonStippleARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnPolygonStippleARB == loader_glGetnPolygonStippleARB) {
      rCtx->dsp.emuTbl.glGetnPolygonStippleARB = driverTbl.glGetnPolygonStippleARB;
   }
   driverTbl.glGetnPolygonStippleARB(bufSize, pattern);
}

static void REGAL_CALL missing_glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(img);
   Warning( "Called missing function glGetnTexImageARB" );
}

static void REGAL_CALL loader_glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnTexImageARB, "glGetnTexImageARB");
   if ( !driverTbl.glGetnTexImageARB ) {
      driverTbl.glGetnTexImageARB = missing_glGetnTexImageARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnTexImageARB == loader_glGetnTexImageARB) {
      rCtx->dsp.emuTbl.glGetnTexImageARB = driverTbl.glGetnTexImageARB;
   }
   driverTbl.glGetnTexImageARB(target, level, format, type, bufSize, img);
}

static void REGAL_CALL missing_glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glReadnPixelsARB" );
}

static void REGAL_CALL loader_glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReadnPixelsARB, "glReadnPixelsARB");
   if ( !driverTbl.glReadnPixelsARB ) {
      driverTbl.glReadnPixelsARB = missing_glReadnPixelsARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReadnPixelsARB == loader_glReadnPixelsARB) {
      rCtx->dsp.emuTbl.glReadnPixelsARB = driverTbl.glReadnPixelsARB;
   }
   driverTbl.glReadnPixelsARB(x, y, width, height, format, type, bufSize, data);
}

static void REGAL_CALL missing_glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *table)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(table);
   Warning( "Called missing function glGetnColorTableARB" );
}

static void REGAL_CALL loader_glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *table)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnColorTableARB, "glGetnColorTableARB");
   if ( !driverTbl.glGetnColorTableARB ) {
      driverTbl.glGetnColorTableARB = missing_glGetnColorTableARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnColorTableARB == loader_glGetnColorTableARB) {
      rCtx->dsp.emuTbl.glGetnColorTableARB = driverTbl.glGetnColorTableARB;
   }
   driverTbl.glGetnColorTableARB(target, format, type, bufSize, table);
}

static void REGAL_CALL missing_glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *image)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(image);
   Warning( "Called missing function glGetnConvolutionFilterARB" );
}

static void REGAL_CALL loader_glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *image)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnConvolutionFilterARB, "glGetnConvolutionFilterARB");
   if ( !driverTbl.glGetnConvolutionFilterARB ) {
      driverTbl.glGetnConvolutionFilterARB = missing_glGetnConvolutionFilterARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnConvolutionFilterARB == loader_glGetnConvolutionFilterARB) {
      rCtx->dsp.emuTbl.glGetnConvolutionFilterARB = driverTbl.glGetnConvolutionFilterARB;
   }
   driverTbl.glGetnConvolutionFilterARB(target, format, type, bufSize, image);
}

static void REGAL_CALL missing_glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *row, GLsizei columnBufSize, GLvoid *column, GLvoid *span)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(rowBufSize);
   UNUSED_PARAMETER(row);
   UNUSED_PARAMETER(columnBufSize);
   UNUSED_PARAMETER(column);
   UNUSED_PARAMETER(span);
   Warning( "Called missing function glGetnSeparableFilterARB" );
}

static void REGAL_CALL loader_glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *row, GLsizei columnBufSize, GLvoid *column, GLvoid *span)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnSeparableFilterARB, "glGetnSeparableFilterARB");
   if ( !driverTbl.glGetnSeparableFilterARB ) {
      driverTbl.glGetnSeparableFilterARB = missing_glGetnSeparableFilterARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnSeparableFilterARB == loader_glGetnSeparableFilterARB) {
      rCtx->dsp.emuTbl.glGetnSeparableFilterARB = driverTbl.glGetnSeparableFilterARB;
   }
   driverTbl.glGetnSeparableFilterARB(target, format, type, rowBufSize, row, columnBufSize, column, span);
}

static void REGAL_CALL missing_glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(reset);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetnHistogramARB" );
}

static void REGAL_CALL loader_glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnHistogramARB, "glGetnHistogramARB");
   if ( !driverTbl.glGetnHistogramARB ) {
      driverTbl.glGetnHistogramARB = missing_glGetnHistogramARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnHistogramARB == loader_glGetnHistogramARB) {
      rCtx->dsp.emuTbl.glGetnHistogramARB = driverTbl.glGetnHistogramARB;
   }
   driverTbl.glGetnHistogramARB(target, reset, format, type, bufSize, values);
}

static void REGAL_CALL missing_glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(reset);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetnMinmaxARB" );
}

static void REGAL_CALL loader_glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnMinmaxARB, "glGetnMinmaxARB");
   if ( !driverTbl.glGetnMinmaxARB ) {
      driverTbl.glGetnMinmaxARB = missing_glGetnMinmaxARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnMinmaxARB == loader_glGetnMinmaxARB) {
      rCtx->dsp.emuTbl.glGetnMinmaxARB = driverTbl.glGetnMinmaxARB;
   }
   driverTbl.glGetnMinmaxARB(target, reset, format, type, bufSize, values);
}

static void REGAL_CALL missing_glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, GLvoid *img)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(lod);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(img);
   Warning( "Called missing function glGetnCompressedTexImageARB" );
}

static void REGAL_CALL loader_glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, GLvoid *img)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnCompressedTexImageARB, "glGetnCompressedTexImageARB");
   if ( !driverTbl.glGetnCompressedTexImageARB ) {
      driverTbl.glGetnCompressedTexImageARB = missing_glGetnCompressedTexImageARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnCompressedTexImageARB == loader_glGetnCompressedTexImageARB) {
      rCtx->dsp.emuTbl.glGetnCompressedTexImageARB = driverTbl.glGetnCompressedTexImageARB;
   }
   driverTbl.glGetnCompressedTexImageARB(target, lod, bufSize, img);
}

static void REGAL_CALL missing_glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetnUniformfvARB" );
}

static void REGAL_CALL loader_glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnUniformfvARB, "glGetnUniformfvARB");
   if ( !driverTbl.glGetnUniformfvARB ) {
      driverTbl.glGetnUniformfvARB = missing_glGetnUniformfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnUniformfvARB == loader_glGetnUniformfvARB) {
      rCtx->dsp.emuTbl.glGetnUniformfvARB = driverTbl.glGetnUniformfvARB;
   }
   driverTbl.glGetnUniformfvARB(program, location, bufSize, params);
}

static void REGAL_CALL missing_glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetnUniformivARB" );
}

static void REGAL_CALL loader_glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnUniformivARB, "glGetnUniformivARB");
   if ( !driverTbl.glGetnUniformivARB ) {
      driverTbl.glGetnUniformivARB = missing_glGetnUniformivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnUniformivARB == loader_glGetnUniformivARB) {
      rCtx->dsp.emuTbl.glGetnUniformivARB = driverTbl.glGetnUniformivARB;
   }
   driverTbl.glGetnUniformivARB(program, location, bufSize, params);
}

static void REGAL_CALL missing_glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetnUniformuivARB" );
}

static void REGAL_CALL loader_glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnUniformuivARB, "glGetnUniformuivARB");
   if ( !driverTbl.glGetnUniformuivARB ) {
      driverTbl.glGetnUniformuivARB = missing_glGetnUniformuivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnUniformuivARB == loader_glGetnUniformuivARB) {
      rCtx->dsp.emuTbl.glGetnUniformuivARB = driverTbl.glGetnUniformuivARB;
   }
   driverTbl.glGetnUniformuivARB(program, location, bufSize, params);
}

static void REGAL_CALL missing_glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetnUniformdvARB" );
}

static void REGAL_CALL loader_glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetnUniformdvARB, "glGetnUniformdvARB");
   if ( !driverTbl.glGetnUniformdvARB ) {
      driverTbl.glGetnUniformdvARB = missing_glGetnUniformdvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetnUniformdvARB == loader_glGetnUniformdvARB) {
      rCtx->dsp.emuTbl.glGetnUniformdvARB = driverTbl.glGetnUniformdvARB;
   }
   driverTbl.glGetnUniformdvARB(program, location, bufSize, params);
}

// GL_EXT_blend_color

static void REGAL_CALL missing_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glBlendColorEXT" );
}

static void REGAL_CALL loader_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendColorEXT, "glBlendColorEXT");
   if ( !driverTbl.glBlendColorEXT ) {
      driverTbl.glBlendColorEXT = missing_glBlendColorEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendColorEXT == loader_glBlendColorEXT) {
      rCtx->dsp.emuTbl.glBlendColorEXT = driverTbl.glBlendColorEXT;
   }
   driverTbl.glBlendColorEXT(red, green, blue, alpha);
}

// GL_EXT_polygon_offset

static void REGAL_CALL missing_glPolygonOffsetEXT(GLfloat factor, GLfloat bias)
{
   UNUSED_PARAMETER(factor);
   UNUSED_PARAMETER(bias);
   Warning( "Called missing function glPolygonOffsetEXT" );
}

static void REGAL_CALL loader_glPolygonOffsetEXT(GLfloat factor, GLfloat bias)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPolygonOffsetEXT, "glPolygonOffsetEXT");
   if ( !driverTbl.glPolygonOffsetEXT ) {
      driverTbl.glPolygonOffsetEXT = missing_glPolygonOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPolygonOffsetEXT == loader_glPolygonOffsetEXT) {
      rCtx->dsp.emuTbl.glPolygonOffsetEXT = driverTbl.glPolygonOffsetEXT;
   }
   driverTbl.glPolygonOffsetEXT(factor, bias);
}

// GL_EXT_texture3D

static void REGAL_CALL missing_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTexImage3DEXT" );
}

static void REGAL_CALL loader_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexImage3DEXT, "glTexImage3DEXT");
   if ( !driverTbl.glTexImage3DEXT ) {
      driverTbl.glTexImage3DEXT = missing_glTexImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexImage3DEXT == loader_glTexImage3DEXT) {
      rCtx->dsp.emuTbl.glTexImage3DEXT = driverTbl.glTexImage3DEXT;
   }
   driverTbl.glTexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

// GL_SGIS_texture_filter4

static void REGAL_CALL missing_glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat *weights)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(filter);
   UNUSED_PARAMETER(weights);
   Warning( "Called missing function glGetTexFilterFuncSGIS" );
}

static void REGAL_CALL loader_glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexFilterFuncSGIS, "glGetTexFilterFuncSGIS");
   if ( !driverTbl.glGetTexFilterFuncSGIS ) {
      driverTbl.glGetTexFilterFuncSGIS = missing_glGetTexFilterFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexFilterFuncSGIS == loader_glGetTexFilterFuncSGIS) {
      rCtx->dsp.emuTbl.glGetTexFilterFuncSGIS = driverTbl.glGetTexFilterFuncSGIS;
   }
   driverTbl.glGetTexFilterFuncSGIS(target, filter, weights);
}

static void REGAL_CALL missing_glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat *weights)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(filter);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(weights);
   Warning( "Called missing function glTexFilterFuncSGIS" );
}

static void REGAL_CALL loader_glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexFilterFuncSGIS, "glTexFilterFuncSGIS");
   if ( !driverTbl.glTexFilterFuncSGIS ) {
      driverTbl.glTexFilterFuncSGIS = missing_glTexFilterFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexFilterFuncSGIS == loader_glTexFilterFuncSGIS) {
      rCtx->dsp.emuTbl.glTexFilterFuncSGIS = driverTbl.glTexFilterFuncSGIS;
   }
   driverTbl.glTexFilterFuncSGIS(target, filter, n, weights);
}

// GL_EXT_subtexture

static void REGAL_CALL missing_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTexSubImage1DEXT" );
}

static void REGAL_CALL loader_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexSubImage1DEXT, "glTexSubImage1DEXT");
   if ( !driverTbl.glTexSubImage1DEXT ) {
      driverTbl.glTexSubImage1DEXT = missing_glTexSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexSubImage1DEXT == loader_glTexSubImage1DEXT) {
      rCtx->dsp.emuTbl.glTexSubImage1DEXT = driverTbl.glTexSubImage1DEXT;
   }
   driverTbl.glTexSubImage1DEXT(target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL missing_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTexSubImage2DEXT" );
}

static void REGAL_CALL loader_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexSubImage2DEXT, "glTexSubImage2DEXT");
   if ( !driverTbl.glTexSubImage2DEXT ) {
      driverTbl.glTexSubImage2DEXT = missing_glTexSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexSubImage2DEXT == loader_glTexSubImage2DEXT) {
      rCtx->dsp.emuTbl.glTexSubImage2DEXT = driverTbl.glTexSubImage2DEXT;
   }
   driverTbl.glTexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL missing_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTexSubImage3DEXT" );
}

static void REGAL_CALL loader_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexSubImage3DEXT, "glTexSubImage3DEXT");
   if ( !driverTbl.glTexSubImage3DEXT ) {
      driverTbl.glTexSubImage3DEXT = missing_glTexSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexSubImage3DEXT == loader_glTexSubImage3DEXT) {
      rCtx->dsp.emuTbl.glTexSubImage3DEXT = driverTbl.glTexSubImage3DEXT;
   }
   driverTbl.glTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

// GL_EXT_copy_texture

static void REGAL_CALL missing_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   Warning( "Called missing function glCopyTexImage1DEXT" );
}

static void REGAL_CALL loader_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTexImage1DEXT, "glCopyTexImage1DEXT");
   if ( !driverTbl.glCopyTexImage1DEXT ) {
      driverTbl.glCopyTexImage1DEXT = missing_glCopyTexImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTexImage1DEXT == loader_glCopyTexImage1DEXT) {
      rCtx->dsp.emuTbl.glCopyTexImage1DEXT = driverTbl.glCopyTexImage1DEXT;
   }
   driverTbl.glCopyTexImage1DEXT(target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL missing_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   Warning( "Called missing function glCopyTexImage2DEXT" );
}

static void REGAL_CALL loader_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTexImage2DEXT, "glCopyTexImage2DEXT");
   if ( !driverTbl.glCopyTexImage2DEXT ) {
      driverTbl.glCopyTexImage2DEXT = missing_glCopyTexImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTexImage2DEXT == loader_glCopyTexImage2DEXT) {
      rCtx->dsp.emuTbl.glCopyTexImage2DEXT = driverTbl.glCopyTexImage2DEXT;
   }
   driverTbl.glCopyTexImage2DEXT(target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL missing_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "Called missing function glCopyTexSubImage1DEXT" );
}

static void REGAL_CALL loader_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTexSubImage1DEXT, "glCopyTexSubImage1DEXT");
   if ( !driverTbl.glCopyTexSubImage1DEXT ) {
      driverTbl.glCopyTexSubImage1DEXT = missing_glCopyTexSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTexSubImage1DEXT == loader_glCopyTexSubImage1DEXT) {
      rCtx->dsp.emuTbl.glCopyTexSubImage1DEXT = driverTbl.glCopyTexSubImage1DEXT;
   }
   driverTbl.glCopyTexSubImage1DEXT(target, level, xoffset, x, y, width);
}

static void REGAL_CALL missing_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glCopyTexSubImage2DEXT" );
}

static void REGAL_CALL loader_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTexSubImage2DEXT, "glCopyTexSubImage2DEXT");
   if ( !driverTbl.glCopyTexSubImage2DEXT ) {
      driverTbl.glCopyTexSubImage2DEXT = missing_glCopyTexSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTexSubImage2DEXT == loader_glCopyTexSubImage2DEXT) {
      rCtx->dsp.emuTbl.glCopyTexSubImage2DEXT = driverTbl.glCopyTexSubImage2DEXT;
   }
   driverTbl.glCopyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL missing_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glCopyTexSubImage3DEXT" );
}

static void REGAL_CALL loader_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTexSubImage3DEXT, "glCopyTexSubImage3DEXT");
   if ( !driverTbl.glCopyTexSubImage3DEXT ) {
      driverTbl.glCopyTexSubImage3DEXT = missing_glCopyTexSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTexSubImage3DEXT == loader_glCopyTexSubImage3DEXT) {
      rCtx->dsp.emuTbl.glCopyTexSubImage3DEXT = driverTbl.glCopyTexSubImage3DEXT;
   }
   driverTbl.glCopyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

// GL_EXT_histogram

static void REGAL_CALL missing_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(reset);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetHistogramEXT" );
}

static void REGAL_CALL loader_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetHistogramEXT, "glGetHistogramEXT");
   if ( !driverTbl.glGetHistogramEXT ) {
      driverTbl.glGetHistogramEXT = missing_glGetHistogramEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetHistogramEXT == loader_glGetHistogramEXT) {
      rCtx->dsp.emuTbl.glGetHistogramEXT = driverTbl.glGetHistogramEXT;
   }
   driverTbl.glGetHistogramEXT(target, reset, format, type, values);
}

static void REGAL_CALL missing_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetHistogramParameterfvEXT" );
}

static void REGAL_CALL loader_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetHistogramParameterfvEXT, "glGetHistogramParameterfvEXT");
   if ( !driverTbl.glGetHistogramParameterfvEXT ) {
      driverTbl.glGetHistogramParameterfvEXT = missing_glGetHistogramParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetHistogramParameterfvEXT == loader_glGetHistogramParameterfvEXT) {
      rCtx->dsp.emuTbl.glGetHistogramParameterfvEXT = driverTbl.glGetHistogramParameterfvEXT;
   }
   driverTbl.glGetHistogramParameterfvEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetHistogramParameterivEXT" );
}

static void REGAL_CALL loader_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetHistogramParameterivEXT, "glGetHistogramParameterivEXT");
   if ( !driverTbl.glGetHistogramParameterivEXT ) {
      driverTbl.glGetHistogramParameterivEXT = missing_glGetHistogramParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetHistogramParameterivEXT == loader_glGetHistogramParameterivEXT) {
      rCtx->dsp.emuTbl.glGetHistogramParameterivEXT = driverTbl.glGetHistogramParameterivEXT;
   }
   driverTbl.glGetHistogramParameterivEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(reset);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glGetMinmaxEXT" );
}

static void REGAL_CALL loader_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMinmaxEXT, "glGetMinmaxEXT");
   if ( !driverTbl.glGetMinmaxEXT ) {
      driverTbl.glGetMinmaxEXT = missing_glGetMinmaxEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMinmaxEXT == loader_glGetMinmaxEXT) {
      rCtx->dsp.emuTbl.glGetMinmaxEXT = driverTbl.glGetMinmaxEXT;
   }
   driverTbl.glGetMinmaxEXT(target, reset, format, type, values);
}

static void REGAL_CALL missing_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMinmaxParameterfvEXT" );
}

static void REGAL_CALL loader_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMinmaxParameterfvEXT, "glGetMinmaxParameterfvEXT");
   if ( !driverTbl.glGetMinmaxParameterfvEXT ) {
      driverTbl.glGetMinmaxParameterfvEXT = missing_glGetMinmaxParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMinmaxParameterfvEXT == loader_glGetMinmaxParameterfvEXT) {
      rCtx->dsp.emuTbl.glGetMinmaxParameterfvEXT = driverTbl.glGetMinmaxParameterfvEXT;
   }
   driverTbl.glGetMinmaxParameterfvEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMinmaxParameterivEXT" );
}

static void REGAL_CALL loader_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMinmaxParameterivEXT, "glGetMinmaxParameterivEXT");
   if ( !driverTbl.glGetMinmaxParameterivEXT ) {
      driverTbl.glGetMinmaxParameterivEXT = missing_glGetMinmaxParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMinmaxParameterivEXT == loader_glGetMinmaxParameterivEXT) {
      rCtx->dsp.emuTbl.glGetMinmaxParameterivEXT = driverTbl.glGetMinmaxParameterivEXT;
   }
   driverTbl.glGetMinmaxParameterivEXT(target, pname, params);
}

static void REGAL_CALL missing_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(sink);
   Warning( "Called missing function glHistogramEXT" );
}

static void REGAL_CALL loader_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glHistogramEXT, "glHistogramEXT");
   if ( !driverTbl.glHistogramEXT ) {
      driverTbl.glHistogramEXT = missing_glHistogramEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glHistogramEXT == loader_glHistogramEXT) {
      rCtx->dsp.emuTbl.glHistogramEXT = driverTbl.glHistogramEXT;
   }
   driverTbl.glHistogramEXT(target, width, internalformat, sink);
}

static void REGAL_CALL missing_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(sink);
   Warning( "Called missing function glMinmaxEXT" );
}

static void REGAL_CALL loader_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMinmaxEXT, "glMinmaxEXT");
   if ( !driverTbl.glMinmaxEXT ) {
      driverTbl.glMinmaxEXT = missing_glMinmaxEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMinmaxEXT == loader_glMinmaxEXT) {
      rCtx->dsp.emuTbl.glMinmaxEXT = driverTbl.glMinmaxEXT;
   }
   driverTbl.glMinmaxEXT(target, internalformat, sink);
}

static void REGAL_CALL missing_glResetHistogramEXT(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glResetHistogramEXT" );
}

static void REGAL_CALL loader_glResetHistogramEXT(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glResetHistogramEXT, "glResetHistogramEXT");
   if ( !driverTbl.glResetHistogramEXT ) {
      driverTbl.glResetHistogramEXT = missing_glResetHistogramEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glResetHistogramEXT == loader_glResetHistogramEXT) {
      rCtx->dsp.emuTbl.glResetHistogramEXT = driverTbl.glResetHistogramEXT;
   }
   driverTbl.glResetHistogramEXT(target);
}

static void REGAL_CALL missing_glResetMinmaxEXT(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glResetMinmaxEXT" );
}

static void REGAL_CALL loader_glResetMinmaxEXT(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glResetMinmaxEXT, "glResetMinmaxEXT");
   if ( !driverTbl.glResetMinmaxEXT ) {
      driverTbl.glResetMinmaxEXT = missing_glResetMinmaxEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glResetMinmaxEXT == loader_glResetMinmaxEXT) {
      rCtx->dsp.emuTbl.glResetMinmaxEXT = driverTbl.glResetMinmaxEXT;
   }
   driverTbl.glResetMinmaxEXT(target);
}

// GL_EXT_convolution

static void REGAL_CALL missing_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(image);
   Warning( "Called missing function glConvolutionFilter1DEXT" );
}

static void REGAL_CALL loader_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glConvolutionFilter1DEXT, "glConvolutionFilter1DEXT");
   if ( !driverTbl.glConvolutionFilter1DEXT ) {
      driverTbl.glConvolutionFilter1DEXT = missing_glConvolutionFilter1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glConvolutionFilter1DEXT == loader_glConvolutionFilter1DEXT) {
      rCtx->dsp.emuTbl.glConvolutionFilter1DEXT = driverTbl.glConvolutionFilter1DEXT;
   }
   driverTbl.glConvolutionFilter1DEXT(target, internalformat, width, format, type, image);
}

static void REGAL_CALL missing_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(image);
   Warning( "Called missing function glConvolutionFilter2DEXT" );
}

static void REGAL_CALL loader_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glConvolutionFilter2DEXT, "glConvolutionFilter2DEXT");
   if ( !driverTbl.glConvolutionFilter2DEXT ) {
      driverTbl.glConvolutionFilter2DEXT = missing_glConvolutionFilter2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glConvolutionFilter2DEXT == loader_glConvolutionFilter2DEXT) {
      rCtx->dsp.emuTbl.glConvolutionFilter2DEXT = driverTbl.glConvolutionFilter2DEXT;
   }
   driverTbl.glConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image);
}

static void REGAL_CALL missing_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glConvolutionParameterfEXT" );
}

static void REGAL_CALL loader_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glConvolutionParameterfEXT, "glConvolutionParameterfEXT");
   if ( !driverTbl.glConvolutionParameterfEXT ) {
      driverTbl.glConvolutionParameterfEXT = missing_glConvolutionParameterfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glConvolutionParameterfEXT == loader_glConvolutionParameterfEXT) {
      rCtx->dsp.emuTbl.glConvolutionParameterfEXT = driverTbl.glConvolutionParameterfEXT;
   }
   driverTbl.glConvolutionParameterfEXT(target, pname, param);
}

static void REGAL_CALL missing_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glConvolutionParameterfvEXT" );
}

static void REGAL_CALL loader_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glConvolutionParameterfvEXT, "glConvolutionParameterfvEXT");
   if ( !driverTbl.glConvolutionParameterfvEXT ) {
      driverTbl.glConvolutionParameterfvEXT = missing_glConvolutionParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glConvolutionParameterfvEXT == loader_glConvolutionParameterfvEXT) {
      rCtx->dsp.emuTbl.glConvolutionParameterfvEXT = driverTbl.glConvolutionParameterfvEXT;
   }
   driverTbl.glConvolutionParameterfvEXT(target, pname, params);
}

static void REGAL_CALL missing_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glConvolutionParameteriEXT" );
}

static void REGAL_CALL loader_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glConvolutionParameteriEXT, "glConvolutionParameteriEXT");
   if ( !driverTbl.glConvolutionParameteriEXT ) {
      driverTbl.glConvolutionParameteriEXT = missing_glConvolutionParameteriEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glConvolutionParameteriEXT == loader_glConvolutionParameteriEXT) {
      rCtx->dsp.emuTbl.glConvolutionParameteriEXT = driverTbl.glConvolutionParameteriEXT;
   }
   driverTbl.glConvolutionParameteriEXT(target, pname, param);
}

static void REGAL_CALL missing_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glConvolutionParameterivEXT" );
}

static void REGAL_CALL loader_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glConvolutionParameterivEXT, "glConvolutionParameterivEXT");
   if ( !driverTbl.glConvolutionParameterivEXT ) {
      driverTbl.glConvolutionParameterivEXT = missing_glConvolutionParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glConvolutionParameterivEXT == loader_glConvolutionParameterivEXT) {
      rCtx->dsp.emuTbl.glConvolutionParameterivEXT = driverTbl.glConvolutionParameterivEXT;
   }
   driverTbl.glConvolutionParameterivEXT(target, pname, params);
}

static void REGAL_CALL missing_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "Called missing function glCopyConvolutionFilter1DEXT" );
}

static void REGAL_CALL loader_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyConvolutionFilter1DEXT, "glCopyConvolutionFilter1DEXT");
   if ( !driverTbl.glCopyConvolutionFilter1DEXT ) {
      driverTbl.glCopyConvolutionFilter1DEXT = missing_glCopyConvolutionFilter1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyConvolutionFilter1DEXT == loader_glCopyConvolutionFilter1DEXT) {
      rCtx->dsp.emuTbl.glCopyConvolutionFilter1DEXT = driverTbl.glCopyConvolutionFilter1DEXT;
   }
   driverTbl.glCopyConvolutionFilter1DEXT(target, internalformat, x, y, width);
}

static void REGAL_CALL missing_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glCopyConvolutionFilter2DEXT" );
}

static void REGAL_CALL loader_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyConvolutionFilter2DEXT, "glCopyConvolutionFilter2DEXT");
   if ( !driverTbl.glCopyConvolutionFilter2DEXT ) {
      driverTbl.glCopyConvolutionFilter2DEXT = missing_glCopyConvolutionFilter2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyConvolutionFilter2DEXT == loader_glCopyConvolutionFilter2DEXT) {
      rCtx->dsp.emuTbl.glCopyConvolutionFilter2DEXT = driverTbl.glCopyConvolutionFilter2DEXT;
   }
   driverTbl.glCopyConvolutionFilter2DEXT(target, internalformat, x, y, width, height);
}

static void REGAL_CALL missing_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(image);
   Warning( "Called missing function glGetConvolutionFilterEXT" );
}

static void REGAL_CALL loader_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetConvolutionFilterEXT, "glGetConvolutionFilterEXT");
   if ( !driverTbl.glGetConvolutionFilterEXT ) {
      driverTbl.glGetConvolutionFilterEXT = missing_glGetConvolutionFilterEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetConvolutionFilterEXT == loader_glGetConvolutionFilterEXT) {
      rCtx->dsp.emuTbl.glGetConvolutionFilterEXT = driverTbl.glGetConvolutionFilterEXT;
   }
   driverTbl.glGetConvolutionFilterEXT(target, format, type, image);
}

static void REGAL_CALL missing_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetConvolutionParameterfvEXT" );
}

static void REGAL_CALL loader_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetConvolutionParameterfvEXT, "glGetConvolutionParameterfvEXT");
   if ( !driverTbl.glGetConvolutionParameterfvEXT ) {
      driverTbl.glGetConvolutionParameterfvEXT = missing_glGetConvolutionParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetConvolutionParameterfvEXT == loader_glGetConvolutionParameterfvEXT) {
      rCtx->dsp.emuTbl.glGetConvolutionParameterfvEXT = driverTbl.glGetConvolutionParameterfvEXT;
   }
   driverTbl.glGetConvolutionParameterfvEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetConvolutionParameterivEXT" );
}

static void REGAL_CALL loader_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetConvolutionParameterivEXT, "glGetConvolutionParameterivEXT");
   if ( !driverTbl.glGetConvolutionParameterivEXT ) {
      driverTbl.glGetConvolutionParameterivEXT = missing_glGetConvolutionParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetConvolutionParameterivEXT == loader_glGetConvolutionParameterivEXT) {
      rCtx->dsp.emuTbl.glGetConvolutionParameterivEXT = driverTbl.glGetConvolutionParameterivEXT;
   }
   driverTbl.glGetConvolutionParameterivEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(row);
   UNUSED_PARAMETER(column);
   UNUSED_PARAMETER(span);
   Warning( "Called missing function glGetSeparableFilterEXT" );
}

static void REGAL_CALL loader_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetSeparableFilterEXT, "glGetSeparableFilterEXT");
   if ( !driverTbl.glGetSeparableFilterEXT ) {
      driverTbl.glGetSeparableFilterEXT = missing_glGetSeparableFilterEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetSeparableFilterEXT == loader_glGetSeparableFilterEXT) {
      rCtx->dsp.emuTbl.glGetSeparableFilterEXT = driverTbl.glGetSeparableFilterEXT;
   }
   driverTbl.glGetSeparableFilterEXT(target, format, type, row, column, span);
}

static void REGAL_CALL missing_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(row);
   UNUSED_PARAMETER(column);
   Warning( "Called missing function glSeparableFilter2DEXT" );
}

static void REGAL_CALL loader_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSeparableFilter2DEXT, "glSeparableFilter2DEXT");
   if ( !driverTbl.glSeparableFilter2DEXT ) {
      driverTbl.glSeparableFilter2DEXT = missing_glSeparableFilter2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSeparableFilter2DEXT == loader_glSeparableFilter2DEXT) {
      rCtx->dsp.emuTbl.glSeparableFilter2DEXT = driverTbl.glSeparableFilter2DEXT;
   }
   driverTbl.glSeparableFilter2DEXT(target, internalformat, width, height, format, type, row, column);
}

// GL_SGI_color_table

static void REGAL_CALL missing_glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(table);
   Warning( "Called missing function glColorTableSGI" );
}

static void REGAL_CALL loader_glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorTableSGI, "glColorTableSGI");
   if ( !driverTbl.glColorTableSGI ) {
      driverTbl.glColorTableSGI = missing_glColorTableSGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorTableSGI == loader_glColorTableSGI) {
      rCtx->dsp.emuTbl.glColorTableSGI = driverTbl.glColorTableSGI;
   }
   driverTbl.glColorTableSGI(target, internalformat, width, format, type, table);
}

static void REGAL_CALL missing_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glColorTableParameterfvSGI" );
}

static void REGAL_CALL loader_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorTableParameterfvSGI, "glColorTableParameterfvSGI");
   if ( !driverTbl.glColorTableParameterfvSGI ) {
      driverTbl.glColorTableParameterfvSGI = missing_glColorTableParameterfvSGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorTableParameterfvSGI == loader_glColorTableParameterfvSGI) {
      rCtx->dsp.emuTbl.glColorTableParameterfvSGI = driverTbl.glColorTableParameterfvSGI;
   }
   driverTbl.glColorTableParameterfvSGI(target, pname, params);
}

static void REGAL_CALL missing_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glColorTableParameterivSGI" );
}

static void REGAL_CALL loader_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorTableParameterivSGI, "glColorTableParameterivSGI");
   if ( !driverTbl.glColorTableParameterivSGI ) {
      driverTbl.glColorTableParameterivSGI = missing_glColorTableParameterivSGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorTableParameterivSGI == loader_glColorTableParameterivSGI) {
      rCtx->dsp.emuTbl.glColorTableParameterivSGI = driverTbl.glColorTableParameterivSGI;
   }
   driverTbl.glColorTableParameterivSGI(target, pname, params);
}

static void REGAL_CALL missing_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "Called missing function glCopyColorTableSGI" );
}

static void REGAL_CALL loader_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyColorTableSGI, "glCopyColorTableSGI");
   if ( !driverTbl.glCopyColorTableSGI ) {
      driverTbl.glCopyColorTableSGI = missing_glCopyColorTableSGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyColorTableSGI == loader_glCopyColorTableSGI) {
      rCtx->dsp.emuTbl.glCopyColorTableSGI = driverTbl.glCopyColorTableSGI;
   }
   driverTbl.glCopyColorTableSGI(target, internalformat, x, y, width);
}

static void REGAL_CALL missing_glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid *table)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(table);
   Warning( "Called missing function glGetColorTableSGI" );
}

static void REGAL_CALL loader_glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid *table)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetColorTableSGI, "glGetColorTableSGI");
   if ( !driverTbl.glGetColorTableSGI ) {
      driverTbl.glGetColorTableSGI = missing_glGetColorTableSGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetColorTableSGI == loader_glGetColorTableSGI) {
      rCtx->dsp.emuTbl.glGetColorTableSGI = driverTbl.glGetColorTableSGI;
   }
   driverTbl.glGetColorTableSGI(target, format, type, table);
}

static void REGAL_CALL missing_glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetColorTableParameterfvSGI" );
}

static void REGAL_CALL loader_glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetColorTableParameterfvSGI, "glGetColorTableParameterfvSGI");
   if ( !driverTbl.glGetColorTableParameterfvSGI ) {
      driverTbl.glGetColorTableParameterfvSGI = missing_glGetColorTableParameterfvSGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetColorTableParameterfvSGI == loader_glGetColorTableParameterfvSGI) {
      rCtx->dsp.emuTbl.glGetColorTableParameterfvSGI = driverTbl.glGetColorTableParameterfvSGI;
   }
   driverTbl.glGetColorTableParameterfvSGI(target, pname, params);
}

static void REGAL_CALL missing_glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetColorTableParameterivSGI" );
}

static void REGAL_CALL loader_glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetColorTableParameterivSGI, "glGetColorTableParameterivSGI");
   if ( !driverTbl.glGetColorTableParameterivSGI ) {
      driverTbl.glGetColorTableParameterivSGI = missing_glGetColorTableParameterivSGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetColorTableParameterivSGI == loader_glGetColorTableParameterivSGI) {
      rCtx->dsp.emuTbl.glGetColorTableParameterivSGI = driverTbl.glGetColorTableParameterivSGI;
   }
   driverTbl.glGetColorTableParameterivSGI(target, pname, params);
}

// GL_SGIX_pixel_texture

static void REGAL_CALL missing_glPixelTexGenSGIX(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glPixelTexGenSGIX" );
}

static void REGAL_CALL loader_glPixelTexGenSGIX(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelTexGenSGIX, "glPixelTexGenSGIX");
   if ( !driverTbl.glPixelTexGenSGIX ) {
      driverTbl.glPixelTexGenSGIX = missing_glPixelTexGenSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelTexGenSGIX == loader_glPixelTexGenSGIX) {
      rCtx->dsp.emuTbl.glPixelTexGenSGIX = driverTbl.glPixelTexGenSGIX;
   }
   driverTbl.glPixelTexGenSGIX(mode);
}

// GL_SGIS_pixel_texture

static void REGAL_CALL missing_glPixelTexGenParameteriSGIS(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPixelTexGenParameteriSGIS" );
}

static void REGAL_CALL loader_glPixelTexGenParameteriSGIS(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelTexGenParameteriSGIS, "glPixelTexGenParameteriSGIS");
   if ( !driverTbl.glPixelTexGenParameteriSGIS ) {
      driverTbl.glPixelTexGenParameteriSGIS = missing_glPixelTexGenParameteriSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelTexGenParameteriSGIS == loader_glPixelTexGenParameteriSGIS) {
      rCtx->dsp.emuTbl.glPixelTexGenParameteriSGIS = driverTbl.glPixelTexGenParameteriSGIS;
   }
   driverTbl.glPixelTexGenParameteriSGIS(pname, param);
}

static void REGAL_CALL missing_glPixelTexGenParameterivSGIS(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glPixelTexGenParameterivSGIS" );
}

static void REGAL_CALL loader_glPixelTexGenParameterivSGIS(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelTexGenParameterivSGIS, "glPixelTexGenParameterivSGIS");
   if ( !driverTbl.glPixelTexGenParameterivSGIS ) {
      driverTbl.glPixelTexGenParameterivSGIS = missing_glPixelTexGenParameterivSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelTexGenParameterivSGIS == loader_glPixelTexGenParameterivSGIS) {
      rCtx->dsp.emuTbl.glPixelTexGenParameterivSGIS = driverTbl.glPixelTexGenParameterivSGIS;
   }
   driverTbl.glPixelTexGenParameterivSGIS(pname, params);
}

static void REGAL_CALL missing_glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPixelTexGenParameterfSGIS" );
}

static void REGAL_CALL loader_glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelTexGenParameterfSGIS, "glPixelTexGenParameterfSGIS");
   if ( !driverTbl.glPixelTexGenParameterfSGIS ) {
      driverTbl.glPixelTexGenParameterfSGIS = missing_glPixelTexGenParameterfSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelTexGenParameterfSGIS == loader_glPixelTexGenParameterfSGIS) {
      rCtx->dsp.emuTbl.glPixelTexGenParameterfSGIS = driverTbl.glPixelTexGenParameterfSGIS;
   }
   driverTbl.glPixelTexGenParameterfSGIS(pname, param);
}

static void REGAL_CALL missing_glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glPixelTexGenParameterfvSGIS" );
}

static void REGAL_CALL loader_glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelTexGenParameterfvSGIS, "glPixelTexGenParameterfvSGIS");
   if ( !driverTbl.glPixelTexGenParameterfvSGIS ) {
      driverTbl.glPixelTexGenParameterfvSGIS = missing_glPixelTexGenParameterfvSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelTexGenParameterfvSGIS == loader_glPixelTexGenParameterfvSGIS) {
      rCtx->dsp.emuTbl.glPixelTexGenParameterfvSGIS = driverTbl.glPixelTexGenParameterfvSGIS;
   }
   driverTbl.glPixelTexGenParameterfvSGIS(pname, params);
}

static void REGAL_CALL missing_glGetPixelTexGenParameterivSGIS(GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetPixelTexGenParameterivSGIS" );
}

static void REGAL_CALL loader_glGetPixelTexGenParameterivSGIS(GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPixelTexGenParameterivSGIS, "glGetPixelTexGenParameterivSGIS");
   if ( !driverTbl.glGetPixelTexGenParameterivSGIS ) {
      driverTbl.glGetPixelTexGenParameterivSGIS = missing_glGetPixelTexGenParameterivSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPixelTexGenParameterivSGIS == loader_glGetPixelTexGenParameterivSGIS) {
      rCtx->dsp.emuTbl.glGetPixelTexGenParameterivSGIS = driverTbl.glGetPixelTexGenParameterivSGIS;
   }
   driverTbl.glGetPixelTexGenParameterivSGIS(pname, params);
}

static void REGAL_CALL missing_glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetPixelTexGenParameterfvSGIS" );
}

static void REGAL_CALL loader_glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPixelTexGenParameterfvSGIS, "glGetPixelTexGenParameterfvSGIS");
   if ( !driverTbl.glGetPixelTexGenParameterfvSGIS ) {
      driverTbl.glGetPixelTexGenParameterfvSGIS = missing_glGetPixelTexGenParameterfvSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPixelTexGenParameterfvSGIS == loader_glGetPixelTexGenParameterfvSGIS) {
      rCtx->dsp.emuTbl.glGetPixelTexGenParameterfvSGIS = driverTbl.glGetPixelTexGenParameterfvSGIS;
   }
   driverTbl.glGetPixelTexGenParameterfvSGIS(pname, params);
}

// GL_SGIS_texture4D

static void REGAL_CALL missing_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(size4d);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTexImage4DSGIS" );
}

static void REGAL_CALL loader_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexImage4DSGIS, "glTexImage4DSGIS");
   if ( !driverTbl.glTexImage4DSGIS ) {
      driverTbl.glTexImage4DSGIS = missing_glTexImage4DSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexImage4DSGIS == loader_glTexImage4DSGIS) {
      rCtx->dsp.emuTbl.glTexImage4DSGIS = driverTbl.glTexImage4DSGIS;
   }
   driverTbl.glTexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
}

static void REGAL_CALL missing_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(woffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(size4d);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTexSubImage4DSGIS" );
}

static void REGAL_CALL loader_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexSubImage4DSGIS, "glTexSubImage4DSGIS");
   if ( !driverTbl.glTexSubImage4DSGIS ) {
      driverTbl.glTexSubImage4DSGIS = missing_glTexSubImage4DSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexSubImage4DSGIS == loader_glTexSubImage4DSGIS) {
      rCtx->dsp.emuTbl.glTexSubImage4DSGIS = driverTbl.glTexSubImage4DSGIS;
   }
   driverTbl.glTexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
}

// GL_EXT_texture_object

static GLboolean REGAL_CALL missing_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   UNUSED_PARAMETER(residences);
   Warning( "Called missing function glAreTexturesResidentEXT" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glAreTexturesResidentEXT, "glAreTexturesResidentEXT");
   if ( !driverTbl.glAreTexturesResidentEXT ) {
      driverTbl.glAreTexturesResidentEXT = missing_glAreTexturesResidentEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glAreTexturesResidentEXT == loader_glAreTexturesResidentEXT) {
      rCtx->dsp.emuTbl.glAreTexturesResidentEXT = driverTbl.glAreTexturesResidentEXT;
   }
   return driverTbl.glAreTexturesResidentEXT(n, textures, residences);
}

static void REGAL_CALL missing_glBindTextureEXT(GLenum target, GLuint texture)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(texture);
   Warning( "Called missing function glBindTextureEXT" );
}

static void REGAL_CALL loader_glBindTextureEXT(GLenum target, GLuint texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindTextureEXT, "glBindTextureEXT");
   if ( !driverTbl.glBindTextureEXT ) {
      driverTbl.glBindTextureEXT = missing_glBindTextureEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindTextureEXT == loader_glBindTextureEXT) {
      rCtx->dsp.emuTbl.glBindTextureEXT = driverTbl.glBindTextureEXT;
   }
   driverTbl.glBindTextureEXT(target, texture);
}

static void REGAL_CALL missing_glDeleteTexturesEXT(GLsizei n, const GLuint *textures)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   Warning( "Called missing function glDeleteTexturesEXT" );
}

static void REGAL_CALL loader_glDeleteTexturesEXT(GLsizei n, const GLuint *textures)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteTexturesEXT, "glDeleteTexturesEXT");
   if ( !driverTbl.glDeleteTexturesEXT ) {
      driverTbl.glDeleteTexturesEXT = missing_glDeleteTexturesEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteTexturesEXT == loader_glDeleteTexturesEXT) {
      rCtx->dsp.emuTbl.glDeleteTexturesEXT = driverTbl.glDeleteTexturesEXT;
   }
   driverTbl.glDeleteTexturesEXT(n, textures);
}

static void REGAL_CALL missing_glGenTexturesEXT(GLsizei n, GLuint *textures)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   Warning( "Called missing function glGenTexturesEXT" );
}

static void REGAL_CALL loader_glGenTexturesEXT(GLsizei n, GLuint *textures)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenTexturesEXT, "glGenTexturesEXT");
   if ( !driverTbl.glGenTexturesEXT ) {
      driverTbl.glGenTexturesEXT = missing_glGenTexturesEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenTexturesEXT == loader_glGenTexturesEXT) {
      rCtx->dsp.emuTbl.glGenTexturesEXT = driverTbl.glGenTexturesEXT;
   }
   driverTbl.glGenTexturesEXT(n, textures);
}

static GLboolean REGAL_CALL missing_glIsTextureEXT(GLuint texture)
{
   UNUSED_PARAMETER(texture);
   Warning( "Called missing function glIsTextureEXT" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsTextureEXT(GLuint texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsTextureEXT, "glIsTextureEXT");
   if ( !driverTbl.glIsTextureEXT ) {
      driverTbl.glIsTextureEXT = missing_glIsTextureEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsTextureEXT == loader_glIsTextureEXT) {
      rCtx->dsp.emuTbl.glIsTextureEXT = driverTbl.glIsTextureEXT;
   }
   return driverTbl.glIsTextureEXT(texture);
}

static void REGAL_CALL missing_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   UNUSED_PARAMETER(priorities);
   Warning( "Called missing function glPrioritizeTexturesEXT" );
}

static void REGAL_CALL loader_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPrioritizeTexturesEXT, "glPrioritizeTexturesEXT");
   if ( !driverTbl.glPrioritizeTexturesEXT ) {
      driverTbl.glPrioritizeTexturesEXT = missing_glPrioritizeTexturesEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPrioritizeTexturesEXT == loader_glPrioritizeTexturesEXT) {
      rCtx->dsp.emuTbl.glPrioritizeTexturesEXT = driverTbl.glPrioritizeTexturesEXT;
   }
   driverTbl.glPrioritizeTexturesEXT(n, textures, priorities);
}

// GL_SGIS_detail_texture

static void REGAL_CALL missing_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glDetailTexFuncSGIS" );
}

static void REGAL_CALL loader_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDetailTexFuncSGIS, "glDetailTexFuncSGIS");
   if ( !driverTbl.glDetailTexFuncSGIS ) {
      driverTbl.glDetailTexFuncSGIS = missing_glDetailTexFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDetailTexFuncSGIS == loader_glDetailTexFuncSGIS) {
      rCtx->dsp.emuTbl.glDetailTexFuncSGIS = driverTbl.glDetailTexFuncSGIS;
   }
   driverTbl.glDetailTexFuncSGIS(target, n, points);
}

static void REGAL_CALL missing_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glGetDetailTexFuncSGIS" );
}

static void REGAL_CALL loader_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetDetailTexFuncSGIS, "glGetDetailTexFuncSGIS");
   if ( !driverTbl.glGetDetailTexFuncSGIS ) {
      driverTbl.glGetDetailTexFuncSGIS = missing_glGetDetailTexFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetDetailTexFuncSGIS == loader_glGetDetailTexFuncSGIS) {
      rCtx->dsp.emuTbl.glGetDetailTexFuncSGIS = driverTbl.glGetDetailTexFuncSGIS;
   }
   driverTbl.glGetDetailTexFuncSGIS(target, points);
}

// GL_SGIS_sharpen_texture

static void REGAL_CALL missing_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glSharpenTexFuncSGIS" );
}

static void REGAL_CALL loader_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSharpenTexFuncSGIS, "glSharpenTexFuncSGIS");
   if ( !driverTbl.glSharpenTexFuncSGIS ) {
      driverTbl.glSharpenTexFuncSGIS = missing_glSharpenTexFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSharpenTexFuncSGIS == loader_glSharpenTexFuncSGIS) {
      rCtx->dsp.emuTbl.glSharpenTexFuncSGIS = driverTbl.glSharpenTexFuncSGIS;
   }
   driverTbl.glSharpenTexFuncSGIS(target, n, points);
}

static void REGAL_CALL missing_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glGetSharpenTexFuncSGIS" );
}

static void REGAL_CALL loader_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetSharpenTexFuncSGIS, "glGetSharpenTexFuncSGIS");
   if ( !driverTbl.glGetSharpenTexFuncSGIS ) {
      driverTbl.glGetSharpenTexFuncSGIS = missing_glGetSharpenTexFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetSharpenTexFuncSGIS == loader_glGetSharpenTexFuncSGIS) {
      rCtx->dsp.emuTbl.glGetSharpenTexFuncSGIS = driverTbl.glGetSharpenTexFuncSGIS;
   }
   driverTbl.glGetSharpenTexFuncSGIS(target, points);
}

// GL_SGIS_multisample

static void REGAL_CALL missing_glSampleMaskSGIS(GLclampf value, GLboolean invert)
{
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(invert);
   Warning( "Called missing function glSampleMaskSGIS" );
}

static void REGAL_CALL loader_glSampleMaskSGIS(GLclampf value, GLboolean invert)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSampleMaskSGIS, "glSampleMaskSGIS");
   if ( !driverTbl.glSampleMaskSGIS ) {
      driverTbl.glSampleMaskSGIS = missing_glSampleMaskSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSampleMaskSGIS == loader_glSampleMaskSGIS) {
      rCtx->dsp.emuTbl.glSampleMaskSGIS = driverTbl.glSampleMaskSGIS;
   }
   driverTbl.glSampleMaskSGIS(value, invert);
}

static void REGAL_CALL missing_glSamplePatternSGIS(GLenum pattern)
{
   UNUSED_PARAMETER(pattern);
   Warning( "Called missing function glSamplePatternSGIS" );
}

static void REGAL_CALL loader_glSamplePatternSGIS(GLenum pattern)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSamplePatternSGIS, "glSamplePatternSGIS");
   if ( !driverTbl.glSamplePatternSGIS ) {
      driverTbl.glSamplePatternSGIS = missing_glSamplePatternSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSamplePatternSGIS == loader_glSamplePatternSGIS) {
      rCtx->dsp.emuTbl.glSamplePatternSGIS = driverTbl.glSamplePatternSGIS;
   }
   driverTbl.glSamplePatternSGIS(pattern);
}

// GL_EXT_vertex_array

static void REGAL_CALL missing_glArrayElementEXT(GLint i)
{
   UNUSED_PARAMETER(i);
   Warning( "Called missing function glArrayElementEXT" );
}

static void REGAL_CALL loader_glArrayElementEXT(GLint i)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glArrayElementEXT, "glArrayElementEXT");
   if ( !driverTbl.glArrayElementEXT ) {
      driverTbl.glArrayElementEXT = missing_glArrayElementEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glArrayElementEXT == loader_glArrayElementEXT) {
      rCtx->dsp.emuTbl.glArrayElementEXT = driverTbl.glArrayElementEXT;
   }
   driverTbl.glArrayElementEXT(i);
}

static void REGAL_CALL missing_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glColorPointerEXT" );
}

static void REGAL_CALL loader_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorPointerEXT, "glColorPointerEXT");
   if ( !driverTbl.glColorPointerEXT ) {
      driverTbl.glColorPointerEXT = missing_glColorPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorPointerEXT == loader_glColorPointerEXT) {
      rCtx->dsp.emuTbl.glColorPointerEXT = driverTbl.glColorPointerEXT;
   }
   driverTbl.glColorPointerEXT(size, type, stride, count, pointer);
}

static void REGAL_CALL missing_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   Warning( "Called missing function glDrawArraysEXT" );
}

static void REGAL_CALL loader_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawArraysEXT, "glDrawArraysEXT");
   if ( !driverTbl.glDrawArraysEXT ) {
      driverTbl.glDrawArraysEXT = missing_glDrawArraysEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawArraysEXT == loader_glDrawArraysEXT) {
      rCtx->dsp.emuTbl.glDrawArraysEXT = driverTbl.glDrawArraysEXT;
   }
   driverTbl.glDrawArraysEXT(mode, first, count);
}

static void REGAL_CALL missing_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer)
{
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glEdgeFlagPointerEXT" );
}

static void REGAL_CALL loader_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEdgeFlagPointerEXT, "glEdgeFlagPointerEXT");
   if ( !driverTbl.glEdgeFlagPointerEXT ) {
      driverTbl.glEdgeFlagPointerEXT = missing_glEdgeFlagPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEdgeFlagPointerEXT == loader_glEdgeFlagPointerEXT) {
      rCtx->dsp.emuTbl.glEdgeFlagPointerEXT = driverTbl.glEdgeFlagPointerEXT;
   }
   driverTbl.glEdgeFlagPointerEXT(stride, count, pointer);
}

static void REGAL_CALL missing_glGetPointervEXT(GLenum pname, GLvoid **params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetPointervEXT" );
}

static void REGAL_CALL loader_glGetPointervEXT(GLenum pname, GLvoid **params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPointervEXT, "glGetPointervEXT");
   if ( !driverTbl.glGetPointervEXT ) {
      driverTbl.glGetPointervEXT = missing_glGetPointervEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPointervEXT == loader_glGetPointervEXT) {
      rCtx->dsp.emuTbl.glGetPointervEXT = driverTbl.glGetPointervEXT;
   }
   driverTbl.glGetPointervEXT(pname, params);
}

static void REGAL_CALL missing_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glIndexPointerEXT" );
}

static void REGAL_CALL loader_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexPointerEXT, "glIndexPointerEXT");
   if ( !driverTbl.glIndexPointerEXT ) {
      driverTbl.glIndexPointerEXT = missing_glIndexPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexPointerEXT == loader_glIndexPointerEXT) {
      rCtx->dsp.emuTbl.glIndexPointerEXT = driverTbl.glIndexPointerEXT;
   }
   driverTbl.glIndexPointerEXT(type, stride, count, pointer);
}

static void REGAL_CALL missing_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glNormalPointerEXT" );
}

static void REGAL_CALL loader_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalPointerEXT, "glNormalPointerEXT");
   if ( !driverTbl.glNormalPointerEXT ) {
      driverTbl.glNormalPointerEXT = missing_glNormalPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalPointerEXT == loader_glNormalPointerEXT) {
      rCtx->dsp.emuTbl.glNormalPointerEXT = driverTbl.glNormalPointerEXT;
   }
   driverTbl.glNormalPointerEXT(type, stride, count, pointer);
}

static void REGAL_CALL missing_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glTexCoordPointerEXT" );
}

static void REGAL_CALL loader_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoordPointerEXT, "glTexCoordPointerEXT");
   if ( !driverTbl.glTexCoordPointerEXT ) {
      driverTbl.glTexCoordPointerEXT = missing_glTexCoordPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoordPointerEXT == loader_glTexCoordPointerEXT) {
      rCtx->dsp.emuTbl.glTexCoordPointerEXT = driverTbl.glTexCoordPointerEXT;
   }
   driverTbl.glTexCoordPointerEXT(size, type, stride, count, pointer);
}

static void REGAL_CALL missing_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glVertexPointerEXT" );
}

static void REGAL_CALL loader_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexPointerEXT, "glVertexPointerEXT");
   if ( !driverTbl.glVertexPointerEXT ) {
      driverTbl.glVertexPointerEXT = missing_glVertexPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexPointerEXT == loader_glVertexPointerEXT) {
      rCtx->dsp.emuTbl.glVertexPointerEXT = driverTbl.glVertexPointerEXT;
   }
   driverTbl.glVertexPointerEXT(size, type, stride, count, pointer);
}

// GL_EXT_blend_minmax

static void REGAL_CALL missing_glBlendEquationEXT(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glBlendEquationEXT" );
}

static void REGAL_CALL loader_glBlendEquationEXT(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendEquationEXT, "glBlendEquationEXT");
   if ( !driverTbl.glBlendEquationEXT ) {
      driverTbl.glBlendEquationEXT = missing_glBlendEquationEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendEquationEXT == loader_glBlendEquationEXT) {
      rCtx->dsp.emuTbl.glBlendEquationEXT = driverTbl.glBlendEquationEXT;
   }
   driverTbl.glBlendEquationEXT(mode);
}

// GL_SGIX_sprite

static void REGAL_CALL missing_glSpriteParameterfSGIX(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glSpriteParameterfSGIX" );
}

static void REGAL_CALL loader_glSpriteParameterfSGIX(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSpriteParameterfSGIX, "glSpriteParameterfSGIX");
   if ( !driverTbl.glSpriteParameterfSGIX ) {
      driverTbl.glSpriteParameterfSGIX = missing_glSpriteParameterfSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSpriteParameterfSGIX == loader_glSpriteParameterfSGIX) {
      rCtx->dsp.emuTbl.glSpriteParameterfSGIX = driverTbl.glSpriteParameterfSGIX;
   }
   driverTbl.glSpriteParameterfSGIX(pname, param);
}

static void REGAL_CALL missing_glSpriteParameterfvSGIX(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glSpriteParameterfvSGIX" );
}

static void REGAL_CALL loader_glSpriteParameterfvSGIX(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSpriteParameterfvSGIX, "glSpriteParameterfvSGIX");
   if ( !driverTbl.glSpriteParameterfvSGIX ) {
      driverTbl.glSpriteParameterfvSGIX = missing_glSpriteParameterfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSpriteParameterfvSGIX == loader_glSpriteParameterfvSGIX) {
      rCtx->dsp.emuTbl.glSpriteParameterfvSGIX = driverTbl.glSpriteParameterfvSGIX;
   }
   driverTbl.glSpriteParameterfvSGIX(pname, params);
}

static void REGAL_CALL missing_glSpriteParameteriSGIX(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glSpriteParameteriSGIX" );
}

static void REGAL_CALL loader_glSpriteParameteriSGIX(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSpriteParameteriSGIX, "glSpriteParameteriSGIX");
   if ( !driverTbl.glSpriteParameteriSGIX ) {
      driverTbl.glSpriteParameteriSGIX = missing_glSpriteParameteriSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSpriteParameteriSGIX == loader_glSpriteParameteriSGIX) {
      rCtx->dsp.emuTbl.glSpriteParameteriSGIX = driverTbl.glSpriteParameteriSGIX;
   }
   driverTbl.glSpriteParameteriSGIX(pname, param);
}

static void REGAL_CALL missing_glSpriteParameterivSGIX(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glSpriteParameterivSGIX" );
}

static void REGAL_CALL loader_glSpriteParameterivSGIX(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSpriteParameterivSGIX, "glSpriteParameterivSGIX");
   if ( !driverTbl.glSpriteParameterivSGIX ) {
      driverTbl.glSpriteParameterivSGIX = missing_glSpriteParameterivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSpriteParameterivSGIX == loader_glSpriteParameterivSGIX) {
      rCtx->dsp.emuTbl.glSpriteParameterivSGIX = driverTbl.glSpriteParameterivSGIX;
   }
   driverTbl.glSpriteParameterivSGIX(pname, params);
}

// GL_EXT_point_parameters

static void REGAL_CALL missing_glPointParameterfEXT(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPointParameterfEXT" );
}

static void REGAL_CALL loader_glPointParameterfEXT(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPointParameterfEXT, "glPointParameterfEXT");
   if ( !driverTbl.glPointParameterfEXT ) {
      driverTbl.glPointParameterfEXT = missing_glPointParameterfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPointParameterfEXT == loader_glPointParameterfEXT) {
      rCtx->dsp.emuTbl.glPointParameterfEXT = driverTbl.glPointParameterfEXT;
   }
   driverTbl.glPointParameterfEXT(pname, param);
}

static void REGAL_CALL missing_glPointParameterfvEXT(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glPointParameterfvEXT" );
}

static void REGAL_CALL loader_glPointParameterfvEXT(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPointParameterfvEXT, "glPointParameterfvEXT");
   if ( !driverTbl.glPointParameterfvEXT ) {
      driverTbl.glPointParameterfvEXT = missing_glPointParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPointParameterfvEXT == loader_glPointParameterfvEXT) {
      rCtx->dsp.emuTbl.glPointParameterfvEXT = driverTbl.glPointParameterfvEXT;
   }
   driverTbl.glPointParameterfvEXT(pname, params);
}

// GL_SGIS_point_parameters

static void REGAL_CALL missing_glPointParameterfSGIS(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPointParameterfSGIS" );
}

static void REGAL_CALL loader_glPointParameterfSGIS(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPointParameterfSGIS, "glPointParameterfSGIS");
   if ( !driverTbl.glPointParameterfSGIS ) {
      driverTbl.glPointParameterfSGIS = missing_glPointParameterfSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPointParameterfSGIS == loader_glPointParameterfSGIS) {
      rCtx->dsp.emuTbl.glPointParameterfSGIS = driverTbl.glPointParameterfSGIS;
   }
   driverTbl.glPointParameterfSGIS(pname, param);
}

static void REGAL_CALL missing_glPointParameterfvSGIS(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glPointParameterfvSGIS" );
}

static void REGAL_CALL loader_glPointParameterfvSGIS(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPointParameterfvSGIS, "glPointParameterfvSGIS");
   if ( !driverTbl.glPointParameterfvSGIS ) {
      driverTbl.glPointParameterfvSGIS = missing_glPointParameterfvSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPointParameterfvSGIS == loader_glPointParameterfvSGIS) {
      rCtx->dsp.emuTbl.glPointParameterfvSGIS = driverTbl.glPointParameterfvSGIS;
   }
   driverTbl.glPointParameterfvSGIS(pname, params);
}

// GL_SGIX_instruments

static GLint REGAL_CALL missing_glGetInstrumentsSGIX(void)
{
   Warning( "Called missing function glGetInstrumentsSGIX" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetInstrumentsSGIX(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetInstrumentsSGIX, "glGetInstrumentsSGIX");
   if ( !driverTbl.glGetInstrumentsSGIX ) {
      driverTbl.glGetInstrumentsSGIX = missing_glGetInstrumentsSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetInstrumentsSGIX == loader_glGetInstrumentsSGIX) {
      rCtx->dsp.emuTbl.glGetInstrumentsSGIX = driverTbl.glGetInstrumentsSGIX;
   }
   return driverTbl.glGetInstrumentsSGIX();
}

static void REGAL_CALL missing_glInstrumentsBufferSGIX(GLsizei size, GLint *buffer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glInstrumentsBufferSGIX" );
}

static void REGAL_CALL loader_glInstrumentsBufferSGIX(GLsizei size, GLint *buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glInstrumentsBufferSGIX, "glInstrumentsBufferSGIX");
   if ( !driverTbl.glInstrumentsBufferSGIX ) {
      driverTbl.glInstrumentsBufferSGIX = missing_glInstrumentsBufferSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glInstrumentsBufferSGIX == loader_glInstrumentsBufferSGIX) {
      rCtx->dsp.emuTbl.glInstrumentsBufferSGIX = driverTbl.glInstrumentsBufferSGIX;
   }
   driverTbl.glInstrumentsBufferSGIX(size, buffer);
}

static GLint REGAL_CALL missing_glPollInstrumentsSGIX(GLint *marker_p)
{
   UNUSED_PARAMETER(marker_p);
   Warning( "Called missing function glPollInstrumentsSGIX" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glPollInstrumentsSGIX(GLint *marker_p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPollInstrumentsSGIX, "glPollInstrumentsSGIX");
   if ( !driverTbl.glPollInstrumentsSGIX ) {
      driverTbl.glPollInstrumentsSGIX = missing_glPollInstrumentsSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPollInstrumentsSGIX == loader_glPollInstrumentsSGIX) {
      rCtx->dsp.emuTbl.glPollInstrumentsSGIX = driverTbl.glPollInstrumentsSGIX;
   }
   return driverTbl.glPollInstrumentsSGIX(marker_p);
}

static void REGAL_CALL missing_glReadInstrumentsSGIX(GLint marker)
{
   UNUSED_PARAMETER(marker);
   Warning( "Called missing function glReadInstrumentsSGIX" );
}

static void REGAL_CALL loader_glReadInstrumentsSGIX(GLint marker)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReadInstrumentsSGIX, "glReadInstrumentsSGIX");
   if ( !driverTbl.glReadInstrumentsSGIX ) {
      driverTbl.glReadInstrumentsSGIX = missing_glReadInstrumentsSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReadInstrumentsSGIX == loader_glReadInstrumentsSGIX) {
      rCtx->dsp.emuTbl.glReadInstrumentsSGIX = driverTbl.glReadInstrumentsSGIX;
   }
   driverTbl.glReadInstrumentsSGIX(marker);
}

static void REGAL_CALL missing_glStartInstrumentsSGIX(void)
{
   Warning( "Called missing function glStartInstrumentsSGIX" );
}

static void REGAL_CALL loader_glStartInstrumentsSGIX(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStartInstrumentsSGIX, "glStartInstrumentsSGIX");
   if ( !driverTbl.glStartInstrumentsSGIX ) {
      driverTbl.glStartInstrumentsSGIX = missing_glStartInstrumentsSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStartInstrumentsSGIX == loader_glStartInstrumentsSGIX) {
      rCtx->dsp.emuTbl.glStartInstrumentsSGIX = driverTbl.glStartInstrumentsSGIX;
   }
   driverTbl.glStartInstrumentsSGIX();
}

static void REGAL_CALL missing_glStopInstrumentsSGIX(GLint marker)
{
   UNUSED_PARAMETER(marker);
   Warning( "Called missing function glStopInstrumentsSGIX" );
}

static void REGAL_CALL loader_glStopInstrumentsSGIX(GLint marker)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStopInstrumentsSGIX, "glStopInstrumentsSGIX");
   if ( !driverTbl.glStopInstrumentsSGIX ) {
      driverTbl.glStopInstrumentsSGIX = missing_glStopInstrumentsSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStopInstrumentsSGIX == loader_glStopInstrumentsSGIX) {
      rCtx->dsp.emuTbl.glStopInstrumentsSGIX = driverTbl.glStopInstrumentsSGIX;
   }
   driverTbl.glStopInstrumentsSGIX(marker);
}

// GL_SGIX_framezoom

static void REGAL_CALL missing_glFrameZoomSGIX(GLint factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "Called missing function glFrameZoomSGIX" );
}

static void REGAL_CALL loader_glFrameZoomSGIX(GLint factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFrameZoomSGIX, "glFrameZoomSGIX");
   if ( !driverTbl.glFrameZoomSGIX ) {
      driverTbl.glFrameZoomSGIX = missing_glFrameZoomSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFrameZoomSGIX == loader_glFrameZoomSGIX) {
      rCtx->dsp.emuTbl.glFrameZoomSGIX = driverTbl.glFrameZoomSGIX;
   }
   driverTbl.glFrameZoomSGIX(factor);
}

// GL_SGIX_tag_sample_buffer

static void REGAL_CALL missing_glTagSampleBufferSGIX(void)
{
   Warning( "Called missing function glTagSampleBufferSGIX" );
}

static void REGAL_CALL loader_glTagSampleBufferSGIX(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTagSampleBufferSGIX, "glTagSampleBufferSGIX");
   if ( !driverTbl.glTagSampleBufferSGIX ) {
      driverTbl.glTagSampleBufferSGIX = missing_glTagSampleBufferSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTagSampleBufferSGIX == loader_glTagSampleBufferSGIX) {
      rCtx->dsp.emuTbl.glTagSampleBufferSGIX = driverTbl.glTagSampleBufferSGIX;
   }
   driverTbl.glTagSampleBufferSGIX();
}

// GL_SGIX_polynomial_ffd

static void REGAL_CALL missing_glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(uorder);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(vorder);
   UNUSED_PARAMETER(w1);
   UNUSED_PARAMETER(w2);
   UNUSED_PARAMETER(wstride);
   UNUSED_PARAMETER(worder);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glDeformationMap3dSGIX" );
}

static void REGAL_CALL loader_glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeformationMap3dSGIX, "glDeformationMap3dSGIX");
   if ( !driverTbl.glDeformationMap3dSGIX ) {
      driverTbl.glDeformationMap3dSGIX = missing_glDeformationMap3dSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeformationMap3dSGIX == loader_glDeformationMap3dSGIX) {
      rCtx->dsp.emuTbl.glDeformationMap3dSGIX = driverTbl.glDeformationMap3dSGIX;
   }
   driverTbl.glDeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
}

static void REGAL_CALL missing_glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(uorder);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(vorder);
   UNUSED_PARAMETER(w1);
   UNUSED_PARAMETER(w2);
   UNUSED_PARAMETER(wstride);
   UNUSED_PARAMETER(worder);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glDeformationMap3fSGIX" );
}

static void REGAL_CALL loader_glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeformationMap3fSGIX, "glDeformationMap3fSGIX");
   if ( !driverTbl.glDeformationMap3fSGIX ) {
      driverTbl.glDeformationMap3fSGIX = missing_glDeformationMap3fSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeformationMap3fSGIX == loader_glDeformationMap3fSGIX) {
      rCtx->dsp.emuTbl.glDeformationMap3fSGIX = driverTbl.glDeformationMap3fSGIX;
   }
   driverTbl.glDeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
}

static void REGAL_CALL missing_glDeformSGIX(GLbitfield mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glDeformSGIX" );
}

static void REGAL_CALL loader_glDeformSGIX(GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeformSGIX, "glDeformSGIX");
   if ( !driverTbl.glDeformSGIX ) {
      driverTbl.glDeformSGIX = missing_glDeformSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeformSGIX == loader_glDeformSGIX) {
      rCtx->dsp.emuTbl.glDeformSGIX = driverTbl.glDeformSGIX;
   }
   driverTbl.glDeformSGIX(mask);
}

static void REGAL_CALL missing_glLoadIdentityDeformationMapSGIX(GLbitfield mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glLoadIdentityDeformationMapSGIX" );
}

static void REGAL_CALL loader_glLoadIdentityDeformationMapSGIX(GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLoadIdentityDeformationMapSGIX, "glLoadIdentityDeformationMapSGIX");
   if ( !driverTbl.glLoadIdentityDeformationMapSGIX ) {
      driverTbl.glLoadIdentityDeformationMapSGIX = missing_glLoadIdentityDeformationMapSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLoadIdentityDeformationMapSGIX == loader_glLoadIdentityDeformationMapSGIX) {
      rCtx->dsp.emuTbl.glLoadIdentityDeformationMapSGIX = driverTbl.glLoadIdentityDeformationMapSGIX;
   }
   driverTbl.glLoadIdentityDeformationMapSGIX(mask);
}

// GL_SGIX_reference_plane

static void REGAL_CALL missing_glReferencePlaneSGIX(const GLdouble *equation)
{
   UNUSED_PARAMETER(equation);
   Warning( "Called missing function glReferencePlaneSGIX" );
}

static void REGAL_CALL loader_glReferencePlaneSGIX(const GLdouble *equation)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReferencePlaneSGIX, "glReferencePlaneSGIX");
   if ( !driverTbl.glReferencePlaneSGIX ) {
      driverTbl.glReferencePlaneSGIX = missing_glReferencePlaneSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReferencePlaneSGIX == loader_glReferencePlaneSGIX) {
      rCtx->dsp.emuTbl.glReferencePlaneSGIX = driverTbl.glReferencePlaneSGIX;
   }
   driverTbl.glReferencePlaneSGIX(equation);
}

// GL_SGIX_flush_raster

static void REGAL_CALL missing_glFlushRasterSGIX(void)
{
   Warning( "Called missing function glFlushRasterSGIX" );
}

static void REGAL_CALL loader_glFlushRasterSGIX(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFlushRasterSGIX, "glFlushRasterSGIX");
   if ( !driverTbl.glFlushRasterSGIX ) {
      driverTbl.glFlushRasterSGIX = missing_glFlushRasterSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFlushRasterSGIX == loader_glFlushRasterSGIX) {
      rCtx->dsp.emuTbl.glFlushRasterSGIX = driverTbl.glFlushRasterSGIX;
   }
   driverTbl.glFlushRasterSGIX();
}

// GL_SGIS_fog_function

static void REGAL_CALL missing_glFogFuncSGIS(GLsizei n, const GLfloat *points)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glFogFuncSGIS" );
}

static void REGAL_CALL loader_glFogFuncSGIS(GLsizei n, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogFuncSGIS, "glFogFuncSGIS");
   if ( !driverTbl.glFogFuncSGIS ) {
      driverTbl.glFogFuncSGIS = missing_glFogFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogFuncSGIS == loader_glFogFuncSGIS) {
      rCtx->dsp.emuTbl.glFogFuncSGIS = driverTbl.glFogFuncSGIS;
   }
   driverTbl.glFogFuncSGIS(n, points);
}

static void REGAL_CALL missing_glGetFogFuncSGIS(GLfloat *points)
{
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glGetFogFuncSGIS" );
}

static void REGAL_CALL loader_glGetFogFuncSGIS(GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFogFuncSGIS, "glGetFogFuncSGIS");
   if ( !driverTbl.glGetFogFuncSGIS ) {
      driverTbl.glGetFogFuncSGIS = missing_glGetFogFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFogFuncSGIS == loader_glGetFogFuncSGIS) {
      rCtx->dsp.emuTbl.glGetFogFuncSGIS = driverTbl.glGetFogFuncSGIS;
   }
   driverTbl.glGetFogFuncSGIS(points);
}

// GL_HP_image_transform

static void REGAL_CALL missing_glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glImageTransformParameteriHP" );
}

static void REGAL_CALL loader_glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glImageTransformParameteriHP, "glImageTransformParameteriHP");
   if ( !driverTbl.glImageTransformParameteriHP ) {
      driverTbl.glImageTransformParameteriHP = missing_glImageTransformParameteriHP;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glImageTransformParameteriHP == loader_glImageTransformParameteriHP) {
      rCtx->dsp.emuTbl.glImageTransformParameteriHP = driverTbl.glImageTransformParameteriHP;
   }
   driverTbl.glImageTransformParameteriHP(target, pname, param);
}

static void REGAL_CALL missing_glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glImageTransformParameterfHP" );
}

static void REGAL_CALL loader_glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glImageTransformParameterfHP, "glImageTransformParameterfHP");
   if ( !driverTbl.glImageTransformParameterfHP ) {
      driverTbl.glImageTransformParameterfHP = missing_glImageTransformParameterfHP;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glImageTransformParameterfHP == loader_glImageTransformParameterfHP) {
      rCtx->dsp.emuTbl.glImageTransformParameterfHP = driverTbl.glImageTransformParameterfHP;
   }
   driverTbl.glImageTransformParameterfHP(target, pname, param);
}

static void REGAL_CALL missing_glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glImageTransformParameterivHP" );
}

static void REGAL_CALL loader_glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glImageTransformParameterivHP, "glImageTransformParameterivHP");
   if ( !driverTbl.glImageTransformParameterivHP ) {
      driverTbl.glImageTransformParameterivHP = missing_glImageTransformParameterivHP;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glImageTransformParameterivHP == loader_glImageTransformParameterivHP) {
      rCtx->dsp.emuTbl.glImageTransformParameterivHP = driverTbl.glImageTransformParameterivHP;
   }
   driverTbl.glImageTransformParameterivHP(target, pname, params);
}

static void REGAL_CALL missing_glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glImageTransformParameterfvHP" );
}

static void REGAL_CALL loader_glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glImageTransformParameterfvHP, "glImageTransformParameterfvHP");
   if ( !driverTbl.glImageTransformParameterfvHP ) {
      driverTbl.glImageTransformParameterfvHP = missing_glImageTransformParameterfvHP;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glImageTransformParameterfvHP == loader_glImageTransformParameterfvHP) {
      rCtx->dsp.emuTbl.glImageTransformParameterfvHP = driverTbl.glImageTransformParameterfvHP;
   }
   driverTbl.glImageTransformParameterfvHP(target, pname, params);
}

static void REGAL_CALL missing_glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetImageTransformParameterivHP" );
}

static void REGAL_CALL loader_glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetImageTransformParameterivHP, "glGetImageTransformParameterivHP");
   if ( !driverTbl.glGetImageTransformParameterivHP ) {
      driverTbl.glGetImageTransformParameterivHP = missing_glGetImageTransformParameterivHP;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetImageTransformParameterivHP == loader_glGetImageTransformParameterivHP) {
      rCtx->dsp.emuTbl.glGetImageTransformParameterivHP = driverTbl.glGetImageTransformParameterivHP;
   }
   driverTbl.glGetImageTransformParameterivHP(target, pname, params);
}

static void REGAL_CALL missing_glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetImageTransformParameterfvHP" );
}

static void REGAL_CALL loader_glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetImageTransformParameterfvHP, "glGetImageTransformParameterfvHP");
   if ( !driverTbl.glGetImageTransformParameterfvHP ) {
      driverTbl.glGetImageTransformParameterfvHP = missing_glGetImageTransformParameterfvHP;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetImageTransformParameterfvHP == loader_glGetImageTransformParameterfvHP) {
      rCtx->dsp.emuTbl.glGetImageTransformParameterfvHP = driverTbl.glGetImageTransformParameterfvHP;
   }
   driverTbl.glGetImageTransformParameterfvHP(target, pname, params);
}

// GL_EXT_color_subtable

static void REGAL_CALL missing_glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *table)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(table);
   Warning( "Called missing function glColorSubTableEXT" );
}

static void REGAL_CALL loader_glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *table)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorSubTableEXT, "glColorSubTableEXT");
   if ( !driverTbl.glColorSubTableEXT ) {
      driverTbl.glColorSubTableEXT = missing_glColorSubTableEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorSubTableEXT == loader_glColorSubTableEXT) {
      rCtx->dsp.emuTbl.glColorSubTableEXT = driverTbl.glColorSubTableEXT;
   }
   driverTbl.glColorSubTableEXT(target, start, count, format, type, table);
}

static void REGAL_CALL missing_glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "Called missing function glCopyColorSubTableEXT" );
}

static void REGAL_CALL loader_glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyColorSubTableEXT, "glCopyColorSubTableEXT");
   if ( !driverTbl.glCopyColorSubTableEXT ) {
      driverTbl.glCopyColorSubTableEXT = missing_glCopyColorSubTableEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyColorSubTableEXT == loader_glCopyColorSubTableEXT) {
      rCtx->dsp.emuTbl.glCopyColorSubTableEXT = driverTbl.glCopyColorSubTableEXT;
   }
   driverTbl.glCopyColorSubTableEXT(target, start, x, y, width);
}

// GL_PGI_misc_hints

static void REGAL_CALL missing_glHintPGI(GLenum target, GLint mode)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glHintPGI" );
}

static void REGAL_CALL loader_glHintPGI(GLenum target, GLint mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glHintPGI, "glHintPGI");
   if ( !driverTbl.glHintPGI ) {
      driverTbl.glHintPGI = missing_glHintPGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glHintPGI == loader_glHintPGI) {
      rCtx->dsp.emuTbl.glHintPGI = driverTbl.glHintPGI;
   }
   driverTbl.glHintPGI(target, mode);
}

// GL_EXT_paletted_texture

static void REGAL_CALL missing_glColorTableEXT(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalFormat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(table);
   Warning( "Called missing function glColorTableEXT" );
}

static void REGAL_CALL loader_glColorTableEXT(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorTableEXT, "glColorTableEXT");
   if ( !driverTbl.glColorTableEXT ) {
      driverTbl.glColorTableEXT = missing_glColorTableEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorTableEXT == loader_glColorTableEXT) {
      rCtx->dsp.emuTbl.glColorTableEXT = driverTbl.glColorTableEXT;
   }
   driverTbl.glColorTableEXT(target, internalFormat, width, format, type, table);
}

static void REGAL_CALL missing_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetColorTableEXT" );
}

static void REGAL_CALL loader_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetColorTableEXT, "glGetColorTableEXT");
   if ( !driverTbl.glGetColorTableEXT ) {
      driverTbl.glGetColorTableEXT = missing_glGetColorTableEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetColorTableEXT == loader_glGetColorTableEXT) {
      rCtx->dsp.emuTbl.glGetColorTableEXT = driverTbl.glGetColorTableEXT;
   }
   driverTbl.glGetColorTableEXT(target, format, type, data);
}

static void REGAL_CALL missing_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetColorTableParameterivEXT" );
}

static void REGAL_CALL loader_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetColorTableParameterivEXT, "glGetColorTableParameterivEXT");
   if ( !driverTbl.glGetColorTableParameterivEXT ) {
      driverTbl.glGetColorTableParameterivEXT = missing_glGetColorTableParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetColorTableParameterivEXT == loader_glGetColorTableParameterivEXT) {
      rCtx->dsp.emuTbl.glGetColorTableParameterivEXT = driverTbl.glGetColorTableParameterivEXT;
   }
   driverTbl.glGetColorTableParameterivEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetColorTableParameterfvEXT" );
}

static void REGAL_CALL loader_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetColorTableParameterfvEXT, "glGetColorTableParameterfvEXT");
   if ( !driverTbl.glGetColorTableParameterfvEXT ) {
      driverTbl.glGetColorTableParameterfvEXT = missing_glGetColorTableParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetColorTableParameterfvEXT == loader_glGetColorTableParameterfvEXT) {
      rCtx->dsp.emuTbl.glGetColorTableParameterfvEXT = driverTbl.glGetColorTableParameterfvEXT;
   }
   driverTbl.glGetColorTableParameterfvEXT(target, pname, params);
}

// GL_SGIX_list_priority

static void REGAL_CALL missing_glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetListParameterfvSGIX" );
}

static void REGAL_CALL loader_glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetListParameterfvSGIX, "glGetListParameterfvSGIX");
   if ( !driverTbl.glGetListParameterfvSGIX ) {
      driverTbl.glGetListParameterfvSGIX = missing_glGetListParameterfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetListParameterfvSGIX == loader_glGetListParameterfvSGIX) {
      rCtx->dsp.emuTbl.glGetListParameterfvSGIX = driverTbl.glGetListParameterfvSGIX;
   }
   driverTbl.glGetListParameterfvSGIX(list, pname, params);
}

static void REGAL_CALL missing_glGetListParameterivSGIX(GLuint list, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetListParameterivSGIX" );
}

static void REGAL_CALL loader_glGetListParameterivSGIX(GLuint list, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetListParameterivSGIX, "glGetListParameterivSGIX");
   if ( !driverTbl.glGetListParameterivSGIX ) {
      driverTbl.glGetListParameterivSGIX = missing_glGetListParameterivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetListParameterivSGIX == loader_glGetListParameterivSGIX) {
      rCtx->dsp.emuTbl.glGetListParameterivSGIX = driverTbl.glGetListParameterivSGIX;
   }
   driverTbl.glGetListParameterivSGIX(list, pname, params);
}

static void REGAL_CALL missing_glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glListParameterfSGIX" );
}

static void REGAL_CALL loader_glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glListParameterfSGIX, "glListParameterfSGIX");
   if ( !driverTbl.glListParameterfSGIX ) {
      driverTbl.glListParameterfSGIX = missing_glListParameterfSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glListParameterfSGIX == loader_glListParameterfSGIX) {
      rCtx->dsp.emuTbl.glListParameterfSGIX = driverTbl.glListParameterfSGIX;
   }
   driverTbl.glListParameterfSGIX(list, pname, param);
}

static void REGAL_CALL missing_glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glListParameterfvSGIX" );
}

static void REGAL_CALL loader_glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glListParameterfvSGIX, "glListParameterfvSGIX");
   if ( !driverTbl.glListParameterfvSGIX ) {
      driverTbl.glListParameterfvSGIX = missing_glListParameterfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glListParameterfvSGIX == loader_glListParameterfvSGIX) {
      rCtx->dsp.emuTbl.glListParameterfvSGIX = driverTbl.glListParameterfvSGIX;
   }
   driverTbl.glListParameterfvSGIX(list, pname, params);
}

static void REGAL_CALL missing_glListParameteriSGIX(GLuint list, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glListParameteriSGIX" );
}

static void REGAL_CALL loader_glListParameteriSGIX(GLuint list, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glListParameteriSGIX, "glListParameteriSGIX");
   if ( !driverTbl.glListParameteriSGIX ) {
      driverTbl.glListParameteriSGIX = missing_glListParameteriSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glListParameteriSGIX == loader_glListParameteriSGIX) {
      rCtx->dsp.emuTbl.glListParameteriSGIX = driverTbl.glListParameteriSGIX;
   }
   driverTbl.glListParameteriSGIX(list, pname, param);
}

static void REGAL_CALL missing_glListParameterivSGIX(GLuint list, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glListParameterivSGIX" );
}

static void REGAL_CALL loader_glListParameterivSGIX(GLuint list, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glListParameterivSGIX, "glListParameterivSGIX");
   if ( !driverTbl.glListParameterivSGIX ) {
      driverTbl.glListParameterivSGIX = missing_glListParameterivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glListParameterivSGIX == loader_glListParameterivSGIX) {
      rCtx->dsp.emuTbl.glListParameterivSGIX = driverTbl.glListParameterivSGIX;
   }
   driverTbl.glListParameterivSGIX(list, pname, params);
}

// GL_EXT_index_material

static void REGAL_CALL missing_glIndexMaterialEXT(GLenum face, GLenum mode)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glIndexMaterialEXT" );
}

static void REGAL_CALL loader_glIndexMaterialEXT(GLenum face, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexMaterialEXT, "glIndexMaterialEXT");
   if ( !driverTbl.glIndexMaterialEXT ) {
      driverTbl.glIndexMaterialEXT = missing_glIndexMaterialEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexMaterialEXT == loader_glIndexMaterialEXT) {
      rCtx->dsp.emuTbl.glIndexMaterialEXT = driverTbl.glIndexMaterialEXT;
   }
   driverTbl.glIndexMaterialEXT(face, mode);
}

// GL_EXT_index_func

static void REGAL_CALL missing_glIndexFuncEXT(GLenum func, GLfloat ref)
{
   UNUSED_PARAMETER(func);
   UNUSED_PARAMETER(ref);
   Warning( "Called missing function glIndexFuncEXT" );
}

static void REGAL_CALL loader_glIndexFuncEXT(GLenum func, GLfloat ref)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexFuncEXT, "glIndexFuncEXT");
   if ( !driverTbl.glIndexFuncEXT ) {
      driverTbl.glIndexFuncEXT = missing_glIndexFuncEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexFuncEXT == loader_glIndexFuncEXT) {
      rCtx->dsp.emuTbl.glIndexFuncEXT = driverTbl.glIndexFuncEXT;
   }
   driverTbl.glIndexFuncEXT(func, ref);
}

// GL_EXT_compiled_vertex_array

static void REGAL_CALL missing_glLockArraysEXT(GLint first, GLsizei count)
{
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   Warning( "Called missing function glLockArraysEXT" );
}

static void REGAL_CALL loader_glLockArraysEXT(GLint first, GLsizei count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLockArraysEXT, "glLockArraysEXT");
   if ( !driverTbl.glLockArraysEXT ) {
      driverTbl.glLockArraysEXT = missing_glLockArraysEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLockArraysEXT == loader_glLockArraysEXT) {
      rCtx->dsp.emuTbl.glLockArraysEXT = driverTbl.glLockArraysEXT;
   }
   driverTbl.glLockArraysEXT(first, count);
}

static void REGAL_CALL missing_glUnlockArraysEXT(void)
{
   Warning( "Called missing function glUnlockArraysEXT" );
}

static void REGAL_CALL loader_glUnlockArraysEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUnlockArraysEXT, "glUnlockArraysEXT");
   if ( !driverTbl.glUnlockArraysEXT ) {
      driverTbl.glUnlockArraysEXT = missing_glUnlockArraysEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUnlockArraysEXT == loader_glUnlockArraysEXT) {
      rCtx->dsp.emuTbl.glUnlockArraysEXT = driverTbl.glUnlockArraysEXT;
   }
   driverTbl.glUnlockArraysEXT();
}

// GL_EXT_cull_vertex

static void REGAL_CALL missing_glCullParameterdvEXT(GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glCullParameterdvEXT" );
}

static void REGAL_CALL loader_glCullParameterdvEXT(GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCullParameterdvEXT, "glCullParameterdvEXT");
   if ( !driverTbl.glCullParameterdvEXT ) {
      driverTbl.glCullParameterdvEXT = missing_glCullParameterdvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCullParameterdvEXT == loader_glCullParameterdvEXT) {
      rCtx->dsp.emuTbl.glCullParameterdvEXT = driverTbl.glCullParameterdvEXT;
   }
   driverTbl.glCullParameterdvEXT(pname, params);
}

static void REGAL_CALL missing_glCullParameterfvEXT(GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glCullParameterfvEXT" );
}

static void REGAL_CALL loader_glCullParameterfvEXT(GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCullParameterfvEXT, "glCullParameterfvEXT");
   if ( !driverTbl.glCullParameterfvEXT ) {
      driverTbl.glCullParameterfvEXT = missing_glCullParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCullParameterfvEXT == loader_glCullParameterfvEXT) {
      rCtx->dsp.emuTbl.glCullParameterfvEXT = driverTbl.glCullParameterfvEXT;
   }
   driverTbl.glCullParameterfvEXT(pname, params);
}

// GL_SGIX_fragment_lighting

static void REGAL_CALL missing_glFragmentColorMaterialSGIX(GLenum face, GLenum mode)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glFragmentColorMaterialSGIX" );
}

static void REGAL_CALL loader_glFragmentColorMaterialSGIX(GLenum face, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentColorMaterialSGIX, "glFragmentColorMaterialSGIX");
   if ( !driverTbl.glFragmentColorMaterialSGIX ) {
      driverTbl.glFragmentColorMaterialSGIX = missing_glFragmentColorMaterialSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentColorMaterialSGIX == loader_glFragmentColorMaterialSGIX) {
      rCtx->dsp.emuTbl.glFragmentColorMaterialSGIX = driverTbl.glFragmentColorMaterialSGIX;
   }
   driverTbl.glFragmentColorMaterialSGIX(face, mode);
}

static void REGAL_CALL missing_glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glFragmentLightfSGIX" );
}

static void REGAL_CALL loader_glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightfSGIX, "glFragmentLightfSGIX");
   if ( !driverTbl.glFragmentLightfSGIX ) {
      driverTbl.glFragmentLightfSGIX = missing_glFragmentLightfSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightfSGIX == loader_glFragmentLightfSGIX) {
      rCtx->dsp.emuTbl.glFragmentLightfSGIX = driverTbl.glFragmentLightfSGIX;
   }
   driverTbl.glFragmentLightfSGIX(light, pname, param);
}

static void REGAL_CALL missing_glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glFragmentLightfvSGIX" );
}

static void REGAL_CALL loader_glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightfvSGIX, "glFragmentLightfvSGIX");
   if ( !driverTbl.glFragmentLightfvSGIX ) {
      driverTbl.glFragmentLightfvSGIX = missing_glFragmentLightfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightfvSGIX == loader_glFragmentLightfvSGIX) {
      rCtx->dsp.emuTbl.glFragmentLightfvSGIX = driverTbl.glFragmentLightfvSGIX;
   }
   driverTbl.glFragmentLightfvSGIX(light, pname, params);
}

static void REGAL_CALL missing_glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glFragmentLightiSGIX" );
}

static void REGAL_CALL loader_glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightiSGIX, "glFragmentLightiSGIX");
   if ( !driverTbl.glFragmentLightiSGIX ) {
      driverTbl.glFragmentLightiSGIX = missing_glFragmentLightiSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightiSGIX == loader_glFragmentLightiSGIX) {
      rCtx->dsp.emuTbl.glFragmentLightiSGIX = driverTbl.glFragmentLightiSGIX;
   }
   driverTbl.glFragmentLightiSGIX(light, pname, param);
}

static void REGAL_CALL missing_glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glFragmentLightivSGIX" );
}

static void REGAL_CALL loader_glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightivSGIX, "glFragmentLightivSGIX");
   if ( !driverTbl.glFragmentLightivSGIX ) {
      driverTbl.glFragmentLightivSGIX = missing_glFragmentLightivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightivSGIX == loader_glFragmentLightivSGIX) {
      rCtx->dsp.emuTbl.glFragmentLightivSGIX = driverTbl.glFragmentLightivSGIX;
   }
   driverTbl.glFragmentLightivSGIX(light, pname, params);
}

static void REGAL_CALL missing_glFragmentLightModelfSGIX(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glFragmentLightModelfSGIX" );
}

static void REGAL_CALL loader_glFragmentLightModelfSGIX(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightModelfSGIX, "glFragmentLightModelfSGIX");
   if ( !driverTbl.glFragmentLightModelfSGIX ) {
      driverTbl.glFragmentLightModelfSGIX = missing_glFragmentLightModelfSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightModelfSGIX == loader_glFragmentLightModelfSGIX) {
      rCtx->dsp.emuTbl.glFragmentLightModelfSGIX = driverTbl.glFragmentLightModelfSGIX;
   }
   driverTbl.glFragmentLightModelfSGIX(pname, param);
}

static void REGAL_CALL missing_glFragmentLightModelfvSGIX(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glFragmentLightModelfvSGIX" );
}

static void REGAL_CALL loader_glFragmentLightModelfvSGIX(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightModelfvSGIX, "glFragmentLightModelfvSGIX");
   if ( !driverTbl.glFragmentLightModelfvSGIX ) {
      driverTbl.glFragmentLightModelfvSGIX = missing_glFragmentLightModelfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightModelfvSGIX == loader_glFragmentLightModelfvSGIX) {
      rCtx->dsp.emuTbl.glFragmentLightModelfvSGIX = driverTbl.glFragmentLightModelfvSGIX;
   }
   driverTbl.glFragmentLightModelfvSGIX(pname, params);
}

static void REGAL_CALL missing_glFragmentLightModeliSGIX(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glFragmentLightModeliSGIX" );
}

static void REGAL_CALL loader_glFragmentLightModeliSGIX(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightModeliSGIX, "glFragmentLightModeliSGIX");
   if ( !driverTbl.glFragmentLightModeliSGIX ) {
      driverTbl.glFragmentLightModeliSGIX = missing_glFragmentLightModeliSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightModeliSGIX == loader_glFragmentLightModeliSGIX) {
      rCtx->dsp.emuTbl.glFragmentLightModeliSGIX = driverTbl.glFragmentLightModeliSGIX;
   }
   driverTbl.glFragmentLightModeliSGIX(pname, param);
}

static void REGAL_CALL missing_glFragmentLightModelivSGIX(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glFragmentLightModelivSGIX" );
}

static void REGAL_CALL loader_glFragmentLightModelivSGIX(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightModelivSGIX, "glFragmentLightModelivSGIX");
   if ( !driverTbl.glFragmentLightModelivSGIX ) {
      driverTbl.glFragmentLightModelivSGIX = missing_glFragmentLightModelivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightModelivSGIX == loader_glFragmentLightModelivSGIX) {
      rCtx->dsp.emuTbl.glFragmentLightModelivSGIX = driverTbl.glFragmentLightModelivSGIX;
   }
   driverTbl.glFragmentLightModelivSGIX(pname, params);
}

static void REGAL_CALL missing_glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glFragmentMaterialfSGIX" );
}

static void REGAL_CALL loader_glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentMaterialfSGIX, "glFragmentMaterialfSGIX");
   if ( !driverTbl.glFragmentMaterialfSGIX ) {
      driverTbl.glFragmentMaterialfSGIX = missing_glFragmentMaterialfSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentMaterialfSGIX == loader_glFragmentMaterialfSGIX) {
      rCtx->dsp.emuTbl.glFragmentMaterialfSGIX = driverTbl.glFragmentMaterialfSGIX;
   }
   driverTbl.glFragmentMaterialfSGIX(face, pname, param);
}

static void REGAL_CALL missing_glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glFragmentMaterialfvSGIX" );
}

static void REGAL_CALL loader_glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentMaterialfvSGIX, "glFragmentMaterialfvSGIX");
   if ( !driverTbl.glFragmentMaterialfvSGIX ) {
      driverTbl.glFragmentMaterialfvSGIX = missing_glFragmentMaterialfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentMaterialfvSGIX == loader_glFragmentMaterialfvSGIX) {
      rCtx->dsp.emuTbl.glFragmentMaterialfvSGIX = driverTbl.glFragmentMaterialfvSGIX;
   }
   driverTbl.glFragmentMaterialfvSGIX(face, pname, params);
}

static void REGAL_CALL missing_glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glFragmentMaterialiSGIX" );
}

static void REGAL_CALL loader_glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentMaterialiSGIX, "glFragmentMaterialiSGIX");
   if ( !driverTbl.glFragmentMaterialiSGIX ) {
      driverTbl.glFragmentMaterialiSGIX = missing_glFragmentMaterialiSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentMaterialiSGIX == loader_glFragmentMaterialiSGIX) {
      rCtx->dsp.emuTbl.glFragmentMaterialiSGIX = driverTbl.glFragmentMaterialiSGIX;
   }
   driverTbl.glFragmentMaterialiSGIX(face, pname, param);
}

static void REGAL_CALL missing_glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glFragmentMaterialivSGIX" );
}

static void REGAL_CALL loader_glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentMaterialivSGIX, "glFragmentMaterialivSGIX");
   if ( !driverTbl.glFragmentMaterialivSGIX ) {
      driverTbl.glFragmentMaterialivSGIX = missing_glFragmentMaterialivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentMaterialivSGIX == loader_glFragmentMaterialivSGIX) {
      rCtx->dsp.emuTbl.glFragmentMaterialivSGIX = driverTbl.glFragmentMaterialivSGIX;
   }
   driverTbl.glFragmentMaterialivSGIX(face, pname, params);
}

static void REGAL_CALL missing_glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFragmentLightfvSGIX" );
}

static void REGAL_CALL loader_glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFragmentLightfvSGIX, "glGetFragmentLightfvSGIX");
   if ( !driverTbl.glGetFragmentLightfvSGIX ) {
      driverTbl.glGetFragmentLightfvSGIX = missing_glGetFragmentLightfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFragmentLightfvSGIX == loader_glGetFragmentLightfvSGIX) {
      rCtx->dsp.emuTbl.glGetFragmentLightfvSGIX = driverTbl.glGetFragmentLightfvSGIX;
   }
   driverTbl.glGetFragmentLightfvSGIX(light, pname, params);
}

static void REGAL_CALL missing_glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFragmentLightivSGIX" );
}

static void REGAL_CALL loader_glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFragmentLightivSGIX, "glGetFragmentLightivSGIX");
   if ( !driverTbl.glGetFragmentLightivSGIX ) {
      driverTbl.glGetFragmentLightivSGIX = missing_glGetFragmentLightivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFragmentLightivSGIX == loader_glGetFragmentLightivSGIX) {
      rCtx->dsp.emuTbl.glGetFragmentLightivSGIX = driverTbl.glGetFragmentLightivSGIX;
   }
   driverTbl.glGetFragmentLightivSGIX(light, pname, params);
}

static void REGAL_CALL missing_glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFragmentMaterialfvSGIX" );
}

static void REGAL_CALL loader_glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFragmentMaterialfvSGIX, "glGetFragmentMaterialfvSGIX");
   if ( !driverTbl.glGetFragmentMaterialfvSGIX ) {
      driverTbl.glGetFragmentMaterialfvSGIX = missing_glGetFragmentMaterialfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFragmentMaterialfvSGIX == loader_glGetFragmentMaterialfvSGIX) {
      rCtx->dsp.emuTbl.glGetFragmentMaterialfvSGIX = driverTbl.glGetFragmentMaterialfvSGIX;
   }
   driverTbl.glGetFragmentMaterialfvSGIX(face, pname, params);
}

static void REGAL_CALL missing_glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFragmentMaterialivSGIX" );
}

static void REGAL_CALL loader_glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFragmentMaterialivSGIX, "glGetFragmentMaterialivSGIX");
   if ( !driverTbl.glGetFragmentMaterialivSGIX ) {
      driverTbl.glGetFragmentMaterialivSGIX = missing_glGetFragmentMaterialivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFragmentMaterialivSGIX == loader_glGetFragmentMaterialivSGIX) {
      rCtx->dsp.emuTbl.glGetFragmentMaterialivSGIX = driverTbl.glGetFragmentMaterialivSGIX;
   }
   driverTbl.glGetFragmentMaterialivSGIX(face, pname, params);
}

static void REGAL_CALL missing_glLightEnviSGIX(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glLightEnviSGIX" );
}

static void REGAL_CALL loader_glLightEnviSGIX(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLightEnviSGIX, "glLightEnviSGIX");
   if ( !driverTbl.glLightEnviSGIX ) {
      driverTbl.glLightEnviSGIX = missing_glLightEnviSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLightEnviSGIX == loader_glLightEnviSGIX) {
      rCtx->dsp.emuTbl.glLightEnviSGIX = driverTbl.glLightEnviSGIX;
   }
   driverTbl.glLightEnviSGIX(pname, param);
}

// GL_EXT_draw_range_elements

static void REGAL_CALL missing_glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(end);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   Warning( "Called missing function glDrawRangeElementsEXT" );
}

static void REGAL_CALL loader_glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawRangeElementsEXT, "glDrawRangeElementsEXT");
   if ( !driverTbl.glDrawRangeElementsEXT ) {
      driverTbl.glDrawRangeElementsEXT = missing_glDrawRangeElementsEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawRangeElementsEXT == loader_glDrawRangeElementsEXT) {
      rCtx->dsp.emuTbl.glDrawRangeElementsEXT = driverTbl.glDrawRangeElementsEXT;
   }
   driverTbl.glDrawRangeElementsEXT(mode, start, end, count, type, indices);
}

// GL_EXT_light_texture

static void REGAL_CALL missing_glApplyTextureEXT(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glApplyTextureEXT" );
}

static void REGAL_CALL loader_glApplyTextureEXT(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glApplyTextureEXT, "glApplyTextureEXT");
   if ( !driverTbl.glApplyTextureEXT ) {
      driverTbl.glApplyTextureEXT = missing_glApplyTextureEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glApplyTextureEXT == loader_glApplyTextureEXT) {
      rCtx->dsp.emuTbl.glApplyTextureEXT = driverTbl.glApplyTextureEXT;
   }
   driverTbl.glApplyTextureEXT(mode);
}

static void REGAL_CALL missing_glTextureLightEXT(GLenum pname)
{
   UNUSED_PARAMETER(pname);
   Warning( "Called missing function glTextureLightEXT" );
}

static void REGAL_CALL loader_glTextureLightEXT(GLenum pname)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureLightEXT, "glTextureLightEXT");
   if ( !driverTbl.glTextureLightEXT ) {
      driverTbl.glTextureLightEXT = missing_glTextureLightEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureLightEXT == loader_glTextureLightEXT) {
      rCtx->dsp.emuTbl.glTextureLightEXT = driverTbl.glTextureLightEXT;
   }
   driverTbl.glTextureLightEXT(pname);
}

static void REGAL_CALL missing_glTextureMaterialEXT(GLenum face, GLenum mode)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glTextureMaterialEXT" );
}

static void REGAL_CALL loader_glTextureMaterialEXT(GLenum face, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureMaterialEXT, "glTextureMaterialEXT");
   if ( !driverTbl.glTextureMaterialEXT ) {
      driverTbl.glTextureMaterialEXT = missing_glTextureMaterialEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureMaterialEXT == loader_glTextureMaterialEXT) {
      rCtx->dsp.emuTbl.glTextureMaterialEXT = driverTbl.glTextureMaterialEXT;
   }
   driverTbl.glTextureMaterialEXT(face, mode);
}

// GL_EXT_scene_marker

static void REGAL_CALL missing_glBeginSceneEXT(void)
{
   Warning( "Called missing function glBeginSceneEXT" );
}

static void REGAL_CALL loader_glBeginSceneEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBeginSceneEXT, "glBeginSceneEXT");
   if ( !driverTbl.glBeginSceneEXT ) {
      driverTbl.glBeginSceneEXT = missing_glBeginSceneEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBeginSceneEXT == loader_glBeginSceneEXT) {
      rCtx->dsp.emuTbl.glBeginSceneEXT = driverTbl.glBeginSceneEXT;
   }
   driverTbl.glBeginSceneEXT();
}

static void REGAL_CALL missing_glEndSceneEXT(void)
{
   Warning( "Called missing function glEndSceneEXT" );
}

static void REGAL_CALL loader_glEndSceneEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndSceneEXT, "glEndSceneEXT");
   if ( !driverTbl.glEndSceneEXT ) {
      driverTbl.glEndSceneEXT = missing_glEndSceneEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndSceneEXT == loader_glEndSceneEXT) {
      rCtx->dsp.emuTbl.glEndSceneEXT = driverTbl.glEndSceneEXT;
   }
   driverTbl.glEndSceneEXT();
}

// GL_SGIX_async

static void REGAL_CALL missing_glAsyncMarkerSGIX(GLuint marker)
{
   UNUSED_PARAMETER(marker);
   Warning( "Called missing function glAsyncMarkerSGIX" );
}

static void REGAL_CALL loader_glAsyncMarkerSGIX(GLuint marker)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glAsyncMarkerSGIX, "glAsyncMarkerSGIX");
   if ( !driverTbl.glAsyncMarkerSGIX ) {
      driverTbl.glAsyncMarkerSGIX = missing_glAsyncMarkerSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glAsyncMarkerSGIX == loader_glAsyncMarkerSGIX) {
      rCtx->dsp.emuTbl.glAsyncMarkerSGIX = driverTbl.glAsyncMarkerSGIX;
   }
   driverTbl.glAsyncMarkerSGIX(marker);
}

static GLint REGAL_CALL missing_glFinishAsyncSGIX(GLuint *markerp)
{
   UNUSED_PARAMETER(markerp);
   Warning( "Called missing function glFinishAsyncSGIX" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glFinishAsyncSGIX(GLuint *markerp)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFinishAsyncSGIX, "glFinishAsyncSGIX");
   if ( !driverTbl.glFinishAsyncSGIX ) {
      driverTbl.glFinishAsyncSGIX = missing_glFinishAsyncSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFinishAsyncSGIX == loader_glFinishAsyncSGIX) {
      rCtx->dsp.emuTbl.glFinishAsyncSGIX = driverTbl.glFinishAsyncSGIX;
   }
   return driverTbl.glFinishAsyncSGIX(markerp);
}

static GLint REGAL_CALL missing_glPollAsyncSGIX(GLuint *markerp)
{
   UNUSED_PARAMETER(markerp);
   Warning( "Called missing function glPollAsyncSGIX" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glPollAsyncSGIX(GLuint *markerp)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPollAsyncSGIX, "glPollAsyncSGIX");
   if ( !driverTbl.glPollAsyncSGIX ) {
      driverTbl.glPollAsyncSGIX = missing_glPollAsyncSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPollAsyncSGIX == loader_glPollAsyncSGIX) {
      rCtx->dsp.emuTbl.glPollAsyncSGIX = driverTbl.glPollAsyncSGIX;
   }
   return driverTbl.glPollAsyncSGIX(markerp);
}

static GLuint REGAL_CALL missing_glGenAsyncMarkersSGIX(GLsizei range)
{
   UNUSED_PARAMETER(range);
   Warning( "Called missing function glGenAsyncMarkersSGIX" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGenAsyncMarkersSGIX(GLsizei range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenAsyncMarkersSGIX, "glGenAsyncMarkersSGIX");
   if ( !driverTbl.glGenAsyncMarkersSGIX ) {
      driverTbl.glGenAsyncMarkersSGIX = missing_glGenAsyncMarkersSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenAsyncMarkersSGIX == loader_glGenAsyncMarkersSGIX) {
      rCtx->dsp.emuTbl.glGenAsyncMarkersSGIX = driverTbl.glGenAsyncMarkersSGIX;
   }
   return driverTbl.glGenAsyncMarkersSGIX(range);
}

static void REGAL_CALL missing_glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range)
{
   UNUSED_PARAMETER(marker);
   UNUSED_PARAMETER(range);
   Warning( "Called missing function glDeleteAsyncMarkersSGIX" );
}

static void REGAL_CALL loader_glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteAsyncMarkersSGIX, "glDeleteAsyncMarkersSGIX");
   if ( !driverTbl.glDeleteAsyncMarkersSGIX ) {
      driverTbl.glDeleteAsyncMarkersSGIX = missing_glDeleteAsyncMarkersSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteAsyncMarkersSGIX == loader_glDeleteAsyncMarkersSGIX) {
      rCtx->dsp.emuTbl.glDeleteAsyncMarkersSGIX = driverTbl.glDeleteAsyncMarkersSGIX;
   }
   driverTbl.glDeleteAsyncMarkersSGIX(marker, range);
}

static GLboolean REGAL_CALL missing_glIsAsyncMarkerSGIX(GLuint marker)
{
   UNUSED_PARAMETER(marker);
   Warning( "Called missing function glIsAsyncMarkerSGIX" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsAsyncMarkerSGIX(GLuint marker)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsAsyncMarkerSGIX, "glIsAsyncMarkerSGIX");
   if ( !driverTbl.glIsAsyncMarkerSGIX ) {
      driverTbl.glIsAsyncMarkerSGIX = missing_glIsAsyncMarkerSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsAsyncMarkerSGIX == loader_glIsAsyncMarkerSGIX) {
      rCtx->dsp.emuTbl.glIsAsyncMarkerSGIX = driverTbl.glIsAsyncMarkerSGIX;
   }
   return driverTbl.glIsAsyncMarkerSGIX(marker);
}

// GL_INTEL_parallel_arrays

static void REGAL_CALL missing_glVertexPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glVertexPointervINTEL" );
}

static void REGAL_CALL loader_glVertexPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexPointervINTEL, "glVertexPointervINTEL");
   if ( !driverTbl.glVertexPointervINTEL ) {
      driverTbl.glVertexPointervINTEL = missing_glVertexPointervINTEL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexPointervINTEL == loader_glVertexPointervINTEL) {
      rCtx->dsp.emuTbl.glVertexPointervINTEL = driverTbl.glVertexPointervINTEL;
   }
   driverTbl.glVertexPointervINTEL(size, type, pointer);
}

static void REGAL_CALL missing_glNormalPointervINTEL(GLenum type, const GLvoid **pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glNormalPointervINTEL" );
}

static void REGAL_CALL loader_glNormalPointervINTEL(GLenum type, const GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalPointervINTEL, "glNormalPointervINTEL");
   if ( !driverTbl.glNormalPointervINTEL ) {
      driverTbl.glNormalPointervINTEL = missing_glNormalPointervINTEL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalPointervINTEL == loader_glNormalPointervINTEL) {
      rCtx->dsp.emuTbl.glNormalPointervINTEL = driverTbl.glNormalPointervINTEL;
   }
   driverTbl.glNormalPointervINTEL(type, pointer);
}

static void REGAL_CALL missing_glColorPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glColorPointervINTEL" );
}

static void REGAL_CALL loader_glColorPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorPointervINTEL, "glColorPointervINTEL");
   if ( !driverTbl.glColorPointervINTEL ) {
      driverTbl.glColorPointervINTEL = missing_glColorPointervINTEL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorPointervINTEL == loader_glColorPointervINTEL) {
      rCtx->dsp.emuTbl.glColorPointervINTEL = driverTbl.glColorPointervINTEL;
   }
   driverTbl.glColorPointervINTEL(size, type, pointer);
}

static void REGAL_CALL missing_glTexCoordPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glTexCoordPointervINTEL" );
}

static void REGAL_CALL loader_glTexCoordPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoordPointervINTEL, "glTexCoordPointervINTEL");
   if ( !driverTbl.glTexCoordPointervINTEL ) {
      driverTbl.glTexCoordPointervINTEL = missing_glTexCoordPointervINTEL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoordPointervINTEL == loader_glTexCoordPointervINTEL) {
      rCtx->dsp.emuTbl.glTexCoordPointervINTEL = driverTbl.glTexCoordPointervINTEL;
   }
   driverTbl.glTexCoordPointervINTEL(size, type, pointer);
}

// GL_EXT_pixel_transform

static void REGAL_CALL missing_glPixelTransformParameteriEXT(GLenum target, GLenum pname, const GLint param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPixelTransformParameteriEXT" );
}

static void REGAL_CALL loader_glPixelTransformParameteriEXT(GLenum target, GLenum pname, const GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelTransformParameteriEXT, "glPixelTransformParameteriEXT");
   if ( !driverTbl.glPixelTransformParameteriEXT ) {
      driverTbl.glPixelTransformParameteriEXT = missing_glPixelTransformParameteriEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelTransformParameteriEXT == loader_glPixelTransformParameteriEXT) {
      rCtx->dsp.emuTbl.glPixelTransformParameteriEXT = driverTbl.glPixelTransformParameteriEXT;
   }
   driverTbl.glPixelTransformParameteriEXT(target, pname, param);
}

static void REGAL_CALL missing_glPixelTransformParameterfEXT(GLenum target, GLenum pname, const GLfloat param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPixelTransformParameterfEXT" );
}

static void REGAL_CALL loader_glPixelTransformParameterfEXT(GLenum target, GLenum pname, const GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelTransformParameterfEXT, "glPixelTransformParameterfEXT");
   if ( !driverTbl.glPixelTransformParameterfEXT ) {
      driverTbl.glPixelTransformParameterfEXT = missing_glPixelTransformParameterfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelTransformParameterfEXT == loader_glPixelTransformParameterfEXT) {
      rCtx->dsp.emuTbl.glPixelTransformParameterfEXT = driverTbl.glPixelTransformParameterfEXT;
   }
   driverTbl.glPixelTransformParameterfEXT(target, pname, param);
}

static void REGAL_CALL missing_glPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glPixelTransformParameterivEXT" );
}

static void REGAL_CALL loader_glPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelTransformParameterivEXT, "glPixelTransformParameterivEXT");
   if ( !driverTbl.glPixelTransformParameterivEXT ) {
      driverTbl.glPixelTransformParameterivEXT = missing_glPixelTransformParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelTransformParameterivEXT == loader_glPixelTransformParameterivEXT) {
      rCtx->dsp.emuTbl.glPixelTransformParameterivEXT = driverTbl.glPixelTransformParameterivEXT;
   }
   driverTbl.glPixelTransformParameterivEXT(target, pname, params);
}

static void REGAL_CALL missing_glPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glPixelTransformParameterfvEXT" );
}

static void REGAL_CALL loader_glPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelTransformParameterfvEXT, "glPixelTransformParameterfvEXT");
   if ( !driverTbl.glPixelTransformParameterfvEXT ) {
      driverTbl.glPixelTransformParameterfvEXT = missing_glPixelTransformParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelTransformParameterfvEXT == loader_glPixelTransformParameterfvEXT) {
      rCtx->dsp.emuTbl.glPixelTransformParameterfvEXT = driverTbl.glPixelTransformParameterfvEXT;
   }
   driverTbl.glPixelTransformParameterfvEXT(target, pname, params);
}

// GL_EXT_secondary_color

static void REGAL_CALL missing_glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3bEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3bEXT, "glSecondaryColor3bEXT");
   if ( !driverTbl.glSecondaryColor3bEXT ) {
      driverTbl.glSecondaryColor3bEXT = missing_glSecondaryColor3bEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3bEXT == loader_glSecondaryColor3bEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3bEXT = driverTbl.glSecondaryColor3bEXT;
   }
   driverTbl.glSecondaryColor3bEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3bvEXT(const GLbyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3bvEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3bvEXT(const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3bvEXT, "glSecondaryColor3bvEXT");
   if ( !driverTbl.glSecondaryColor3bvEXT ) {
      driverTbl.glSecondaryColor3bvEXT = missing_glSecondaryColor3bvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3bvEXT == loader_glSecondaryColor3bvEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3bvEXT = driverTbl.glSecondaryColor3bvEXT;
   }
   driverTbl.glSecondaryColor3bvEXT(v);
}

static void REGAL_CALL missing_glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3dEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3dEXT, "glSecondaryColor3dEXT");
   if ( !driverTbl.glSecondaryColor3dEXT ) {
      driverTbl.glSecondaryColor3dEXT = missing_glSecondaryColor3dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3dEXT == loader_glSecondaryColor3dEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3dEXT = driverTbl.glSecondaryColor3dEXT;
   }
   driverTbl.glSecondaryColor3dEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3dvEXT(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3dvEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3dvEXT(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3dvEXT, "glSecondaryColor3dvEXT");
   if ( !driverTbl.glSecondaryColor3dvEXT ) {
      driverTbl.glSecondaryColor3dvEXT = missing_glSecondaryColor3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3dvEXT == loader_glSecondaryColor3dvEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3dvEXT = driverTbl.glSecondaryColor3dvEXT;
   }
   driverTbl.glSecondaryColor3dvEXT(v);
}

static void REGAL_CALL missing_glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3fEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3fEXT, "glSecondaryColor3fEXT");
   if ( !driverTbl.glSecondaryColor3fEXT ) {
      driverTbl.glSecondaryColor3fEXT = missing_glSecondaryColor3fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3fEXT == loader_glSecondaryColor3fEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3fEXT = driverTbl.glSecondaryColor3fEXT;
   }
   driverTbl.glSecondaryColor3fEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3fvEXT(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3fvEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3fvEXT(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3fvEXT, "glSecondaryColor3fvEXT");
   if ( !driverTbl.glSecondaryColor3fvEXT ) {
      driverTbl.glSecondaryColor3fvEXT = missing_glSecondaryColor3fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3fvEXT == loader_glSecondaryColor3fvEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3fvEXT = driverTbl.glSecondaryColor3fvEXT;
   }
   driverTbl.glSecondaryColor3fvEXT(v);
}

static void REGAL_CALL missing_glSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3iEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3iEXT, "glSecondaryColor3iEXT");
   if ( !driverTbl.glSecondaryColor3iEXT ) {
      driverTbl.glSecondaryColor3iEXT = missing_glSecondaryColor3iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3iEXT == loader_glSecondaryColor3iEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3iEXT = driverTbl.glSecondaryColor3iEXT;
   }
   driverTbl.glSecondaryColor3iEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3ivEXT(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3ivEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3ivEXT(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3ivEXT, "glSecondaryColor3ivEXT");
   if ( !driverTbl.glSecondaryColor3ivEXT ) {
      driverTbl.glSecondaryColor3ivEXT = missing_glSecondaryColor3ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3ivEXT == loader_glSecondaryColor3ivEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3ivEXT = driverTbl.glSecondaryColor3ivEXT;
   }
   driverTbl.glSecondaryColor3ivEXT(v);
}

static void REGAL_CALL missing_glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3sEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3sEXT, "glSecondaryColor3sEXT");
   if ( !driverTbl.glSecondaryColor3sEXT ) {
      driverTbl.glSecondaryColor3sEXT = missing_glSecondaryColor3sEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3sEXT == loader_glSecondaryColor3sEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3sEXT = driverTbl.glSecondaryColor3sEXT;
   }
   driverTbl.glSecondaryColor3sEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3svEXT(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3svEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3svEXT(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3svEXT, "glSecondaryColor3svEXT");
   if ( !driverTbl.glSecondaryColor3svEXT ) {
      driverTbl.glSecondaryColor3svEXT = missing_glSecondaryColor3svEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3svEXT == loader_glSecondaryColor3svEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3svEXT = driverTbl.glSecondaryColor3svEXT;
   }
   driverTbl.glSecondaryColor3svEXT(v);
}

static void REGAL_CALL missing_glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3ubEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3ubEXT, "glSecondaryColor3ubEXT");
   if ( !driverTbl.glSecondaryColor3ubEXT ) {
      driverTbl.glSecondaryColor3ubEXT = missing_glSecondaryColor3ubEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3ubEXT == loader_glSecondaryColor3ubEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3ubEXT = driverTbl.glSecondaryColor3ubEXT;
   }
   driverTbl.glSecondaryColor3ubEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3ubvEXT(const GLubyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3ubvEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3ubvEXT(const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3ubvEXT, "glSecondaryColor3ubvEXT");
   if ( !driverTbl.glSecondaryColor3ubvEXT ) {
      driverTbl.glSecondaryColor3ubvEXT = missing_glSecondaryColor3ubvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3ubvEXT == loader_glSecondaryColor3ubvEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3ubvEXT = driverTbl.glSecondaryColor3ubvEXT;
   }
   driverTbl.glSecondaryColor3ubvEXT(v);
}

static void REGAL_CALL missing_glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3uiEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3uiEXT, "glSecondaryColor3uiEXT");
   if ( !driverTbl.glSecondaryColor3uiEXT ) {
      driverTbl.glSecondaryColor3uiEXT = missing_glSecondaryColor3uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3uiEXT == loader_glSecondaryColor3uiEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3uiEXT = driverTbl.glSecondaryColor3uiEXT;
   }
   driverTbl.glSecondaryColor3uiEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3uivEXT(const GLuint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3uivEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3uivEXT(const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3uivEXT, "glSecondaryColor3uivEXT");
   if ( !driverTbl.glSecondaryColor3uivEXT ) {
      driverTbl.glSecondaryColor3uivEXT = missing_glSecondaryColor3uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3uivEXT == loader_glSecondaryColor3uivEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3uivEXT = driverTbl.glSecondaryColor3uivEXT;
   }
   driverTbl.glSecondaryColor3uivEXT(v);
}

static void REGAL_CALL missing_glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3usEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3usEXT, "glSecondaryColor3usEXT");
   if ( !driverTbl.glSecondaryColor3usEXT ) {
      driverTbl.glSecondaryColor3usEXT = missing_glSecondaryColor3usEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3usEXT == loader_glSecondaryColor3usEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3usEXT = driverTbl.glSecondaryColor3usEXT;
   }
   driverTbl.glSecondaryColor3usEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3usvEXT(const GLushort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3usvEXT" );
}

static void REGAL_CALL loader_glSecondaryColor3usvEXT(const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3usvEXT, "glSecondaryColor3usvEXT");
   if ( !driverTbl.glSecondaryColor3usvEXT ) {
      driverTbl.glSecondaryColor3usvEXT = missing_glSecondaryColor3usvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3usvEXT == loader_glSecondaryColor3usvEXT) {
      rCtx->dsp.emuTbl.glSecondaryColor3usvEXT = driverTbl.glSecondaryColor3usvEXT;
   }
   driverTbl.glSecondaryColor3usvEXT(v);
}

static void REGAL_CALL missing_glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glSecondaryColorPointerEXT" );
}

static void REGAL_CALL loader_glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColorPointerEXT, "glSecondaryColorPointerEXT");
   if ( !driverTbl.glSecondaryColorPointerEXT ) {
      driverTbl.glSecondaryColorPointerEXT = missing_glSecondaryColorPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColorPointerEXT == loader_glSecondaryColorPointerEXT) {
      rCtx->dsp.emuTbl.glSecondaryColorPointerEXT = driverTbl.glSecondaryColorPointerEXT;
   }
   driverTbl.glSecondaryColorPointerEXT(size, type, stride, pointer);
}

// GL_EXT_texture_perturb_normal

static void REGAL_CALL missing_glTextureNormalEXT(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glTextureNormalEXT" );
}

static void REGAL_CALL loader_glTextureNormalEXT(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureNormalEXT, "glTextureNormalEXT");
   if ( !driverTbl.glTextureNormalEXT ) {
      driverTbl.glTextureNormalEXT = missing_glTextureNormalEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureNormalEXT == loader_glTextureNormalEXT) {
      rCtx->dsp.emuTbl.glTextureNormalEXT = driverTbl.glTextureNormalEXT;
   }
   driverTbl.glTextureNormalEXT(mode);
}

// GL_EXT_multi_draw_arrays

static void REGAL_CALL missing_glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   Warning( "Called missing function glMultiDrawArraysEXT" );
}

static void REGAL_CALL loader_glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiDrawArraysEXT, "glMultiDrawArraysEXT");
   if ( !driverTbl.glMultiDrawArraysEXT ) {
      driverTbl.glMultiDrawArraysEXT = missing_glMultiDrawArraysEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiDrawArraysEXT == loader_glMultiDrawArraysEXT) {
      rCtx->dsp.emuTbl.glMultiDrawArraysEXT = driverTbl.glMultiDrawArraysEXT;
   }
   driverTbl.glMultiDrawArraysEXT(mode, first, count, primcount);
}

static void REGAL_CALL missing_glMultiDrawElementsEXT(GLenum mode, GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   Warning( "Called missing function glMultiDrawElementsEXT" );
}

static void REGAL_CALL loader_glMultiDrawElementsEXT(GLenum mode, GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiDrawElementsEXT, "glMultiDrawElementsEXT");
   if ( !driverTbl.glMultiDrawElementsEXT ) {
      driverTbl.glMultiDrawElementsEXT = missing_glMultiDrawElementsEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiDrawElementsEXT == loader_glMultiDrawElementsEXT) {
      rCtx->dsp.emuTbl.glMultiDrawElementsEXT = driverTbl.glMultiDrawElementsEXT;
   }
   driverTbl.glMultiDrawElementsEXT(mode, count, type, indices, primcount);
}

// GL_EXT_fog_coord

static void REGAL_CALL missing_glFogCoordfEXT(GLfloat coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "Called missing function glFogCoordfEXT" );
}

static void REGAL_CALL loader_glFogCoordfEXT(GLfloat coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogCoordfEXT, "glFogCoordfEXT");
   if ( !driverTbl.glFogCoordfEXT ) {
      driverTbl.glFogCoordfEXT = missing_glFogCoordfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogCoordfEXT == loader_glFogCoordfEXT) {
      rCtx->dsp.emuTbl.glFogCoordfEXT = driverTbl.glFogCoordfEXT;
   }
   driverTbl.glFogCoordfEXT(coord);
}

static void REGAL_CALL missing_glFogCoordfvEXT(const GLfloat *coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "Called missing function glFogCoordfvEXT" );
}

static void REGAL_CALL loader_glFogCoordfvEXT(const GLfloat *coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogCoordfvEXT, "glFogCoordfvEXT");
   if ( !driverTbl.glFogCoordfvEXT ) {
      driverTbl.glFogCoordfvEXT = missing_glFogCoordfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogCoordfvEXT == loader_glFogCoordfvEXT) {
      rCtx->dsp.emuTbl.glFogCoordfvEXT = driverTbl.glFogCoordfvEXT;
   }
   driverTbl.glFogCoordfvEXT(coord);
}

static void REGAL_CALL missing_glFogCoorddEXT(GLdouble coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "Called missing function glFogCoorddEXT" );
}

static void REGAL_CALL loader_glFogCoorddEXT(GLdouble coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogCoorddEXT, "glFogCoorddEXT");
   if ( !driverTbl.glFogCoorddEXT ) {
      driverTbl.glFogCoorddEXT = missing_glFogCoorddEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogCoorddEXT == loader_glFogCoorddEXT) {
      rCtx->dsp.emuTbl.glFogCoorddEXT = driverTbl.glFogCoorddEXT;
   }
   driverTbl.glFogCoorddEXT(coord);
}

static void REGAL_CALL missing_glFogCoorddvEXT(const GLdouble *coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "Called missing function glFogCoorddvEXT" );
}

static void REGAL_CALL loader_glFogCoorddvEXT(const GLdouble *coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogCoorddvEXT, "glFogCoorddvEXT");
   if ( !driverTbl.glFogCoorddvEXT ) {
      driverTbl.glFogCoorddvEXT = missing_glFogCoorddvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogCoorddvEXT == loader_glFogCoorddvEXT) {
      rCtx->dsp.emuTbl.glFogCoorddvEXT = driverTbl.glFogCoorddvEXT;
   }
   driverTbl.glFogCoorddvEXT(coord);
}

static void REGAL_CALL missing_glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glFogCoordPointerEXT" );
}

static void REGAL_CALL loader_glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogCoordPointerEXT, "glFogCoordPointerEXT");
   if ( !driverTbl.glFogCoordPointerEXT ) {
      driverTbl.glFogCoordPointerEXT = missing_glFogCoordPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogCoordPointerEXT == loader_glFogCoordPointerEXT) {
      rCtx->dsp.emuTbl.glFogCoordPointerEXT = driverTbl.glFogCoordPointerEXT;
   }
   driverTbl.glFogCoordPointerEXT(type, stride, pointer);
}

// GL_EXT_coordinate_frame

static void REGAL_CALL missing_glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz)
{
   UNUSED_PARAMETER(tx);
   UNUSED_PARAMETER(ty);
   UNUSED_PARAMETER(tz);
   Warning( "Called missing function glTangent3bEXT" );
}

static void REGAL_CALL loader_glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTangent3bEXT, "glTangent3bEXT");
   if ( !driverTbl.glTangent3bEXT ) {
      driverTbl.glTangent3bEXT = missing_glTangent3bEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTangent3bEXT == loader_glTangent3bEXT) {
      rCtx->dsp.emuTbl.glTangent3bEXT = driverTbl.glTangent3bEXT;
   }
   driverTbl.glTangent3bEXT(tx, ty, tz);
}

static void REGAL_CALL missing_glTangent3bvEXT(const GLbyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTangent3bvEXT" );
}

static void REGAL_CALL loader_glTangent3bvEXT(const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTangent3bvEXT, "glTangent3bvEXT");
   if ( !driverTbl.glTangent3bvEXT ) {
      driverTbl.glTangent3bvEXT = missing_glTangent3bvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTangent3bvEXT == loader_glTangent3bvEXT) {
      rCtx->dsp.emuTbl.glTangent3bvEXT = driverTbl.glTangent3bvEXT;
   }
   driverTbl.glTangent3bvEXT(v);
}

static void REGAL_CALL missing_glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz)
{
   UNUSED_PARAMETER(tx);
   UNUSED_PARAMETER(ty);
   UNUSED_PARAMETER(tz);
   Warning( "Called missing function glTangent3dEXT" );
}

static void REGAL_CALL loader_glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTangent3dEXT, "glTangent3dEXT");
   if ( !driverTbl.glTangent3dEXT ) {
      driverTbl.glTangent3dEXT = missing_glTangent3dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTangent3dEXT == loader_glTangent3dEXT) {
      rCtx->dsp.emuTbl.glTangent3dEXT = driverTbl.glTangent3dEXT;
   }
   driverTbl.glTangent3dEXT(tx, ty, tz);
}

static void REGAL_CALL missing_glTangent3dvEXT(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTangent3dvEXT" );
}

static void REGAL_CALL loader_glTangent3dvEXT(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTangent3dvEXT, "glTangent3dvEXT");
   if ( !driverTbl.glTangent3dvEXT ) {
      driverTbl.glTangent3dvEXT = missing_glTangent3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTangent3dvEXT == loader_glTangent3dvEXT) {
      rCtx->dsp.emuTbl.glTangent3dvEXT = driverTbl.glTangent3dvEXT;
   }
   driverTbl.glTangent3dvEXT(v);
}

static void REGAL_CALL missing_glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz)
{
   UNUSED_PARAMETER(tx);
   UNUSED_PARAMETER(ty);
   UNUSED_PARAMETER(tz);
   Warning( "Called missing function glTangent3fEXT" );
}

static void REGAL_CALL loader_glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTangent3fEXT, "glTangent3fEXT");
   if ( !driverTbl.glTangent3fEXT ) {
      driverTbl.glTangent3fEXT = missing_glTangent3fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTangent3fEXT == loader_glTangent3fEXT) {
      rCtx->dsp.emuTbl.glTangent3fEXT = driverTbl.glTangent3fEXT;
   }
   driverTbl.glTangent3fEXT(tx, ty, tz);
}

static void REGAL_CALL missing_glTangent3fvEXT(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTangent3fvEXT" );
}

static void REGAL_CALL loader_glTangent3fvEXT(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTangent3fvEXT, "glTangent3fvEXT");
   if ( !driverTbl.glTangent3fvEXT ) {
      driverTbl.glTangent3fvEXT = missing_glTangent3fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTangent3fvEXT == loader_glTangent3fvEXT) {
      rCtx->dsp.emuTbl.glTangent3fvEXT = driverTbl.glTangent3fvEXT;
   }
   driverTbl.glTangent3fvEXT(v);
}

static void REGAL_CALL missing_glTangent3iEXT(GLint tx, GLint ty, GLint tz)
{
   UNUSED_PARAMETER(tx);
   UNUSED_PARAMETER(ty);
   UNUSED_PARAMETER(tz);
   Warning( "Called missing function glTangent3iEXT" );
}

static void REGAL_CALL loader_glTangent3iEXT(GLint tx, GLint ty, GLint tz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTangent3iEXT, "glTangent3iEXT");
   if ( !driverTbl.glTangent3iEXT ) {
      driverTbl.glTangent3iEXT = missing_glTangent3iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTangent3iEXT == loader_glTangent3iEXT) {
      rCtx->dsp.emuTbl.glTangent3iEXT = driverTbl.glTangent3iEXT;
   }
   driverTbl.glTangent3iEXT(tx, ty, tz);
}

static void REGAL_CALL missing_glTangent3ivEXT(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTangent3ivEXT" );
}

static void REGAL_CALL loader_glTangent3ivEXT(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTangent3ivEXT, "glTangent3ivEXT");
   if ( !driverTbl.glTangent3ivEXT ) {
      driverTbl.glTangent3ivEXT = missing_glTangent3ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTangent3ivEXT == loader_glTangent3ivEXT) {
      rCtx->dsp.emuTbl.glTangent3ivEXT = driverTbl.glTangent3ivEXT;
   }
   driverTbl.glTangent3ivEXT(v);
}

static void REGAL_CALL missing_glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz)
{
   UNUSED_PARAMETER(tx);
   UNUSED_PARAMETER(ty);
   UNUSED_PARAMETER(tz);
   Warning( "Called missing function glTangent3sEXT" );
}

static void REGAL_CALL loader_glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTangent3sEXT, "glTangent3sEXT");
   if ( !driverTbl.glTangent3sEXT ) {
      driverTbl.glTangent3sEXT = missing_glTangent3sEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTangent3sEXT == loader_glTangent3sEXT) {
      rCtx->dsp.emuTbl.glTangent3sEXT = driverTbl.glTangent3sEXT;
   }
   driverTbl.glTangent3sEXT(tx, ty, tz);
}

static void REGAL_CALL missing_glTangent3svEXT(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTangent3svEXT" );
}

static void REGAL_CALL loader_glTangent3svEXT(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTangent3svEXT, "glTangent3svEXT");
   if ( !driverTbl.glTangent3svEXT ) {
      driverTbl.glTangent3svEXT = missing_glTangent3svEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTangent3svEXT == loader_glTangent3svEXT) {
      rCtx->dsp.emuTbl.glTangent3svEXT = driverTbl.glTangent3svEXT;
   }
   driverTbl.glTangent3svEXT(v);
}

static void REGAL_CALL missing_glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz)
{
   UNUSED_PARAMETER(bx);
   UNUSED_PARAMETER(by);
   UNUSED_PARAMETER(bz);
   Warning( "Called missing function glBinormal3bEXT" );
}

static void REGAL_CALL loader_glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBinormal3bEXT, "glBinormal3bEXT");
   if ( !driverTbl.glBinormal3bEXT ) {
      driverTbl.glBinormal3bEXT = missing_glBinormal3bEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBinormal3bEXT == loader_glBinormal3bEXT) {
      rCtx->dsp.emuTbl.glBinormal3bEXT = driverTbl.glBinormal3bEXT;
   }
   driverTbl.glBinormal3bEXT(bx, by, bz);
}

static void REGAL_CALL missing_glBinormal3bvEXT(const GLbyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glBinormal3bvEXT" );
}

static void REGAL_CALL loader_glBinormal3bvEXT(const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBinormal3bvEXT, "glBinormal3bvEXT");
   if ( !driverTbl.glBinormal3bvEXT ) {
      driverTbl.glBinormal3bvEXT = missing_glBinormal3bvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBinormal3bvEXT == loader_glBinormal3bvEXT) {
      rCtx->dsp.emuTbl.glBinormal3bvEXT = driverTbl.glBinormal3bvEXT;
   }
   driverTbl.glBinormal3bvEXT(v);
}

static void REGAL_CALL missing_glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz)
{
   UNUSED_PARAMETER(bx);
   UNUSED_PARAMETER(by);
   UNUSED_PARAMETER(bz);
   Warning( "Called missing function glBinormal3dEXT" );
}

static void REGAL_CALL loader_glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBinormal3dEXT, "glBinormal3dEXT");
   if ( !driverTbl.glBinormal3dEXT ) {
      driverTbl.glBinormal3dEXT = missing_glBinormal3dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBinormal3dEXT == loader_glBinormal3dEXT) {
      rCtx->dsp.emuTbl.glBinormal3dEXT = driverTbl.glBinormal3dEXT;
   }
   driverTbl.glBinormal3dEXT(bx, by, bz);
}

static void REGAL_CALL missing_glBinormal3dvEXT(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glBinormal3dvEXT" );
}

static void REGAL_CALL loader_glBinormal3dvEXT(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBinormal3dvEXT, "glBinormal3dvEXT");
   if ( !driverTbl.glBinormal3dvEXT ) {
      driverTbl.glBinormal3dvEXT = missing_glBinormal3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBinormal3dvEXT == loader_glBinormal3dvEXT) {
      rCtx->dsp.emuTbl.glBinormal3dvEXT = driverTbl.glBinormal3dvEXT;
   }
   driverTbl.glBinormal3dvEXT(v);
}

static void REGAL_CALL missing_glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz)
{
   UNUSED_PARAMETER(bx);
   UNUSED_PARAMETER(by);
   UNUSED_PARAMETER(bz);
   Warning( "Called missing function glBinormal3fEXT" );
}

static void REGAL_CALL loader_glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBinormal3fEXT, "glBinormal3fEXT");
   if ( !driverTbl.glBinormal3fEXT ) {
      driverTbl.glBinormal3fEXT = missing_glBinormal3fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBinormal3fEXT == loader_glBinormal3fEXT) {
      rCtx->dsp.emuTbl.glBinormal3fEXT = driverTbl.glBinormal3fEXT;
   }
   driverTbl.glBinormal3fEXT(bx, by, bz);
}

static void REGAL_CALL missing_glBinormal3fvEXT(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glBinormal3fvEXT" );
}

static void REGAL_CALL loader_glBinormal3fvEXT(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBinormal3fvEXT, "glBinormal3fvEXT");
   if ( !driverTbl.glBinormal3fvEXT ) {
      driverTbl.glBinormal3fvEXT = missing_glBinormal3fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBinormal3fvEXT == loader_glBinormal3fvEXT) {
      rCtx->dsp.emuTbl.glBinormal3fvEXT = driverTbl.glBinormal3fvEXT;
   }
   driverTbl.glBinormal3fvEXT(v);
}

static void REGAL_CALL missing_glBinormal3iEXT(GLint bx, GLint by, GLint bz)
{
   UNUSED_PARAMETER(bx);
   UNUSED_PARAMETER(by);
   UNUSED_PARAMETER(bz);
   Warning( "Called missing function glBinormal3iEXT" );
}

static void REGAL_CALL loader_glBinormal3iEXT(GLint bx, GLint by, GLint bz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBinormal3iEXT, "glBinormal3iEXT");
   if ( !driverTbl.glBinormal3iEXT ) {
      driverTbl.glBinormal3iEXT = missing_glBinormal3iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBinormal3iEXT == loader_glBinormal3iEXT) {
      rCtx->dsp.emuTbl.glBinormal3iEXT = driverTbl.glBinormal3iEXT;
   }
   driverTbl.glBinormal3iEXT(bx, by, bz);
}

static void REGAL_CALL missing_glBinormal3ivEXT(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glBinormal3ivEXT" );
}

static void REGAL_CALL loader_glBinormal3ivEXT(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBinormal3ivEXT, "glBinormal3ivEXT");
   if ( !driverTbl.glBinormal3ivEXT ) {
      driverTbl.glBinormal3ivEXT = missing_glBinormal3ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBinormal3ivEXT == loader_glBinormal3ivEXT) {
      rCtx->dsp.emuTbl.glBinormal3ivEXT = driverTbl.glBinormal3ivEXT;
   }
   driverTbl.glBinormal3ivEXT(v);
}

static void REGAL_CALL missing_glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz)
{
   UNUSED_PARAMETER(bx);
   UNUSED_PARAMETER(by);
   UNUSED_PARAMETER(bz);
   Warning( "Called missing function glBinormal3sEXT" );
}

static void REGAL_CALL loader_glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBinormal3sEXT, "glBinormal3sEXT");
   if ( !driverTbl.glBinormal3sEXT ) {
      driverTbl.glBinormal3sEXT = missing_glBinormal3sEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBinormal3sEXT == loader_glBinormal3sEXT) {
      rCtx->dsp.emuTbl.glBinormal3sEXT = driverTbl.glBinormal3sEXT;
   }
   driverTbl.glBinormal3sEXT(bx, by, bz);
}

static void REGAL_CALL missing_glBinormal3svEXT(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glBinormal3svEXT" );
}

static void REGAL_CALL loader_glBinormal3svEXT(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBinormal3svEXT, "glBinormal3svEXT");
   if ( !driverTbl.glBinormal3svEXT ) {
      driverTbl.glBinormal3svEXT = missing_glBinormal3svEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBinormal3svEXT == loader_glBinormal3svEXT) {
      rCtx->dsp.emuTbl.glBinormal3svEXT = driverTbl.glBinormal3svEXT;
   }
   driverTbl.glBinormal3svEXT(v);
}

static void REGAL_CALL missing_glTangentPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glTangentPointerEXT" );
}

static void REGAL_CALL loader_glTangentPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTangentPointerEXT, "glTangentPointerEXT");
   if ( !driverTbl.glTangentPointerEXT ) {
      driverTbl.glTangentPointerEXT = missing_glTangentPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTangentPointerEXT == loader_glTangentPointerEXT) {
      rCtx->dsp.emuTbl.glTangentPointerEXT = driverTbl.glTangentPointerEXT;
   }
   driverTbl.glTangentPointerEXT(type, stride, pointer);
}

static void REGAL_CALL missing_glBinormalPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glBinormalPointerEXT" );
}

static void REGAL_CALL loader_glBinormalPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBinormalPointerEXT, "glBinormalPointerEXT");
   if ( !driverTbl.glBinormalPointerEXT ) {
      driverTbl.glBinormalPointerEXT = missing_glBinormalPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBinormalPointerEXT == loader_glBinormalPointerEXT) {
      rCtx->dsp.emuTbl.glBinormalPointerEXT = driverTbl.glBinormalPointerEXT;
   }
   driverTbl.glBinormalPointerEXT(type, stride, pointer);
}

// GL_SUNX_constant_data

static void REGAL_CALL missing_glFinishTextureSUNX(void)
{
   Warning( "Called missing function glFinishTextureSUNX" );
}

static void REGAL_CALL loader_glFinishTextureSUNX(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFinishTextureSUNX, "glFinishTextureSUNX");
   if ( !driverTbl.glFinishTextureSUNX ) {
      driverTbl.glFinishTextureSUNX = missing_glFinishTextureSUNX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFinishTextureSUNX == loader_glFinishTextureSUNX) {
      rCtx->dsp.emuTbl.glFinishTextureSUNX = driverTbl.glFinishTextureSUNX;
   }
   driverTbl.glFinishTextureSUNX();
}

// GL_SUN_global_alpha

static void REGAL_CALL missing_glGlobalAlphaFactorbSUN(GLbyte factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "Called missing function glGlobalAlphaFactorbSUN" );
}

static void REGAL_CALL loader_glGlobalAlphaFactorbSUN(GLbyte factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGlobalAlphaFactorbSUN, "glGlobalAlphaFactorbSUN");
   if ( !driverTbl.glGlobalAlphaFactorbSUN ) {
      driverTbl.glGlobalAlphaFactorbSUN = missing_glGlobalAlphaFactorbSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGlobalAlphaFactorbSUN == loader_glGlobalAlphaFactorbSUN) {
      rCtx->dsp.emuTbl.glGlobalAlphaFactorbSUN = driverTbl.glGlobalAlphaFactorbSUN;
   }
   driverTbl.glGlobalAlphaFactorbSUN(factor);
}

static void REGAL_CALL missing_glGlobalAlphaFactorsSUN(GLshort factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "Called missing function glGlobalAlphaFactorsSUN" );
}

static void REGAL_CALL loader_glGlobalAlphaFactorsSUN(GLshort factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGlobalAlphaFactorsSUN, "glGlobalAlphaFactorsSUN");
   if ( !driverTbl.glGlobalAlphaFactorsSUN ) {
      driverTbl.glGlobalAlphaFactorsSUN = missing_glGlobalAlphaFactorsSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGlobalAlphaFactorsSUN == loader_glGlobalAlphaFactorsSUN) {
      rCtx->dsp.emuTbl.glGlobalAlphaFactorsSUN = driverTbl.glGlobalAlphaFactorsSUN;
   }
   driverTbl.glGlobalAlphaFactorsSUN(factor);
}

static void REGAL_CALL missing_glGlobalAlphaFactoriSUN(GLint factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "Called missing function glGlobalAlphaFactoriSUN" );
}

static void REGAL_CALL loader_glGlobalAlphaFactoriSUN(GLint factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGlobalAlphaFactoriSUN, "glGlobalAlphaFactoriSUN");
   if ( !driverTbl.glGlobalAlphaFactoriSUN ) {
      driverTbl.glGlobalAlphaFactoriSUN = missing_glGlobalAlphaFactoriSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGlobalAlphaFactoriSUN == loader_glGlobalAlphaFactoriSUN) {
      rCtx->dsp.emuTbl.glGlobalAlphaFactoriSUN = driverTbl.glGlobalAlphaFactoriSUN;
   }
   driverTbl.glGlobalAlphaFactoriSUN(factor);
}

static void REGAL_CALL missing_glGlobalAlphaFactorfSUN(GLfloat factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "Called missing function glGlobalAlphaFactorfSUN" );
}

static void REGAL_CALL loader_glGlobalAlphaFactorfSUN(GLfloat factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGlobalAlphaFactorfSUN, "glGlobalAlphaFactorfSUN");
   if ( !driverTbl.glGlobalAlphaFactorfSUN ) {
      driverTbl.glGlobalAlphaFactorfSUN = missing_glGlobalAlphaFactorfSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGlobalAlphaFactorfSUN == loader_glGlobalAlphaFactorfSUN) {
      rCtx->dsp.emuTbl.glGlobalAlphaFactorfSUN = driverTbl.glGlobalAlphaFactorfSUN;
   }
   driverTbl.glGlobalAlphaFactorfSUN(factor);
}

static void REGAL_CALL missing_glGlobalAlphaFactordSUN(GLdouble factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "Called missing function glGlobalAlphaFactordSUN" );
}

static void REGAL_CALL loader_glGlobalAlphaFactordSUN(GLdouble factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGlobalAlphaFactordSUN, "glGlobalAlphaFactordSUN");
   if ( !driverTbl.glGlobalAlphaFactordSUN ) {
      driverTbl.glGlobalAlphaFactordSUN = missing_glGlobalAlphaFactordSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGlobalAlphaFactordSUN == loader_glGlobalAlphaFactordSUN) {
      rCtx->dsp.emuTbl.glGlobalAlphaFactordSUN = driverTbl.glGlobalAlphaFactordSUN;
   }
   driverTbl.glGlobalAlphaFactordSUN(factor);
}

static void REGAL_CALL missing_glGlobalAlphaFactorubSUN(GLubyte factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "Called missing function glGlobalAlphaFactorubSUN" );
}

static void REGAL_CALL loader_glGlobalAlphaFactorubSUN(GLubyte factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGlobalAlphaFactorubSUN, "glGlobalAlphaFactorubSUN");
   if ( !driverTbl.glGlobalAlphaFactorubSUN ) {
      driverTbl.glGlobalAlphaFactorubSUN = missing_glGlobalAlphaFactorubSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGlobalAlphaFactorubSUN == loader_glGlobalAlphaFactorubSUN) {
      rCtx->dsp.emuTbl.glGlobalAlphaFactorubSUN = driverTbl.glGlobalAlphaFactorubSUN;
   }
   driverTbl.glGlobalAlphaFactorubSUN(factor);
}

static void REGAL_CALL missing_glGlobalAlphaFactorusSUN(GLushort factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "Called missing function glGlobalAlphaFactorusSUN" );
}

static void REGAL_CALL loader_glGlobalAlphaFactorusSUN(GLushort factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGlobalAlphaFactorusSUN, "glGlobalAlphaFactorusSUN");
   if ( !driverTbl.glGlobalAlphaFactorusSUN ) {
      driverTbl.glGlobalAlphaFactorusSUN = missing_glGlobalAlphaFactorusSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGlobalAlphaFactorusSUN == loader_glGlobalAlphaFactorusSUN) {
      rCtx->dsp.emuTbl.glGlobalAlphaFactorusSUN = driverTbl.glGlobalAlphaFactorusSUN;
   }
   driverTbl.glGlobalAlphaFactorusSUN(factor);
}

static void REGAL_CALL missing_glGlobalAlphaFactoruiSUN(GLuint factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "Called missing function glGlobalAlphaFactoruiSUN" );
}

static void REGAL_CALL loader_glGlobalAlphaFactoruiSUN(GLuint factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGlobalAlphaFactoruiSUN, "glGlobalAlphaFactoruiSUN");
   if ( !driverTbl.glGlobalAlphaFactoruiSUN ) {
      driverTbl.glGlobalAlphaFactoruiSUN = missing_glGlobalAlphaFactoruiSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGlobalAlphaFactoruiSUN == loader_glGlobalAlphaFactoruiSUN) {
      rCtx->dsp.emuTbl.glGlobalAlphaFactoruiSUN = driverTbl.glGlobalAlphaFactoruiSUN;
   }
   driverTbl.glGlobalAlphaFactoruiSUN(factor);
}

// GL_SUN_triangle_list

static void REGAL_CALL missing_glReplacementCodeuiSUN(GLuint code)
{
   UNUSED_PARAMETER(code);
   Warning( "Called missing function glReplacementCodeuiSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiSUN(GLuint code)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiSUN, "glReplacementCodeuiSUN");
   if ( !driverTbl.glReplacementCodeuiSUN ) {
      driverTbl.glReplacementCodeuiSUN = missing_glReplacementCodeuiSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiSUN == loader_glReplacementCodeuiSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiSUN = driverTbl.glReplacementCodeuiSUN;
   }
   driverTbl.glReplacementCodeuiSUN(code);
}

static void REGAL_CALL missing_glReplacementCodeusSUN(GLushort code)
{
   UNUSED_PARAMETER(code);
   Warning( "Called missing function glReplacementCodeusSUN" );
}

static void REGAL_CALL loader_glReplacementCodeusSUN(GLushort code)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeusSUN, "glReplacementCodeusSUN");
   if ( !driverTbl.glReplacementCodeusSUN ) {
      driverTbl.glReplacementCodeusSUN = missing_glReplacementCodeusSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeusSUN == loader_glReplacementCodeusSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeusSUN = driverTbl.glReplacementCodeusSUN;
   }
   driverTbl.glReplacementCodeusSUN(code);
}

static void REGAL_CALL missing_glReplacementCodeubSUN(GLubyte code)
{
   UNUSED_PARAMETER(code);
   Warning( "Called missing function glReplacementCodeubSUN" );
}

static void REGAL_CALL loader_glReplacementCodeubSUN(GLubyte code)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeubSUN, "glReplacementCodeubSUN");
   if ( !driverTbl.glReplacementCodeubSUN ) {
      driverTbl.glReplacementCodeubSUN = missing_glReplacementCodeubSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeubSUN == loader_glReplacementCodeubSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeubSUN = driverTbl.glReplacementCodeubSUN;
   }
   driverTbl.glReplacementCodeubSUN(code);
}

static void REGAL_CALL missing_glReplacementCodeuivSUN(const GLuint *code)
{
   UNUSED_PARAMETER(code);
   Warning( "Called missing function glReplacementCodeuivSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuivSUN(const GLuint *code)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuivSUN, "glReplacementCodeuivSUN");
   if ( !driverTbl.glReplacementCodeuivSUN ) {
      driverTbl.glReplacementCodeuivSUN = missing_glReplacementCodeuivSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuivSUN == loader_glReplacementCodeuivSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuivSUN = driverTbl.glReplacementCodeuivSUN;
   }
   driverTbl.glReplacementCodeuivSUN(code);
}

static void REGAL_CALL missing_glReplacementCodeusvSUN(const GLushort *code)
{
   UNUSED_PARAMETER(code);
   Warning( "Called missing function glReplacementCodeusvSUN" );
}

static void REGAL_CALL loader_glReplacementCodeusvSUN(const GLushort *code)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeusvSUN, "glReplacementCodeusvSUN");
   if ( !driverTbl.glReplacementCodeusvSUN ) {
      driverTbl.glReplacementCodeusvSUN = missing_glReplacementCodeusvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeusvSUN == loader_glReplacementCodeusvSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeusvSUN = driverTbl.glReplacementCodeusvSUN;
   }
   driverTbl.glReplacementCodeusvSUN(code);
}

static void REGAL_CALL missing_glReplacementCodeubvSUN(const GLubyte *code)
{
   UNUSED_PARAMETER(code);
   Warning( "Called missing function glReplacementCodeubvSUN" );
}

static void REGAL_CALL loader_glReplacementCodeubvSUN(const GLubyte *code)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeubvSUN, "glReplacementCodeubvSUN");
   if ( !driverTbl.glReplacementCodeubvSUN ) {
      driverTbl.glReplacementCodeubvSUN = missing_glReplacementCodeubvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeubvSUN == loader_glReplacementCodeubvSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeubvSUN = driverTbl.glReplacementCodeubvSUN;
   }
   driverTbl.glReplacementCodeubvSUN(code);
}

static void REGAL_CALL missing_glReplacementCodePointerSUN(GLenum type, GLsizei stride, const GLvoid **pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glReplacementCodePointerSUN" );
}

static void REGAL_CALL loader_glReplacementCodePointerSUN(GLenum type, GLsizei stride, const GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodePointerSUN, "glReplacementCodePointerSUN");
   if ( !driverTbl.glReplacementCodePointerSUN ) {
      driverTbl.glReplacementCodePointerSUN = missing_glReplacementCodePointerSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodePointerSUN == loader_glReplacementCodePointerSUN) {
      rCtx->dsp.emuTbl.glReplacementCodePointerSUN = driverTbl.glReplacementCodePointerSUN;
   }
   driverTbl.glReplacementCodePointerSUN(type, stride, pointer);
}

// GL_SUN_vertex

static void REGAL_CALL missing_glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glColor4ubVertex2fSUN" );
}

static void REGAL_CALL loader_glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4ubVertex2fSUN, "glColor4ubVertex2fSUN");
   if ( !driverTbl.glColor4ubVertex2fSUN ) {
      driverTbl.glColor4ubVertex2fSUN = missing_glColor4ubVertex2fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4ubVertex2fSUN == loader_glColor4ubVertex2fSUN) {
      rCtx->dsp.emuTbl.glColor4ubVertex2fSUN = driverTbl.glColor4ubVertex2fSUN;
   }
   driverTbl.glColor4ubVertex2fSUN(r, g, b, a, x, y);
}

static void REGAL_CALL missing_glColor4ubVertex2fvSUN(const GLubyte *c, const GLfloat *v)
{
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor4ubVertex2fvSUN" );
}

static void REGAL_CALL loader_glColor4ubVertex2fvSUN(const GLubyte *c, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4ubVertex2fvSUN, "glColor4ubVertex2fvSUN");
   if ( !driverTbl.glColor4ubVertex2fvSUN ) {
      driverTbl.glColor4ubVertex2fvSUN = missing_glColor4ubVertex2fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4ubVertex2fvSUN == loader_glColor4ubVertex2fvSUN) {
      rCtx->dsp.emuTbl.glColor4ubVertex2fvSUN = driverTbl.glColor4ubVertex2fvSUN;
   }
   driverTbl.glColor4ubVertex2fvSUN(c, v);
}

static void REGAL_CALL missing_glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glColor4ubVertex3fSUN" );
}

static void REGAL_CALL loader_glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4ubVertex3fSUN, "glColor4ubVertex3fSUN");
   if ( !driverTbl.glColor4ubVertex3fSUN ) {
      driverTbl.glColor4ubVertex3fSUN = missing_glColor4ubVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4ubVertex3fSUN == loader_glColor4ubVertex3fSUN) {
      rCtx->dsp.emuTbl.glColor4ubVertex3fSUN = driverTbl.glColor4ubVertex3fSUN;
   }
   driverTbl.glColor4ubVertex3fSUN(r, g, b, a, x, y, z);
}

static void REGAL_CALL missing_glColor4ubVertex3fvSUN(const GLubyte *c, const GLfloat *v)
{
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor4ubVertex3fvSUN" );
}

static void REGAL_CALL loader_glColor4ubVertex3fvSUN(const GLubyte *c, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4ubVertex3fvSUN, "glColor4ubVertex3fvSUN");
   if ( !driverTbl.glColor4ubVertex3fvSUN ) {
      driverTbl.glColor4ubVertex3fvSUN = missing_glColor4ubVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4ubVertex3fvSUN == loader_glColor4ubVertex3fvSUN) {
      rCtx->dsp.emuTbl.glColor4ubVertex3fvSUN = driverTbl.glColor4ubVertex3fvSUN;
   }
   driverTbl.glColor4ubVertex3fvSUN(c, v);
}

static void REGAL_CALL missing_glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glColor3fVertex3fSUN" );
}

static void REGAL_CALL loader_glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3fVertex3fSUN, "glColor3fVertex3fSUN");
   if ( !driverTbl.glColor3fVertex3fSUN ) {
      driverTbl.glColor3fVertex3fSUN = missing_glColor3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3fVertex3fSUN == loader_glColor3fVertex3fSUN) {
      rCtx->dsp.emuTbl.glColor3fVertex3fSUN = driverTbl.glColor3fVertex3fSUN;
   }
   driverTbl.glColor3fVertex3fSUN(r, g, b, x, y, z);
}

static void REGAL_CALL missing_glColor3fVertex3fvSUN(const GLfloat *c, const GLfloat *v)
{
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor3fVertex3fvSUN" );
}

static void REGAL_CALL loader_glColor3fVertex3fvSUN(const GLfloat *c, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3fVertex3fvSUN, "glColor3fVertex3fvSUN");
   if ( !driverTbl.glColor3fVertex3fvSUN ) {
      driverTbl.glColor3fVertex3fvSUN = missing_glColor3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3fVertex3fvSUN == loader_glColor3fVertex3fvSUN) {
      rCtx->dsp.emuTbl.glColor3fVertex3fvSUN = driverTbl.glColor3fVertex3fvSUN;
   }
   driverTbl.glColor3fVertex3fvSUN(c, v);
}

static void REGAL_CALL missing_glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glNormal3fVertex3fSUN" );
}

static void REGAL_CALL loader_glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormal3fVertex3fSUN, "glNormal3fVertex3fSUN");
   if ( !driverTbl.glNormal3fVertex3fSUN ) {
      driverTbl.glNormal3fVertex3fSUN = missing_glNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormal3fVertex3fSUN == loader_glNormal3fVertex3fSUN) {
      rCtx->dsp.emuTbl.glNormal3fVertex3fSUN = driverTbl.glNormal3fVertex3fSUN;
   }
   driverTbl.glNormal3fVertex3fSUN(nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glNormal3fVertex3fvSUN(const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glNormal3fVertex3fvSUN" );
}

static void REGAL_CALL loader_glNormal3fVertex3fvSUN(const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormal3fVertex3fvSUN, "glNormal3fVertex3fvSUN");
   if ( !driverTbl.glNormal3fVertex3fvSUN ) {
      driverTbl.glNormal3fVertex3fvSUN = missing_glNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormal3fVertex3fvSUN == loader_glNormal3fVertex3fvSUN) {
      rCtx->dsp.emuTbl.glNormal3fVertex3fvSUN = driverTbl.glNormal3fVertex3fvSUN;
   }
   driverTbl.glNormal3fVertex3fvSUN(n, v);
}

static void REGAL_CALL missing_glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glColor4fNormal3fVertex3fSUN" );
}

static void REGAL_CALL loader_glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4fNormal3fVertex3fSUN, "glColor4fNormal3fVertex3fSUN");
   if ( !driverTbl.glColor4fNormal3fVertex3fSUN ) {
      driverTbl.glColor4fNormal3fVertex3fSUN = missing_glColor4fNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4fNormal3fVertex3fSUN == loader_glColor4fNormal3fVertex3fSUN) {
      rCtx->dsp.emuTbl.glColor4fNormal3fVertex3fSUN = driverTbl.glColor4fNormal3fVertex3fSUN;
   }
   driverTbl.glColor4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glColor4fNormal3fVertex3fvSUN(const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor4fNormal3fVertex3fvSUN" );
}

static void REGAL_CALL loader_glColor4fNormal3fVertex3fvSUN(const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4fNormal3fVertex3fvSUN, "glColor4fNormal3fVertex3fvSUN");
   if ( !driverTbl.glColor4fNormal3fVertex3fvSUN ) {
      driverTbl.glColor4fNormal3fVertex3fvSUN = missing_glColor4fNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4fNormal3fVertex3fvSUN == loader_glColor4fNormal3fVertex3fvSUN) {
      rCtx->dsp.emuTbl.glColor4fNormal3fVertex3fvSUN = driverTbl.glColor4fNormal3fVertex3fvSUN;
   }
   driverTbl.glColor4fNormal3fVertex3fvSUN(c, n, v);
}

static void REGAL_CALL missing_glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glTexCoord2fVertex3fSUN" );
}

static void REGAL_CALL loader_glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2fVertex3fSUN, "glTexCoord2fVertex3fSUN");
   if ( !driverTbl.glTexCoord2fVertex3fSUN ) {
      driverTbl.glTexCoord2fVertex3fSUN = missing_glTexCoord2fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2fVertex3fSUN == loader_glTexCoord2fVertex3fSUN) {
      rCtx->dsp.emuTbl.glTexCoord2fVertex3fSUN = driverTbl.glTexCoord2fVertex3fSUN;
   }
   driverTbl.glTexCoord2fVertex3fSUN(s, t, x, y, z);
}

static void REGAL_CALL missing_glTexCoord2fVertex3fvSUN(const GLfloat *tc, const GLfloat *v)
{
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord2fVertex3fvSUN" );
}

static void REGAL_CALL loader_glTexCoord2fVertex3fvSUN(const GLfloat *tc, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2fVertex3fvSUN, "glTexCoord2fVertex3fvSUN");
   if ( !driverTbl.glTexCoord2fVertex3fvSUN ) {
      driverTbl.glTexCoord2fVertex3fvSUN = missing_glTexCoord2fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2fVertex3fvSUN == loader_glTexCoord2fVertex3fvSUN) {
      rCtx->dsp.emuTbl.glTexCoord2fVertex3fvSUN = driverTbl.glTexCoord2fVertex3fvSUN;
   }
   driverTbl.glTexCoord2fVertex3fvSUN(tc, v);
}

static void REGAL_CALL missing_glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(p);
   UNUSED_PARAMETER(q);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glTexCoord4fVertex4fSUN" );
}

static void REGAL_CALL loader_glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord4fVertex4fSUN, "glTexCoord4fVertex4fSUN");
   if ( !driverTbl.glTexCoord4fVertex4fSUN ) {
      driverTbl.glTexCoord4fVertex4fSUN = missing_glTexCoord4fVertex4fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord4fVertex4fSUN == loader_glTexCoord4fVertex4fSUN) {
      rCtx->dsp.emuTbl.glTexCoord4fVertex4fSUN = driverTbl.glTexCoord4fVertex4fSUN;
   }
   driverTbl.glTexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);
}

static void REGAL_CALL missing_glTexCoord4fVertex4fvSUN(const GLfloat *tc, const GLfloat *v)
{
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord4fVertex4fvSUN" );
}

static void REGAL_CALL loader_glTexCoord4fVertex4fvSUN(const GLfloat *tc, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord4fVertex4fvSUN, "glTexCoord4fVertex4fvSUN");
   if ( !driverTbl.glTexCoord4fVertex4fvSUN ) {
      driverTbl.glTexCoord4fVertex4fvSUN = missing_glTexCoord4fVertex4fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord4fVertex4fvSUN == loader_glTexCoord4fVertex4fvSUN) {
      rCtx->dsp.emuTbl.glTexCoord4fVertex4fvSUN = driverTbl.glTexCoord4fVertex4fvSUN;
   }
   driverTbl.glTexCoord4fVertex4fvSUN(tc, v);
}

static void REGAL_CALL missing_glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glTexCoord2fColor4ubVertex3fSUN" );
}

static void REGAL_CALL loader_glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2fColor4ubVertex3fSUN, "glTexCoord2fColor4ubVertex3fSUN");
   if ( !driverTbl.glTexCoord2fColor4ubVertex3fSUN ) {
      driverTbl.glTexCoord2fColor4ubVertex3fSUN = missing_glTexCoord2fColor4ubVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2fColor4ubVertex3fSUN == loader_glTexCoord2fColor4ubVertex3fSUN) {
      rCtx->dsp.emuTbl.glTexCoord2fColor4ubVertex3fSUN = driverTbl.glTexCoord2fColor4ubVertex3fSUN;
   }
   driverTbl.glTexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);
}

static void REGAL_CALL missing_glTexCoord2fColor4ubVertex3fvSUN(const GLfloat *tc, const GLubyte *c, const GLfloat *v)
{
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord2fColor4ubVertex3fvSUN" );
}

static void REGAL_CALL loader_glTexCoord2fColor4ubVertex3fvSUN(const GLfloat *tc, const GLubyte *c, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2fColor4ubVertex3fvSUN, "glTexCoord2fColor4ubVertex3fvSUN");
   if ( !driverTbl.glTexCoord2fColor4ubVertex3fvSUN ) {
      driverTbl.glTexCoord2fColor4ubVertex3fvSUN = missing_glTexCoord2fColor4ubVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2fColor4ubVertex3fvSUN == loader_glTexCoord2fColor4ubVertex3fvSUN) {
      rCtx->dsp.emuTbl.glTexCoord2fColor4ubVertex3fvSUN = driverTbl.glTexCoord2fColor4ubVertex3fvSUN;
   }
   driverTbl.glTexCoord2fColor4ubVertex3fvSUN(tc, c, v);
}

static void REGAL_CALL missing_glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glTexCoord2fColor3fVertex3fSUN" );
}

static void REGAL_CALL loader_glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2fColor3fVertex3fSUN, "glTexCoord2fColor3fVertex3fSUN");
   if ( !driverTbl.glTexCoord2fColor3fVertex3fSUN ) {
      driverTbl.glTexCoord2fColor3fVertex3fSUN = missing_glTexCoord2fColor3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2fColor3fVertex3fSUN == loader_glTexCoord2fColor3fVertex3fSUN) {
      rCtx->dsp.emuTbl.glTexCoord2fColor3fVertex3fSUN = driverTbl.glTexCoord2fColor3fVertex3fSUN;
   }
   driverTbl.glTexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);
}

static void REGAL_CALL missing_glTexCoord2fColor3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *v)
{
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord2fColor3fVertex3fvSUN" );
}

static void REGAL_CALL loader_glTexCoord2fColor3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2fColor3fVertex3fvSUN, "glTexCoord2fColor3fVertex3fvSUN");
   if ( !driverTbl.glTexCoord2fColor3fVertex3fvSUN ) {
      driverTbl.glTexCoord2fColor3fVertex3fvSUN = missing_glTexCoord2fColor3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2fColor3fVertex3fvSUN == loader_glTexCoord2fColor3fVertex3fvSUN) {
      rCtx->dsp.emuTbl.glTexCoord2fColor3fVertex3fvSUN = driverTbl.glTexCoord2fColor3fVertex3fvSUN;
   }
   driverTbl.glTexCoord2fColor3fVertex3fvSUN(tc, c, v);
}

static void REGAL_CALL missing_glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glTexCoord2fNormal3fVertex3fSUN" );
}

static void REGAL_CALL loader_glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2fNormal3fVertex3fSUN, "glTexCoord2fNormal3fVertex3fSUN");
   if ( !driverTbl.glTexCoord2fNormal3fVertex3fSUN ) {
      driverTbl.glTexCoord2fNormal3fVertex3fSUN = missing_glTexCoord2fNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2fNormal3fVertex3fSUN == loader_glTexCoord2fNormal3fVertex3fSUN) {
      rCtx->dsp.emuTbl.glTexCoord2fNormal3fVertex3fSUN = driverTbl.glTexCoord2fNormal3fVertex3fSUN;
   }
   driverTbl.glTexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glTexCoord2fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord2fNormal3fVertex3fvSUN" );
}

static void REGAL_CALL loader_glTexCoord2fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2fNormal3fVertex3fvSUN, "glTexCoord2fNormal3fVertex3fvSUN");
   if ( !driverTbl.glTexCoord2fNormal3fVertex3fvSUN ) {
      driverTbl.glTexCoord2fNormal3fVertex3fvSUN = missing_glTexCoord2fNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2fNormal3fVertex3fvSUN == loader_glTexCoord2fNormal3fVertex3fvSUN) {
      rCtx->dsp.emuTbl.glTexCoord2fNormal3fVertex3fvSUN = driverTbl.glTexCoord2fNormal3fVertex3fvSUN;
   }
   driverTbl.glTexCoord2fNormal3fVertex3fvSUN(tc, n, v);
}

static void REGAL_CALL missing_glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glTexCoord2fColor4fNormal3fVertex3fSUN" );
}

static void REGAL_CALL loader_glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2fColor4fNormal3fVertex3fSUN, "glTexCoord2fColor4fNormal3fVertex3fSUN");
   if ( !driverTbl.glTexCoord2fColor4fNormal3fVertex3fSUN ) {
      driverTbl.glTexCoord2fColor4fNormal3fVertex3fSUN = missing_glTexCoord2fColor4fNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2fColor4fNormal3fVertex3fSUN == loader_glTexCoord2fColor4fNormal3fVertex3fSUN) {
      rCtx->dsp.emuTbl.glTexCoord2fColor4fNormal3fVertex3fSUN = driverTbl.glTexCoord2fColor4fNormal3fVertex3fSUN;
   }
   driverTbl.glTexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord2fColor4fNormal3fVertex3fvSUN" );
}

static void REGAL_CALL loader_glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2fColor4fNormal3fVertex3fvSUN, "glTexCoord2fColor4fNormal3fVertex3fvSUN");
   if ( !driverTbl.glTexCoord2fColor4fNormal3fVertex3fvSUN ) {
      driverTbl.glTexCoord2fColor4fNormal3fVertex3fvSUN = missing_glTexCoord2fColor4fNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2fColor4fNormal3fVertex3fvSUN == loader_glTexCoord2fColor4fNormal3fVertex3fvSUN) {
      rCtx->dsp.emuTbl.glTexCoord2fColor4fNormal3fVertex3fvSUN = driverTbl.glTexCoord2fColor4fNormal3fVertex3fvSUN;
   }
   driverTbl.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v);
}

static void REGAL_CALL missing_glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(p);
   UNUSED_PARAMETER(q);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glTexCoord4fColor4fNormal3fVertex4fSUN" );
}

static void REGAL_CALL loader_glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord4fColor4fNormal3fVertex4fSUN, "glTexCoord4fColor4fNormal3fVertex4fSUN");
   if ( !driverTbl.glTexCoord4fColor4fNormal3fVertex4fSUN ) {
      driverTbl.glTexCoord4fColor4fNormal3fVertex4fSUN = missing_glTexCoord4fColor4fNormal3fVertex4fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord4fColor4fNormal3fVertex4fSUN == loader_glTexCoord4fColor4fNormal3fVertex4fSUN) {
      rCtx->dsp.emuTbl.glTexCoord4fColor4fNormal3fVertex4fSUN = driverTbl.glTexCoord4fColor4fNormal3fVertex4fSUN;
   }
   driverTbl.glTexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
}

static void REGAL_CALL missing_glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord4fColor4fNormal3fVertex4fvSUN" );
}

static void REGAL_CALL loader_glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord4fColor4fNormal3fVertex4fvSUN, "glTexCoord4fColor4fNormal3fVertex4fvSUN");
   if ( !driverTbl.glTexCoord4fColor4fNormal3fVertex4fvSUN ) {
      driverTbl.glTexCoord4fColor4fNormal3fVertex4fvSUN = missing_glTexCoord4fColor4fNormal3fVertex4fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord4fColor4fNormal3fVertex4fvSUN == loader_glTexCoord4fColor4fNormal3fVertex4fvSUN) {
      rCtx->dsp.emuTbl.glTexCoord4fColor4fNormal3fVertex4fvSUN = driverTbl.glTexCoord4fColor4fNormal3fVertex4fvSUN;
   }
   driverTbl.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v);
}

static void REGAL_CALL missing_glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glReplacementCodeuiVertex3fSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiVertex3fSUN, "glReplacementCodeuiVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiVertex3fSUN ) {
      driverTbl.glReplacementCodeuiVertex3fSUN = missing_glReplacementCodeuiVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiVertex3fSUN == loader_glReplacementCodeuiVertex3fSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiVertex3fSUN = driverTbl.glReplacementCodeuiVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiVertex3fSUN(rc, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiVertex3fvSUN(const GLuint *rc, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glReplacementCodeuiVertex3fvSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiVertex3fvSUN(const GLuint *rc, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiVertex3fvSUN, "glReplacementCodeuiVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiVertex3fvSUN = missing_glReplacementCodeuiVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiVertex3fvSUN == loader_glReplacementCodeuiVertex3fvSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiVertex3fvSUN = driverTbl.glReplacementCodeuiVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiVertex3fvSUN(rc, v);
}

static void REGAL_CALL missing_glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glReplacementCodeuiColor4ubVertex3fSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiColor4ubVertex3fSUN, "glReplacementCodeuiColor4ubVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiColor4ubVertex3fSUN ) {
      driverTbl.glReplacementCodeuiColor4ubVertex3fSUN = missing_glReplacementCodeuiColor4ubVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiColor4ubVertex3fSUN == loader_glReplacementCodeuiColor4ubVertex3fSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiColor4ubVertex3fSUN = driverTbl.glReplacementCodeuiColor4ubVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint *rc, const GLubyte *c, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glReplacementCodeuiColor4ubVertex3fvSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint *rc, const GLubyte *c, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiColor4ubVertex3fvSUN, "glReplacementCodeuiColor4ubVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiColor4ubVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiColor4ubVertex3fvSUN = missing_glReplacementCodeuiColor4ubVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiColor4ubVertex3fvSUN == loader_glReplacementCodeuiColor4ubVertex3fvSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiColor4ubVertex3fvSUN = driverTbl.glReplacementCodeuiColor4ubVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v);
}

static void REGAL_CALL missing_glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glReplacementCodeuiColor3fVertex3fSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiColor3fVertex3fSUN, "glReplacementCodeuiColor3fVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiColor3fVertex3fSUN ) {
      driverTbl.glReplacementCodeuiColor3fVertex3fSUN = missing_glReplacementCodeuiColor3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiColor3fVertex3fSUN == loader_glReplacementCodeuiColor3fVertex3fSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiColor3fVertex3fSUN = driverTbl.glReplacementCodeuiColor3fVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiColor3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glReplacementCodeuiColor3fVertex3fvSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiColor3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiColor3fVertex3fvSUN, "glReplacementCodeuiColor3fVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiColor3fVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiColor3fVertex3fvSUN = missing_glReplacementCodeuiColor3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiColor3fVertex3fvSUN == loader_glReplacementCodeuiColor3fVertex3fvSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiColor3fVertex3fvSUN = driverTbl.glReplacementCodeuiColor3fVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiColor3fVertex3fvSUN(rc, c, v);
}

static void REGAL_CALL missing_glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glReplacementCodeuiNormal3fVertex3fSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiNormal3fVertex3fSUN, "glReplacementCodeuiNormal3fVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiNormal3fVertex3fSUN ) {
      driverTbl.glReplacementCodeuiNormal3fVertex3fSUN = missing_glReplacementCodeuiNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiNormal3fVertex3fSUN == loader_glReplacementCodeuiNormal3fVertex3fSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiNormal3fVertex3fSUN = driverTbl.glReplacementCodeuiNormal3fVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glReplacementCodeuiNormal3fVertex3fvSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiNormal3fVertex3fvSUN, "glReplacementCodeuiNormal3fVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiNormal3fVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiNormal3fVertex3fvSUN = missing_glReplacementCodeuiNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiNormal3fVertex3fvSUN == loader_glReplacementCodeuiNormal3fVertex3fvSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiNormal3fVertex3fvSUN = driverTbl.glReplacementCodeuiNormal3fVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v);
}

static void REGAL_CALL missing_glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glReplacementCodeuiColor4fNormal3fVertex3fSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN, "glReplacementCodeuiColor4fNormal3fVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN ) {
      driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN = missing_glReplacementCodeuiColor4fNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN == loader_glReplacementCodeuiColor4fNormal3fVertex3fSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN = driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glReplacementCodeuiColor4fNormal3fVertex3fvSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN, "glReplacementCodeuiColor4fNormal3fVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN = missing_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN == loader_glReplacementCodeuiColor4fNormal3fVertex3fvSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN = driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v);
}

static void REGAL_CALL missing_glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glReplacementCodeuiTexCoord2fVertex3fSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiTexCoord2fVertex3fSUN, "glReplacementCodeuiTexCoord2fVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiTexCoord2fVertex3fSUN ) {
      driverTbl.glReplacementCodeuiTexCoord2fVertex3fSUN = missing_glReplacementCodeuiTexCoord2fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiTexCoord2fVertex3fSUN == loader_glReplacementCodeuiTexCoord2fVertex3fSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiTexCoord2fVertex3fSUN = driverTbl.glReplacementCodeuiTexCoord2fVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glReplacementCodeuiTexCoord2fVertex3fvSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiTexCoord2fVertex3fvSUN, "glReplacementCodeuiTexCoord2fVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiTexCoord2fVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiTexCoord2fVertex3fvSUN = missing_glReplacementCodeuiTexCoord2fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiTexCoord2fVertex3fvSUN == loader_glReplacementCodeuiTexCoord2fVertex3fvSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiTexCoord2fVertex3fvSUN = driverTbl.glReplacementCodeuiTexCoord2fVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v);
}

static void REGAL_CALL missing_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN, "glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN ) {
      driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = missing_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN == loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN, "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = missing_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN == loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v);
}

static void REGAL_CALL missing_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN, "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN ) {
      driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = missing_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN == loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN" );
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN, "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = missing_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN == loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN) {
      rCtx->dsp.emuTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v);
}

// GL_EXT_blend_func_separate

static void REGAL_CALL missing_glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
   UNUSED_PARAMETER(sfactorRGB);
   UNUSED_PARAMETER(dfactorRGB);
   UNUSED_PARAMETER(sfactorAlpha);
   UNUSED_PARAMETER(dfactorAlpha);
   Warning( "Called missing function glBlendFuncSeparateEXT" );
}

static void REGAL_CALL loader_glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendFuncSeparateEXT, "glBlendFuncSeparateEXT");
   if ( !driverTbl.glBlendFuncSeparateEXT ) {
      driverTbl.glBlendFuncSeparateEXT = missing_glBlendFuncSeparateEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendFuncSeparateEXT == loader_glBlendFuncSeparateEXT) {
      rCtx->dsp.emuTbl.glBlendFuncSeparateEXT = driverTbl.glBlendFuncSeparateEXT;
   }
   driverTbl.glBlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

// GL_INGR_blend_func_separate

static void REGAL_CALL missing_glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
   UNUSED_PARAMETER(sfactorRGB);
   UNUSED_PARAMETER(dfactorRGB);
   UNUSED_PARAMETER(sfactorAlpha);
   UNUSED_PARAMETER(dfactorAlpha);
   Warning( "Called missing function glBlendFuncSeparateINGR" );
}

static void REGAL_CALL loader_glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendFuncSeparateINGR, "glBlendFuncSeparateINGR");
   if ( !driverTbl.glBlendFuncSeparateINGR ) {
      driverTbl.glBlendFuncSeparateINGR = missing_glBlendFuncSeparateINGR;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendFuncSeparateINGR == loader_glBlendFuncSeparateINGR) {
      rCtx->dsp.emuTbl.glBlendFuncSeparateINGR = driverTbl.glBlendFuncSeparateINGR;
   }
   driverTbl.glBlendFuncSeparateINGR(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

// GL_EXT_vertex_weighting

static void REGAL_CALL missing_glVertexWeightfEXT(GLfloat weight)
{
   UNUSED_PARAMETER(weight);
   Warning( "Called missing function glVertexWeightfEXT" );
}

static void REGAL_CALL loader_glVertexWeightfEXT(GLfloat weight)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexWeightfEXT, "glVertexWeightfEXT");
   if ( !driverTbl.glVertexWeightfEXT ) {
      driverTbl.glVertexWeightfEXT = missing_glVertexWeightfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexWeightfEXT == loader_glVertexWeightfEXT) {
      rCtx->dsp.emuTbl.glVertexWeightfEXT = driverTbl.glVertexWeightfEXT;
   }
   driverTbl.glVertexWeightfEXT(weight);
}

static void REGAL_CALL missing_glVertexWeightfvEXT(const GLfloat *weight)
{
   UNUSED_PARAMETER(weight);
   Warning( "Called missing function glVertexWeightfvEXT" );
}

static void REGAL_CALL loader_glVertexWeightfvEXT(const GLfloat *weight)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexWeightfvEXT, "glVertexWeightfvEXT");
   if ( !driverTbl.glVertexWeightfvEXT ) {
      driverTbl.glVertexWeightfvEXT = missing_glVertexWeightfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexWeightfvEXT == loader_glVertexWeightfvEXT) {
      rCtx->dsp.emuTbl.glVertexWeightfvEXT = driverTbl.glVertexWeightfvEXT;
   }
   driverTbl.glVertexWeightfvEXT(weight);
}

static void REGAL_CALL missing_glVertexWeightPointerEXT(GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glVertexWeightPointerEXT" );
}

static void REGAL_CALL loader_glVertexWeightPointerEXT(GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexWeightPointerEXT, "glVertexWeightPointerEXT");
   if ( !driverTbl.glVertexWeightPointerEXT ) {
      driverTbl.glVertexWeightPointerEXT = missing_glVertexWeightPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexWeightPointerEXT == loader_glVertexWeightPointerEXT) {
      rCtx->dsp.emuTbl.glVertexWeightPointerEXT = driverTbl.glVertexWeightPointerEXT;
   }
   driverTbl.glVertexWeightPointerEXT(size, type, stride, pointer);
}

// GL_NV_vertex_array_range

static void REGAL_CALL missing_glFlushVertexArrayRangeNV(void)
{
   Warning( "Called missing function glFlushVertexArrayRangeNV" );
}

static void REGAL_CALL loader_glFlushVertexArrayRangeNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFlushVertexArrayRangeNV, "glFlushVertexArrayRangeNV");
   if ( !driverTbl.glFlushVertexArrayRangeNV ) {
      driverTbl.glFlushVertexArrayRangeNV = missing_glFlushVertexArrayRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFlushVertexArrayRangeNV == loader_glFlushVertexArrayRangeNV) {
      rCtx->dsp.emuTbl.glFlushVertexArrayRangeNV = driverTbl.glFlushVertexArrayRangeNV;
   }
   driverTbl.glFlushVertexArrayRangeNV();
}

static void REGAL_CALL missing_glVertexArrayRangeNV(GLsizei size, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glVertexArrayRangeNV" );
}

static void REGAL_CALL loader_glVertexArrayRangeNV(GLsizei size, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexArrayRangeNV, "glVertexArrayRangeNV");
   if ( !driverTbl.glVertexArrayRangeNV ) {
      driverTbl.glVertexArrayRangeNV = missing_glVertexArrayRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexArrayRangeNV == loader_glVertexArrayRangeNV) {
      rCtx->dsp.emuTbl.glVertexArrayRangeNV = driverTbl.glVertexArrayRangeNV;
   }
   driverTbl.glVertexArrayRangeNV(size, pointer);
}

// GL_NV_register_combiners

static void REGAL_CALL missing_glCombinerParameterfvNV(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glCombinerParameterfvNV" );
}

static void REGAL_CALL loader_glCombinerParameterfvNV(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCombinerParameterfvNV, "glCombinerParameterfvNV");
   if ( !driverTbl.glCombinerParameterfvNV ) {
      driverTbl.glCombinerParameterfvNV = missing_glCombinerParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCombinerParameterfvNV == loader_glCombinerParameterfvNV) {
      rCtx->dsp.emuTbl.glCombinerParameterfvNV = driverTbl.glCombinerParameterfvNV;
   }
   driverTbl.glCombinerParameterfvNV(pname, params);
}

static void REGAL_CALL missing_glCombinerParameterfNV(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glCombinerParameterfNV" );
}

static void REGAL_CALL loader_glCombinerParameterfNV(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCombinerParameterfNV, "glCombinerParameterfNV");
   if ( !driverTbl.glCombinerParameterfNV ) {
      driverTbl.glCombinerParameterfNV = missing_glCombinerParameterfNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCombinerParameterfNV == loader_glCombinerParameterfNV) {
      rCtx->dsp.emuTbl.glCombinerParameterfNV = driverTbl.glCombinerParameterfNV;
   }
   driverTbl.glCombinerParameterfNV(pname, param);
}

static void REGAL_CALL missing_glCombinerParameterivNV(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glCombinerParameterivNV" );
}

static void REGAL_CALL loader_glCombinerParameterivNV(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCombinerParameterivNV, "glCombinerParameterivNV");
   if ( !driverTbl.glCombinerParameterivNV ) {
      driverTbl.glCombinerParameterivNV = missing_glCombinerParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCombinerParameterivNV == loader_glCombinerParameterivNV) {
      rCtx->dsp.emuTbl.glCombinerParameterivNV = driverTbl.glCombinerParameterivNV;
   }
   driverTbl.glCombinerParameterivNV(pname, params);
}

static void REGAL_CALL missing_glCombinerParameteriNV(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glCombinerParameteriNV" );
}

static void REGAL_CALL loader_glCombinerParameteriNV(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCombinerParameteriNV, "glCombinerParameteriNV");
   if ( !driverTbl.glCombinerParameteriNV ) {
      driverTbl.glCombinerParameteriNV = missing_glCombinerParameteriNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCombinerParameteriNV == loader_glCombinerParameteriNV) {
      rCtx->dsp.emuTbl.glCombinerParameteriNV = driverTbl.glCombinerParameteriNV;
   }
   driverTbl.glCombinerParameteriNV(pname, param);
}

static void REGAL_CALL missing_glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(portion);
   UNUSED_PARAMETER(variable);
   UNUSED_PARAMETER(input);
   UNUSED_PARAMETER(mapping);
   UNUSED_PARAMETER(componentUsage);
   Warning( "Called missing function glCombinerInputNV" );
}

static void REGAL_CALL loader_glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCombinerInputNV, "glCombinerInputNV");
   if ( !driverTbl.glCombinerInputNV ) {
      driverTbl.glCombinerInputNV = missing_glCombinerInputNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCombinerInputNV == loader_glCombinerInputNV) {
      rCtx->dsp.emuTbl.glCombinerInputNV = driverTbl.glCombinerInputNV;
   }
   driverTbl.glCombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
}

static void REGAL_CALL missing_glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(portion);
   UNUSED_PARAMETER(abOutput);
   UNUSED_PARAMETER(cdOutput);
   UNUSED_PARAMETER(sumOutput);
   UNUSED_PARAMETER(scale);
   UNUSED_PARAMETER(bias);
   UNUSED_PARAMETER(abDotProduct);
   UNUSED_PARAMETER(cdDotProduct);
   UNUSED_PARAMETER(muxSum);
   Warning( "Called missing function glCombinerOutputNV" );
}

static void REGAL_CALL loader_glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCombinerOutputNV, "glCombinerOutputNV");
   if ( !driverTbl.glCombinerOutputNV ) {
      driverTbl.glCombinerOutputNV = missing_glCombinerOutputNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCombinerOutputNV == loader_glCombinerOutputNV) {
      rCtx->dsp.emuTbl.glCombinerOutputNV = driverTbl.glCombinerOutputNV;
   }
   driverTbl.glCombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
}

static void REGAL_CALL missing_glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
   UNUSED_PARAMETER(variable);
   UNUSED_PARAMETER(input);
   UNUSED_PARAMETER(mapping);
   UNUSED_PARAMETER(componentUsage);
   Warning( "Called missing function glFinalCombinerInputNV" );
}

static void REGAL_CALL loader_glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFinalCombinerInputNV, "glFinalCombinerInputNV");
   if ( !driverTbl.glFinalCombinerInputNV ) {
      driverTbl.glFinalCombinerInputNV = missing_glFinalCombinerInputNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFinalCombinerInputNV == loader_glFinalCombinerInputNV) {
      rCtx->dsp.emuTbl.glFinalCombinerInputNV = driverTbl.glFinalCombinerInputNV;
   }
   driverTbl.glFinalCombinerInputNV(variable, input, mapping, componentUsage);
}

static void REGAL_CALL missing_glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(portion);
   UNUSED_PARAMETER(variable);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetCombinerInputParameterfvNV" );
}

static void REGAL_CALL loader_glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetCombinerInputParameterfvNV, "glGetCombinerInputParameterfvNV");
   if ( !driverTbl.glGetCombinerInputParameterfvNV ) {
      driverTbl.glGetCombinerInputParameterfvNV = missing_glGetCombinerInputParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetCombinerInputParameterfvNV == loader_glGetCombinerInputParameterfvNV) {
      rCtx->dsp.emuTbl.glGetCombinerInputParameterfvNV = driverTbl.glGetCombinerInputParameterfvNV;
   }
   driverTbl.glGetCombinerInputParameterfvNV(stage, portion, variable, pname, params);
}

static void REGAL_CALL missing_glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(portion);
   UNUSED_PARAMETER(variable);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetCombinerInputParameterivNV" );
}

static void REGAL_CALL loader_glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetCombinerInputParameterivNV, "glGetCombinerInputParameterivNV");
   if ( !driverTbl.glGetCombinerInputParameterivNV ) {
      driverTbl.glGetCombinerInputParameterivNV = missing_glGetCombinerInputParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetCombinerInputParameterivNV == loader_glGetCombinerInputParameterivNV) {
      rCtx->dsp.emuTbl.glGetCombinerInputParameterivNV = driverTbl.glGetCombinerInputParameterivNV;
   }
   driverTbl.glGetCombinerInputParameterivNV(stage, portion, variable, pname, params);
}

static void REGAL_CALL missing_glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(portion);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetCombinerOutputParameterfvNV" );
}

static void REGAL_CALL loader_glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetCombinerOutputParameterfvNV, "glGetCombinerOutputParameterfvNV");
   if ( !driverTbl.glGetCombinerOutputParameterfvNV ) {
      driverTbl.glGetCombinerOutputParameterfvNV = missing_glGetCombinerOutputParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetCombinerOutputParameterfvNV == loader_glGetCombinerOutputParameterfvNV) {
      rCtx->dsp.emuTbl.glGetCombinerOutputParameterfvNV = driverTbl.glGetCombinerOutputParameterfvNV;
   }
   driverTbl.glGetCombinerOutputParameterfvNV(stage, portion, pname, params);
}

static void REGAL_CALL missing_glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(portion);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetCombinerOutputParameterivNV" );
}

static void REGAL_CALL loader_glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetCombinerOutputParameterivNV, "glGetCombinerOutputParameterivNV");
   if ( !driverTbl.glGetCombinerOutputParameterivNV ) {
      driverTbl.glGetCombinerOutputParameterivNV = missing_glGetCombinerOutputParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetCombinerOutputParameterivNV == loader_glGetCombinerOutputParameterivNV) {
      rCtx->dsp.emuTbl.glGetCombinerOutputParameterivNV = driverTbl.glGetCombinerOutputParameterivNV;
   }
   driverTbl.glGetCombinerOutputParameterivNV(stage, portion, pname, params);
}

static void REGAL_CALL missing_glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(variable);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFinalCombinerInputParameterfvNV" );
}

static void REGAL_CALL loader_glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFinalCombinerInputParameterfvNV, "glGetFinalCombinerInputParameterfvNV");
   if ( !driverTbl.glGetFinalCombinerInputParameterfvNV ) {
      driverTbl.glGetFinalCombinerInputParameterfvNV = missing_glGetFinalCombinerInputParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFinalCombinerInputParameterfvNV == loader_glGetFinalCombinerInputParameterfvNV) {
      rCtx->dsp.emuTbl.glGetFinalCombinerInputParameterfvNV = driverTbl.glGetFinalCombinerInputParameterfvNV;
   }
   driverTbl.glGetFinalCombinerInputParameterfvNV(variable, pname, params);
}

static void REGAL_CALL missing_glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(variable);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFinalCombinerInputParameterivNV" );
}

static void REGAL_CALL loader_glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFinalCombinerInputParameterivNV, "glGetFinalCombinerInputParameterivNV");
   if ( !driverTbl.glGetFinalCombinerInputParameterivNV ) {
      driverTbl.glGetFinalCombinerInputParameterivNV = missing_glGetFinalCombinerInputParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFinalCombinerInputParameterivNV == loader_glGetFinalCombinerInputParameterivNV) {
      rCtx->dsp.emuTbl.glGetFinalCombinerInputParameterivNV = driverTbl.glGetFinalCombinerInputParameterivNV;
   }
   driverTbl.glGetFinalCombinerInputParameterivNV(variable, pname, params);
}

// GL_MESA_resize_buffers

static void REGAL_CALL missing_glResizeBuffersMESA(void)
{
   Warning( "Called missing function glResizeBuffersMESA" );
}

static void REGAL_CALL loader_glResizeBuffersMESA(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glResizeBuffersMESA, "glResizeBuffersMESA");
   if ( !driverTbl.glResizeBuffersMESA ) {
      driverTbl.glResizeBuffersMESA = missing_glResizeBuffersMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glResizeBuffersMESA == loader_glResizeBuffersMESA) {
      rCtx->dsp.emuTbl.glResizeBuffersMESA = driverTbl.glResizeBuffersMESA;
   }
   driverTbl.glResizeBuffersMESA();
}

// GL_MESA_window_pos

static void REGAL_CALL missing_glWindowPos2dMESA(GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glWindowPos2dMESA" );
}

static void REGAL_CALL loader_glWindowPos2dMESA(GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2dMESA, "glWindowPos2dMESA");
   if ( !driverTbl.glWindowPos2dMESA ) {
      driverTbl.glWindowPos2dMESA = missing_glWindowPos2dMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2dMESA == loader_glWindowPos2dMESA) {
      rCtx->dsp.emuTbl.glWindowPos2dMESA = driverTbl.glWindowPos2dMESA;
   }
   driverTbl.glWindowPos2dMESA(x, y);
}

static void REGAL_CALL missing_glWindowPos2dvMESA(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glWindowPos2dvMESA" );
}

static void REGAL_CALL loader_glWindowPos2dvMESA(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2dvMESA, "glWindowPos2dvMESA");
   if ( !driverTbl.glWindowPos2dvMESA ) {
      driverTbl.glWindowPos2dvMESA = missing_glWindowPos2dvMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2dvMESA == loader_glWindowPos2dvMESA) {
      rCtx->dsp.emuTbl.glWindowPos2dvMESA = driverTbl.glWindowPos2dvMESA;
   }
   driverTbl.glWindowPos2dvMESA(v);
}

static void REGAL_CALL missing_glWindowPos2fMESA(GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glWindowPos2fMESA" );
}

static void REGAL_CALL loader_glWindowPos2fMESA(GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2fMESA, "glWindowPos2fMESA");
   if ( !driverTbl.glWindowPos2fMESA ) {
      driverTbl.glWindowPos2fMESA = missing_glWindowPos2fMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2fMESA == loader_glWindowPos2fMESA) {
      rCtx->dsp.emuTbl.glWindowPos2fMESA = driverTbl.glWindowPos2fMESA;
   }
   driverTbl.glWindowPos2fMESA(x, y);
}

static void REGAL_CALL missing_glWindowPos2fvMESA(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glWindowPos2fvMESA" );
}

static void REGAL_CALL loader_glWindowPos2fvMESA(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2fvMESA, "glWindowPos2fvMESA");
   if ( !driverTbl.glWindowPos2fvMESA ) {
      driverTbl.glWindowPos2fvMESA = missing_glWindowPos2fvMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2fvMESA == loader_glWindowPos2fvMESA) {
      rCtx->dsp.emuTbl.glWindowPos2fvMESA = driverTbl.glWindowPos2fvMESA;
   }
   driverTbl.glWindowPos2fvMESA(v);
}

static void REGAL_CALL missing_glWindowPos2iMESA(GLint x, GLint y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glWindowPos2iMESA" );
}

static void REGAL_CALL loader_glWindowPos2iMESA(GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2iMESA, "glWindowPos2iMESA");
   if ( !driverTbl.glWindowPos2iMESA ) {
      driverTbl.glWindowPos2iMESA = missing_glWindowPos2iMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2iMESA == loader_glWindowPos2iMESA) {
      rCtx->dsp.emuTbl.glWindowPos2iMESA = driverTbl.glWindowPos2iMESA;
   }
   driverTbl.glWindowPos2iMESA(x, y);
}

static void REGAL_CALL missing_glWindowPos2ivMESA(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glWindowPos2ivMESA" );
}

static void REGAL_CALL loader_glWindowPos2ivMESA(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2ivMESA, "glWindowPos2ivMESA");
   if ( !driverTbl.glWindowPos2ivMESA ) {
      driverTbl.glWindowPos2ivMESA = missing_glWindowPos2ivMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2ivMESA == loader_glWindowPos2ivMESA) {
      rCtx->dsp.emuTbl.glWindowPos2ivMESA = driverTbl.glWindowPos2ivMESA;
   }
   driverTbl.glWindowPos2ivMESA(v);
}

static void REGAL_CALL missing_glWindowPos2sMESA(GLshort x, GLshort y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glWindowPos2sMESA" );
}

static void REGAL_CALL loader_glWindowPos2sMESA(GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2sMESA, "glWindowPos2sMESA");
   if ( !driverTbl.glWindowPos2sMESA ) {
      driverTbl.glWindowPos2sMESA = missing_glWindowPos2sMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2sMESA == loader_glWindowPos2sMESA) {
      rCtx->dsp.emuTbl.glWindowPos2sMESA = driverTbl.glWindowPos2sMESA;
   }
   driverTbl.glWindowPos2sMESA(x, y);
}

static void REGAL_CALL missing_glWindowPos2svMESA(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glWindowPos2svMESA" );
}

static void REGAL_CALL loader_glWindowPos2svMESA(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos2svMESA, "glWindowPos2svMESA");
   if ( !driverTbl.glWindowPos2svMESA ) {
      driverTbl.glWindowPos2svMESA = missing_glWindowPos2svMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos2svMESA == loader_glWindowPos2svMESA) {
      rCtx->dsp.emuTbl.glWindowPos2svMESA = driverTbl.glWindowPos2svMESA;
   }
   driverTbl.glWindowPos2svMESA(v);
}

static void REGAL_CALL missing_glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glWindowPos3dMESA" );
}

static void REGAL_CALL loader_glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3dMESA, "glWindowPos3dMESA");
   if ( !driverTbl.glWindowPos3dMESA ) {
      driverTbl.glWindowPos3dMESA = missing_glWindowPos3dMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3dMESA == loader_glWindowPos3dMESA) {
      rCtx->dsp.emuTbl.glWindowPos3dMESA = driverTbl.glWindowPos3dMESA;
   }
   driverTbl.glWindowPos3dMESA(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3dvMESA(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glWindowPos3dvMESA" );
}

static void REGAL_CALL loader_glWindowPos3dvMESA(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3dvMESA, "glWindowPos3dvMESA");
   if ( !driverTbl.glWindowPos3dvMESA ) {
      driverTbl.glWindowPos3dvMESA = missing_glWindowPos3dvMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3dvMESA == loader_glWindowPos3dvMESA) {
      rCtx->dsp.emuTbl.glWindowPos3dvMESA = driverTbl.glWindowPos3dvMESA;
   }
   driverTbl.glWindowPos3dvMESA(v);
}

static void REGAL_CALL missing_glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glWindowPos3fMESA" );
}

static void REGAL_CALL loader_glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3fMESA, "glWindowPos3fMESA");
   if ( !driverTbl.glWindowPos3fMESA ) {
      driverTbl.glWindowPos3fMESA = missing_glWindowPos3fMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3fMESA == loader_glWindowPos3fMESA) {
      rCtx->dsp.emuTbl.glWindowPos3fMESA = driverTbl.glWindowPos3fMESA;
   }
   driverTbl.glWindowPos3fMESA(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3fvMESA(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glWindowPos3fvMESA" );
}

static void REGAL_CALL loader_glWindowPos3fvMESA(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3fvMESA, "glWindowPos3fvMESA");
   if ( !driverTbl.glWindowPos3fvMESA ) {
      driverTbl.glWindowPos3fvMESA = missing_glWindowPos3fvMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3fvMESA == loader_glWindowPos3fvMESA) {
      rCtx->dsp.emuTbl.glWindowPos3fvMESA = driverTbl.glWindowPos3fvMESA;
   }
   driverTbl.glWindowPos3fvMESA(v);
}

static void REGAL_CALL missing_glWindowPos3iMESA(GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glWindowPos3iMESA" );
}

static void REGAL_CALL loader_glWindowPos3iMESA(GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3iMESA, "glWindowPos3iMESA");
   if ( !driverTbl.glWindowPos3iMESA ) {
      driverTbl.glWindowPos3iMESA = missing_glWindowPos3iMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3iMESA == loader_glWindowPos3iMESA) {
      rCtx->dsp.emuTbl.glWindowPos3iMESA = driverTbl.glWindowPos3iMESA;
   }
   driverTbl.glWindowPos3iMESA(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3ivMESA(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glWindowPos3ivMESA" );
}

static void REGAL_CALL loader_glWindowPos3ivMESA(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3ivMESA, "glWindowPos3ivMESA");
   if ( !driverTbl.glWindowPos3ivMESA ) {
      driverTbl.glWindowPos3ivMESA = missing_glWindowPos3ivMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3ivMESA == loader_glWindowPos3ivMESA) {
      rCtx->dsp.emuTbl.glWindowPos3ivMESA = driverTbl.glWindowPos3ivMESA;
   }
   driverTbl.glWindowPos3ivMESA(v);
}

static void REGAL_CALL missing_glWindowPos3sMESA(GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glWindowPos3sMESA" );
}

static void REGAL_CALL loader_glWindowPos3sMESA(GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3sMESA, "glWindowPos3sMESA");
   if ( !driverTbl.glWindowPos3sMESA ) {
      driverTbl.glWindowPos3sMESA = missing_glWindowPos3sMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3sMESA == loader_glWindowPos3sMESA) {
      rCtx->dsp.emuTbl.glWindowPos3sMESA = driverTbl.glWindowPos3sMESA;
   }
   driverTbl.glWindowPos3sMESA(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3svMESA(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glWindowPos3svMESA" );
}

static void REGAL_CALL loader_glWindowPos3svMESA(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos3svMESA, "glWindowPos3svMESA");
   if ( !driverTbl.glWindowPos3svMESA ) {
      driverTbl.glWindowPos3svMESA = missing_glWindowPos3svMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos3svMESA == loader_glWindowPos3svMESA) {
      rCtx->dsp.emuTbl.glWindowPos3svMESA = driverTbl.glWindowPos3svMESA;
   }
   driverTbl.glWindowPos3svMESA(v);
}

static void REGAL_CALL missing_glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glWindowPos4dMESA" );
}

static void REGAL_CALL loader_glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos4dMESA, "glWindowPos4dMESA");
   if ( !driverTbl.glWindowPos4dMESA ) {
      driverTbl.glWindowPos4dMESA = missing_glWindowPos4dMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos4dMESA == loader_glWindowPos4dMESA) {
      rCtx->dsp.emuTbl.glWindowPos4dMESA = driverTbl.glWindowPos4dMESA;
   }
   driverTbl.glWindowPos4dMESA(x, y, z, w);
}

static void REGAL_CALL missing_glWindowPos4dvMESA(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glWindowPos4dvMESA" );
}

static void REGAL_CALL loader_glWindowPos4dvMESA(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos4dvMESA, "glWindowPos4dvMESA");
   if ( !driverTbl.glWindowPos4dvMESA ) {
      driverTbl.glWindowPos4dvMESA = missing_glWindowPos4dvMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos4dvMESA == loader_glWindowPos4dvMESA) {
      rCtx->dsp.emuTbl.glWindowPos4dvMESA = driverTbl.glWindowPos4dvMESA;
   }
   driverTbl.glWindowPos4dvMESA(v);
}

static void REGAL_CALL missing_glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glWindowPos4fMESA" );
}

static void REGAL_CALL loader_glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos4fMESA, "glWindowPos4fMESA");
   if ( !driverTbl.glWindowPos4fMESA ) {
      driverTbl.glWindowPos4fMESA = missing_glWindowPos4fMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos4fMESA == loader_glWindowPos4fMESA) {
      rCtx->dsp.emuTbl.glWindowPos4fMESA = driverTbl.glWindowPos4fMESA;
   }
   driverTbl.glWindowPos4fMESA(x, y, z, w);
}

static void REGAL_CALL missing_glWindowPos4fvMESA(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glWindowPos4fvMESA" );
}

static void REGAL_CALL loader_glWindowPos4fvMESA(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos4fvMESA, "glWindowPos4fvMESA");
   if ( !driverTbl.glWindowPos4fvMESA ) {
      driverTbl.glWindowPos4fvMESA = missing_glWindowPos4fvMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos4fvMESA == loader_glWindowPos4fvMESA) {
      rCtx->dsp.emuTbl.glWindowPos4fvMESA = driverTbl.glWindowPos4fvMESA;
   }
   driverTbl.glWindowPos4fvMESA(v);
}

static void REGAL_CALL missing_glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glWindowPos4iMESA" );
}

static void REGAL_CALL loader_glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos4iMESA, "glWindowPos4iMESA");
   if ( !driverTbl.glWindowPos4iMESA ) {
      driverTbl.glWindowPos4iMESA = missing_glWindowPos4iMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos4iMESA == loader_glWindowPos4iMESA) {
      rCtx->dsp.emuTbl.glWindowPos4iMESA = driverTbl.glWindowPos4iMESA;
   }
   driverTbl.glWindowPos4iMESA(x, y, z, w);
}

static void REGAL_CALL missing_glWindowPos4ivMESA(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glWindowPos4ivMESA" );
}

static void REGAL_CALL loader_glWindowPos4ivMESA(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos4ivMESA, "glWindowPos4ivMESA");
   if ( !driverTbl.glWindowPos4ivMESA ) {
      driverTbl.glWindowPos4ivMESA = missing_glWindowPos4ivMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos4ivMESA == loader_glWindowPos4ivMESA) {
      rCtx->dsp.emuTbl.glWindowPos4ivMESA = driverTbl.glWindowPos4ivMESA;
   }
   driverTbl.glWindowPos4ivMESA(v);
}

static void REGAL_CALL missing_glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glWindowPos4sMESA" );
}

static void REGAL_CALL loader_glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos4sMESA, "glWindowPos4sMESA");
   if ( !driverTbl.glWindowPos4sMESA ) {
      driverTbl.glWindowPos4sMESA = missing_glWindowPos4sMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos4sMESA == loader_glWindowPos4sMESA) {
      rCtx->dsp.emuTbl.glWindowPos4sMESA = driverTbl.glWindowPos4sMESA;
   }
   driverTbl.glWindowPos4sMESA(x, y, z, w);
}

static void REGAL_CALL missing_glWindowPos4svMESA(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glWindowPos4svMESA" );
}

static void REGAL_CALL loader_glWindowPos4svMESA(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWindowPos4svMESA, "glWindowPos4svMESA");
   if ( !driverTbl.glWindowPos4svMESA ) {
      driverTbl.glWindowPos4svMESA = missing_glWindowPos4svMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWindowPos4svMESA == loader_glWindowPos4svMESA) {
      rCtx->dsp.emuTbl.glWindowPos4svMESA = driverTbl.glWindowPos4svMESA;
   }
   driverTbl.glWindowPos4svMESA(v);
}

// GL_IBM_multimode_draw_arrays

static void REGAL_CALL missing_glMultiModeDrawArraysIBM(const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(modestride);
   Warning( "Called missing function glMultiModeDrawArraysIBM" );
}

static void REGAL_CALL loader_glMultiModeDrawArraysIBM(const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiModeDrawArraysIBM, "glMultiModeDrawArraysIBM");
   if ( !driverTbl.glMultiModeDrawArraysIBM ) {
      driverTbl.glMultiModeDrawArraysIBM = missing_glMultiModeDrawArraysIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiModeDrawArraysIBM == loader_glMultiModeDrawArraysIBM) {
      rCtx->dsp.emuTbl.glMultiModeDrawArraysIBM = driverTbl.glMultiModeDrawArraysIBM;
   }
   driverTbl.glMultiModeDrawArraysIBM(mode, first, count, primcount, modestride);
}

static void REGAL_CALL missing_glMultiModeDrawElementsIBM(const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, GLint modestride)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(modestride);
   Warning( "Called missing function glMultiModeDrawElementsIBM" );
}

static void REGAL_CALL loader_glMultiModeDrawElementsIBM(const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, GLint modestride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiModeDrawElementsIBM, "glMultiModeDrawElementsIBM");
   if ( !driverTbl.glMultiModeDrawElementsIBM ) {
      driverTbl.glMultiModeDrawElementsIBM = missing_glMultiModeDrawElementsIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiModeDrawElementsIBM == loader_glMultiModeDrawElementsIBM) {
      rCtx->dsp.emuTbl.glMultiModeDrawElementsIBM = driverTbl.glMultiModeDrawElementsIBM;
   }
   driverTbl.glMultiModeDrawElementsIBM(mode, count, type, indices, primcount, modestride);
}

// GL_IBM_vertex_array_lists

static void REGAL_CALL missing_glColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "Called missing function glColorPointerListIBM" );
}

static void REGAL_CALL loader_glColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorPointerListIBM, "glColorPointerListIBM");
   if ( !driverTbl.glColorPointerListIBM ) {
      driverTbl.glColorPointerListIBM = missing_glColorPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorPointerListIBM == loader_glColorPointerListIBM) {
      rCtx->dsp.emuTbl.glColorPointerListIBM = driverTbl.glColorPointerListIBM;
   }
   driverTbl.glColorPointerListIBM(size, type, stride, pointer, ptrstride);
}

static void REGAL_CALL missing_glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "Called missing function glSecondaryColorPointerListIBM" );
}

static void REGAL_CALL loader_glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColorPointerListIBM, "glSecondaryColorPointerListIBM");
   if ( !driverTbl.glSecondaryColorPointerListIBM ) {
      driverTbl.glSecondaryColorPointerListIBM = missing_glSecondaryColorPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColorPointerListIBM == loader_glSecondaryColorPointerListIBM) {
      rCtx->dsp.emuTbl.glSecondaryColorPointerListIBM = driverTbl.glSecondaryColorPointerListIBM;
   }
   driverTbl.glSecondaryColorPointerListIBM(size, type, stride, pointer, ptrstride);
}

static void REGAL_CALL missing_glEdgeFlagPointerListIBM(GLint stride, const GLboolean **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "Called missing function glEdgeFlagPointerListIBM" );
}

static void REGAL_CALL loader_glEdgeFlagPointerListIBM(GLint stride, const GLboolean **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEdgeFlagPointerListIBM, "glEdgeFlagPointerListIBM");
   if ( !driverTbl.glEdgeFlagPointerListIBM ) {
      driverTbl.glEdgeFlagPointerListIBM = missing_glEdgeFlagPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEdgeFlagPointerListIBM == loader_glEdgeFlagPointerListIBM) {
      rCtx->dsp.emuTbl.glEdgeFlagPointerListIBM = driverTbl.glEdgeFlagPointerListIBM;
   }
   driverTbl.glEdgeFlagPointerListIBM(stride, pointer, ptrstride);
}

static void REGAL_CALL missing_glFogCoordPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "Called missing function glFogCoordPointerListIBM" );
}

static void REGAL_CALL loader_glFogCoordPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogCoordPointerListIBM, "glFogCoordPointerListIBM");
   if ( !driverTbl.glFogCoordPointerListIBM ) {
      driverTbl.glFogCoordPointerListIBM = missing_glFogCoordPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogCoordPointerListIBM == loader_glFogCoordPointerListIBM) {
      rCtx->dsp.emuTbl.glFogCoordPointerListIBM = driverTbl.glFogCoordPointerListIBM;
   }
   driverTbl.glFogCoordPointerListIBM(type, stride, pointer, ptrstride);
}

static void REGAL_CALL missing_glIndexPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "Called missing function glIndexPointerListIBM" );
}

static void REGAL_CALL loader_glIndexPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexPointerListIBM, "glIndexPointerListIBM");
   if ( !driverTbl.glIndexPointerListIBM ) {
      driverTbl.glIndexPointerListIBM = missing_glIndexPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexPointerListIBM == loader_glIndexPointerListIBM) {
      rCtx->dsp.emuTbl.glIndexPointerListIBM = driverTbl.glIndexPointerListIBM;
   }
   driverTbl.glIndexPointerListIBM(type, stride, pointer, ptrstride);
}

static void REGAL_CALL missing_glNormalPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "Called missing function glNormalPointerListIBM" );
}

static void REGAL_CALL loader_glNormalPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalPointerListIBM, "glNormalPointerListIBM");
   if ( !driverTbl.glNormalPointerListIBM ) {
      driverTbl.glNormalPointerListIBM = missing_glNormalPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalPointerListIBM == loader_glNormalPointerListIBM) {
      rCtx->dsp.emuTbl.glNormalPointerListIBM = driverTbl.glNormalPointerListIBM;
   }
   driverTbl.glNormalPointerListIBM(type, stride, pointer, ptrstride);
}

static void REGAL_CALL missing_glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "Called missing function glTexCoordPointerListIBM" );
}

static void REGAL_CALL loader_glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoordPointerListIBM, "glTexCoordPointerListIBM");
   if ( !driverTbl.glTexCoordPointerListIBM ) {
      driverTbl.glTexCoordPointerListIBM = missing_glTexCoordPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoordPointerListIBM == loader_glTexCoordPointerListIBM) {
      rCtx->dsp.emuTbl.glTexCoordPointerListIBM = driverTbl.glTexCoordPointerListIBM;
   }
   driverTbl.glTexCoordPointerListIBM(size, type, stride, pointer, ptrstride);
}

static void REGAL_CALL missing_glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "Called missing function glVertexPointerListIBM" );
}

static void REGAL_CALL loader_glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexPointerListIBM, "glVertexPointerListIBM");
   if ( !driverTbl.glVertexPointerListIBM ) {
      driverTbl.glVertexPointerListIBM = missing_glVertexPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexPointerListIBM == loader_glVertexPointerListIBM) {
      rCtx->dsp.emuTbl.glVertexPointerListIBM = driverTbl.glVertexPointerListIBM;
   }
   driverTbl.glVertexPointerListIBM(size, type, stride, pointer, ptrstride);
}

// GL_3DFX_tbuffer

static void REGAL_CALL missing_glTbufferMask3DFX(GLuint mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glTbufferMask3DFX" );
}

static void REGAL_CALL loader_glTbufferMask3DFX(GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTbufferMask3DFX, "glTbufferMask3DFX");
   if ( !driverTbl.glTbufferMask3DFX ) {
      driverTbl.glTbufferMask3DFX = missing_glTbufferMask3DFX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTbufferMask3DFX == loader_glTbufferMask3DFX) {
      rCtx->dsp.emuTbl.glTbufferMask3DFX = driverTbl.glTbufferMask3DFX;
   }
   driverTbl.glTbufferMask3DFX(mask);
}

// GL_EXT_multisample

static void REGAL_CALL missing_glSampleMaskEXT(GLclampf value, GLboolean invert)
{
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(invert);
   Warning( "Called missing function glSampleMaskEXT" );
}

static void REGAL_CALL loader_glSampleMaskEXT(GLclampf value, GLboolean invert)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSampleMaskEXT, "glSampleMaskEXT");
   if ( !driverTbl.glSampleMaskEXT ) {
      driverTbl.glSampleMaskEXT = missing_glSampleMaskEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSampleMaskEXT == loader_glSampleMaskEXT) {
      rCtx->dsp.emuTbl.glSampleMaskEXT = driverTbl.glSampleMaskEXT;
   }
   driverTbl.glSampleMaskEXT(value, invert);
}

static void REGAL_CALL missing_glSamplePatternEXT(GLenum pattern)
{
   UNUSED_PARAMETER(pattern);
   Warning( "Called missing function glSamplePatternEXT" );
}

static void REGAL_CALL loader_glSamplePatternEXT(GLenum pattern)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSamplePatternEXT, "glSamplePatternEXT");
   if ( !driverTbl.glSamplePatternEXT ) {
      driverTbl.glSamplePatternEXT = missing_glSamplePatternEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSamplePatternEXT == loader_glSamplePatternEXT) {
      rCtx->dsp.emuTbl.glSamplePatternEXT = driverTbl.glSamplePatternEXT;
   }
   driverTbl.glSamplePatternEXT(pattern);
}

// GL_SGIS_texture_color_mask

static void REGAL_CALL missing_glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glTextureColorMaskSGIS" );
}

static void REGAL_CALL loader_glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureColorMaskSGIS, "glTextureColorMaskSGIS");
   if ( !driverTbl.glTextureColorMaskSGIS ) {
      driverTbl.glTextureColorMaskSGIS = missing_glTextureColorMaskSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureColorMaskSGIS == loader_glTextureColorMaskSGIS) {
      rCtx->dsp.emuTbl.glTextureColorMaskSGIS = driverTbl.glTextureColorMaskSGIS;
   }
   driverTbl.glTextureColorMaskSGIS(red, green, blue, alpha);
}

// GL_SGIX_igloo_interface

static void REGAL_CALL missing_glIglooInterfaceSGIX(GLenum pname, const GLvoid *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glIglooInterfaceSGIX" );
}

static void REGAL_CALL loader_glIglooInterfaceSGIX(GLenum pname, const GLvoid *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIglooInterfaceSGIX, "glIglooInterfaceSGIX");
   if ( !driverTbl.glIglooInterfaceSGIX ) {
      driverTbl.glIglooInterfaceSGIX = missing_glIglooInterfaceSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIglooInterfaceSGIX == loader_glIglooInterfaceSGIX) {
      rCtx->dsp.emuTbl.glIglooInterfaceSGIX = driverTbl.glIglooInterfaceSGIX;
   }
   driverTbl.glIglooInterfaceSGIX(pname, params);
}

// GL_NV_fence

static void REGAL_CALL missing_glDeleteFencesNV(GLsizei n, const GLuint *fences)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(fences);
   Warning( "Called missing function glDeleteFencesNV" );
}

static void REGAL_CALL loader_glDeleteFencesNV(GLsizei n, const GLuint *fences)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteFencesNV, "glDeleteFencesNV");
   if ( !driverTbl.glDeleteFencesNV ) {
      driverTbl.glDeleteFencesNV = missing_glDeleteFencesNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteFencesNV == loader_glDeleteFencesNV) {
      rCtx->dsp.emuTbl.glDeleteFencesNV = driverTbl.glDeleteFencesNV;
   }
   driverTbl.glDeleteFencesNV(n, fences);
}

static void REGAL_CALL missing_glGenFencesNV(GLsizei n, GLuint *fences)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(fences);
   Warning( "Called missing function glGenFencesNV" );
}

static void REGAL_CALL loader_glGenFencesNV(GLsizei n, GLuint *fences)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenFencesNV, "glGenFencesNV");
   if ( !driverTbl.glGenFencesNV ) {
      driverTbl.glGenFencesNV = missing_glGenFencesNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenFencesNV == loader_glGenFencesNV) {
      rCtx->dsp.emuTbl.glGenFencesNV = driverTbl.glGenFencesNV;
   }
   driverTbl.glGenFencesNV(n, fences);
}

static GLboolean REGAL_CALL missing_glIsFenceNV(GLuint fence)
{
   UNUSED_PARAMETER(fence);
   Warning( "Called missing function glIsFenceNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsFenceNV(GLuint fence)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsFenceNV, "glIsFenceNV");
   if ( !driverTbl.glIsFenceNV ) {
      driverTbl.glIsFenceNV = missing_glIsFenceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsFenceNV == loader_glIsFenceNV) {
      rCtx->dsp.emuTbl.glIsFenceNV = driverTbl.glIsFenceNV;
   }
   return driverTbl.glIsFenceNV(fence);
}

static GLboolean REGAL_CALL missing_glTestFenceNV(GLuint fence)
{
   UNUSED_PARAMETER(fence);
   Warning( "Called missing function glTestFenceNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glTestFenceNV(GLuint fence)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTestFenceNV, "glTestFenceNV");
   if ( !driverTbl.glTestFenceNV ) {
      driverTbl.glTestFenceNV = missing_glTestFenceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTestFenceNV == loader_glTestFenceNV) {
      rCtx->dsp.emuTbl.glTestFenceNV = driverTbl.glTestFenceNV;
   }
   return driverTbl.glTestFenceNV(fence);
}

static void REGAL_CALL missing_glGetFenceivNV(GLuint fence, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(fence);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFenceivNV" );
}

static void REGAL_CALL loader_glGetFenceivNV(GLuint fence, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFenceivNV, "glGetFenceivNV");
   if ( !driverTbl.glGetFenceivNV ) {
      driverTbl.glGetFenceivNV = missing_glGetFenceivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFenceivNV == loader_glGetFenceivNV) {
      rCtx->dsp.emuTbl.glGetFenceivNV = driverTbl.glGetFenceivNV;
   }
   driverTbl.glGetFenceivNV(fence, pname, params);
}

static void REGAL_CALL missing_glFinishFenceNV(GLuint fence)
{
   UNUSED_PARAMETER(fence);
   Warning( "Called missing function glFinishFenceNV" );
}

static void REGAL_CALL loader_glFinishFenceNV(GLuint fence)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFinishFenceNV, "glFinishFenceNV");
   if ( !driverTbl.glFinishFenceNV ) {
      driverTbl.glFinishFenceNV = missing_glFinishFenceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFinishFenceNV == loader_glFinishFenceNV) {
      rCtx->dsp.emuTbl.glFinishFenceNV = driverTbl.glFinishFenceNV;
   }
   driverTbl.glFinishFenceNV(fence);
}

static void REGAL_CALL missing_glSetFenceNV(GLuint fence, GLenum condition)
{
   UNUSED_PARAMETER(fence);
   UNUSED_PARAMETER(condition);
   Warning( "Called missing function glSetFenceNV" );
}

static void REGAL_CALL loader_glSetFenceNV(GLuint fence, GLenum condition)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSetFenceNV, "glSetFenceNV");
   if ( !driverTbl.glSetFenceNV ) {
      driverTbl.glSetFenceNV = missing_glSetFenceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSetFenceNV == loader_glSetFenceNV) {
      rCtx->dsp.emuTbl.glSetFenceNV = driverTbl.glSetFenceNV;
   }
   driverTbl.glSetFenceNV(fence, condition);
}

// GL_NV_evaluators

static void REGAL_CALL missing_glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(uorder);
   UNUSED_PARAMETER(vorder);
   UNUSED_PARAMETER(packed);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glMapControlPointsNV" );
}

static void REGAL_CALL loader_glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapControlPointsNV, "glMapControlPointsNV");
   if ( !driverTbl.glMapControlPointsNV ) {
      driverTbl.glMapControlPointsNV = missing_glMapControlPointsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapControlPointsNV == loader_glMapControlPointsNV) {
      rCtx->dsp.emuTbl.glMapControlPointsNV = driverTbl.glMapControlPointsNV;
   }
   driverTbl.glMapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed, points);
}

static void REGAL_CALL missing_glMapParameterivNV(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glMapParameterivNV" );
}

static void REGAL_CALL loader_glMapParameterivNV(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapParameterivNV, "glMapParameterivNV");
   if ( !driverTbl.glMapParameterivNV ) {
      driverTbl.glMapParameterivNV = missing_glMapParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapParameterivNV == loader_glMapParameterivNV) {
      rCtx->dsp.emuTbl.glMapParameterivNV = driverTbl.glMapParameterivNV;
   }
   driverTbl.glMapParameterivNV(target, pname, params);
}

static void REGAL_CALL missing_glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glMapParameterfvNV" );
}

static void REGAL_CALL loader_glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapParameterfvNV, "glMapParameterfvNV");
   if ( !driverTbl.glMapParameterfvNV ) {
      driverTbl.glMapParameterfvNV = missing_glMapParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapParameterfvNV == loader_glMapParameterfvNV) {
      rCtx->dsp.emuTbl.glMapParameterfvNV = driverTbl.glMapParameterfvNV;
   }
   driverTbl.glMapParameterfvNV(target, pname, params);
}

static void REGAL_CALL missing_glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(packed);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glGetMapControlPointsNV" );
}

static void REGAL_CALL loader_glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMapControlPointsNV, "glGetMapControlPointsNV");
   if ( !driverTbl.glGetMapControlPointsNV ) {
      driverTbl.glGetMapControlPointsNV = missing_glGetMapControlPointsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMapControlPointsNV == loader_glGetMapControlPointsNV) {
      rCtx->dsp.emuTbl.glGetMapControlPointsNV = driverTbl.glGetMapControlPointsNV;
   }
   driverTbl.glGetMapControlPointsNV(target, index, type, ustride, vstride, packed, points);
}

static void REGAL_CALL missing_glGetMapParameterivNV(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMapParameterivNV" );
}

static void REGAL_CALL loader_glGetMapParameterivNV(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMapParameterivNV, "glGetMapParameterivNV");
   if ( !driverTbl.glGetMapParameterivNV ) {
      driverTbl.glGetMapParameterivNV = missing_glGetMapParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMapParameterivNV == loader_glGetMapParameterivNV) {
      rCtx->dsp.emuTbl.glGetMapParameterivNV = driverTbl.glGetMapParameterivNV;
   }
   driverTbl.glGetMapParameterivNV(target, pname, params);
}

static void REGAL_CALL missing_glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMapParameterfvNV" );
}

static void REGAL_CALL loader_glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMapParameterfvNV, "glGetMapParameterfvNV");
   if ( !driverTbl.glGetMapParameterfvNV ) {
      driverTbl.glGetMapParameterfvNV = missing_glGetMapParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMapParameterfvNV == loader_glGetMapParameterfvNV) {
      rCtx->dsp.emuTbl.glGetMapParameterfvNV = driverTbl.glGetMapParameterfvNV;
   }
   driverTbl.glGetMapParameterfvNV(target, pname, params);
}

static void REGAL_CALL missing_glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMapAttribParameterivNV" );
}

static void REGAL_CALL loader_glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMapAttribParameterivNV, "glGetMapAttribParameterivNV");
   if ( !driverTbl.glGetMapAttribParameterivNV ) {
      driverTbl.glGetMapAttribParameterivNV = missing_glGetMapAttribParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMapAttribParameterivNV == loader_glGetMapAttribParameterivNV) {
      rCtx->dsp.emuTbl.glGetMapAttribParameterivNV = driverTbl.glGetMapAttribParameterivNV;
   }
   driverTbl.glGetMapAttribParameterivNV(target, index, pname, params);
}

static void REGAL_CALL missing_glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMapAttribParameterfvNV" );
}

static void REGAL_CALL loader_glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMapAttribParameterfvNV, "glGetMapAttribParameterfvNV");
   if ( !driverTbl.glGetMapAttribParameterfvNV ) {
      driverTbl.glGetMapAttribParameterfvNV = missing_glGetMapAttribParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMapAttribParameterfvNV == loader_glGetMapAttribParameterfvNV) {
      rCtx->dsp.emuTbl.glGetMapAttribParameterfvNV = driverTbl.glGetMapAttribParameterfvNV;
   }
   driverTbl.glGetMapAttribParameterfvNV(target, index, pname, params);
}

static void REGAL_CALL missing_glEvalMapsNV(GLenum target, GLenum mode)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glEvalMapsNV" );
}

static void REGAL_CALL loader_glEvalMapsNV(GLenum target, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEvalMapsNV, "glEvalMapsNV");
   if ( !driverTbl.glEvalMapsNV ) {
      driverTbl.glEvalMapsNV = missing_glEvalMapsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEvalMapsNV == loader_glEvalMapsNV) {
      rCtx->dsp.emuTbl.glEvalMapsNV = driverTbl.glEvalMapsNV;
   }
   driverTbl.glEvalMapsNV(target, mode);
}

// GL_NV_register_combiners2

static void REGAL_CALL missing_glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glCombinerStageParameterfvNV" );
}

static void REGAL_CALL loader_glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCombinerStageParameterfvNV, "glCombinerStageParameterfvNV");
   if ( !driverTbl.glCombinerStageParameterfvNV ) {
      driverTbl.glCombinerStageParameterfvNV = missing_glCombinerStageParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCombinerStageParameterfvNV == loader_glCombinerStageParameterfvNV) {
      rCtx->dsp.emuTbl.glCombinerStageParameterfvNV = driverTbl.glCombinerStageParameterfvNV;
   }
   driverTbl.glCombinerStageParameterfvNV(stage, pname, params);
}

static void REGAL_CALL missing_glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetCombinerStageParameterfvNV" );
}

static void REGAL_CALL loader_glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetCombinerStageParameterfvNV, "glGetCombinerStageParameterfvNV");
   if ( !driverTbl.glGetCombinerStageParameterfvNV ) {
      driverTbl.glGetCombinerStageParameterfvNV = missing_glGetCombinerStageParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetCombinerStageParameterfvNV == loader_glGetCombinerStageParameterfvNV) {
      rCtx->dsp.emuTbl.glGetCombinerStageParameterfvNV = driverTbl.glGetCombinerStageParameterfvNV;
   }
   driverTbl.glGetCombinerStageParameterfvNV(stage, pname, params);
}

// GL_NV_vertex_program

static GLboolean REGAL_CALL missing_glAreProgramsResidentNV(GLsizei n, const GLuint *programs, GLboolean *residences)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(programs);
   UNUSED_PARAMETER(residences);
   Warning( "Called missing function glAreProgramsResidentNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glAreProgramsResidentNV(GLsizei n, const GLuint *programs, GLboolean *residences)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glAreProgramsResidentNV, "glAreProgramsResidentNV");
   if ( !driverTbl.glAreProgramsResidentNV ) {
      driverTbl.glAreProgramsResidentNV = missing_glAreProgramsResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glAreProgramsResidentNV == loader_glAreProgramsResidentNV) {
      rCtx->dsp.emuTbl.glAreProgramsResidentNV = driverTbl.glAreProgramsResidentNV;
   }
   return driverTbl.glAreProgramsResidentNV(n, programs, residences);
}

static void REGAL_CALL missing_glBindProgramNV(GLenum target, GLuint id)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glBindProgramNV" );
}

static void REGAL_CALL loader_glBindProgramNV(GLenum target, GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindProgramNV, "glBindProgramNV");
   if ( !driverTbl.glBindProgramNV ) {
      driverTbl.glBindProgramNV = missing_glBindProgramNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindProgramNV == loader_glBindProgramNV) {
      rCtx->dsp.emuTbl.glBindProgramNV = driverTbl.glBindProgramNV;
   }
   driverTbl.glBindProgramNV(target, id);
}

static void REGAL_CALL missing_glDeleteProgramsNV(GLsizei n, const GLuint *programs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(programs);
   Warning( "Called missing function glDeleteProgramsNV" );
}

static void REGAL_CALL loader_glDeleteProgramsNV(GLsizei n, const GLuint *programs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteProgramsNV, "glDeleteProgramsNV");
   if ( !driverTbl.glDeleteProgramsNV ) {
      driverTbl.glDeleteProgramsNV = missing_glDeleteProgramsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteProgramsNV == loader_glDeleteProgramsNV) {
      rCtx->dsp.emuTbl.glDeleteProgramsNV = driverTbl.glDeleteProgramsNV;
   }
   driverTbl.glDeleteProgramsNV(n, programs);
}

static void REGAL_CALL missing_glExecuteProgramNV(GLenum target, GLuint id, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glExecuteProgramNV" );
}

static void REGAL_CALL loader_glExecuteProgramNV(GLenum target, GLuint id, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glExecuteProgramNV, "glExecuteProgramNV");
   if ( !driverTbl.glExecuteProgramNV ) {
      driverTbl.glExecuteProgramNV = missing_glExecuteProgramNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glExecuteProgramNV == loader_glExecuteProgramNV) {
      rCtx->dsp.emuTbl.glExecuteProgramNV = driverTbl.glExecuteProgramNV;
   }
   driverTbl.glExecuteProgramNV(target, id, params);
}

static void REGAL_CALL missing_glGenProgramsNV(GLsizei n, GLuint *programs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(programs);
   Warning( "Called missing function glGenProgramsNV" );
}

static void REGAL_CALL loader_glGenProgramsNV(GLsizei n, GLuint *programs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenProgramsNV, "glGenProgramsNV");
   if ( !driverTbl.glGenProgramsNV ) {
      driverTbl.glGenProgramsNV = missing_glGenProgramsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenProgramsNV == loader_glGenProgramsNV) {
      rCtx->dsp.emuTbl.glGenProgramsNV = driverTbl.glGenProgramsNV;
   }
   driverTbl.glGenProgramsNV(n, programs);
}

static void REGAL_CALL missing_glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramParameterdvNV" );
}

static void REGAL_CALL loader_glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramParameterdvNV, "glGetProgramParameterdvNV");
   if ( !driverTbl.glGetProgramParameterdvNV ) {
      driverTbl.glGetProgramParameterdvNV = missing_glGetProgramParameterdvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramParameterdvNV == loader_glGetProgramParameterdvNV) {
      rCtx->dsp.emuTbl.glGetProgramParameterdvNV = driverTbl.glGetProgramParameterdvNV;
   }
   driverTbl.glGetProgramParameterdvNV(target, index, pname, params);
}

static void REGAL_CALL missing_glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramParameterfvNV" );
}

static void REGAL_CALL loader_glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramParameterfvNV, "glGetProgramParameterfvNV");
   if ( !driverTbl.glGetProgramParameterfvNV ) {
      driverTbl.glGetProgramParameterfvNV = missing_glGetProgramParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramParameterfvNV == loader_glGetProgramParameterfvNV) {
      rCtx->dsp.emuTbl.glGetProgramParameterfvNV = driverTbl.glGetProgramParameterfvNV;
   }
   driverTbl.glGetProgramParameterfvNV(target, index, pname, params);
}

static void REGAL_CALL missing_glGetProgramivNV(GLuint id, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramivNV" );
}

static void REGAL_CALL loader_glGetProgramivNV(GLuint id, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramivNV, "glGetProgramivNV");
   if ( !driverTbl.glGetProgramivNV ) {
      driverTbl.glGetProgramivNV = missing_glGetProgramivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramivNV == loader_glGetProgramivNV) {
      rCtx->dsp.emuTbl.glGetProgramivNV = driverTbl.glGetProgramivNV;
   }
   driverTbl.glGetProgramivNV(id, pname, params);
}

static void REGAL_CALL missing_glGetProgramStringNV(GLuint id, GLenum pname, GLubyte *program)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(program);
   Warning( "Called missing function glGetProgramStringNV" );
}

static void REGAL_CALL loader_glGetProgramStringNV(GLuint id, GLenum pname, GLubyte *program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramStringNV, "glGetProgramStringNV");
   if ( !driverTbl.glGetProgramStringNV ) {
      driverTbl.glGetProgramStringNV = missing_glGetProgramStringNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramStringNV == loader_glGetProgramStringNV) {
      rCtx->dsp.emuTbl.glGetProgramStringNV = driverTbl.glGetProgramStringNV;
   }
   driverTbl.glGetProgramStringNV(id, pname, program);
}

static void REGAL_CALL missing_glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(address);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTrackMatrixivNV" );
}

static void REGAL_CALL loader_glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTrackMatrixivNV, "glGetTrackMatrixivNV");
   if ( !driverTbl.glGetTrackMatrixivNV ) {
      driverTbl.glGetTrackMatrixivNV = missing_glGetTrackMatrixivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTrackMatrixivNV == loader_glGetTrackMatrixivNV) {
      rCtx->dsp.emuTbl.glGetTrackMatrixivNV = driverTbl.glGetTrackMatrixivNV;
   }
   driverTbl.glGetTrackMatrixivNV(target, address, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribdvNV" );
}

static void REGAL_CALL loader_glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribdvNV, "glGetVertexAttribdvNV");
   if ( !driverTbl.glGetVertexAttribdvNV ) {
      driverTbl.glGetVertexAttribdvNV = missing_glGetVertexAttribdvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribdvNV == loader_glGetVertexAttribdvNV) {
      rCtx->dsp.emuTbl.glGetVertexAttribdvNV = driverTbl.glGetVertexAttribdvNV;
   }
   driverTbl.glGetVertexAttribdvNV(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribfvNV" );
}

static void REGAL_CALL loader_glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribfvNV, "glGetVertexAttribfvNV");
   if ( !driverTbl.glGetVertexAttribfvNV ) {
      driverTbl.glGetVertexAttribfvNV = missing_glGetVertexAttribfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribfvNV == loader_glGetVertexAttribfvNV) {
      rCtx->dsp.emuTbl.glGetVertexAttribfvNV = driverTbl.glGetVertexAttribfvNV;
   }
   driverTbl.glGetVertexAttribfvNV(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribivNV(GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribivNV" );
}

static void REGAL_CALL loader_glGetVertexAttribivNV(GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribivNV, "glGetVertexAttribivNV");
   if ( !driverTbl.glGetVertexAttribivNV ) {
      driverTbl.glGetVertexAttribivNV = missing_glGetVertexAttribivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribivNV == loader_glGetVertexAttribivNV) {
      rCtx->dsp.emuTbl.glGetVertexAttribivNV = driverTbl.glGetVertexAttribivNV;
   }
   driverTbl.glGetVertexAttribivNV(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid **pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glGetVertexAttribPointervNV" );
}

static void REGAL_CALL loader_glGetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribPointervNV, "glGetVertexAttribPointervNV");
   if ( !driverTbl.glGetVertexAttribPointervNV ) {
      driverTbl.glGetVertexAttribPointervNV = missing_glGetVertexAttribPointervNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribPointervNV == loader_glGetVertexAttribPointervNV) {
      rCtx->dsp.emuTbl.glGetVertexAttribPointervNV = driverTbl.glGetVertexAttribPointervNV;
   }
   driverTbl.glGetVertexAttribPointervNV(index, pname, pointer);
}

static GLboolean REGAL_CALL missing_glIsProgramNV(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glIsProgramNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsProgramNV(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsProgramNV, "glIsProgramNV");
   if ( !driverTbl.glIsProgramNV ) {
      driverTbl.glIsProgramNV = missing_glIsProgramNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsProgramNV == loader_glIsProgramNV) {
      rCtx->dsp.emuTbl.glIsProgramNV = driverTbl.glIsProgramNV;
   }
   return driverTbl.glIsProgramNV(id);
}

static void REGAL_CALL missing_glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte *program)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(program);
   Warning( "Called missing function glLoadProgramNV" );
}

static void REGAL_CALL loader_glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte *program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLoadProgramNV, "glLoadProgramNV");
   if ( !driverTbl.glLoadProgramNV ) {
      driverTbl.glLoadProgramNV = missing_glLoadProgramNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLoadProgramNV == loader_glLoadProgramNV) {
      rCtx->dsp.emuTbl.glLoadProgramNV = driverTbl.glLoadProgramNV;
   }
   driverTbl.glLoadProgramNV(target, id, len, program);
}

static void REGAL_CALL missing_glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramParameter4dNV" );
}

static void REGAL_CALL loader_glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramParameter4dNV, "glProgramParameter4dNV");
   if ( !driverTbl.glProgramParameter4dNV ) {
      driverTbl.glProgramParameter4dNV = missing_glProgramParameter4dNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramParameter4dNV == loader_glProgramParameter4dNV) {
      rCtx->dsp.emuTbl.glProgramParameter4dNV = driverTbl.glProgramParameter4dNV;
   }
   driverTbl.glProgramParameter4dNV(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glProgramParameter4dvNV" );
}

static void REGAL_CALL loader_glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramParameter4dvNV, "glProgramParameter4dvNV");
   if ( !driverTbl.glProgramParameter4dvNV ) {
      driverTbl.glProgramParameter4dvNV = missing_glProgramParameter4dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramParameter4dvNV == loader_glProgramParameter4dvNV) {
      rCtx->dsp.emuTbl.glProgramParameter4dvNV = driverTbl.glProgramParameter4dvNV;
   }
   driverTbl.glProgramParameter4dvNV(target, index, v);
}

static void REGAL_CALL missing_glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramParameter4fNV" );
}

static void REGAL_CALL loader_glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramParameter4fNV, "glProgramParameter4fNV");
   if ( !driverTbl.glProgramParameter4fNV ) {
      driverTbl.glProgramParameter4fNV = missing_glProgramParameter4fNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramParameter4fNV == loader_glProgramParameter4fNV) {
      rCtx->dsp.emuTbl.glProgramParameter4fNV = driverTbl.glProgramParameter4fNV;
   }
   driverTbl.glProgramParameter4fNV(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glProgramParameter4fvNV" );
}

static void REGAL_CALL loader_glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramParameter4fvNV, "glProgramParameter4fvNV");
   if ( !driverTbl.glProgramParameter4fvNV ) {
      driverTbl.glProgramParameter4fvNV = missing_glProgramParameter4fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramParameter4fvNV == loader_glProgramParameter4fvNV) {
      rCtx->dsp.emuTbl.glProgramParameter4fvNV = driverTbl.glProgramParameter4fvNV;
   }
   driverTbl.glProgramParameter4fvNV(target, index, v);
}

static void REGAL_CALL missing_glProgramParameters4dvNV(GLenum target, GLuint index, GLuint count, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glProgramParameters4dvNV" );
}

static void REGAL_CALL loader_glProgramParameters4dvNV(GLenum target, GLuint index, GLuint count, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramParameters4dvNV, "glProgramParameters4dvNV");
   if ( !driverTbl.glProgramParameters4dvNV ) {
      driverTbl.glProgramParameters4dvNV = missing_glProgramParameters4dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramParameters4dvNV == loader_glProgramParameters4dvNV) {
      rCtx->dsp.emuTbl.glProgramParameters4dvNV = driverTbl.glProgramParameters4dvNV;
   }
   driverTbl.glProgramParameters4dvNV(target, index, count, v);
}

static void REGAL_CALL missing_glProgramParameters4fvNV(GLenum target, GLuint index, GLuint count, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glProgramParameters4fvNV" );
}

static void REGAL_CALL loader_glProgramParameters4fvNV(GLenum target, GLuint index, GLuint count, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramParameters4fvNV, "glProgramParameters4fvNV");
   if ( !driverTbl.glProgramParameters4fvNV ) {
      driverTbl.glProgramParameters4fvNV = missing_glProgramParameters4fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramParameters4fvNV == loader_glProgramParameters4fvNV) {
      rCtx->dsp.emuTbl.glProgramParameters4fvNV = driverTbl.glProgramParameters4fvNV;
   }
   driverTbl.glProgramParameters4fvNV(target, index, count, v);
}

static void REGAL_CALL missing_glRequestResidentProgramsNV(GLsizei n, const GLuint *programs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(programs);
   Warning( "Called missing function glRequestResidentProgramsNV" );
}

static void REGAL_CALL loader_glRequestResidentProgramsNV(GLsizei n, const GLuint *programs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRequestResidentProgramsNV, "glRequestResidentProgramsNV");
   if ( !driverTbl.glRequestResidentProgramsNV ) {
      driverTbl.glRequestResidentProgramsNV = missing_glRequestResidentProgramsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRequestResidentProgramsNV == loader_glRequestResidentProgramsNV) {
      rCtx->dsp.emuTbl.glRequestResidentProgramsNV = driverTbl.glRequestResidentProgramsNV;
   }
   driverTbl.glRequestResidentProgramsNV(n, programs);
}

static void REGAL_CALL missing_glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(address);
   UNUSED_PARAMETER(matrix);
   UNUSED_PARAMETER(transform);
   Warning( "Called missing function glTrackMatrixNV" );
}

static void REGAL_CALL loader_glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTrackMatrixNV, "glTrackMatrixNV");
   if ( !driverTbl.glTrackMatrixNV ) {
      driverTbl.glTrackMatrixNV = missing_glTrackMatrixNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTrackMatrixNV == loader_glTrackMatrixNV) {
      rCtx->dsp.emuTbl.glTrackMatrixNV = driverTbl.glTrackMatrixNV;
   }
   driverTbl.glTrackMatrixNV(target, address, matrix, transform);
}

static void REGAL_CALL missing_glVertexAttribPointerNV(GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(fsize);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glVertexAttribPointerNV" );
}

static void REGAL_CALL loader_glVertexAttribPointerNV(GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribPointerNV, "glVertexAttribPointerNV");
   if ( !driverTbl.glVertexAttribPointerNV ) {
      driverTbl.glVertexAttribPointerNV = missing_glVertexAttribPointerNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribPointerNV == loader_glVertexAttribPointerNV) {
      rCtx->dsp.emuTbl.glVertexAttribPointerNV = driverTbl.glVertexAttribPointerNV;
   }
   driverTbl.glVertexAttribPointerNV(index, fsize, type, stride, pointer);
}

static void REGAL_CALL missing_glVertexAttrib1dNV(GLuint index, GLdouble x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttrib1dNV" );
}

static void REGAL_CALL loader_glVertexAttrib1dNV(GLuint index, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1dNV, "glVertexAttrib1dNV");
   if ( !driverTbl.glVertexAttrib1dNV ) {
      driverTbl.glVertexAttrib1dNV = missing_glVertexAttrib1dNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1dNV == loader_glVertexAttrib1dNV) {
      rCtx->dsp.emuTbl.glVertexAttrib1dNV = driverTbl.glVertexAttrib1dNV;
   }
   driverTbl.glVertexAttrib1dNV(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1dvNV(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib1dvNV" );
}

static void REGAL_CALL loader_glVertexAttrib1dvNV(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1dvNV, "glVertexAttrib1dvNV");
   if ( !driverTbl.glVertexAttrib1dvNV ) {
      driverTbl.glVertexAttrib1dvNV = missing_glVertexAttrib1dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1dvNV == loader_glVertexAttrib1dvNV) {
      rCtx->dsp.emuTbl.glVertexAttrib1dvNV = driverTbl.glVertexAttrib1dvNV;
   }
   driverTbl.glVertexAttrib1dvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib1fNV(GLuint index, GLfloat x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttrib1fNV" );
}

static void REGAL_CALL loader_glVertexAttrib1fNV(GLuint index, GLfloat x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1fNV, "glVertexAttrib1fNV");
   if ( !driverTbl.glVertexAttrib1fNV ) {
      driverTbl.glVertexAttrib1fNV = missing_glVertexAttrib1fNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1fNV == loader_glVertexAttrib1fNV) {
      rCtx->dsp.emuTbl.glVertexAttrib1fNV = driverTbl.glVertexAttrib1fNV;
   }
   driverTbl.glVertexAttrib1fNV(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1fvNV(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib1fvNV" );
}

static void REGAL_CALL loader_glVertexAttrib1fvNV(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1fvNV, "glVertexAttrib1fvNV");
   if ( !driverTbl.glVertexAttrib1fvNV ) {
      driverTbl.glVertexAttrib1fvNV = missing_glVertexAttrib1fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1fvNV == loader_glVertexAttrib1fvNV) {
      rCtx->dsp.emuTbl.glVertexAttrib1fvNV = driverTbl.glVertexAttrib1fvNV;
   }
   driverTbl.glVertexAttrib1fvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib1sNV(GLuint index, GLshort x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttrib1sNV" );
}

static void REGAL_CALL loader_glVertexAttrib1sNV(GLuint index, GLshort x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1sNV, "glVertexAttrib1sNV");
   if ( !driverTbl.glVertexAttrib1sNV ) {
      driverTbl.glVertexAttrib1sNV = missing_glVertexAttrib1sNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1sNV == loader_glVertexAttrib1sNV) {
      rCtx->dsp.emuTbl.glVertexAttrib1sNV = driverTbl.glVertexAttrib1sNV;
   }
   driverTbl.glVertexAttrib1sNV(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1svNV(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib1svNV" );
}

static void REGAL_CALL loader_glVertexAttrib1svNV(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1svNV, "glVertexAttrib1svNV");
   if ( !driverTbl.glVertexAttrib1svNV ) {
      driverTbl.glVertexAttrib1svNV = missing_glVertexAttrib1svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1svNV == loader_glVertexAttrib1svNV) {
      rCtx->dsp.emuTbl.glVertexAttrib1svNV = driverTbl.glVertexAttrib1svNV;
   }
   driverTbl.glVertexAttrib1svNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttrib2dNV" );
}

static void REGAL_CALL loader_glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2dNV, "glVertexAttrib2dNV");
   if ( !driverTbl.glVertexAttrib2dNV ) {
      driverTbl.glVertexAttrib2dNV = missing_glVertexAttrib2dNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2dNV == loader_glVertexAttrib2dNV) {
      rCtx->dsp.emuTbl.glVertexAttrib2dNV = driverTbl.glVertexAttrib2dNV;
   }
   driverTbl.glVertexAttrib2dNV(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2dvNV(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib2dvNV" );
}

static void REGAL_CALL loader_glVertexAttrib2dvNV(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2dvNV, "glVertexAttrib2dvNV");
   if ( !driverTbl.glVertexAttrib2dvNV ) {
      driverTbl.glVertexAttrib2dvNV = missing_glVertexAttrib2dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2dvNV == loader_glVertexAttrib2dvNV) {
      rCtx->dsp.emuTbl.glVertexAttrib2dvNV = driverTbl.glVertexAttrib2dvNV;
   }
   driverTbl.glVertexAttrib2dvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttrib2fNV" );
}

static void REGAL_CALL loader_glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2fNV, "glVertexAttrib2fNV");
   if ( !driverTbl.glVertexAttrib2fNV ) {
      driverTbl.glVertexAttrib2fNV = missing_glVertexAttrib2fNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2fNV == loader_glVertexAttrib2fNV) {
      rCtx->dsp.emuTbl.glVertexAttrib2fNV = driverTbl.glVertexAttrib2fNV;
   }
   driverTbl.glVertexAttrib2fNV(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2fvNV(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib2fvNV" );
}

static void REGAL_CALL loader_glVertexAttrib2fvNV(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2fvNV, "glVertexAttrib2fvNV");
   if ( !driverTbl.glVertexAttrib2fvNV ) {
      driverTbl.glVertexAttrib2fvNV = missing_glVertexAttrib2fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2fvNV == loader_glVertexAttrib2fvNV) {
      rCtx->dsp.emuTbl.glVertexAttrib2fvNV = driverTbl.glVertexAttrib2fvNV;
   }
   driverTbl.glVertexAttrib2fvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttrib2sNV" );
}

static void REGAL_CALL loader_glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2sNV, "glVertexAttrib2sNV");
   if ( !driverTbl.glVertexAttrib2sNV ) {
      driverTbl.glVertexAttrib2sNV = missing_glVertexAttrib2sNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2sNV == loader_glVertexAttrib2sNV) {
      rCtx->dsp.emuTbl.glVertexAttrib2sNV = driverTbl.glVertexAttrib2sNV;
   }
   driverTbl.glVertexAttrib2sNV(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2svNV(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib2svNV" );
}

static void REGAL_CALL loader_glVertexAttrib2svNV(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2svNV, "glVertexAttrib2svNV");
   if ( !driverTbl.glVertexAttrib2svNV ) {
      driverTbl.glVertexAttrib2svNV = missing_glVertexAttrib2svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2svNV == loader_glVertexAttrib2svNV) {
      rCtx->dsp.emuTbl.glVertexAttrib2svNV = driverTbl.glVertexAttrib2svNV;
   }
   driverTbl.glVertexAttrib2svNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttrib3dNV" );
}

static void REGAL_CALL loader_glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3dNV, "glVertexAttrib3dNV");
   if ( !driverTbl.glVertexAttrib3dNV ) {
      driverTbl.glVertexAttrib3dNV = missing_glVertexAttrib3dNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3dNV == loader_glVertexAttrib3dNV) {
      rCtx->dsp.emuTbl.glVertexAttrib3dNV = driverTbl.glVertexAttrib3dNV;
   }
   driverTbl.glVertexAttrib3dNV(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3dvNV(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib3dvNV" );
}

static void REGAL_CALL loader_glVertexAttrib3dvNV(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3dvNV, "glVertexAttrib3dvNV");
   if ( !driverTbl.glVertexAttrib3dvNV ) {
      driverTbl.glVertexAttrib3dvNV = missing_glVertexAttrib3dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3dvNV == loader_glVertexAttrib3dvNV) {
      rCtx->dsp.emuTbl.glVertexAttrib3dvNV = driverTbl.glVertexAttrib3dvNV;
   }
   driverTbl.glVertexAttrib3dvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttrib3fNV" );
}

static void REGAL_CALL loader_glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3fNV, "glVertexAttrib3fNV");
   if ( !driverTbl.glVertexAttrib3fNV ) {
      driverTbl.glVertexAttrib3fNV = missing_glVertexAttrib3fNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3fNV == loader_glVertexAttrib3fNV) {
      rCtx->dsp.emuTbl.glVertexAttrib3fNV = driverTbl.glVertexAttrib3fNV;
   }
   driverTbl.glVertexAttrib3fNV(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3fvNV(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib3fvNV" );
}

static void REGAL_CALL loader_glVertexAttrib3fvNV(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3fvNV, "glVertexAttrib3fvNV");
   if ( !driverTbl.glVertexAttrib3fvNV ) {
      driverTbl.glVertexAttrib3fvNV = missing_glVertexAttrib3fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3fvNV == loader_glVertexAttrib3fvNV) {
      rCtx->dsp.emuTbl.glVertexAttrib3fvNV = driverTbl.glVertexAttrib3fvNV;
   }
   driverTbl.glVertexAttrib3fvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttrib3sNV" );
}

static void REGAL_CALL loader_glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3sNV, "glVertexAttrib3sNV");
   if ( !driverTbl.glVertexAttrib3sNV ) {
      driverTbl.glVertexAttrib3sNV = missing_glVertexAttrib3sNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3sNV == loader_glVertexAttrib3sNV) {
      rCtx->dsp.emuTbl.glVertexAttrib3sNV = driverTbl.glVertexAttrib3sNV;
   }
   driverTbl.glVertexAttrib3sNV(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3svNV(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib3svNV" );
}

static void REGAL_CALL loader_glVertexAttrib3svNV(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3svNV, "glVertexAttrib3svNV");
   if ( !driverTbl.glVertexAttrib3svNV ) {
      driverTbl.glVertexAttrib3svNV = missing_glVertexAttrib3svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3svNV == loader_glVertexAttrib3svNV) {
      rCtx->dsp.emuTbl.glVertexAttrib3svNV = driverTbl.glVertexAttrib3svNV;
   }
   driverTbl.glVertexAttrib3svNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttrib4dNV" );
}

static void REGAL_CALL loader_glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4dNV, "glVertexAttrib4dNV");
   if ( !driverTbl.glVertexAttrib4dNV ) {
      driverTbl.glVertexAttrib4dNV = missing_glVertexAttrib4dNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4dNV == loader_glVertexAttrib4dNV) {
      rCtx->dsp.emuTbl.glVertexAttrib4dNV = driverTbl.glVertexAttrib4dNV;
   }
   driverTbl.glVertexAttrib4dNV(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4dvNV(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4dvNV" );
}

static void REGAL_CALL loader_glVertexAttrib4dvNV(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4dvNV, "glVertexAttrib4dvNV");
   if ( !driverTbl.glVertexAttrib4dvNV ) {
      driverTbl.glVertexAttrib4dvNV = missing_glVertexAttrib4dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4dvNV == loader_glVertexAttrib4dvNV) {
      rCtx->dsp.emuTbl.glVertexAttrib4dvNV = driverTbl.glVertexAttrib4dvNV;
   }
   driverTbl.glVertexAttrib4dvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttrib4fNV" );
}

static void REGAL_CALL loader_glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4fNV, "glVertexAttrib4fNV");
   if ( !driverTbl.glVertexAttrib4fNV ) {
      driverTbl.glVertexAttrib4fNV = missing_glVertexAttrib4fNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4fNV == loader_glVertexAttrib4fNV) {
      rCtx->dsp.emuTbl.glVertexAttrib4fNV = driverTbl.glVertexAttrib4fNV;
   }
   driverTbl.glVertexAttrib4fNV(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4fvNV(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4fvNV" );
}

static void REGAL_CALL loader_glVertexAttrib4fvNV(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4fvNV, "glVertexAttrib4fvNV");
   if ( !driverTbl.glVertexAttrib4fvNV ) {
      driverTbl.glVertexAttrib4fvNV = missing_glVertexAttrib4fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4fvNV == loader_glVertexAttrib4fvNV) {
      rCtx->dsp.emuTbl.glVertexAttrib4fvNV = driverTbl.glVertexAttrib4fvNV;
   }
   driverTbl.glVertexAttrib4fvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttrib4sNV" );
}

static void REGAL_CALL loader_glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4sNV, "glVertexAttrib4sNV");
   if ( !driverTbl.glVertexAttrib4sNV ) {
      driverTbl.glVertexAttrib4sNV = missing_glVertexAttrib4sNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4sNV == loader_glVertexAttrib4sNV) {
      rCtx->dsp.emuTbl.glVertexAttrib4sNV = driverTbl.glVertexAttrib4sNV;
   }
   driverTbl.glVertexAttrib4sNV(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4svNV(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4svNV" );
}

static void REGAL_CALL loader_glVertexAttrib4svNV(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4svNV, "glVertexAttrib4svNV");
   if ( !driverTbl.glVertexAttrib4svNV ) {
      driverTbl.glVertexAttrib4svNV = missing_glVertexAttrib4svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4svNV == loader_glVertexAttrib4svNV) {
      rCtx->dsp.emuTbl.glVertexAttrib4svNV = driverTbl.glVertexAttrib4svNV;
   }
   driverTbl.glVertexAttrib4svNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttrib4ubNV" );
}

static void REGAL_CALL loader_glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4ubNV, "glVertexAttrib4ubNV");
   if ( !driverTbl.glVertexAttrib4ubNV ) {
      driverTbl.glVertexAttrib4ubNV = missing_glVertexAttrib4ubNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4ubNV == loader_glVertexAttrib4ubNV) {
      rCtx->dsp.emuTbl.glVertexAttrib4ubNV = driverTbl.glVertexAttrib4ubNV;
   }
   driverTbl.glVertexAttrib4ubNV(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4ubvNV(GLuint index, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4ubvNV" );
}

static void REGAL_CALL loader_glVertexAttrib4ubvNV(GLuint index, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4ubvNV, "glVertexAttrib4ubvNV");
   if ( !driverTbl.glVertexAttrib4ubvNV ) {
      driverTbl.glVertexAttrib4ubvNV = missing_glVertexAttrib4ubvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4ubvNV == loader_glVertexAttrib4ubvNV) {
      rCtx->dsp.emuTbl.glVertexAttrib4ubvNV = driverTbl.glVertexAttrib4ubvNV;
   }
   driverTbl.glVertexAttrib4ubvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribs1dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs1dvNV" );
}

static void REGAL_CALL loader_glVertexAttribs1dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs1dvNV, "glVertexAttribs1dvNV");
   if ( !driverTbl.glVertexAttribs1dvNV ) {
      driverTbl.glVertexAttribs1dvNV = missing_glVertexAttribs1dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs1dvNV == loader_glVertexAttribs1dvNV) {
      rCtx->dsp.emuTbl.glVertexAttribs1dvNV = driverTbl.glVertexAttribs1dvNV;
   }
   driverTbl.glVertexAttribs1dvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs1fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs1fvNV" );
}

static void REGAL_CALL loader_glVertexAttribs1fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs1fvNV, "glVertexAttribs1fvNV");
   if ( !driverTbl.glVertexAttribs1fvNV ) {
      driverTbl.glVertexAttribs1fvNV = missing_glVertexAttribs1fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs1fvNV == loader_glVertexAttribs1fvNV) {
      rCtx->dsp.emuTbl.glVertexAttribs1fvNV = driverTbl.glVertexAttribs1fvNV;
   }
   driverTbl.glVertexAttribs1fvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs1svNV(GLuint index, GLsizei n, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs1svNV" );
}

static void REGAL_CALL loader_glVertexAttribs1svNV(GLuint index, GLsizei n, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs1svNV, "glVertexAttribs1svNV");
   if ( !driverTbl.glVertexAttribs1svNV ) {
      driverTbl.glVertexAttribs1svNV = missing_glVertexAttribs1svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs1svNV == loader_glVertexAttribs1svNV) {
      rCtx->dsp.emuTbl.glVertexAttribs1svNV = driverTbl.glVertexAttribs1svNV;
   }
   driverTbl.glVertexAttribs1svNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs2dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs2dvNV" );
}

static void REGAL_CALL loader_glVertexAttribs2dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs2dvNV, "glVertexAttribs2dvNV");
   if ( !driverTbl.glVertexAttribs2dvNV ) {
      driverTbl.glVertexAttribs2dvNV = missing_glVertexAttribs2dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs2dvNV == loader_glVertexAttribs2dvNV) {
      rCtx->dsp.emuTbl.glVertexAttribs2dvNV = driverTbl.glVertexAttribs2dvNV;
   }
   driverTbl.glVertexAttribs2dvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs2fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs2fvNV" );
}

static void REGAL_CALL loader_glVertexAttribs2fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs2fvNV, "glVertexAttribs2fvNV");
   if ( !driverTbl.glVertexAttribs2fvNV ) {
      driverTbl.glVertexAttribs2fvNV = missing_glVertexAttribs2fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs2fvNV == loader_glVertexAttribs2fvNV) {
      rCtx->dsp.emuTbl.glVertexAttribs2fvNV = driverTbl.glVertexAttribs2fvNV;
   }
   driverTbl.glVertexAttribs2fvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs2svNV(GLuint index, GLsizei n, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs2svNV" );
}

static void REGAL_CALL loader_glVertexAttribs2svNV(GLuint index, GLsizei n, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs2svNV, "glVertexAttribs2svNV");
   if ( !driverTbl.glVertexAttribs2svNV ) {
      driverTbl.glVertexAttribs2svNV = missing_glVertexAttribs2svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs2svNV == loader_glVertexAttribs2svNV) {
      rCtx->dsp.emuTbl.glVertexAttribs2svNV = driverTbl.glVertexAttribs2svNV;
   }
   driverTbl.glVertexAttribs2svNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs3dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs3dvNV" );
}

static void REGAL_CALL loader_glVertexAttribs3dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs3dvNV, "glVertexAttribs3dvNV");
   if ( !driverTbl.glVertexAttribs3dvNV ) {
      driverTbl.glVertexAttribs3dvNV = missing_glVertexAttribs3dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs3dvNV == loader_glVertexAttribs3dvNV) {
      rCtx->dsp.emuTbl.glVertexAttribs3dvNV = driverTbl.glVertexAttribs3dvNV;
   }
   driverTbl.glVertexAttribs3dvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs3fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs3fvNV" );
}

static void REGAL_CALL loader_glVertexAttribs3fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs3fvNV, "glVertexAttribs3fvNV");
   if ( !driverTbl.glVertexAttribs3fvNV ) {
      driverTbl.glVertexAttribs3fvNV = missing_glVertexAttribs3fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs3fvNV == loader_glVertexAttribs3fvNV) {
      rCtx->dsp.emuTbl.glVertexAttribs3fvNV = driverTbl.glVertexAttribs3fvNV;
   }
   driverTbl.glVertexAttribs3fvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs3svNV(GLuint index, GLsizei n, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs3svNV" );
}

static void REGAL_CALL loader_glVertexAttribs3svNV(GLuint index, GLsizei n, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs3svNV, "glVertexAttribs3svNV");
   if ( !driverTbl.glVertexAttribs3svNV ) {
      driverTbl.glVertexAttribs3svNV = missing_glVertexAttribs3svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs3svNV == loader_glVertexAttribs3svNV) {
      rCtx->dsp.emuTbl.glVertexAttribs3svNV = driverTbl.glVertexAttribs3svNV;
   }
   driverTbl.glVertexAttribs3svNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs4dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs4dvNV" );
}

static void REGAL_CALL loader_glVertexAttribs4dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs4dvNV, "glVertexAttribs4dvNV");
   if ( !driverTbl.glVertexAttribs4dvNV ) {
      driverTbl.glVertexAttribs4dvNV = missing_glVertexAttribs4dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs4dvNV == loader_glVertexAttribs4dvNV) {
      rCtx->dsp.emuTbl.glVertexAttribs4dvNV = driverTbl.glVertexAttribs4dvNV;
   }
   driverTbl.glVertexAttribs4dvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs4fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs4fvNV" );
}

static void REGAL_CALL loader_glVertexAttribs4fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs4fvNV, "glVertexAttribs4fvNV");
   if ( !driverTbl.glVertexAttribs4fvNV ) {
      driverTbl.glVertexAttribs4fvNV = missing_glVertexAttribs4fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs4fvNV == loader_glVertexAttribs4fvNV) {
      rCtx->dsp.emuTbl.glVertexAttribs4fvNV = driverTbl.glVertexAttribs4fvNV;
   }
   driverTbl.glVertexAttribs4fvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs4svNV(GLuint index, GLsizei n, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs4svNV" );
}

static void REGAL_CALL loader_glVertexAttribs4svNV(GLuint index, GLsizei n, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs4svNV, "glVertexAttribs4svNV");
   if ( !driverTbl.glVertexAttribs4svNV ) {
      driverTbl.glVertexAttribs4svNV = missing_glVertexAttribs4svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs4svNV == loader_glVertexAttribs4svNV) {
      rCtx->dsp.emuTbl.glVertexAttribs4svNV = driverTbl.glVertexAttribs4svNV;
   }
   driverTbl.glVertexAttribs4svNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs4ubvNV(GLuint index, GLsizei n, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs4ubvNV" );
}

static void REGAL_CALL loader_glVertexAttribs4ubvNV(GLuint index, GLsizei n, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs4ubvNV, "glVertexAttribs4ubvNV");
   if ( !driverTbl.glVertexAttribs4ubvNV ) {
      driverTbl.glVertexAttribs4ubvNV = missing_glVertexAttribs4ubvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs4ubvNV == loader_glVertexAttribs4ubvNV) {
      rCtx->dsp.emuTbl.glVertexAttribs4ubvNV = driverTbl.glVertexAttribs4ubvNV;
   }
   driverTbl.glVertexAttribs4ubvNV(index, n, v);
}

// GL_ATI_envmap_bumpmap

static void REGAL_CALL missing_glTexBumpParameterivATI(GLenum pname, GLint *param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glTexBumpParameterivATI" );
}

static void REGAL_CALL loader_glTexBumpParameterivATI(GLenum pname, GLint *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexBumpParameterivATI, "glTexBumpParameterivATI");
   if ( !driverTbl.glTexBumpParameterivATI ) {
      driverTbl.glTexBumpParameterivATI = missing_glTexBumpParameterivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexBumpParameterivATI == loader_glTexBumpParameterivATI) {
      rCtx->dsp.emuTbl.glTexBumpParameterivATI = driverTbl.glTexBumpParameterivATI;
   }
   driverTbl.glTexBumpParameterivATI(pname, param);
}

static void REGAL_CALL missing_glTexBumpParameterfvATI(GLenum pname, GLfloat *param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glTexBumpParameterfvATI" );
}

static void REGAL_CALL loader_glTexBumpParameterfvATI(GLenum pname, GLfloat *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexBumpParameterfvATI, "glTexBumpParameterfvATI");
   if ( !driverTbl.glTexBumpParameterfvATI ) {
      driverTbl.glTexBumpParameterfvATI = missing_glTexBumpParameterfvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexBumpParameterfvATI == loader_glTexBumpParameterfvATI) {
      rCtx->dsp.emuTbl.glTexBumpParameterfvATI = driverTbl.glTexBumpParameterfvATI;
   }
   driverTbl.glTexBumpParameterfvATI(pname, param);
}

static void REGAL_CALL missing_glGetTexBumpParameterivATI(GLenum pname, GLint *param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glGetTexBumpParameterivATI" );
}

static void REGAL_CALL loader_glGetTexBumpParameterivATI(GLenum pname, GLint *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexBumpParameterivATI, "glGetTexBumpParameterivATI");
   if ( !driverTbl.glGetTexBumpParameterivATI ) {
      driverTbl.glGetTexBumpParameterivATI = missing_glGetTexBumpParameterivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexBumpParameterivATI == loader_glGetTexBumpParameterivATI) {
      rCtx->dsp.emuTbl.glGetTexBumpParameterivATI = driverTbl.glGetTexBumpParameterivATI;
   }
   driverTbl.glGetTexBumpParameterivATI(pname, param);
}

static void REGAL_CALL missing_glGetTexBumpParameterfvATI(GLenum pname, GLfloat *param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glGetTexBumpParameterfvATI" );
}

static void REGAL_CALL loader_glGetTexBumpParameterfvATI(GLenum pname, GLfloat *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexBumpParameterfvATI, "glGetTexBumpParameterfvATI");
   if ( !driverTbl.glGetTexBumpParameterfvATI ) {
      driverTbl.glGetTexBumpParameterfvATI = missing_glGetTexBumpParameterfvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexBumpParameterfvATI == loader_glGetTexBumpParameterfvATI) {
      rCtx->dsp.emuTbl.glGetTexBumpParameterfvATI = driverTbl.glGetTexBumpParameterfvATI;
   }
   driverTbl.glGetTexBumpParameterfvATI(pname, param);
}

// GL_ATI_fragment_shader

static GLuint REGAL_CALL missing_glGenFragmentShadersATI(GLuint range)
{
   UNUSED_PARAMETER(range);
   Warning( "Called missing function glGenFragmentShadersATI" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGenFragmentShadersATI(GLuint range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenFragmentShadersATI, "glGenFragmentShadersATI");
   if ( !driverTbl.glGenFragmentShadersATI ) {
      driverTbl.glGenFragmentShadersATI = missing_glGenFragmentShadersATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenFragmentShadersATI == loader_glGenFragmentShadersATI) {
      rCtx->dsp.emuTbl.glGenFragmentShadersATI = driverTbl.glGenFragmentShadersATI;
   }
   return driverTbl.glGenFragmentShadersATI(range);
}

static void REGAL_CALL missing_glBindFragmentShaderATI(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glBindFragmentShaderATI" );
}

static void REGAL_CALL loader_glBindFragmentShaderATI(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindFragmentShaderATI, "glBindFragmentShaderATI");
   if ( !driverTbl.glBindFragmentShaderATI ) {
      driverTbl.glBindFragmentShaderATI = missing_glBindFragmentShaderATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindFragmentShaderATI == loader_glBindFragmentShaderATI) {
      rCtx->dsp.emuTbl.glBindFragmentShaderATI = driverTbl.glBindFragmentShaderATI;
   }
   driverTbl.glBindFragmentShaderATI(id);
}

static void REGAL_CALL missing_glDeleteFragmentShaderATI(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glDeleteFragmentShaderATI" );
}

static void REGAL_CALL loader_glDeleteFragmentShaderATI(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteFragmentShaderATI, "glDeleteFragmentShaderATI");
   if ( !driverTbl.glDeleteFragmentShaderATI ) {
      driverTbl.glDeleteFragmentShaderATI = missing_glDeleteFragmentShaderATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteFragmentShaderATI == loader_glDeleteFragmentShaderATI) {
      rCtx->dsp.emuTbl.glDeleteFragmentShaderATI = driverTbl.glDeleteFragmentShaderATI;
   }
   driverTbl.glDeleteFragmentShaderATI(id);
}

static void REGAL_CALL missing_glBeginFragmentShaderATI(void)
{
   Warning( "Called missing function glBeginFragmentShaderATI" );
}

static void REGAL_CALL loader_glBeginFragmentShaderATI(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBeginFragmentShaderATI, "glBeginFragmentShaderATI");
   if ( !driverTbl.glBeginFragmentShaderATI ) {
      driverTbl.glBeginFragmentShaderATI = missing_glBeginFragmentShaderATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBeginFragmentShaderATI == loader_glBeginFragmentShaderATI) {
      rCtx->dsp.emuTbl.glBeginFragmentShaderATI = driverTbl.glBeginFragmentShaderATI;
   }
   driverTbl.glBeginFragmentShaderATI();
}

static void REGAL_CALL missing_glEndFragmentShaderATI(void)
{
   Warning( "Called missing function glEndFragmentShaderATI" );
}

static void REGAL_CALL loader_glEndFragmentShaderATI(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndFragmentShaderATI, "glEndFragmentShaderATI");
   if ( !driverTbl.glEndFragmentShaderATI ) {
      driverTbl.glEndFragmentShaderATI = missing_glEndFragmentShaderATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndFragmentShaderATI == loader_glEndFragmentShaderATI) {
      rCtx->dsp.emuTbl.glEndFragmentShaderATI = driverTbl.glEndFragmentShaderATI;
   }
   driverTbl.glEndFragmentShaderATI();
}

static void REGAL_CALL missing_glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle)
{
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(swizzle);
   Warning( "Called missing function glPassTexCoordATI" );
}

static void REGAL_CALL loader_glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPassTexCoordATI, "glPassTexCoordATI");
   if ( !driverTbl.glPassTexCoordATI ) {
      driverTbl.glPassTexCoordATI = missing_glPassTexCoordATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPassTexCoordATI == loader_glPassTexCoordATI) {
      rCtx->dsp.emuTbl.glPassTexCoordATI = driverTbl.glPassTexCoordATI;
   }
   driverTbl.glPassTexCoordATI(dst, coord, swizzle);
}

static void REGAL_CALL missing_glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle)
{
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(interp);
   UNUSED_PARAMETER(swizzle);
   Warning( "Called missing function glSampleMapATI" );
}

static void REGAL_CALL loader_glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSampleMapATI, "glSampleMapATI");
   if ( !driverTbl.glSampleMapATI ) {
      driverTbl.glSampleMapATI = missing_glSampleMapATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSampleMapATI == loader_glSampleMapATI) {
      rCtx->dsp.emuTbl.glSampleMapATI = driverTbl.glSampleMapATI;
   }
   driverTbl.glSampleMapATI(dst, interp, swizzle);
}

static void REGAL_CALL missing_glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(dstMask);
   UNUSED_PARAMETER(dstMod);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg1Rep);
   UNUSED_PARAMETER(arg1Mod);
   Warning( "Called missing function glColorFragmentOp1ATI" );
}

static void REGAL_CALL loader_glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorFragmentOp1ATI, "glColorFragmentOp1ATI");
   if ( !driverTbl.glColorFragmentOp1ATI ) {
      driverTbl.glColorFragmentOp1ATI = missing_glColorFragmentOp1ATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorFragmentOp1ATI == loader_glColorFragmentOp1ATI) {
      rCtx->dsp.emuTbl.glColorFragmentOp1ATI = driverTbl.glColorFragmentOp1ATI;
   }
   driverTbl.glColorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
}

static void REGAL_CALL missing_glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(dstMask);
   UNUSED_PARAMETER(dstMod);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg1Rep);
   UNUSED_PARAMETER(arg1Mod);
   UNUSED_PARAMETER(arg2);
   UNUSED_PARAMETER(arg2Rep);
   UNUSED_PARAMETER(arg2Mod);
   Warning( "Called missing function glColorFragmentOp2ATI" );
}

static void REGAL_CALL loader_glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorFragmentOp2ATI, "glColorFragmentOp2ATI");
   if ( !driverTbl.glColorFragmentOp2ATI ) {
      driverTbl.glColorFragmentOp2ATI = missing_glColorFragmentOp2ATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorFragmentOp2ATI == loader_glColorFragmentOp2ATI) {
      rCtx->dsp.emuTbl.glColorFragmentOp2ATI = driverTbl.glColorFragmentOp2ATI;
   }
   driverTbl.glColorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
}

static void REGAL_CALL missing_glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(dstMask);
   UNUSED_PARAMETER(dstMod);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg1Rep);
   UNUSED_PARAMETER(arg1Mod);
   UNUSED_PARAMETER(arg2);
   UNUSED_PARAMETER(arg2Rep);
   UNUSED_PARAMETER(arg2Mod);
   UNUSED_PARAMETER(arg3);
   UNUSED_PARAMETER(arg3Rep);
   UNUSED_PARAMETER(arg3Mod);
   Warning( "Called missing function glColorFragmentOp3ATI" );
}

static void REGAL_CALL loader_glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorFragmentOp3ATI, "glColorFragmentOp3ATI");
   if ( !driverTbl.glColorFragmentOp3ATI ) {
      driverTbl.glColorFragmentOp3ATI = missing_glColorFragmentOp3ATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorFragmentOp3ATI == loader_glColorFragmentOp3ATI) {
      rCtx->dsp.emuTbl.glColorFragmentOp3ATI = driverTbl.glColorFragmentOp3ATI;
   }
   driverTbl.glColorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
}

static void REGAL_CALL missing_glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(dstMod);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg1Rep);
   UNUSED_PARAMETER(arg1Mod);
   Warning( "Called missing function glAlphaFragmentOp1ATI" );
}

static void REGAL_CALL loader_glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glAlphaFragmentOp1ATI, "glAlphaFragmentOp1ATI");
   if ( !driverTbl.glAlphaFragmentOp1ATI ) {
      driverTbl.glAlphaFragmentOp1ATI = missing_glAlphaFragmentOp1ATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glAlphaFragmentOp1ATI == loader_glAlphaFragmentOp1ATI) {
      rCtx->dsp.emuTbl.glAlphaFragmentOp1ATI = driverTbl.glAlphaFragmentOp1ATI;
   }
   driverTbl.glAlphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
}

static void REGAL_CALL missing_glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(dstMod);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg1Rep);
   UNUSED_PARAMETER(arg1Mod);
   UNUSED_PARAMETER(arg2);
   UNUSED_PARAMETER(arg2Rep);
   UNUSED_PARAMETER(arg2Mod);
   Warning( "Called missing function glAlphaFragmentOp2ATI" );
}

static void REGAL_CALL loader_glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glAlphaFragmentOp2ATI, "glAlphaFragmentOp2ATI");
   if ( !driverTbl.glAlphaFragmentOp2ATI ) {
      driverTbl.glAlphaFragmentOp2ATI = missing_glAlphaFragmentOp2ATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glAlphaFragmentOp2ATI == loader_glAlphaFragmentOp2ATI) {
      rCtx->dsp.emuTbl.glAlphaFragmentOp2ATI = driverTbl.glAlphaFragmentOp2ATI;
   }
   driverTbl.glAlphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
}

static void REGAL_CALL missing_glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(dstMod);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg1Rep);
   UNUSED_PARAMETER(arg1Mod);
   UNUSED_PARAMETER(arg2);
   UNUSED_PARAMETER(arg2Rep);
   UNUSED_PARAMETER(arg2Mod);
   UNUSED_PARAMETER(arg3);
   UNUSED_PARAMETER(arg3Rep);
   UNUSED_PARAMETER(arg3Mod);
   Warning( "Called missing function glAlphaFragmentOp3ATI" );
}

static void REGAL_CALL loader_glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glAlphaFragmentOp3ATI, "glAlphaFragmentOp3ATI");
   if ( !driverTbl.glAlphaFragmentOp3ATI ) {
      driverTbl.glAlphaFragmentOp3ATI = missing_glAlphaFragmentOp3ATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glAlphaFragmentOp3ATI == loader_glAlphaFragmentOp3ATI) {
      rCtx->dsp.emuTbl.glAlphaFragmentOp3ATI = driverTbl.glAlphaFragmentOp3ATI;
   }
   driverTbl.glAlphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
}

static void REGAL_CALL missing_glSetFragmentShaderConstantATI(GLuint dst, const GLfloat *value)
{
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glSetFragmentShaderConstantATI" );
}

static void REGAL_CALL loader_glSetFragmentShaderConstantATI(GLuint dst, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSetFragmentShaderConstantATI, "glSetFragmentShaderConstantATI");
   if ( !driverTbl.glSetFragmentShaderConstantATI ) {
      driverTbl.glSetFragmentShaderConstantATI = missing_glSetFragmentShaderConstantATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSetFragmentShaderConstantATI == loader_glSetFragmentShaderConstantATI) {
      rCtx->dsp.emuTbl.glSetFragmentShaderConstantATI = driverTbl.glSetFragmentShaderConstantATI;
   }
   driverTbl.glSetFragmentShaderConstantATI(dst, value);
}

// GL_ATI_pn_triangles

static void REGAL_CALL missing_glPNTrianglesiATI(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPNTrianglesiATI" );
}

static void REGAL_CALL loader_glPNTrianglesiATI(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPNTrianglesiATI, "glPNTrianglesiATI");
   if ( !driverTbl.glPNTrianglesiATI ) {
      driverTbl.glPNTrianglesiATI = missing_glPNTrianglesiATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPNTrianglesiATI == loader_glPNTrianglesiATI) {
      rCtx->dsp.emuTbl.glPNTrianglesiATI = driverTbl.glPNTrianglesiATI;
   }
   driverTbl.glPNTrianglesiATI(pname, param);
}

static void REGAL_CALL missing_glPNTrianglesfATI(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPNTrianglesfATI" );
}

static void REGAL_CALL loader_glPNTrianglesfATI(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPNTrianglesfATI, "glPNTrianglesfATI");
   if ( !driverTbl.glPNTrianglesfATI ) {
      driverTbl.glPNTrianglesfATI = missing_glPNTrianglesfATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPNTrianglesfATI == loader_glPNTrianglesfATI) {
      rCtx->dsp.emuTbl.glPNTrianglesfATI = driverTbl.glPNTrianglesfATI;
   }
   driverTbl.glPNTrianglesfATI(pname, param);
}

// GL_ATI_vertex_array_object

static GLuint REGAL_CALL missing_glNewObjectBufferATI(GLsizei size, const GLvoid *pointer, GLenum usage)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(usage);
   Warning( "Called missing function glNewObjectBufferATI" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glNewObjectBufferATI(GLsizei size, const GLvoid *pointer, GLenum usage)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNewObjectBufferATI, "glNewObjectBufferATI");
   if ( !driverTbl.glNewObjectBufferATI ) {
      driverTbl.glNewObjectBufferATI = missing_glNewObjectBufferATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNewObjectBufferATI == loader_glNewObjectBufferATI) {
      rCtx->dsp.emuTbl.glNewObjectBufferATI = driverTbl.glNewObjectBufferATI;
   }
   return driverTbl.glNewObjectBufferATI(size, pointer, usage);
}

static GLboolean REGAL_CALL missing_glIsObjectBufferATI(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glIsObjectBufferATI" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsObjectBufferATI(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsObjectBufferATI, "glIsObjectBufferATI");
   if ( !driverTbl.glIsObjectBufferATI ) {
      driverTbl.glIsObjectBufferATI = missing_glIsObjectBufferATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsObjectBufferATI == loader_glIsObjectBufferATI) {
      rCtx->dsp.emuTbl.glIsObjectBufferATI = driverTbl.glIsObjectBufferATI;
   }
   return driverTbl.glIsObjectBufferATI(buffer);
}

static void REGAL_CALL missing_glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(preserve);
   Warning( "Called missing function glUpdateObjectBufferATI" );
}

static void REGAL_CALL loader_glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUpdateObjectBufferATI, "glUpdateObjectBufferATI");
   if ( !driverTbl.glUpdateObjectBufferATI ) {
      driverTbl.glUpdateObjectBufferATI = missing_glUpdateObjectBufferATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUpdateObjectBufferATI == loader_glUpdateObjectBufferATI) {
      rCtx->dsp.emuTbl.glUpdateObjectBufferATI = driverTbl.glUpdateObjectBufferATI;
   }
   driverTbl.glUpdateObjectBufferATI(buffer, offset, size, pointer, preserve);
}

static void REGAL_CALL missing_glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetObjectBufferfvATI" );
}

static void REGAL_CALL loader_glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetObjectBufferfvATI, "glGetObjectBufferfvATI");
   if ( !driverTbl.glGetObjectBufferfvATI ) {
      driverTbl.glGetObjectBufferfvATI = missing_glGetObjectBufferfvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetObjectBufferfvATI == loader_glGetObjectBufferfvATI) {
      rCtx->dsp.emuTbl.glGetObjectBufferfvATI = driverTbl.glGetObjectBufferfvATI;
   }
   driverTbl.glGetObjectBufferfvATI(buffer, pname, params);
}

static void REGAL_CALL missing_glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetObjectBufferivATI" );
}

static void REGAL_CALL loader_glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetObjectBufferivATI, "glGetObjectBufferivATI");
   if ( !driverTbl.glGetObjectBufferivATI ) {
      driverTbl.glGetObjectBufferivATI = missing_glGetObjectBufferivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetObjectBufferivATI == loader_glGetObjectBufferivATI) {
      rCtx->dsp.emuTbl.glGetObjectBufferivATI = driverTbl.glGetObjectBufferivATI;
   }
   driverTbl.glGetObjectBufferivATI(buffer, pname, params);
}

static void REGAL_CALL missing_glFreeObjectBufferATI(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glFreeObjectBufferATI" );
}

static void REGAL_CALL loader_glFreeObjectBufferATI(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFreeObjectBufferATI, "glFreeObjectBufferATI");
   if ( !driverTbl.glFreeObjectBufferATI ) {
      driverTbl.glFreeObjectBufferATI = missing_glFreeObjectBufferATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFreeObjectBufferATI == loader_glFreeObjectBufferATI) {
      rCtx->dsp.emuTbl.glFreeObjectBufferATI = driverTbl.glFreeObjectBufferATI;
   }
   driverTbl.glFreeObjectBufferATI(buffer);
}

static void REGAL_CALL missing_glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
   UNUSED_PARAMETER(array);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   Warning( "Called missing function glArrayObjectATI" );
}

static void REGAL_CALL loader_glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glArrayObjectATI, "glArrayObjectATI");
   if ( !driverTbl.glArrayObjectATI ) {
      driverTbl.glArrayObjectATI = missing_glArrayObjectATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glArrayObjectATI == loader_glArrayObjectATI) {
      rCtx->dsp.emuTbl.glArrayObjectATI = driverTbl.glArrayObjectATI;
   }
   driverTbl.glArrayObjectATI(array, size, type, stride, buffer, offset);
}

static void REGAL_CALL missing_glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(array);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetArrayObjectfvATI" );
}

static void REGAL_CALL loader_glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetArrayObjectfvATI, "glGetArrayObjectfvATI");
   if ( !driverTbl.glGetArrayObjectfvATI ) {
      driverTbl.glGetArrayObjectfvATI = missing_glGetArrayObjectfvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetArrayObjectfvATI == loader_glGetArrayObjectfvATI) {
      rCtx->dsp.emuTbl.glGetArrayObjectfvATI = driverTbl.glGetArrayObjectfvATI;
   }
   driverTbl.glGetArrayObjectfvATI(array, pname, params);
}

static void REGAL_CALL missing_glGetArrayObjectivATI(GLenum array, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(array);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetArrayObjectivATI" );
}

static void REGAL_CALL loader_glGetArrayObjectivATI(GLenum array, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetArrayObjectivATI, "glGetArrayObjectivATI");
   if ( !driverTbl.glGetArrayObjectivATI ) {
      driverTbl.glGetArrayObjectivATI = missing_glGetArrayObjectivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetArrayObjectivATI == loader_glGetArrayObjectivATI) {
      rCtx->dsp.emuTbl.glGetArrayObjectivATI = driverTbl.glGetArrayObjectivATI;
   }
   driverTbl.glGetArrayObjectivATI(array, pname, params);
}

static void REGAL_CALL missing_glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   Warning( "Called missing function glVariantArrayObjectATI" );
}

static void REGAL_CALL loader_glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVariantArrayObjectATI, "glVariantArrayObjectATI");
   if ( !driverTbl.glVariantArrayObjectATI ) {
      driverTbl.glVariantArrayObjectATI = missing_glVariantArrayObjectATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVariantArrayObjectATI == loader_glVariantArrayObjectATI) {
      rCtx->dsp.emuTbl.glVariantArrayObjectATI = driverTbl.glVariantArrayObjectATI;
   }
   driverTbl.glVariantArrayObjectATI(id, type, stride, buffer, offset);
}

static void REGAL_CALL missing_glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVariantArrayObjectfvATI" );
}

static void REGAL_CALL loader_glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVariantArrayObjectfvATI, "glGetVariantArrayObjectfvATI");
   if ( !driverTbl.glGetVariantArrayObjectfvATI ) {
      driverTbl.glGetVariantArrayObjectfvATI = missing_glGetVariantArrayObjectfvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVariantArrayObjectfvATI == loader_glGetVariantArrayObjectfvATI) {
      rCtx->dsp.emuTbl.glGetVariantArrayObjectfvATI = driverTbl.glGetVariantArrayObjectfvATI;
   }
   driverTbl.glGetVariantArrayObjectfvATI(id, pname, params);
}

static void REGAL_CALL missing_glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVariantArrayObjectivATI" );
}

static void REGAL_CALL loader_glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVariantArrayObjectivATI, "glGetVariantArrayObjectivATI");
   if ( !driverTbl.glGetVariantArrayObjectivATI ) {
      driverTbl.glGetVariantArrayObjectivATI = missing_glGetVariantArrayObjectivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVariantArrayObjectivATI == loader_glGetVariantArrayObjectivATI) {
      rCtx->dsp.emuTbl.glGetVariantArrayObjectivATI = driverTbl.glGetVariantArrayObjectivATI;
   }
   driverTbl.glGetVariantArrayObjectivATI(id, pname, params);
}

// GL_EXT_vertex_shader

static void REGAL_CALL missing_glBeginVertexShaderEXT(void)
{
   Warning( "Called missing function glBeginVertexShaderEXT" );
}

static void REGAL_CALL loader_glBeginVertexShaderEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBeginVertexShaderEXT, "glBeginVertexShaderEXT");
   if ( !driverTbl.glBeginVertexShaderEXT ) {
      driverTbl.glBeginVertexShaderEXT = missing_glBeginVertexShaderEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBeginVertexShaderEXT == loader_glBeginVertexShaderEXT) {
      rCtx->dsp.emuTbl.glBeginVertexShaderEXT = driverTbl.glBeginVertexShaderEXT;
   }
   driverTbl.glBeginVertexShaderEXT();
}

static void REGAL_CALL missing_glEndVertexShaderEXT(void)
{
   Warning( "Called missing function glEndVertexShaderEXT" );
}

static void REGAL_CALL loader_glEndVertexShaderEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndVertexShaderEXT, "glEndVertexShaderEXT");
   if ( !driverTbl.glEndVertexShaderEXT ) {
      driverTbl.glEndVertexShaderEXT = missing_glEndVertexShaderEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndVertexShaderEXT == loader_glEndVertexShaderEXT) {
      rCtx->dsp.emuTbl.glEndVertexShaderEXT = driverTbl.glEndVertexShaderEXT;
   }
   driverTbl.glEndVertexShaderEXT();
}

static void REGAL_CALL missing_glBindVertexShaderEXT(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glBindVertexShaderEXT" );
}

static void REGAL_CALL loader_glBindVertexShaderEXT(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindVertexShaderEXT, "glBindVertexShaderEXT");
   if ( !driverTbl.glBindVertexShaderEXT ) {
      driverTbl.glBindVertexShaderEXT = missing_glBindVertexShaderEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindVertexShaderEXT == loader_glBindVertexShaderEXT) {
      rCtx->dsp.emuTbl.glBindVertexShaderEXT = driverTbl.glBindVertexShaderEXT;
   }
   driverTbl.glBindVertexShaderEXT(id);
}

static GLuint REGAL_CALL missing_glGenVertexShadersEXT(GLuint range)
{
   UNUSED_PARAMETER(range);
   Warning( "Called missing function glGenVertexShadersEXT" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGenVertexShadersEXT(GLuint range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenVertexShadersEXT, "glGenVertexShadersEXT");
   if ( !driverTbl.glGenVertexShadersEXT ) {
      driverTbl.glGenVertexShadersEXT = missing_glGenVertexShadersEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenVertexShadersEXT == loader_glGenVertexShadersEXT) {
      rCtx->dsp.emuTbl.glGenVertexShadersEXT = driverTbl.glGenVertexShadersEXT;
   }
   return driverTbl.glGenVertexShadersEXT(range);
}

static void REGAL_CALL missing_glDeleteVertexShaderEXT(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glDeleteVertexShaderEXT" );
}

static void REGAL_CALL loader_glDeleteVertexShaderEXT(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteVertexShaderEXT, "glDeleteVertexShaderEXT");
   if ( !driverTbl.glDeleteVertexShaderEXT ) {
      driverTbl.glDeleteVertexShaderEXT = missing_glDeleteVertexShaderEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteVertexShaderEXT == loader_glDeleteVertexShaderEXT) {
      rCtx->dsp.emuTbl.glDeleteVertexShaderEXT = driverTbl.glDeleteVertexShaderEXT;
   }
   driverTbl.glDeleteVertexShaderEXT(id);
}

static void REGAL_CALL missing_glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(res);
   UNUSED_PARAMETER(arg1);
   Warning( "Called missing function glShaderOp1EXT" );
}

static void REGAL_CALL loader_glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glShaderOp1EXT, "glShaderOp1EXT");
   if ( !driverTbl.glShaderOp1EXT ) {
      driverTbl.glShaderOp1EXT = missing_glShaderOp1EXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glShaderOp1EXT == loader_glShaderOp1EXT) {
      rCtx->dsp.emuTbl.glShaderOp1EXT = driverTbl.glShaderOp1EXT;
   }
   driverTbl.glShaderOp1EXT(op, res, arg1);
}

static void REGAL_CALL missing_glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(res);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg2);
   Warning( "Called missing function glShaderOp2EXT" );
}

static void REGAL_CALL loader_glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glShaderOp2EXT, "glShaderOp2EXT");
   if ( !driverTbl.glShaderOp2EXT ) {
      driverTbl.glShaderOp2EXT = missing_glShaderOp2EXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glShaderOp2EXT == loader_glShaderOp2EXT) {
      rCtx->dsp.emuTbl.glShaderOp2EXT = driverTbl.glShaderOp2EXT;
   }
   driverTbl.glShaderOp2EXT(op, res, arg1, arg2);
}

static void REGAL_CALL missing_glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(res);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg2);
   UNUSED_PARAMETER(arg3);
   Warning( "Called missing function glShaderOp3EXT" );
}

static void REGAL_CALL loader_glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glShaderOp3EXT, "glShaderOp3EXT");
   if ( !driverTbl.glShaderOp3EXT ) {
      driverTbl.glShaderOp3EXT = missing_glShaderOp3EXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glShaderOp3EXT == loader_glShaderOp3EXT) {
      rCtx->dsp.emuTbl.glShaderOp3EXT = driverTbl.glShaderOp3EXT;
   }
   driverTbl.glShaderOp3EXT(op, res, arg1, arg2, arg3);
}

static void REGAL_CALL missing_glSwizzleEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
   UNUSED_PARAMETER(res);
   UNUSED_PARAMETER(in);
   UNUSED_PARAMETER(outX);
   UNUSED_PARAMETER(outY);
   UNUSED_PARAMETER(outZ);
   UNUSED_PARAMETER(outW);
   Warning( "Called missing function glSwizzleEXT" );
}

static void REGAL_CALL loader_glSwizzleEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSwizzleEXT, "glSwizzleEXT");
   if ( !driverTbl.glSwizzleEXT ) {
      driverTbl.glSwizzleEXT = missing_glSwizzleEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSwizzleEXT == loader_glSwizzleEXT) {
      rCtx->dsp.emuTbl.glSwizzleEXT = driverTbl.glSwizzleEXT;
   }
   driverTbl.glSwizzleEXT(res, in, outX, outY, outZ, outW);
}

static void REGAL_CALL missing_glWriteMaskEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
   UNUSED_PARAMETER(res);
   UNUSED_PARAMETER(in);
   UNUSED_PARAMETER(outX);
   UNUSED_PARAMETER(outY);
   UNUSED_PARAMETER(outZ);
   UNUSED_PARAMETER(outW);
   Warning( "Called missing function glWriteMaskEXT" );
}

static void REGAL_CALL loader_glWriteMaskEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWriteMaskEXT, "glWriteMaskEXT");
   if ( !driverTbl.glWriteMaskEXT ) {
      driverTbl.glWriteMaskEXT = missing_glWriteMaskEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWriteMaskEXT == loader_glWriteMaskEXT) {
      rCtx->dsp.emuTbl.glWriteMaskEXT = driverTbl.glWriteMaskEXT;
   }
   driverTbl.glWriteMaskEXT(res, in, outX, outY, outZ, outW);
}

static void REGAL_CALL missing_glInsertComponentEXT(GLuint res, GLuint src, GLuint num)
{
   UNUSED_PARAMETER(res);
   UNUSED_PARAMETER(src);
   UNUSED_PARAMETER(num);
   Warning( "Called missing function glInsertComponentEXT" );
}

static void REGAL_CALL loader_glInsertComponentEXT(GLuint res, GLuint src, GLuint num)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glInsertComponentEXT, "glInsertComponentEXT");
   if ( !driverTbl.glInsertComponentEXT ) {
      driverTbl.glInsertComponentEXT = missing_glInsertComponentEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glInsertComponentEXT == loader_glInsertComponentEXT) {
      rCtx->dsp.emuTbl.glInsertComponentEXT = driverTbl.glInsertComponentEXT;
   }
   driverTbl.glInsertComponentEXT(res, src, num);
}

static void REGAL_CALL missing_glExtractComponentEXT(GLuint res, GLuint src, GLuint num)
{
   UNUSED_PARAMETER(res);
   UNUSED_PARAMETER(src);
   UNUSED_PARAMETER(num);
   Warning( "Called missing function glExtractComponentEXT" );
}

static void REGAL_CALL loader_glExtractComponentEXT(GLuint res, GLuint src, GLuint num)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glExtractComponentEXT, "glExtractComponentEXT");
   if ( !driverTbl.glExtractComponentEXT ) {
      driverTbl.glExtractComponentEXT = missing_glExtractComponentEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glExtractComponentEXT == loader_glExtractComponentEXT) {
      rCtx->dsp.emuTbl.glExtractComponentEXT = driverTbl.glExtractComponentEXT;
   }
   driverTbl.glExtractComponentEXT(res, src, num);
}

static GLuint REGAL_CALL missing_glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components)
{
   UNUSED_PARAMETER(datatype);
   UNUSED_PARAMETER(storagetype);
   UNUSED_PARAMETER(range);
   UNUSED_PARAMETER(components);
   Warning( "Called missing function glGenSymbolsEXT" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenSymbolsEXT, "glGenSymbolsEXT");
   if ( !driverTbl.glGenSymbolsEXT ) {
      driverTbl.glGenSymbolsEXT = missing_glGenSymbolsEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenSymbolsEXT == loader_glGenSymbolsEXT) {
      rCtx->dsp.emuTbl.glGenSymbolsEXT = driverTbl.glGenSymbolsEXT;
   }
   return driverTbl.glGenSymbolsEXT(datatype, storagetype, range, components);
}

static void REGAL_CALL missing_glSetInvariantEXT(GLuint id, GLenum type, const GLvoid *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(addr);
   Warning( "Called missing function glSetInvariantEXT" );
}

static void REGAL_CALL loader_glSetInvariantEXT(GLuint id, GLenum type, const GLvoid *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSetInvariantEXT, "glSetInvariantEXT");
   if ( !driverTbl.glSetInvariantEXT ) {
      driverTbl.glSetInvariantEXT = missing_glSetInvariantEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSetInvariantEXT == loader_glSetInvariantEXT) {
      rCtx->dsp.emuTbl.glSetInvariantEXT = driverTbl.glSetInvariantEXT;
   }
   driverTbl.glSetInvariantEXT(id, type, addr);
}

static void REGAL_CALL missing_glSetLocalConstantEXT(GLuint id, GLenum type, const GLvoid *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(addr);
   Warning( "Called missing function glSetLocalConstantEXT" );
}

static void REGAL_CALL loader_glSetLocalConstantEXT(GLuint id, GLenum type, const GLvoid *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSetLocalConstantEXT, "glSetLocalConstantEXT");
   if ( !driverTbl.glSetLocalConstantEXT ) {
      driverTbl.glSetLocalConstantEXT = missing_glSetLocalConstantEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSetLocalConstantEXT == loader_glSetLocalConstantEXT) {
      rCtx->dsp.emuTbl.glSetLocalConstantEXT = driverTbl.glSetLocalConstantEXT;
   }
   driverTbl.glSetLocalConstantEXT(id, type, addr);
}

static void REGAL_CALL missing_glVariantbvEXT(GLuint id, const GLbyte *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "Called missing function glVariantbvEXT" );
}

static void REGAL_CALL loader_glVariantbvEXT(GLuint id, const GLbyte *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVariantbvEXT, "glVariantbvEXT");
   if ( !driverTbl.glVariantbvEXT ) {
      driverTbl.glVariantbvEXT = missing_glVariantbvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVariantbvEXT == loader_glVariantbvEXT) {
      rCtx->dsp.emuTbl.glVariantbvEXT = driverTbl.glVariantbvEXT;
   }
   driverTbl.glVariantbvEXT(id, addr);
}

static void REGAL_CALL missing_glVariantsvEXT(GLuint id, const GLshort *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "Called missing function glVariantsvEXT" );
}

static void REGAL_CALL loader_glVariantsvEXT(GLuint id, const GLshort *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVariantsvEXT, "glVariantsvEXT");
   if ( !driverTbl.glVariantsvEXT ) {
      driverTbl.glVariantsvEXT = missing_glVariantsvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVariantsvEXT == loader_glVariantsvEXT) {
      rCtx->dsp.emuTbl.glVariantsvEXT = driverTbl.glVariantsvEXT;
   }
   driverTbl.glVariantsvEXT(id, addr);
}

static void REGAL_CALL missing_glVariantivEXT(GLuint id, const GLint *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "Called missing function glVariantivEXT" );
}

static void REGAL_CALL loader_glVariantivEXT(GLuint id, const GLint *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVariantivEXT, "glVariantivEXT");
   if ( !driverTbl.glVariantivEXT ) {
      driverTbl.glVariantivEXT = missing_glVariantivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVariantivEXT == loader_glVariantivEXT) {
      rCtx->dsp.emuTbl.glVariantivEXT = driverTbl.glVariantivEXT;
   }
   driverTbl.glVariantivEXT(id, addr);
}

static void REGAL_CALL missing_glVariantfvEXT(GLuint id, const GLfloat *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "Called missing function glVariantfvEXT" );
}

static void REGAL_CALL loader_glVariantfvEXT(GLuint id, const GLfloat *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVariantfvEXT, "glVariantfvEXT");
   if ( !driverTbl.glVariantfvEXT ) {
      driverTbl.glVariantfvEXT = missing_glVariantfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVariantfvEXT == loader_glVariantfvEXT) {
      rCtx->dsp.emuTbl.glVariantfvEXT = driverTbl.glVariantfvEXT;
   }
   driverTbl.glVariantfvEXT(id, addr);
}

static void REGAL_CALL missing_glVariantdvEXT(GLuint id, const GLdouble *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "Called missing function glVariantdvEXT" );
}

static void REGAL_CALL loader_glVariantdvEXT(GLuint id, const GLdouble *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVariantdvEXT, "glVariantdvEXT");
   if ( !driverTbl.glVariantdvEXT ) {
      driverTbl.glVariantdvEXT = missing_glVariantdvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVariantdvEXT == loader_glVariantdvEXT) {
      rCtx->dsp.emuTbl.glVariantdvEXT = driverTbl.glVariantdvEXT;
   }
   driverTbl.glVariantdvEXT(id, addr);
}

static void REGAL_CALL missing_glVariantubvEXT(GLuint id, const GLubyte *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "Called missing function glVariantubvEXT" );
}

static void REGAL_CALL loader_glVariantubvEXT(GLuint id, const GLubyte *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVariantubvEXT, "glVariantubvEXT");
   if ( !driverTbl.glVariantubvEXT ) {
      driverTbl.glVariantubvEXT = missing_glVariantubvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVariantubvEXT == loader_glVariantubvEXT) {
      rCtx->dsp.emuTbl.glVariantubvEXT = driverTbl.glVariantubvEXT;
   }
   driverTbl.glVariantubvEXT(id, addr);
}

static void REGAL_CALL missing_glVariantusvEXT(GLuint id, const GLushort *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "Called missing function glVariantusvEXT" );
}

static void REGAL_CALL loader_glVariantusvEXT(GLuint id, const GLushort *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVariantusvEXT, "glVariantusvEXT");
   if ( !driverTbl.glVariantusvEXT ) {
      driverTbl.glVariantusvEXT = missing_glVariantusvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVariantusvEXT == loader_glVariantusvEXT) {
      rCtx->dsp.emuTbl.glVariantusvEXT = driverTbl.glVariantusvEXT;
   }
   driverTbl.glVariantusvEXT(id, addr);
}

static void REGAL_CALL missing_glVariantuivEXT(GLuint id, const GLuint *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "Called missing function glVariantuivEXT" );
}

static void REGAL_CALL loader_glVariantuivEXT(GLuint id, const GLuint *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVariantuivEXT, "glVariantuivEXT");
   if ( !driverTbl.glVariantuivEXT ) {
      driverTbl.glVariantuivEXT = missing_glVariantuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVariantuivEXT == loader_glVariantuivEXT) {
      rCtx->dsp.emuTbl.glVariantuivEXT = driverTbl.glVariantuivEXT;
   }
   driverTbl.glVariantuivEXT(id, addr);
}

static void REGAL_CALL missing_glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const GLvoid *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(addr);
   Warning( "Called missing function glVariantPointerEXT" );
}

static void REGAL_CALL loader_glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const GLvoid *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVariantPointerEXT, "glVariantPointerEXT");
   if ( !driverTbl.glVariantPointerEXT ) {
      driverTbl.glVariantPointerEXT = missing_glVariantPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVariantPointerEXT == loader_glVariantPointerEXT) {
      rCtx->dsp.emuTbl.glVariantPointerEXT = driverTbl.glVariantPointerEXT;
   }
   driverTbl.glVariantPointerEXT(id, type, stride, addr);
}

static void REGAL_CALL missing_glEnableVariantClientStateEXT(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glEnableVariantClientStateEXT" );
}

static void REGAL_CALL loader_glEnableVariantClientStateEXT(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEnableVariantClientStateEXT, "glEnableVariantClientStateEXT");
   if ( !driverTbl.glEnableVariantClientStateEXT ) {
      driverTbl.glEnableVariantClientStateEXT = missing_glEnableVariantClientStateEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEnableVariantClientStateEXT == loader_glEnableVariantClientStateEXT) {
      rCtx->dsp.emuTbl.glEnableVariantClientStateEXT = driverTbl.glEnableVariantClientStateEXT;
   }
   driverTbl.glEnableVariantClientStateEXT(id);
}

static void REGAL_CALL missing_glDisableVariantClientStateEXT(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glDisableVariantClientStateEXT" );
}

static void REGAL_CALL loader_glDisableVariantClientStateEXT(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDisableVariantClientStateEXT, "glDisableVariantClientStateEXT");
   if ( !driverTbl.glDisableVariantClientStateEXT ) {
      driverTbl.glDisableVariantClientStateEXT = missing_glDisableVariantClientStateEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDisableVariantClientStateEXT == loader_glDisableVariantClientStateEXT) {
      rCtx->dsp.emuTbl.glDisableVariantClientStateEXT = driverTbl.glDisableVariantClientStateEXT;
   }
   driverTbl.glDisableVariantClientStateEXT(id);
}

static GLuint REGAL_CALL missing_glBindLightParameterEXT(GLenum light, GLenum value)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glBindLightParameterEXT" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glBindLightParameterEXT(GLenum light, GLenum value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindLightParameterEXT, "glBindLightParameterEXT");
   if ( !driverTbl.glBindLightParameterEXT ) {
      driverTbl.glBindLightParameterEXT = missing_glBindLightParameterEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindLightParameterEXT == loader_glBindLightParameterEXT) {
      rCtx->dsp.emuTbl.glBindLightParameterEXT = driverTbl.glBindLightParameterEXT;
   }
   return driverTbl.glBindLightParameterEXT(light, value);
}

static GLuint REGAL_CALL missing_glBindMaterialParameterEXT(GLenum face, GLenum value)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glBindMaterialParameterEXT" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glBindMaterialParameterEXT(GLenum face, GLenum value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindMaterialParameterEXT, "glBindMaterialParameterEXT");
   if ( !driverTbl.glBindMaterialParameterEXT ) {
      driverTbl.glBindMaterialParameterEXT = missing_glBindMaterialParameterEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindMaterialParameterEXT == loader_glBindMaterialParameterEXT) {
      rCtx->dsp.emuTbl.glBindMaterialParameterEXT = driverTbl.glBindMaterialParameterEXT;
   }
   return driverTbl.glBindMaterialParameterEXT(face, value);
}

static GLuint REGAL_CALL missing_glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value)
{
   UNUSED_PARAMETER(unit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glBindTexGenParameterEXT" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindTexGenParameterEXT, "glBindTexGenParameterEXT");
   if ( !driverTbl.glBindTexGenParameterEXT ) {
      driverTbl.glBindTexGenParameterEXT = missing_glBindTexGenParameterEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindTexGenParameterEXT == loader_glBindTexGenParameterEXT) {
      rCtx->dsp.emuTbl.glBindTexGenParameterEXT = driverTbl.glBindTexGenParameterEXT;
   }
   return driverTbl.glBindTexGenParameterEXT(unit, coord, value);
}

static GLuint REGAL_CALL missing_glBindTextureUnitParameterEXT(GLenum unit, GLenum value)
{
   UNUSED_PARAMETER(unit);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glBindTextureUnitParameterEXT" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glBindTextureUnitParameterEXT(GLenum unit, GLenum value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindTextureUnitParameterEXT, "glBindTextureUnitParameterEXT");
   if ( !driverTbl.glBindTextureUnitParameterEXT ) {
      driverTbl.glBindTextureUnitParameterEXT = missing_glBindTextureUnitParameterEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindTextureUnitParameterEXT == loader_glBindTextureUnitParameterEXT) {
      rCtx->dsp.emuTbl.glBindTextureUnitParameterEXT = driverTbl.glBindTextureUnitParameterEXT;
   }
   return driverTbl.glBindTextureUnitParameterEXT(unit, value);
}

static GLuint REGAL_CALL missing_glBindParameterEXT(GLenum value)
{
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glBindParameterEXT" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glBindParameterEXT(GLenum value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindParameterEXT, "glBindParameterEXT");
   if ( !driverTbl.glBindParameterEXT ) {
      driverTbl.glBindParameterEXT = missing_glBindParameterEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindParameterEXT == loader_glBindParameterEXT) {
      rCtx->dsp.emuTbl.glBindParameterEXT = driverTbl.glBindParameterEXT;
   }
   return driverTbl.glBindParameterEXT(value);
}

static GLboolean REGAL_CALL missing_glIsVariantEnabledEXT(GLuint id, GLenum cap)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(cap);
   Warning( "Called missing function glIsVariantEnabledEXT" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsVariantEnabledEXT(GLuint id, GLenum cap)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsVariantEnabledEXT, "glIsVariantEnabledEXT");
   if ( !driverTbl.glIsVariantEnabledEXT ) {
      driverTbl.glIsVariantEnabledEXT = missing_glIsVariantEnabledEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsVariantEnabledEXT == loader_glIsVariantEnabledEXT) {
      rCtx->dsp.emuTbl.glIsVariantEnabledEXT = driverTbl.glIsVariantEnabledEXT;
   }
   return driverTbl.glIsVariantEnabledEXT(id, cap);
}

static void REGAL_CALL missing_glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetVariantBooleanvEXT" );
}

static void REGAL_CALL loader_glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVariantBooleanvEXT, "glGetVariantBooleanvEXT");
   if ( !driverTbl.glGetVariantBooleanvEXT ) {
      driverTbl.glGetVariantBooleanvEXT = missing_glGetVariantBooleanvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVariantBooleanvEXT == loader_glGetVariantBooleanvEXT) {
      rCtx->dsp.emuTbl.glGetVariantBooleanvEXT = driverTbl.glGetVariantBooleanvEXT;
   }
   driverTbl.glGetVariantBooleanvEXT(id, value, data);
}

static void REGAL_CALL missing_glGetVariantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetVariantIntegervEXT" );
}

static void REGAL_CALL loader_glGetVariantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVariantIntegervEXT, "glGetVariantIntegervEXT");
   if ( !driverTbl.glGetVariantIntegervEXT ) {
      driverTbl.glGetVariantIntegervEXT = missing_glGetVariantIntegervEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVariantIntegervEXT == loader_glGetVariantIntegervEXT) {
      rCtx->dsp.emuTbl.glGetVariantIntegervEXT = driverTbl.glGetVariantIntegervEXT;
   }
   driverTbl.glGetVariantIntegervEXT(id, value, data);
}

static void REGAL_CALL missing_glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetVariantFloatvEXT" );
}

static void REGAL_CALL loader_glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVariantFloatvEXT, "glGetVariantFloatvEXT");
   if ( !driverTbl.glGetVariantFloatvEXT ) {
      driverTbl.glGetVariantFloatvEXT = missing_glGetVariantFloatvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVariantFloatvEXT == loader_glGetVariantFloatvEXT) {
      rCtx->dsp.emuTbl.glGetVariantFloatvEXT = driverTbl.glGetVariantFloatvEXT;
   }
   driverTbl.glGetVariantFloatvEXT(id, value, data);
}

static void REGAL_CALL missing_glGetVariantPointervEXT(GLuint id, GLenum value, GLvoid **data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetVariantPointervEXT" );
}

static void REGAL_CALL loader_glGetVariantPointervEXT(GLuint id, GLenum value, GLvoid **data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVariantPointervEXT, "glGetVariantPointervEXT");
   if ( !driverTbl.glGetVariantPointervEXT ) {
      driverTbl.glGetVariantPointervEXT = missing_glGetVariantPointervEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVariantPointervEXT == loader_glGetVariantPointervEXT) {
      rCtx->dsp.emuTbl.glGetVariantPointervEXT = driverTbl.glGetVariantPointervEXT;
   }
   driverTbl.glGetVariantPointervEXT(id, value, data);
}

static void REGAL_CALL missing_glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetInvariantBooleanvEXT" );
}

static void REGAL_CALL loader_glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetInvariantBooleanvEXT, "glGetInvariantBooleanvEXT");
   if ( !driverTbl.glGetInvariantBooleanvEXT ) {
      driverTbl.glGetInvariantBooleanvEXT = missing_glGetInvariantBooleanvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetInvariantBooleanvEXT == loader_glGetInvariantBooleanvEXT) {
      rCtx->dsp.emuTbl.glGetInvariantBooleanvEXT = driverTbl.glGetInvariantBooleanvEXT;
   }
   driverTbl.glGetInvariantBooleanvEXT(id, value, data);
}

static void REGAL_CALL missing_glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetInvariantIntegervEXT" );
}

static void REGAL_CALL loader_glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetInvariantIntegervEXT, "glGetInvariantIntegervEXT");
   if ( !driverTbl.glGetInvariantIntegervEXT ) {
      driverTbl.glGetInvariantIntegervEXT = missing_glGetInvariantIntegervEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetInvariantIntegervEXT == loader_glGetInvariantIntegervEXT) {
      rCtx->dsp.emuTbl.glGetInvariantIntegervEXT = driverTbl.glGetInvariantIntegervEXT;
   }
   driverTbl.glGetInvariantIntegervEXT(id, value, data);
}

static void REGAL_CALL missing_glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetInvariantFloatvEXT" );
}

static void REGAL_CALL loader_glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetInvariantFloatvEXT, "glGetInvariantFloatvEXT");
   if ( !driverTbl.glGetInvariantFloatvEXT ) {
      driverTbl.glGetInvariantFloatvEXT = missing_glGetInvariantFloatvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetInvariantFloatvEXT == loader_glGetInvariantFloatvEXT) {
      rCtx->dsp.emuTbl.glGetInvariantFloatvEXT = driverTbl.glGetInvariantFloatvEXT;
   }
   driverTbl.glGetInvariantFloatvEXT(id, value, data);
}

static void REGAL_CALL missing_glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetLocalConstantBooleanvEXT" );
}

static void REGAL_CALL loader_glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetLocalConstantBooleanvEXT, "glGetLocalConstantBooleanvEXT");
   if ( !driverTbl.glGetLocalConstantBooleanvEXT ) {
      driverTbl.glGetLocalConstantBooleanvEXT = missing_glGetLocalConstantBooleanvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetLocalConstantBooleanvEXT == loader_glGetLocalConstantBooleanvEXT) {
      rCtx->dsp.emuTbl.glGetLocalConstantBooleanvEXT = driverTbl.glGetLocalConstantBooleanvEXT;
   }
   driverTbl.glGetLocalConstantBooleanvEXT(id, value, data);
}

static void REGAL_CALL missing_glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetLocalConstantIntegervEXT" );
}

static void REGAL_CALL loader_glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetLocalConstantIntegervEXT, "glGetLocalConstantIntegervEXT");
   if ( !driverTbl.glGetLocalConstantIntegervEXT ) {
      driverTbl.glGetLocalConstantIntegervEXT = missing_glGetLocalConstantIntegervEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetLocalConstantIntegervEXT == loader_glGetLocalConstantIntegervEXT) {
      rCtx->dsp.emuTbl.glGetLocalConstantIntegervEXT = driverTbl.glGetLocalConstantIntegervEXT;
   }
   driverTbl.glGetLocalConstantIntegervEXT(id, value, data);
}

static void REGAL_CALL missing_glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetLocalConstantFloatvEXT" );
}

static void REGAL_CALL loader_glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetLocalConstantFloatvEXT, "glGetLocalConstantFloatvEXT");
   if ( !driverTbl.glGetLocalConstantFloatvEXT ) {
      driverTbl.glGetLocalConstantFloatvEXT = missing_glGetLocalConstantFloatvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetLocalConstantFloatvEXT == loader_glGetLocalConstantFloatvEXT) {
      rCtx->dsp.emuTbl.glGetLocalConstantFloatvEXT = driverTbl.glGetLocalConstantFloatvEXT;
   }
   driverTbl.glGetLocalConstantFloatvEXT(id, value, data);
}

// GL_ATI_vertex_streams

static void REGAL_CALL missing_glVertexStream1sATI(GLenum stream, GLshort x)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexStream1sATI" );
}

static void REGAL_CALL loader_glVertexStream1sATI(GLenum stream, GLshort x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream1sATI, "glVertexStream1sATI");
   if ( !driverTbl.glVertexStream1sATI ) {
      driverTbl.glVertexStream1sATI = missing_glVertexStream1sATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream1sATI == loader_glVertexStream1sATI) {
      rCtx->dsp.emuTbl.glVertexStream1sATI = driverTbl.glVertexStream1sATI;
   }
   driverTbl.glVertexStream1sATI(stream, x);
}

static void REGAL_CALL missing_glVertexStream1svATI(GLenum stream, const GLshort *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream1svATI" );
}

static void REGAL_CALL loader_glVertexStream1svATI(GLenum stream, const GLshort *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream1svATI, "glVertexStream1svATI");
   if ( !driverTbl.glVertexStream1svATI ) {
      driverTbl.glVertexStream1svATI = missing_glVertexStream1svATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream1svATI == loader_glVertexStream1svATI) {
      rCtx->dsp.emuTbl.glVertexStream1svATI = driverTbl.glVertexStream1svATI;
   }
   driverTbl.glVertexStream1svATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream1iATI(GLenum stream, GLint x)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexStream1iATI" );
}

static void REGAL_CALL loader_glVertexStream1iATI(GLenum stream, GLint x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream1iATI, "glVertexStream1iATI");
   if ( !driverTbl.glVertexStream1iATI ) {
      driverTbl.glVertexStream1iATI = missing_glVertexStream1iATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream1iATI == loader_glVertexStream1iATI) {
      rCtx->dsp.emuTbl.glVertexStream1iATI = driverTbl.glVertexStream1iATI;
   }
   driverTbl.glVertexStream1iATI(stream, x);
}

static void REGAL_CALL missing_glVertexStream1ivATI(GLenum stream, const GLint *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream1ivATI" );
}

static void REGAL_CALL loader_glVertexStream1ivATI(GLenum stream, const GLint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream1ivATI, "glVertexStream1ivATI");
   if ( !driverTbl.glVertexStream1ivATI ) {
      driverTbl.glVertexStream1ivATI = missing_glVertexStream1ivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream1ivATI == loader_glVertexStream1ivATI) {
      rCtx->dsp.emuTbl.glVertexStream1ivATI = driverTbl.glVertexStream1ivATI;
   }
   driverTbl.glVertexStream1ivATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream1fATI(GLenum stream, GLfloat x)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexStream1fATI" );
}

static void REGAL_CALL loader_glVertexStream1fATI(GLenum stream, GLfloat x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream1fATI, "glVertexStream1fATI");
   if ( !driverTbl.glVertexStream1fATI ) {
      driverTbl.glVertexStream1fATI = missing_glVertexStream1fATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream1fATI == loader_glVertexStream1fATI) {
      rCtx->dsp.emuTbl.glVertexStream1fATI = driverTbl.glVertexStream1fATI;
   }
   driverTbl.glVertexStream1fATI(stream, x);
}

static void REGAL_CALL missing_glVertexStream1fvATI(GLenum stream, const GLfloat *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream1fvATI" );
}

static void REGAL_CALL loader_glVertexStream1fvATI(GLenum stream, const GLfloat *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream1fvATI, "glVertexStream1fvATI");
   if ( !driverTbl.glVertexStream1fvATI ) {
      driverTbl.glVertexStream1fvATI = missing_glVertexStream1fvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream1fvATI == loader_glVertexStream1fvATI) {
      rCtx->dsp.emuTbl.glVertexStream1fvATI = driverTbl.glVertexStream1fvATI;
   }
   driverTbl.glVertexStream1fvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream1dATI(GLenum stream, GLdouble x)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexStream1dATI" );
}

static void REGAL_CALL loader_glVertexStream1dATI(GLenum stream, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream1dATI, "glVertexStream1dATI");
   if ( !driverTbl.glVertexStream1dATI ) {
      driverTbl.glVertexStream1dATI = missing_glVertexStream1dATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream1dATI == loader_glVertexStream1dATI) {
      rCtx->dsp.emuTbl.glVertexStream1dATI = driverTbl.glVertexStream1dATI;
   }
   driverTbl.glVertexStream1dATI(stream, x);
}

static void REGAL_CALL missing_glVertexStream1dvATI(GLenum stream, const GLdouble *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream1dvATI" );
}

static void REGAL_CALL loader_glVertexStream1dvATI(GLenum stream, const GLdouble *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream1dvATI, "glVertexStream1dvATI");
   if ( !driverTbl.glVertexStream1dvATI ) {
      driverTbl.glVertexStream1dvATI = missing_glVertexStream1dvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream1dvATI == loader_glVertexStream1dvATI) {
      rCtx->dsp.emuTbl.glVertexStream1dvATI = driverTbl.glVertexStream1dvATI;
   }
   driverTbl.glVertexStream1dvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream2sATI(GLenum stream, GLshort x, GLshort y)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexStream2sATI" );
}

static void REGAL_CALL loader_glVertexStream2sATI(GLenum stream, GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream2sATI, "glVertexStream2sATI");
   if ( !driverTbl.glVertexStream2sATI ) {
      driverTbl.glVertexStream2sATI = missing_glVertexStream2sATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream2sATI == loader_glVertexStream2sATI) {
      rCtx->dsp.emuTbl.glVertexStream2sATI = driverTbl.glVertexStream2sATI;
   }
   driverTbl.glVertexStream2sATI(stream, x, y);
}

static void REGAL_CALL missing_glVertexStream2svATI(GLenum stream, const GLshort *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream2svATI" );
}

static void REGAL_CALL loader_glVertexStream2svATI(GLenum stream, const GLshort *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream2svATI, "glVertexStream2svATI");
   if ( !driverTbl.glVertexStream2svATI ) {
      driverTbl.glVertexStream2svATI = missing_glVertexStream2svATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream2svATI == loader_glVertexStream2svATI) {
      rCtx->dsp.emuTbl.glVertexStream2svATI = driverTbl.glVertexStream2svATI;
   }
   driverTbl.glVertexStream2svATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream2iATI(GLenum stream, GLint x, GLint y)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexStream2iATI" );
}

static void REGAL_CALL loader_glVertexStream2iATI(GLenum stream, GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream2iATI, "glVertexStream2iATI");
   if ( !driverTbl.glVertexStream2iATI ) {
      driverTbl.glVertexStream2iATI = missing_glVertexStream2iATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream2iATI == loader_glVertexStream2iATI) {
      rCtx->dsp.emuTbl.glVertexStream2iATI = driverTbl.glVertexStream2iATI;
   }
   driverTbl.glVertexStream2iATI(stream, x, y);
}

static void REGAL_CALL missing_glVertexStream2ivATI(GLenum stream, const GLint *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream2ivATI" );
}

static void REGAL_CALL loader_glVertexStream2ivATI(GLenum stream, const GLint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream2ivATI, "glVertexStream2ivATI");
   if ( !driverTbl.glVertexStream2ivATI ) {
      driverTbl.glVertexStream2ivATI = missing_glVertexStream2ivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream2ivATI == loader_glVertexStream2ivATI) {
      rCtx->dsp.emuTbl.glVertexStream2ivATI = driverTbl.glVertexStream2ivATI;
   }
   driverTbl.glVertexStream2ivATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexStream2fATI" );
}

static void REGAL_CALL loader_glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream2fATI, "glVertexStream2fATI");
   if ( !driverTbl.glVertexStream2fATI ) {
      driverTbl.glVertexStream2fATI = missing_glVertexStream2fATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream2fATI == loader_glVertexStream2fATI) {
      rCtx->dsp.emuTbl.glVertexStream2fATI = driverTbl.glVertexStream2fATI;
   }
   driverTbl.glVertexStream2fATI(stream, x, y);
}

static void REGAL_CALL missing_glVertexStream2fvATI(GLenum stream, const GLfloat *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream2fvATI" );
}

static void REGAL_CALL loader_glVertexStream2fvATI(GLenum stream, const GLfloat *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream2fvATI, "glVertexStream2fvATI");
   if ( !driverTbl.glVertexStream2fvATI ) {
      driverTbl.glVertexStream2fvATI = missing_glVertexStream2fvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream2fvATI == loader_glVertexStream2fvATI) {
      rCtx->dsp.emuTbl.glVertexStream2fvATI = driverTbl.glVertexStream2fvATI;
   }
   driverTbl.glVertexStream2fvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexStream2dATI" );
}

static void REGAL_CALL loader_glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream2dATI, "glVertexStream2dATI");
   if ( !driverTbl.glVertexStream2dATI ) {
      driverTbl.glVertexStream2dATI = missing_glVertexStream2dATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream2dATI == loader_glVertexStream2dATI) {
      rCtx->dsp.emuTbl.glVertexStream2dATI = driverTbl.glVertexStream2dATI;
   }
   driverTbl.glVertexStream2dATI(stream, x, y);
}

static void REGAL_CALL missing_glVertexStream2dvATI(GLenum stream, const GLdouble *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream2dvATI" );
}

static void REGAL_CALL loader_glVertexStream2dvATI(GLenum stream, const GLdouble *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream2dvATI, "glVertexStream2dvATI");
   if ( !driverTbl.glVertexStream2dvATI ) {
      driverTbl.glVertexStream2dvATI = missing_glVertexStream2dvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream2dvATI == loader_glVertexStream2dvATI) {
      rCtx->dsp.emuTbl.glVertexStream2dvATI = driverTbl.glVertexStream2dvATI;
   }
   driverTbl.glVertexStream2dvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexStream3sATI" );
}

static void REGAL_CALL loader_glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream3sATI, "glVertexStream3sATI");
   if ( !driverTbl.glVertexStream3sATI ) {
      driverTbl.glVertexStream3sATI = missing_glVertexStream3sATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream3sATI == loader_glVertexStream3sATI) {
      rCtx->dsp.emuTbl.glVertexStream3sATI = driverTbl.glVertexStream3sATI;
   }
   driverTbl.glVertexStream3sATI(stream, x, y, z);
}

static void REGAL_CALL missing_glVertexStream3svATI(GLenum stream, const GLshort *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream3svATI" );
}

static void REGAL_CALL loader_glVertexStream3svATI(GLenum stream, const GLshort *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream3svATI, "glVertexStream3svATI");
   if ( !driverTbl.glVertexStream3svATI ) {
      driverTbl.glVertexStream3svATI = missing_glVertexStream3svATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream3svATI == loader_glVertexStream3svATI) {
      rCtx->dsp.emuTbl.glVertexStream3svATI = driverTbl.glVertexStream3svATI;
   }
   driverTbl.glVertexStream3svATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexStream3iATI" );
}

static void REGAL_CALL loader_glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream3iATI, "glVertexStream3iATI");
   if ( !driverTbl.glVertexStream3iATI ) {
      driverTbl.glVertexStream3iATI = missing_glVertexStream3iATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream3iATI == loader_glVertexStream3iATI) {
      rCtx->dsp.emuTbl.glVertexStream3iATI = driverTbl.glVertexStream3iATI;
   }
   driverTbl.glVertexStream3iATI(stream, x, y, z);
}

static void REGAL_CALL missing_glVertexStream3ivATI(GLenum stream, const GLint *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream3ivATI" );
}

static void REGAL_CALL loader_glVertexStream3ivATI(GLenum stream, const GLint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream3ivATI, "glVertexStream3ivATI");
   if ( !driverTbl.glVertexStream3ivATI ) {
      driverTbl.glVertexStream3ivATI = missing_glVertexStream3ivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream3ivATI == loader_glVertexStream3ivATI) {
      rCtx->dsp.emuTbl.glVertexStream3ivATI = driverTbl.glVertexStream3ivATI;
   }
   driverTbl.glVertexStream3ivATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexStream3fATI" );
}

static void REGAL_CALL loader_glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream3fATI, "glVertexStream3fATI");
   if ( !driverTbl.glVertexStream3fATI ) {
      driverTbl.glVertexStream3fATI = missing_glVertexStream3fATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream3fATI == loader_glVertexStream3fATI) {
      rCtx->dsp.emuTbl.glVertexStream3fATI = driverTbl.glVertexStream3fATI;
   }
   driverTbl.glVertexStream3fATI(stream, x, y, z);
}

static void REGAL_CALL missing_glVertexStream3fvATI(GLenum stream, const GLfloat *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream3fvATI" );
}

static void REGAL_CALL loader_glVertexStream3fvATI(GLenum stream, const GLfloat *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream3fvATI, "glVertexStream3fvATI");
   if ( !driverTbl.glVertexStream3fvATI ) {
      driverTbl.glVertexStream3fvATI = missing_glVertexStream3fvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream3fvATI == loader_glVertexStream3fvATI) {
      rCtx->dsp.emuTbl.glVertexStream3fvATI = driverTbl.glVertexStream3fvATI;
   }
   driverTbl.glVertexStream3fvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexStream3dATI" );
}

static void REGAL_CALL loader_glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream3dATI, "glVertexStream3dATI");
   if ( !driverTbl.glVertexStream3dATI ) {
      driverTbl.glVertexStream3dATI = missing_glVertexStream3dATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream3dATI == loader_glVertexStream3dATI) {
      rCtx->dsp.emuTbl.glVertexStream3dATI = driverTbl.glVertexStream3dATI;
   }
   driverTbl.glVertexStream3dATI(stream, x, y, z);
}

static void REGAL_CALL missing_glVertexStream3dvATI(GLenum stream, const GLdouble *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream3dvATI" );
}

static void REGAL_CALL loader_glVertexStream3dvATI(GLenum stream, const GLdouble *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream3dvATI, "glVertexStream3dvATI");
   if ( !driverTbl.glVertexStream3dvATI ) {
      driverTbl.glVertexStream3dvATI = missing_glVertexStream3dvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream3dvATI == loader_glVertexStream3dvATI) {
      rCtx->dsp.emuTbl.glVertexStream3dvATI = driverTbl.glVertexStream3dvATI;
   }
   driverTbl.glVertexStream3dvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexStream4sATI" );
}

static void REGAL_CALL loader_glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream4sATI, "glVertexStream4sATI");
   if ( !driverTbl.glVertexStream4sATI ) {
      driverTbl.glVertexStream4sATI = missing_glVertexStream4sATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream4sATI == loader_glVertexStream4sATI) {
      rCtx->dsp.emuTbl.glVertexStream4sATI = driverTbl.glVertexStream4sATI;
   }
   driverTbl.glVertexStream4sATI(stream, x, y, z, w);
}

static void REGAL_CALL missing_glVertexStream4svATI(GLenum stream, const GLshort *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream4svATI" );
}

static void REGAL_CALL loader_glVertexStream4svATI(GLenum stream, const GLshort *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream4svATI, "glVertexStream4svATI");
   if ( !driverTbl.glVertexStream4svATI ) {
      driverTbl.glVertexStream4svATI = missing_glVertexStream4svATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream4svATI == loader_glVertexStream4svATI) {
      rCtx->dsp.emuTbl.glVertexStream4svATI = driverTbl.glVertexStream4svATI;
   }
   driverTbl.glVertexStream4svATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexStream4iATI" );
}

static void REGAL_CALL loader_glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream4iATI, "glVertexStream4iATI");
   if ( !driverTbl.glVertexStream4iATI ) {
      driverTbl.glVertexStream4iATI = missing_glVertexStream4iATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream4iATI == loader_glVertexStream4iATI) {
      rCtx->dsp.emuTbl.glVertexStream4iATI = driverTbl.glVertexStream4iATI;
   }
   driverTbl.glVertexStream4iATI(stream, x, y, z, w);
}

static void REGAL_CALL missing_glVertexStream4ivATI(GLenum stream, const GLint *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream4ivATI" );
}

static void REGAL_CALL loader_glVertexStream4ivATI(GLenum stream, const GLint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream4ivATI, "glVertexStream4ivATI");
   if ( !driverTbl.glVertexStream4ivATI ) {
      driverTbl.glVertexStream4ivATI = missing_glVertexStream4ivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream4ivATI == loader_glVertexStream4ivATI) {
      rCtx->dsp.emuTbl.glVertexStream4ivATI = driverTbl.glVertexStream4ivATI;
   }
   driverTbl.glVertexStream4ivATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexStream4fATI" );
}

static void REGAL_CALL loader_glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream4fATI, "glVertexStream4fATI");
   if ( !driverTbl.glVertexStream4fATI ) {
      driverTbl.glVertexStream4fATI = missing_glVertexStream4fATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream4fATI == loader_glVertexStream4fATI) {
      rCtx->dsp.emuTbl.glVertexStream4fATI = driverTbl.glVertexStream4fATI;
   }
   driverTbl.glVertexStream4fATI(stream, x, y, z, w);
}

static void REGAL_CALL missing_glVertexStream4fvATI(GLenum stream, const GLfloat *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream4fvATI" );
}

static void REGAL_CALL loader_glVertexStream4fvATI(GLenum stream, const GLfloat *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream4fvATI, "glVertexStream4fvATI");
   if ( !driverTbl.glVertexStream4fvATI ) {
      driverTbl.glVertexStream4fvATI = missing_glVertexStream4fvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream4fvATI == loader_glVertexStream4fvATI) {
      rCtx->dsp.emuTbl.glVertexStream4fvATI = driverTbl.glVertexStream4fvATI;
   }
   driverTbl.glVertexStream4fvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexStream4dATI" );
}

static void REGAL_CALL loader_glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream4dATI, "glVertexStream4dATI");
   if ( !driverTbl.glVertexStream4dATI ) {
      driverTbl.glVertexStream4dATI = missing_glVertexStream4dATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream4dATI == loader_glVertexStream4dATI) {
      rCtx->dsp.emuTbl.glVertexStream4dATI = driverTbl.glVertexStream4dATI;
   }
   driverTbl.glVertexStream4dATI(stream, x, y, z, w);
}

static void REGAL_CALL missing_glVertexStream4dvATI(GLenum stream, const GLdouble *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glVertexStream4dvATI" );
}

static void REGAL_CALL loader_glVertexStream4dvATI(GLenum stream, const GLdouble *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexStream4dvATI, "glVertexStream4dvATI");
   if ( !driverTbl.glVertexStream4dvATI ) {
      driverTbl.glVertexStream4dvATI = missing_glVertexStream4dvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexStream4dvATI == loader_glVertexStream4dvATI) {
      rCtx->dsp.emuTbl.glVertexStream4dvATI = driverTbl.glVertexStream4dvATI;
   }
   driverTbl.glVertexStream4dvATI(stream, coords);
}

static void REGAL_CALL missing_glNormalStream3bATI(GLenum stream, GLbyte x, GLbyte y, GLbyte z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glNormalStream3bATI" );
}

static void REGAL_CALL loader_glNormalStream3bATI(GLenum stream, GLbyte x, GLbyte y, GLbyte z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalStream3bATI, "glNormalStream3bATI");
   if ( !driverTbl.glNormalStream3bATI ) {
      driverTbl.glNormalStream3bATI = missing_glNormalStream3bATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalStream3bATI == loader_glNormalStream3bATI) {
      rCtx->dsp.emuTbl.glNormalStream3bATI = driverTbl.glNormalStream3bATI;
   }
   driverTbl.glNormalStream3bATI(stream, x, y, z);
}

static void REGAL_CALL missing_glNormalStream3bvATI(GLenum stream, const GLbyte *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glNormalStream3bvATI" );
}

static void REGAL_CALL loader_glNormalStream3bvATI(GLenum stream, const GLbyte *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalStream3bvATI, "glNormalStream3bvATI");
   if ( !driverTbl.glNormalStream3bvATI ) {
      driverTbl.glNormalStream3bvATI = missing_glNormalStream3bvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalStream3bvATI == loader_glNormalStream3bvATI) {
      rCtx->dsp.emuTbl.glNormalStream3bvATI = driverTbl.glNormalStream3bvATI;
   }
   driverTbl.glNormalStream3bvATI(stream, coords);
}

static void REGAL_CALL missing_glNormalStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glNormalStream3sATI" );
}

static void REGAL_CALL loader_glNormalStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalStream3sATI, "glNormalStream3sATI");
   if ( !driverTbl.glNormalStream3sATI ) {
      driverTbl.glNormalStream3sATI = missing_glNormalStream3sATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalStream3sATI == loader_glNormalStream3sATI) {
      rCtx->dsp.emuTbl.glNormalStream3sATI = driverTbl.glNormalStream3sATI;
   }
   driverTbl.glNormalStream3sATI(stream, x, y, z);
}

static void REGAL_CALL missing_glNormalStream3svATI(GLenum stream, const GLshort *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glNormalStream3svATI" );
}

static void REGAL_CALL loader_glNormalStream3svATI(GLenum stream, const GLshort *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalStream3svATI, "glNormalStream3svATI");
   if ( !driverTbl.glNormalStream3svATI ) {
      driverTbl.glNormalStream3svATI = missing_glNormalStream3svATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalStream3svATI == loader_glNormalStream3svATI) {
      rCtx->dsp.emuTbl.glNormalStream3svATI = driverTbl.glNormalStream3svATI;
   }
   driverTbl.glNormalStream3svATI(stream, coords);
}

static void REGAL_CALL missing_glNormalStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glNormalStream3iATI" );
}

static void REGAL_CALL loader_glNormalStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalStream3iATI, "glNormalStream3iATI");
   if ( !driverTbl.glNormalStream3iATI ) {
      driverTbl.glNormalStream3iATI = missing_glNormalStream3iATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalStream3iATI == loader_glNormalStream3iATI) {
      rCtx->dsp.emuTbl.glNormalStream3iATI = driverTbl.glNormalStream3iATI;
   }
   driverTbl.glNormalStream3iATI(stream, x, y, z);
}

static void REGAL_CALL missing_glNormalStream3ivATI(GLenum stream, const GLint *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glNormalStream3ivATI" );
}

static void REGAL_CALL loader_glNormalStream3ivATI(GLenum stream, const GLint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalStream3ivATI, "glNormalStream3ivATI");
   if ( !driverTbl.glNormalStream3ivATI ) {
      driverTbl.glNormalStream3ivATI = missing_glNormalStream3ivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalStream3ivATI == loader_glNormalStream3ivATI) {
      rCtx->dsp.emuTbl.glNormalStream3ivATI = driverTbl.glNormalStream3ivATI;
   }
   driverTbl.glNormalStream3ivATI(stream, coords);
}

static void REGAL_CALL missing_glNormalStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glNormalStream3fATI" );
}

static void REGAL_CALL loader_glNormalStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalStream3fATI, "glNormalStream3fATI");
   if ( !driverTbl.glNormalStream3fATI ) {
      driverTbl.glNormalStream3fATI = missing_glNormalStream3fATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalStream3fATI == loader_glNormalStream3fATI) {
      rCtx->dsp.emuTbl.glNormalStream3fATI = driverTbl.glNormalStream3fATI;
   }
   driverTbl.glNormalStream3fATI(stream, x, y, z);
}

static void REGAL_CALL missing_glNormalStream3fvATI(GLenum stream, const GLfloat *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glNormalStream3fvATI" );
}

static void REGAL_CALL loader_glNormalStream3fvATI(GLenum stream, const GLfloat *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalStream3fvATI, "glNormalStream3fvATI");
   if ( !driverTbl.glNormalStream3fvATI ) {
      driverTbl.glNormalStream3fvATI = missing_glNormalStream3fvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalStream3fvATI == loader_glNormalStream3fvATI) {
      rCtx->dsp.emuTbl.glNormalStream3fvATI = driverTbl.glNormalStream3fvATI;
   }
   driverTbl.glNormalStream3fvATI(stream, coords);
}

static void REGAL_CALL missing_glNormalStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glNormalStream3dATI" );
}

static void REGAL_CALL loader_glNormalStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalStream3dATI, "glNormalStream3dATI");
   if ( !driverTbl.glNormalStream3dATI ) {
      driverTbl.glNormalStream3dATI = missing_glNormalStream3dATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalStream3dATI == loader_glNormalStream3dATI) {
      rCtx->dsp.emuTbl.glNormalStream3dATI = driverTbl.glNormalStream3dATI;
   }
   driverTbl.glNormalStream3dATI(stream, x, y, z);
}

static void REGAL_CALL missing_glNormalStream3dvATI(GLenum stream, const GLdouble *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glNormalStream3dvATI" );
}

static void REGAL_CALL loader_glNormalStream3dvATI(GLenum stream, const GLdouble *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalStream3dvATI, "glNormalStream3dvATI");
   if ( !driverTbl.glNormalStream3dvATI ) {
      driverTbl.glNormalStream3dvATI = missing_glNormalStream3dvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalStream3dvATI == loader_glNormalStream3dvATI) {
      rCtx->dsp.emuTbl.glNormalStream3dvATI = driverTbl.glNormalStream3dvATI;
   }
   driverTbl.glNormalStream3dvATI(stream, coords);
}

static void REGAL_CALL missing_glClientActiveVertexStreamATI(GLenum stream)
{
   UNUSED_PARAMETER(stream);
   Warning( "Called missing function glClientActiveVertexStreamATI" );
}

static void REGAL_CALL loader_glClientActiveVertexStreamATI(GLenum stream)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClientActiveVertexStreamATI, "glClientActiveVertexStreamATI");
   if ( !driverTbl.glClientActiveVertexStreamATI ) {
      driverTbl.glClientActiveVertexStreamATI = missing_glClientActiveVertexStreamATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClientActiveVertexStreamATI == loader_glClientActiveVertexStreamATI) {
      rCtx->dsp.emuTbl.glClientActiveVertexStreamATI = driverTbl.glClientActiveVertexStreamATI;
   }
   driverTbl.glClientActiveVertexStreamATI(stream);
}

static void REGAL_CALL missing_glVertexBlendEnviATI(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glVertexBlendEnviATI" );
}

static void REGAL_CALL loader_glVertexBlendEnviATI(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexBlendEnviATI, "glVertexBlendEnviATI");
   if ( !driverTbl.glVertexBlendEnviATI ) {
      driverTbl.glVertexBlendEnviATI = missing_glVertexBlendEnviATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexBlendEnviATI == loader_glVertexBlendEnviATI) {
      rCtx->dsp.emuTbl.glVertexBlendEnviATI = driverTbl.glVertexBlendEnviATI;
   }
   driverTbl.glVertexBlendEnviATI(pname, param);
}

static void REGAL_CALL missing_glVertexBlendEnvfATI(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glVertexBlendEnvfATI" );
}

static void REGAL_CALL loader_glVertexBlendEnvfATI(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexBlendEnvfATI, "glVertexBlendEnvfATI");
   if ( !driverTbl.glVertexBlendEnvfATI ) {
      driverTbl.glVertexBlendEnvfATI = missing_glVertexBlendEnvfATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexBlendEnvfATI == loader_glVertexBlendEnvfATI) {
      rCtx->dsp.emuTbl.glVertexBlendEnvfATI = driverTbl.glVertexBlendEnvfATI;
   }
   driverTbl.glVertexBlendEnvfATI(pname, param);
}

// GL_ATI_element_array

static void REGAL_CALL missing_glElementPointerATI(GLenum type, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glElementPointerATI" );
}

static void REGAL_CALL loader_glElementPointerATI(GLenum type, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glElementPointerATI, "glElementPointerATI");
   if ( !driverTbl.glElementPointerATI ) {
      driverTbl.glElementPointerATI = missing_glElementPointerATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glElementPointerATI == loader_glElementPointerATI) {
      rCtx->dsp.emuTbl.glElementPointerATI = driverTbl.glElementPointerATI;
   }
   driverTbl.glElementPointerATI(type, pointer);
}

static void REGAL_CALL missing_glDrawElementArrayATI(GLenum mode, GLsizei count)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   Warning( "Called missing function glDrawElementArrayATI" );
}

static void REGAL_CALL loader_glDrawElementArrayATI(GLenum mode, GLsizei count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawElementArrayATI, "glDrawElementArrayATI");
   if ( !driverTbl.glDrawElementArrayATI ) {
      driverTbl.glDrawElementArrayATI = missing_glDrawElementArrayATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawElementArrayATI == loader_glDrawElementArrayATI) {
      rCtx->dsp.emuTbl.glDrawElementArrayATI = driverTbl.glDrawElementArrayATI;
   }
   driverTbl.glDrawElementArrayATI(mode, count);
}

static void REGAL_CALL missing_glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(end);
   UNUSED_PARAMETER(count);
   Warning( "Called missing function glDrawRangeElementArrayATI" );
}

static void REGAL_CALL loader_glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawRangeElementArrayATI, "glDrawRangeElementArrayATI");
   if ( !driverTbl.glDrawRangeElementArrayATI ) {
      driverTbl.glDrawRangeElementArrayATI = missing_glDrawRangeElementArrayATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawRangeElementArrayATI == loader_glDrawRangeElementArrayATI) {
      rCtx->dsp.emuTbl.glDrawRangeElementArrayATI = driverTbl.glDrawRangeElementArrayATI;
   }
   driverTbl.glDrawRangeElementArrayATI(mode, start, end, count);
}

// GL_SUN_mesh_array

static void REGAL_CALL missing_glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(width);
   Warning( "Called missing function glDrawMeshArraysSUN" );
}

static void REGAL_CALL loader_glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawMeshArraysSUN, "glDrawMeshArraysSUN");
   if ( !driverTbl.glDrawMeshArraysSUN ) {
      driverTbl.glDrawMeshArraysSUN = missing_glDrawMeshArraysSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawMeshArraysSUN == loader_glDrawMeshArraysSUN) {
      rCtx->dsp.emuTbl.glDrawMeshArraysSUN = driverTbl.glDrawMeshArraysSUN;
   }
   driverTbl.glDrawMeshArraysSUN(mode, first, count, width);
}

// GL_NV_occlusion_query

static void REGAL_CALL missing_glGenOcclusionQueriesNV(GLsizei n, GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "Called missing function glGenOcclusionQueriesNV" );
}

static void REGAL_CALL loader_glGenOcclusionQueriesNV(GLsizei n, GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenOcclusionQueriesNV, "glGenOcclusionQueriesNV");
   if ( !driverTbl.glGenOcclusionQueriesNV ) {
      driverTbl.glGenOcclusionQueriesNV = missing_glGenOcclusionQueriesNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenOcclusionQueriesNV == loader_glGenOcclusionQueriesNV) {
      rCtx->dsp.emuTbl.glGenOcclusionQueriesNV = driverTbl.glGenOcclusionQueriesNV;
   }
   driverTbl.glGenOcclusionQueriesNV(n, ids);
}

static void REGAL_CALL missing_glDeleteOcclusionQueriesNV(GLsizei n, const GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "Called missing function glDeleteOcclusionQueriesNV" );
}

static void REGAL_CALL loader_glDeleteOcclusionQueriesNV(GLsizei n, const GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteOcclusionQueriesNV, "glDeleteOcclusionQueriesNV");
   if ( !driverTbl.glDeleteOcclusionQueriesNV ) {
      driverTbl.glDeleteOcclusionQueriesNV = missing_glDeleteOcclusionQueriesNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteOcclusionQueriesNV == loader_glDeleteOcclusionQueriesNV) {
      rCtx->dsp.emuTbl.glDeleteOcclusionQueriesNV = driverTbl.glDeleteOcclusionQueriesNV;
   }
   driverTbl.glDeleteOcclusionQueriesNV(n, ids);
}

static GLboolean REGAL_CALL missing_glIsOcclusionQueryNV(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glIsOcclusionQueryNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsOcclusionQueryNV(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsOcclusionQueryNV, "glIsOcclusionQueryNV");
   if ( !driverTbl.glIsOcclusionQueryNV ) {
      driverTbl.glIsOcclusionQueryNV = missing_glIsOcclusionQueryNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsOcclusionQueryNV == loader_glIsOcclusionQueryNV) {
      rCtx->dsp.emuTbl.glIsOcclusionQueryNV = driverTbl.glIsOcclusionQueryNV;
   }
   return driverTbl.glIsOcclusionQueryNV(id);
}

static void REGAL_CALL missing_glBeginOcclusionQueryNV(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glBeginOcclusionQueryNV" );
}

static void REGAL_CALL loader_glBeginOcclusionQueryNV(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBeginOcclusionQueryNV, "glBeginOcclusionQueryNV");
   if ( !driverTbl.glBeginOcclusionQueryNV ) {
      driverTbl.glBeginOcclusionQueryNV = missing_glBeginOcclusionQueryNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBeginOcclusionQueryNV == loader_glBeginOcclusionQueryNV) {
      rCtx->dsp.emuTbl.glBeginOcclusionQueryNV = driverTbl.glBeginOcclusionQueryNV;
   }
   driverTbl.glBeginOcclusionQueryNV(id);
}

static void REGAL_CALL missing_glEndOcclusionQueryNV(void)
{
   Warning( "Called missing function glEndOcclusionQueryNV" );
}

static void REGAL_CALL loader_glEndOcclusionQueryNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndOcclusionQueryNV, "glEndOcclusionQueryNV");
   if ( !driverTbl.glEndOcclusionQueryNV ) {
      driverTbl.glEndOcclusionQueryNV = missing_glEndOcclusionQueryNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndOcclusionQueryNV == loader_glEndOcclusionQueryNV) {
      rCtx->dsp.emuTbl.glEndOcclusionQueryNV = driverTbl.glEndOcclusionQueryNV;
   }
   driverTbl.glEndOcclusionQueryNV();
}

static void REGAL_CALL missing_glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetOcclusionQueryivNV" );
}

static void REGAL_CALL loader_glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetOcclusionQueryivNV, "glGetOcclusionQueryivNV");
   if ( !driverTbl.glGetOcclusionQueryivNV ) {
      driverTbl.glGetOcclusionQueryivNV = missing_glGetOcclusionQueryivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetOcclusionQueryivNV == loader_glGetOcclusionQueryivNV) {
      rCtx->dsp.emuTbl.glGetOcclusionQueryivNV = driverTbl.glGetOcclusionQueryivNV;
   }
   driverTbl.glGetOcclusionQueryivNV(id, pname, params);
}

static void REGAL_CALL missing_glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetOcclusionQueryuivNV" );
}

static void REGAL_CALL loader_glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetOcclusionQueryuivNV, "glGetOcclusionQueryuivNV");
   if ( !driverTbl.glGetOcclusionQueryuivNV ) {
      driverTbl.glGetOcclusionQueryuivNV = missing_glGetOcclusionQueryuivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetOcclusionQueryuivNV == loader_glGetOcclusionQueryuivNV) {
      rCtx->dsp.emuTbl.glGetOcclusionQueryuivNV = driverTbl.glGetOcclusionQueryuivNV;
   }
   driverTbl.glGetOcclusionQueryuivNV(id, pname, params);
}

// GL_NV_point_sprite

static void REGAL_CALL missing_glPointParameteriNV(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glPointParameteriNV" );
}

static void REGAL_CALL loader_glPointParameteriNV(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPointParameteriNV, "glPointParameteriNV");
   if ( !driverTbl.glPointParameteriNV ) {
      driverTbl.glPointParameteriNV = missing_glPointParameteriNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPointParameteriNV == loader_glPointParameteriNV) {
      rCtx->dsp.emuTbl.glPointParameteriNV = driverTbl.glPointParameteriNV;
   }
   driverTbl.glPointParameteriNV(pname, param);
}

static void REGAL_CALL missing_glPointParameterivNV(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glPointParameterivNV" );
}

static void REGAL_CALL loader_glPointParameterivNV(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPointParameterivNV, "glPointParameterivNV");
   if ( !driverTbl.glPointParameterivNV ) {
      driverTbl.glPointParameterivNV = missing_glPointParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPointParameterivNV == loader_glPointParameterivNV) {
      rCtx->dsp.emuTbl.glPointParameterivNV = driverTbl.glPointParameterivNV;
   }
   driverTbl.glPointParameterivNV(pname, params);
}

// GL_EXT_stencil_two_side

static void REGAL_CALL missing_glActiveStencilFaceEXT(GLenum face)
{
   UNUSED_PARAMETER(face);
   Warning( "Called missing function glActiveStencilFaceEXT" );
}

static void REGAL_CALL loader_glActiveStencilFaceEXT(GLenum face)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glActiveStencilFaceEXT, "glActiveStencilFaceEXT");
   if ( !driverTbl.glActiveStencilFaceEXT ) {
      driverTbl.glActiveStencilFaceEXT = missing_glActiveStencilFaceEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glActiveStencilFaceEXT == loader_glActiveStencilFaceEXT) {
      rCtx->dsp.emuTbl.glActiveStencilFaceEXT = driverTbl.glActiveStencilFaceEXT;
   }
   driverTbl.glActiveStencilFaceEXT(face);
}

// GL_APPLE_element_array

static void REGAL_CALL missing_glElementPointerAPPLE(GLenum type, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glElementPointerAPPLE" );
}

static void REGAL_CALL loader_glElementPointerAPPLE(GLenum type, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glElementPointerAPPLE, "glElementPointerAPPLE");
   if ( !driverTbl.glElementPointerAPPLE ) {
      driverTbl.glElementPointerAPPLE = missing_glElementPointerAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glElementPointerAPPLE == loader_glElementPointerAPPLE) {
      rCtx->dsp.emuTbl.glElementPointerAPPLE = driverTbl.glElementPointerAPPLE;
   }
   driverTbl.glElementPointerAPPLE(type, pointer);
}

static void REGAL_CALL missing_glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   Warning( "Called missing function glDrawElementArrayAPPLE" );
}

static void REGAL_CALL loader_glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawElementArrayAPPLE, "glDrawElementArrayAPPLE");
   if ( !driverTbl.glDrawElementArrayAPPLE ) {
      driverTbl.glDrawElementArrayAPPLE = missing_glDrawElementArrayAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawElementArrayAPPLE == loader_glDrawElementArrayAPPLE) {
      rCtx->dsp.emuTbl.glDrawElementArrayAPPLE = driverTbl.glDrawElementArrayAPPLE;
   }
   driverTbl.glDrawElementArrayAPPLE(mode, first, count);
}

static void REGAL_CALL missing_glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(end);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   Warning( "Called missing function glDrawRangeElementArrayAPPLE" );
}

static void REGAL_CALL loader_glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawRangeElementArrayAPPLE, "glDrawRangeElementArrayAPPLE");
   if ( !driverTbl.glDrawRangeElementArrayAPPLE ) {
      driverTbl.glDrawRangeElementArrayAPPLE = missing_glDrawRangeElementArrayAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawRangeElementArrayAPPLE == loader_glDrawRangeElementArrayAPPLE) {
      rCtx->dsp.emuTbl.glDrawRangeElementArrayAPPLE = driverTbl.glDrawRangeElementArrayAPPLE;
   }
   driverTbl.glDrawRangeElementArrayAPPLE(mode, start, end, first, count);
}

static void REGAL_CALL missing_glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   Warning( "Called missing function glMultiDrawElementArrayAPPLE" );
}

static void REGAL_CALL loader_glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiDrawElementArrayAPPLE, "glMultiDrawElementArrayAPPLE");
   if ( !driverTbl.glMultiDrawElementArrayAPPLE ) {
      driverTbl.glMultiDrawElementArrayAPPLE = missing_glMultiDrawElementArrayAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiDrawElementArrayAPPLE == loader_glMultiDrawElementArrayAPPLE) {
      rCtx->dsp.emuTbl.glMultiDrawElementArrayAPPLE = driverTbl.glMultiDrawElementArrayAPPLE;
   }
   driverTbl.glMultiDrawElementArrayAPPLE(mode, first, count, primcount);
}

static void REGAL_CALL missing_glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(end);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   Warning( "Called missing function glMultiDrawRangeElementArrayAPPLE" );
}

static void REGAL_CALL loader_glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiDrawRangeElementArrayAPPLE, "glMultiDrawRangeElementArrayAPPLE");
   if ( !driverTbl.glMultiDrawRangeElementArrayAPPLE ) {
      driverTbl.glMultiDrawRangeElementArrayAPPLE = missing_glMultiDrawRangeElementArrayAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiDrawRangeElementArrayAPPLE == loader_glMultiDrawRangeElementArrayAPPLE) {
      rCtx->dsp.emuTbl.glMultiDrawRangeElementArrayAPPLE = driverTbl.glMultiDrawRangeElementArrayAPPLE;
   }
   driverTbl.glMultiDrawRangeElementArrayAPPLE(mode, start, end, first, count, primcount);
}

// GL_APPLE_fence

static void REGAL_CALL missing_glGenFencesAPPLE(GLsizei n, GLuint *fences)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(fences);
   Warning( "Called missing function glGenFencesAPPLE" );
}

static void REGAL_CALL loader_glGenFencesAPPLE(GLsizei n, GLuint *fences)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenFencesAPPLE, "glGenFencesAPPLE");
   if ( !driverTbl.glGenFencesAPPLE ) {
      driverTbl.glGenFencesAPPLE = missing_glGenFencesAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenFencesAPPLE == loader_glGenFencesAPPLE) {
      rCtx->dsp.emuTbl.glGenFencesAPPLE = driverTbl.glGenFencesAPPLE;
   }
   driverTbl.glGenFencesAPPLE(n, fences);
}

static void REGAL_CALL missing_glDeleteFencesAPPLE(GLsizei n, const GLuint *fences)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(fences);
   Warning( "Called missing function glDeleteFencesAPPLE" );
}

static void REGAL_CALL loader_glDeleteFencesAPPLE(GLsizei n, const GLuint *fences)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteFencesAPPLE, "glDeleteFencesAPPLE");
   if ( !driverTbl.glDeleteFencesAPPLE ) {
      driverTbl.glDeleteFencesAPPLE = missing_glDeleteFencesAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteFencesAPPLE == loader_glDeleteFencesAPPLE) {
      rCtx->dsp.emuTbl.glDeleteFencesAPPLE = driverTbl.glDeleteFencesAPPLE;
   }
   driverTbl.glDeleteFencesAPPLE(n, fences);
}

static void REGAL_CALL missing_glSetFenceAPPLE(GLuint fence)
{
   UNUSED_PARAMETER(fence);
   Warning( "Called missing function glSetFenceAPPLE" );
}

static void REGAL_CALL loader_glSetFenceAPPLE(GLuint fence)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSetFenceAPPLE, "glSetFenceAPPLE");
   if ( !driverTbl.glSetFenceAPPLE ) {
      driverTbl.glSetFenceAPPLE = missing_glSetFenceAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSetFenceAPPLE == loader_glSetFenceAPPLE) {
      rCtx->dsp.emuTbl.glSetFenceAPPLE = driverTbl.glSetFenceAPPLE;
   }
   driverTbl.glSetFenceAPPLE(fence);
}

static GLboolean REGAL_CALL missing_glIsFenceAPPLE(GLuint fence)
{
   UNUSED_PARAMETER(fence);
   Warning( "Called missing function glIsFenceAPPLE" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsFenceAPPLE(GLuint fence)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsFenceAPPLE, "glIsFenceAPPLE");
   if ( !driverTbl.glIsFenceAPPLE ) {
      driverTbl.glIsFenceAPPLE = missing_glIsFenceAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsFenceAPPLE == loader_glIsFenceAPPLE) {
      rCtx->dsp.emuTbl.glIsFenceAPPLE = driverTbl.glIsFenceAPPLE;
   }
   return driverTbl.glIsFenceAPPLE(fence);
}

static GLboolean REGAL_CALL missing_glTestFenceAPPLE(GLuint fence)
{
   UNUSED_PARAMETER(fence);
   Warning( "Called missing function glTestFenceAPPLE" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glTestFenceAPPLE(GLuint fence)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTestFenceAPPLE, "glTestFenceAPPLE");
   if ( !driverTbl.glTestFenceAPPLE ) {
      driverTbl.glTestFenceAPPLE = missing_glTestFenceAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTestFenceAPPLE == loader_glTestFenceAPPLE) {
      rCtx->dsp.emuTbl.glTestFenceAPPLE = driverTbl.glTestFenceAPPLE;
   }
   return driverTbl.glTestFenceAPPLE(fence);
}

static void REGAL_CALL missing_glFinishFenceAPPLE(GLuint fence)
{
   UNUSED_PARAMETER(fence);
   Warning( "Called missing function glFinishFenceAPPLE" );
}

static void REGAL_CALL loader_glFinishFenceAPPLE(GLuint fence)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFinishFenceAPPLE, "glFinishFenceAPPLE");
   if ( !driverTbl.glFinishFenceAPPLE ) {
      driverTbl.glFinishFenceAPPLE = missing_glFinishFenceAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFinishFenceAPPLE == loader_glFinishFenceAPPLE) {
      rCtx->dsp.emuTbl.glFinishFenceAPPLE = driverTbl.glFinishFenceAPPLE;
   }
   driverTbl.glFinishFenceAPPLE(fence);
}

static GLboolean REGAL_CALL missing_glTestObjectAPPLE(GLenum object, GLuint name)
{
   UNUSED_PARAMETER(object);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glTestObjectAPPLE" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glTestObjectAPPLE(GLenum object, GLuint name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTestObjectAPPLE, "glTestObjectAPPLE");
   if ( !driverTbl.glTestObjectAPPLE ) {
      driverTbl.glTestObjectAPPLE = missing_glTestObjectAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTestObjectAPPLE == loader_glTestObjectAPPLE) {
      rCtx->dsp.emuTbl.glTestObjectAPPLE = driverTbl.glTestObjectAPPLE;
   }
   return driverTbl.glTestObjectAPPLE(object, name);
}

static void REGAL_CALL missing_glFinishObjectAPPLE(GLenum object, GLint name)
{
   UNUSED_PARAMETER(object);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glFinishObjectAPPLE" );
}

static void REGAL_CALL loader_glFinishObjectAPPLE(GLenum object, GLint name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFinishObjectAPPLE, "glFinishObjectAPPLE");
   if ( !driverTbl.glFinishObjectAPPLE ) {
      driverTbl.glFinishObjectAPPLE = missing_glFinishObjectAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFinishObjectAPPLE == loader_glFinishObjectAPPLE) {
      rCtx->dsp.emuTbl.glFinishObjectAPPLE = driverTbl.glFinishObjectAPPLE;
   }
   driverTbl.glFinishObjectAPPLE(object, name);
}

// GL_APPLE_vertex_array_object

static void REGAL_CALL missing_glBindVertexArrayAPPLE(GLuint array)
{
   UNUSED_PARAMETER(array);
   Warning( "Called missing function glBindVertexArrayAPPLE" );
}

static void REGAL_CALL loader_glBindVertexArrayAPPLE(GLuint array)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindVertexArrayAPPLE, "glBindVertexArrayAPPLE");
   if ( !driverTbl.glBindVertexArrayAPPLE ) {
      driverTbl.glBindVertexArrayAPPLE = missing_glBindVertexArrayAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindVertexArrayAPPLE == loader_glBindVertexArrayAPPLE) {
      rCtx->dsp.emuTbl.glBindVertexArrayAPPLE = driverTbl.glBindVertexArrayAPPLE;
   }
   driverTbl.glBindVertexArrayAPPLE(array);
}

static void REGAL_CALL missing_glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *arrays)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(arrays);
   Warning( "Called missing function glDeleteVertexArraysAPPLE" );
}

static void REGAL_CALL loader_glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *arrays)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteVertexArraysAPPLE, "glDeleteVertexArraysAPPLE");
   if ( !driverTbl.glDeleteVertexArraysAPPLE ) {
      driverTbl.glDeleteVertexArraysAPPLE = missing_glDeleteVertexArraysAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteVertexArraysAPPLE == loader_glDeleteVertexArraysAPPLE) {
      rCtx->dsp.emuTbl.glDeleteVertexArraysAPPLE = driverTbl.glDeleteVertexArraysAPPLE;
   }
   driverTbl.glDeleteVertexArraysAPPLE(n, arrays);
}

static void REGAL_CALL missing_glGenVertexArraysAPPLE(GLsizei n, const GLuint *arrays)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(arrays);
   Warning( "Called missing function glGenVertexArraysAPPLE" );
}

static void REGAL_CALL loader_glGenVertexArraysAPPLE(GLsizei n, const GLuint *arrays)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenVertexArraysAPPLE, "glGenVertexArraysAPPLE");
   if ( !driverTbl.glGenVertexArraysAPPLE ) {
      driverTbl.glGenVertexArraysAPPLE = missing_glGenVertexArraysAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenVertexArraysAPPLE == loader_glGenVertexArraysAPPLE) {
      rCtx->dsp.emuTbl.glGenVertexArraysAPPLE = driverTbl.glGenVertexArraysAPPLE;
   }
   driverTbl.glGenVertexArraysAPPLE(n, arrays);
}

static GLboolean REGAL_CALL missing_glIsVertexArrayAPPLE(GLuint array)
{
   UNUSED_PARAMETER(array);
   Warning( "Called missing function glIsVertexArrayAPPLE" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsVertexArrayAPPLE(GLuint array)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsVertexArrayAPPLE, "glIsVertexArrayAPPLE");
   if ( !driverTbl.glIsVertexArrayAPPLE ) {
      driverTbl.glIsVertexArrayAPPLE = missing_glIsVertexArrayAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsVertexArrayAPPLE == loader_glIsVertexArrayAPPLE) {
      rCtx->dsp.emuTbl.glIsVertexArrayAPPLE = driverTbl.glIsVertexArrayAPPLE;
   }
   return driverTbl.glIsVertexArrayAPPLE(array);
}

// GL_APPLE_vertex_array_range

static void REGAL_CALL missing_glVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
{
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glVertexArrayRangeAPPLE" );
}

static void REGAL_CALL loader_glVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexArrayRangeAPPLE, "glVertexArrayRangeAPPLE");
   if ( !driverTbl.glVertexArrayRangeAPPLE ) {
      driverTbl.glVertexArrayRangeAPPLE = missing_glVertexArrayRangeAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexArrayRangeAPPLE == loader_glVertexArrayRangeAPPLE) {
      rCtx->dsp.emuTbl.glVertexArrayRangeAPPLE = driverTbl.glVertexArrayRangeAPPLE;
   }
   driverTbl.glVertexArrayRangeAPPLE(length, pointer);
}

static void REGAL_CALL missing_glFlushVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
{
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glFlushVertexArrayRangeAPPLE" );
}

static void REGAL_CALL loader_glFlushVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFlushVertexArrayRangeAPPLE, "glFlushVertexArrayRangeAPPLE");
   if ( !driverTbl.glFlushVertexArrayRangeAPPLE ) {
      driverTbl.glFlushVertexArrayRangeAPPLE = missing_glFlushVertexArrayRangeAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFlushVertexArrayRangeAPPLE == loader_glFlushVertexArrayRangeAPPLE) {
      rCtx->dsp.emuTbl.glFlushVertexArrayRangeAPPLE = driverTbl.glFlushVertexArrayRangeAPPLE;
   }
   driverTbl.glFlushVertexArrayRangeAPPLE(length, pointer);
}

static void REGAL_CALL missing_glVertexArrayParameteriAPPLE(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glVertexArrayParameteriAPPLE" );
}

static void REGAL_CALL loader_glVertexArrayParameteriAPPLE(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexArrayParameteriAPPLE, "glVertexArrayParameteriAPPLE");
   if ( !driverTbl.glVertexArrayParameteriAPPLE ) {
      driverTbl.glVertexArrayParameteriAPPLE = missing_glVertexArrayParameteriAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexArrayParameteriAPPLE == loader_glVertexArrayParameteriAPPLE) {
      rCtx->dsp.emuTbl.glVertexArrayParameteriAPPLE = driverTbl.glVertexArrayParameteriAPPLE;
   }
   driverTbl.glVertexArrayParameteriAPPLE(pname, param);
}

// GL_ATI_draw_buffers

static void REGAL_CALL missing_glDrawBuffersATI(GLsizei n, const GLenum *bufs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(bufs);
   Warning( "Called missing function glDrawBuffersATI" );
}

static void REGAL_CALL loader_glDrawBuffersATI(GLsizei n, const GLenum *bufs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawBuffersATI, "glDrawBuffersATI");
   if ( !driverTbl.glDrawBuffersATI ) {
      driverTbl.glDrawBuffersATI = missing_glDrawBuffersATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawBuffersATI == loader_glDrawBuffersATI) {
      rCtx->dsp.emuTbl.glDrawBuffersATI = driverTbl.glDrawBuffersATI;
   }
   driverTbl.glDrawBuffersATI(n, bufs);
}

// GL_NV_fragment_program

static void REGAL_CALL missing_glProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramNamedParameter4fNV" );
}

static void REGAL_CALL loader_glProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramNamedParameter4fNV, "glProgramNamedParameter4fNV");
   if ( !driverTbl.glProgramNamedParameter4fNV ) {
      driverTbl.glProgramNamedParameter4fNV = missing_glProgramNamedParameter4fNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramNamedParameter4fNV == loader_glProgramNamedParameter4fNV) {
      rCtx->dsp.emuTbl.glProgramNamedParameter4fNV = driverTbl.glProgramNamedParameter4fNV;
   }
   driverTbl.glProgramNamedParameter4fNV(id, len, name, x, y, z, w);
}

static void REGAL_CALL missing_glProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramNamedParameter4dNV" );
}

static void REGAL_CALL loader_glProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramNamedParameter4dNV, "glProgramNamedParameter4dNV");
   if ( !driverTbl.glProgramNamedParameter4dNV ) {
      driverTbl.glProgramNamedParameter4dNV = missing_glProgramNamedParameter4dNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramNamedParameter4dNV == loader_glProgramNamedParameter4dNV) {
      rCtx->dsp.emuTbl.glProgramNamedParameter4dNV = driverTbl.glProgramNamedParameter4dNV;
   }
   driverTbl.glProgramNamedParameter4dNV(id, len, name, x, y, z, w);
}

static void REGAL_CALL missing_glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glProgramNamedParameter4fvNV" );
}

static void REGAL_CALL loader_glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramNamedParameter4fvNV, "glProgramNamedParameter4fvNV");
   if ( !driverTbl.glProgramNamedParameter4fvNV ) {
      driverTbl.glProgramNamedParameter4fvNV = missing_glProgramNamedParameter4fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramNamedParameter4fvNV == loader_glProgramNamedParameter4fvNV) {
      rCtx->dsp.emuTbl.glProgramNamedParameter4fvNV = driverTbl.glProgramNamedParameter4fvNV;
   }
   driverTbl.glProgramNamedParameter4fvNV(id, len, name, v);
}

static void REGAL_CALL missing_glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glProgramNamedParameter4dvNV" );
}

static void REGAL_CALL loader_glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramNamedParameter4dvNV, "glProgramNamedParameter4dvNV");
   if ( !driverTbl.glProgramNamedParameter4dvNV ) {
      driverTbl.glProgramNamedParameter4dvNV = missing_glProgramNamedParameter4dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramNamedParameter4dvNV == loader_glProgramNamedParameter4dvNV) {
      rCtx->dsp.emuTbl.glProgramNamedParameter4dvNV = driverTbl.glProgramNamedParameter4dvNV;
   }
   driverTbl.glProgramNamedParameter4dvNV(id, len, name, v);
}

static void REGAL_CALL missing_glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramNamedParameterfvNV" );
}

static void REGAL_CALL loader_glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramNamedParameterfvNV, "glGetProgramNamedParameterfvNV");
   if ( !driverTbl.glGetProgramNamedParameterfvNV ) {
      driverTbl.glGetProgramNamedParameterfvNV = missing_glGetProgramNamedParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramNamedParameterfvNV == loader_glGetProgramNamedParameterfvNV) {
      rCtx->dsp.emuTbl.glGetProgramNamedParameterfvNV = driverTbl.glGetProgramNamedParameterfvNV;
   }
   driverTbl.glGetProgramNamedParameterfvNV(id, len, name, params);
}

static void REGAL_CALL missing_glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramNamedParameterdvNV" );
}

static void REGAL_CALL loader_glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramNamedParameterdvNV, "glGetProgramNamedParameterdvNV");
   if ( !driverTbl.glGetProgramNamedParameterdvNV ) {
      driverTbl.glGetProgramNamedParameterdvNV = missing_glGetProgramNamedParameterdvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramNamedParameterdvNV == loader_glGetProgramNamedParameterdvNV) {
      rCtx->dsp.emuTbl.glGetProgramNamedParameterdvNV = driverTbl.glGetProgramNamedParameterdvNV;
   }
   driverTbl.glGetProgramNamedParameterdvNV(id, len, name, params);
}

// GL_NV_half_float

static void REGAL_CALL missing_glVertex2hNV(GLhalfNV x, GLhalfNV y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertex2hNV" );
}

static void REGAL_CALL loader_glVertex2hNV(GLhalfNV x, GLhalfNV y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex2hNV, "glVertex2hNV");
   if ( !driverTbl.glVertex2hNV ) {
      driverTbl.glVertex2hNV = missing_glVertex2hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex2hNV == loader_glVertex2hNV) {
      rCtx->dsp.emuTbl.glVertex2hNV = driverTbl.glVertex2hNV;
   }
   driverTbl.glVertex2hNV(x, y);
}

static void REGAL_CALL missing_glVertex2hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex2hvNV" );
}

static void REGAL_CALL loader_glVertex2hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex2hvNV, "glVertex2hvNV");
   if ( !driverTbl.glVertex2hvNV ) {
      driverTbl.glVertex2hvNV = missing_glVertex2hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex2hvNV == loader_glVertex2hvNV) {
      rCtx->dsp.emuTbl.glVertex2hvNV = driverTbl.glVertex2hvNV;
   }
   driverTbl.glVertex2hvNV(v);
}

static void REGAL_CALL missing_glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertex3hNV" );
}

static void REGAL_CALL loader_glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex3hNV, "glVertex3hNV");
   if ( !driverTbl.glVertex3hNV ) {
      driverTbl.glVertex3hNV = missing_glVertex3hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex3hNV == loader_glVertex3hNV) {
      rCtx->dsp.emuTbl.glVertex3hNV = driverTbl.glVertex3hNV;
   }
   driverTbl.glVertex3hNV(x, y, z);
}

static void REGAL_CALL missing_glVertex3hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex3hvNV" );
}

static void REGAL_CALL loader_glVertex3hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex3hvNV, "glVertex3hvNV");
   if ( !driverTbl.glVertex3hvNV ) {
      driverTbl.glVertex3hvNV = missing_glVertex3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex3hvNV == loader_glVertex3hvNV) {
      rCtx->dsp.emuTbl.glVertex3hvNV = driverTbl.glVertex3hvNV;
   }
   driverTbl.glVertex3hvNV(v);
}

static void REGAL_CALL missing_glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertex4hNV" );
}

static void REGAL_CALL loader_glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex4hNV, "glVertex4hNV");
   if ( !driverTbl.glVertex4hNV ) {
      driverTbl.glVertex4hNV = missing_glVertex4hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex4hNV == loader_glVertex4hNV) {
      rCtx->dsp.emuTbl.glVertex4hNV = driverTbl.glVertex4hNV;
   }
   driverTbl.glVertex4hNV(x, y, z, w);
}

static void REGAL_CALL missing_glVertex4hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertex4hvNV" );
}

static void REGAL_CALL loader_glVertex4hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertex4hvNV, "glVertex4hvNV");
   if ( !driverTbl.glVertex4hvNV ) {
      driverTbl.glVertex4hvNV = missing_glVertex4hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertex4hvNV == loader_glVertex4hvNV) {
      rCtx->dsp.emuTbl.glVertex4hvNV = driverTbl.glVertex4hvNV;
   }
   driverTbl.glVertex4hvNV(v);
}

static void REGAL_CALL missing_glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz)
{
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   Warning( "Called missing function glNormal3hNV" );
}

static void REGAL_CALL loader_glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormal3hNV, "glNormal3hNV");
   if ( !driverTbl.glNormal3hNV ) {
      driverTbl.glNormal3hNV = missing_glNormal3hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormal3hNV == loader_glNormal3hNV) {
      rCtx->dsp.emuTbl.glNormal3hNV = driverTbl.glNormal3hNV;
   }
   driverTbl.glNormal3hNV(nx, ny, nz);
}

static void REGAL_CALL missing_glNormal3hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glNormal3hvNV" );
}

static void REGAL_CALL loader_glNormal3hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormal3hvNV, "glNormal3hvNV");
   if ( !driverTbl.glNormal3hvNV ) {
      driverTbl.glNormal3hvNV = missing_glNormal3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormal3hvNV == loader_glNormal3hvNV) {
      rCtx->dsp.emuTbl.glNormal3hvNV = driverTbl.glNormal3hvNV;
   }
   driverTbl.glNormal3hvNV(v);
}

static void REGAL_CALL missing_glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glColor3hNV" );
}

static void REGAL_CALL loader_glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3hNV, "glColor3hNV");
   if ( !driverTbl.glColor3hNV ) {
      driverTbl.glColor3hNV = missing_glColor3hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3hNV == loader_glColor3hNV) {
      rCtx->dsp.emuTbl.glColor3hNV = driverTbl.glColor3hNV;
   }
   driverTbl.glColor3hNV(red, green, blue);
}

static void REGAL_CALL missing_glColor3hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor3hvNV" );
}

static void REGAL_CALL loader_glColor3hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor3hvNV, "glColor3hvNV");
   if ( !driverTbl.glColor3hvNV ) {
      driverTbl.glColor3hvNV = missing_glColor3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor3hvNV == loader_glColor3hvNV) {
      rCtx->dsp.emuTbl.glColor3hvNV = driverTbl.glColor3hvNV;
   }
   driverTbl.glColor3hvNV(v);
}

static void REGAL_CALL missing_glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glColor4hNV" );
}

static void REGAL_CALL loader_glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4hNV, "glColor4hNV");
   if ( !driverTbl.glColor4hNV ) {
      driverTbl.glColor4hNV = missing_glColor4hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4hNV == loader_glColor4hNV) {
      rCtx->dsp.emuTbl.glColor4hNV = driverTbl.glColor4hNV;
   }
   driverTbl.glColor4hNV(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glColor4hvNV" );
}

static void REGAL_CALL loader_glColor4hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColor4hvNV, "glColor4hvNV");
   if ( !driverTbl.glColor4hvNV ) {
      driverTbl.glColor4hvNV = missing_glColor4hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColor4hvNV == loader_glColor4hvNV) {
      rCtx->dsp.emuTbl.glColor4hvNV = driverTbl.glColor4hvNV;
   }
   driverTbl.glColor4hvNV(v);
}

static void REGAL_CALL missing_glTexCoord1hNV(GLhalfNV s)
{
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glTexCoord1hNV" );
}

static void REGAL_CALL loader_glTexCoord1hNV(GLhalfNV s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord1hNV, "glTexCoord1hNV");
   if ( !driverTbl.glTexCoord1hNV ) {
      driverTbl.glTexCoord1hNV = missing_glTexCoord1hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord1hNV == loader_glTexCoord1hNV) {
      rCtx->dsp.emuTbl.glTexCoord1hNV = driverTbl.glTexCoord1hNV;
   }
   driverTbl.glTexCoord1hNV(s);
}

static void REGAL_CALL missing_glTexCoord1hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord1hvNV" );
}

static void REGAL_CALL loader_glTexCoord1hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord1hvNV, "glTexCoord1hvNV");
   if ( !driverTbl.glTexCoord1hvNV ) {
      driverTbl.glTexCoord1hvNV = missing_glTexCoord1hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord1hvNV == loader_glTexCoord1hvNV) {
      rCtx->dsp.emuTbl.glTexCoord1hvNV = driverTbl.glTexCoord1hvNV;
   }
   driverTbl.glTexCoord1hvNV(v);
}

static void REGAL_CALL missing_glTexCoord2hNV(GLhalfNV s, GLhalfNV t)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "Called missing function glTexCoord2hNV" );
}

static void REGAL_CALL loader_glTexCoord2hNV(GLhalfNV s, GLhalfNV t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2hNV, "glTexCoord2hNV");
   if ( !driverTbl.glTexCoord2hNV ) {
      driverTbl.glTexCoord2hNV = missing_glTexCoord2hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2hNV == loader_glTexCoord2hNV) {
      rCtx->dsp.emuTbl.glTexCoord2hNV = driverTbl.glTexCoord2hNV;
   }
   driverTbl.glTexCoord2hNV(s, t);
}

static void REGAL_CALL missing_glTexCoord2hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord2hvNV" );
}

static void REGAL_CALL loader_glTexCoord2hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord2hvNV, "glTexCoord2hvNV");
   if ( !driverTbl.glTexCoord2hvNV ) {
      driverTbl.glTexCoord2hvNV = missing_glTexCoord2hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord2hvNV == loader_glTexCoord2hvNV) {
      rCtx->dsp.emuTbl.glTexCoord2hvNV = driverTbl.glTexCoord2hvNV;
   }
   driverTbl.glTexCoord2hvNV(v);
}

static void REGAL_CALL missing_glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "Called missing function glTexCoord3hNV" );
}

static void REGAL_CALL loader_glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord3hNV, "glTexCoord3hNV");
   if ( !driverTbl.glTexCoord3hNV ) {
      driverTbl.glTexCoord3hNV = missing_glTexCoord3hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord3hNV == loader_glTexCoord3hNV) {
      rCtx->dsp.emuTbl.glTexCoord3hNV = driverTbl.glTexCoord3hNV;
   }
   driverTbl.glTexCoord3hNV(s, t, r);
}

static void REGAL_CALL missing_glTexCoord3hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord3hvNV" );
}

static void REGAL_CALL loader_glTexCoord3hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord3hvNV, "glTexCoord3hvNV");
   if ( !driverTbl.glTexCoord3hvNV ) {
      driverTbl.glTexCoord3hvNV = missing_glTexCoord3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord3hvNV == loader_glTexCoord3hvNV) {
      rCtx->dsp.emuTbl.glTexCoord3hvNV = driverTbl.glTexCoord3hvNV;
   }
   driverTbl.glTexCoord3hvNV(v);
}

static void REGAL_CALL missing_glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "Called missing function glTexCoord4hNV" );
}

static void REGAL_CALL loader_glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord4hNV, "glTexCoord4hNV");
   if ( !driverTbl.glTexCoord4hNV ) {
      driverTbl.glTexCoord4hNV = missing_glTexCoord4hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord4hNV == loader_glTexCoord4hNV) {
      rCtx->dsp.emuTbl.glTexCoord4hNV = driverTbl.glTexCoord4hNV;
   }
   driverTbl.glTexCoord4hNV(s, t, r, q);
}

static void REGAL_CALL missing_glTexCoord4hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glTexCoord4hvNV" );
}

static void REGAL_CALL loader_glTexCoord4hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoord4hvNV, "glTexCoord4hvNV");
   if ( !driverTbl.glTexCoord4hvNV ) {
      driverTbl.glTexCoord4hvNV = missing_glTexCoord4hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoord4hvNV == loader_glTexCoord4hvNV) {
      rCtx->dsp.emuTbl.glTexCoord4hvNV = driverTbl.glTexCoord4hvNV;
   }
   driverTbl.glTexCoord4hvNV(v);
}

static void REGAL_CALL missing_glMultiTexCoord1hNV(GLenum target, GLhalfNV s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "Called missing function glMultiTexCoord1hNV" );
}

static void REGAL_CALL loader_glMultiTexCoord1hNV(GLenum target, GLhalfNV s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1hNV, "glMultiTexCoord1hNV");
   if ( !driverTbl.glMultiTexCoord1hNV ) {
      driverTbl.glMultiTexCoord1hNV = missing_glMultiTexCoord1hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1hNV == loader_glMultiTexCoord1hNV) {
      rCtx->dsp.emuTbl.glMultiTexCoord1hNV = driverTbl.glMultiTexCoord1hNV;
   }
   driverTbl.glMultiTexCoord1hNV(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1hvNV(GLenum target, const GLhalfNV *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord1hvNV" );
}

static void REGAL_CALL loader_glMultiTexCoord1hvNV(GLenum target, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord1hvNV, "glMultiTexCoord1hvNV");
   if ( !driverTbl.glMultiTexCoord1hvNV ) {
      driverTbl.glMultiTexCoord1hvNV = missing_glMultiTexCoord1hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord1hvNV == loader_glMultiTexCoord1hvNV) {
      rCtx->dsp.emuTbl.glMultiTexCoord1hvNV = driverTbl.glMultiTexCoord1hvNV;
   }
   driverTbl.glMultiTexCoord1hvNV(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "Called missing function glMultiTexCoord2hNV" );
}

static void REGAL_CALL loader_glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2hNV, "glMultiTexCoord2hNV");
   if ( !driverTbl.glMultiTexCoord2hNV ) {
      driverTbl.glMultiTexCoord2hNV = missing_glMultiTexCoord2hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2hNV == loader_glMultiTexCoord2hNV) {
      rCtx->dsp.emuTbl.glMultiTexCoord2hNV = driverTbl.glMultiTexCoord2hNV;
   }
   driverTbl.glMultiTexCoord2hNV(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2hvNV(GLenum target, const GLhalfNV *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord2hvNV" );
}

static void REGAL_CALL loader_glMultiTexCoord2hvNV(GLenum target, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord2hvNV, "glMultiTexCoord2hvNV");
   if ( !driverTbl.glMultiTexCoord2hvNV ) {
      driverTbl.glMultiTexCoord2hvNV = missing_glMultiTexCoord2hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord2hvNV == loader_glMultiTexCoord2hvNV) {
      rCtx->dsp.emuTbl.glMultiTexCoord2hvNV = driverTbl.glMultiTexCoord2hvNV;
   }
   driverTbl.glMultiTexCoord2hvNV(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "Called missing function glMultiTexCoord3hNV" );
}

static void REGAL_CALL loader_glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3hNV, "glMultiTexCoord3hNV");
   if ( !driverTbl.glMultiTexCoord3hNV ) {
      driverTbl.glMultiTexCoord3hNV = missing_glMultiTexCoord3hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3hNV == loader_glMultiTexCoord3hNV) {
      rCtx->dsp.emuTbl.glMultiTexCoord3hNV = driverTbl.glMultiTexCoord3hNV;
   }
   driverTbl.glMultiTexCoord3hNV(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3hvNV(GLenum target, const GLhalfNV *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord3hvNV" );
}

static void REGAL_CALL loader_glMultiTexCoord3hvNV(GLenum target, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord3hvNV, "glMultiTexCoord3hvNV");
   if ( !driverTbl.glMultiTexCoord3hvNV ) {
      driverTbl.glMultiTexCoord3hvNV = missing_glMultiTexCoord3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord3hvNV == loader_glMultiTexCoord3hvNV) {
      rCtx->dsp.emuTbl.glMultiTexCoord3hvNV = driverTbl.glMultiTexCoord3hvNV;
   }
   driverTbl.glMultiTexCoord3hvNV(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "Called missing function glMultiTexCoord4hNV" );
}

static void REGAL_CALL loader_glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4hNV, "glMultiTexCoord4hNV");
   if ( !driverTbl.glMultiTexCoord4hNV ) {
      driverTbl.glMultiTexCoord4hNV = missing_glMultiTexCoord4hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4hNV == loader_glMultiTexCoord4hNV) {
      rCtx->dsp.emuTbl.glMultiTexCoord4hNV = driverTbl.glMultiTexCoord4hNV;
   }
   driverTbl.glMultiTexCoord4hNV(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4hvNV(GLenum target, const GLhalfNV *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glMultiTexCoord4hvNV" );
}

static void REGAL_CALL loader_glMultiTexCoord4hvNV(GLenum target, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoord4hvNV, "glMultiTexCoord4hvNV");
   if ( !driverTbl.glMultiTexCoord4hvNV ) {
      driverTbl.glMultiTexCoord4hvNV = missing_glMultiTexCoord4hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoord4hvNV == loader_glMultiTexCoord4hvNV) {
      rCtx->dsp.emuTbl.glMultiTexCoord4hvNV = driverTbl.glMultiTexCoord4hvNV;
   }
   driverTbl.glMultiTexCoord4hvNV(target, v);
}

static void REGAL_CALL missing_glFogCoordhNV(GLhalfNV coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "Called missing function glFogCoordhNV" );
}

static void REGAL_CALL loader_glFogCoordhNV(GLhalfNV coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogCoordhNV, "glFogCoordhNV");
   if ( !driverTbl.glFogCoordhNV ) {
      driverTbl.glFogCoordhNV = missing_glFogCoordhNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogCoordhNV == loader_glFogCoordhNV) {
      rCtx->dsp.emuTbl.glFogCoordhNV = driverTbl.glFogCoordhNV;
   }
   driverTbl.glFogCoordhNV(coord);
}

static void REGAL_CALL missing_glFogCoordhvNV(const GLhalfNV *coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "Called missing function glFogCoordhvNV" );
}

static void REGAL_CALL loader_glFogCoordhvNV(const GLhalfNV *coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogCoordhvNV, "glFogCoordhvNV");
   if ( !driverTbl.glFogCoordhvNV ) {
      driverTbl.glFogCoordhvNV = missing_glFogCoordhvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogCoordhvNV == loader_glFogCoordhvNV) {
      rCtx->dsp.emuTbl.glFogCoordhvNV = driverTbl.glFogCoordhvNV;
   }
   driverTbl.glFogCoordhvNV(coord);
}

static void REGAL_CALL missing_glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "Called missing function glSecondaryColor3hNV" );
}

static void REGAL_CALL loader_glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3hNV, "glSecondaryColor3hNV");
   if ( !driverTbl.glSecondaryColor3hNV ) {
      driverTbl.glSecondaryColor3hNV = missing_glSecondaryColor3hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3hNV == loader_glSecondaryColor3hNV) {
      rCtx->dsp.emuTbl.glSecondaryColor3hNV = driverTbl.glSecondaryColor3hNV;
   }
   driverTbl.glSecondaryColor3hNV(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glSecondaryColor3hvNV" );
}

static void REGAL_CALL loader_glSecondaryColor3hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColor3hvNV, "glSecondaryColor3hvNV");
   if ( !driverTbl.glSecondaryColor3hvNV ) {
      driverTbl.glSecondaryColor3hvNV = missing_glSecondaryColor3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColor3hvNV == loader_glSecondaryColor3hvNV) {
      rCtx->dsp.emuTbl.glSecondaryColor3hvNV = driverTbl.glSecondaryColor3hvNV;
   }
   driverTbl.glSecondaryColor3hvNV(v);
}

static void REGAL_CALL missing_glVertexWeighthNV(GLhalfNV weight)
{
   UNUSED_PARAMETER(weight);
   Warning( "Called missing function glVertexWeighthNV" );
}

static void REGAL_CALL loader_glVertexWeighthNV(GLhalfNV weight)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexWeighthNV, "glVertexWeighthNV");
   if ( !driverTbl.glVertexWeighthNV ) {
      driverTbl.glVertexWeighthNV = missing_glVertexWeighthNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexWeighthNV == loader_glVertexWeighthNV) {
      rCtx->dsp.emuTbl.glVertexWeighthNV = driverTbl.glVertexWeighthNV;
   }
   driverTbl.glVertexWeighthNV(weight);
}

static void REGAL_CALL missing_glVertexWeighthvNV(const GLhalfNV *weight)
{
   UNUSED_PARAMETER(weight);
   Warning( "Called missing function glVertexWeighthvNV" );
}

static void REGAL_CALL loader_glVertexWeighthvNV(const GLhalfNV *weight)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexWeighthvNV, "glVertexWeighthvNV");
   if ( !driverTbl.glVertexWeighthvNV ) {
      driverTbl.glVertexWeighthvNV = missing_glVertexWeighthvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexWeighthvNV == loader_glVertexWeighthvNV) {
      rCtx->dsp.emuTbl.glVertexWeighthvNV = driverTbl.glVertexWeighthvNV;
   }
   driverTbl.glVertexWeighthvNV(weight);
}

static void REGAL_CALL missing_glVertexAttrib1hNV(GLuint index, GLhalfNV x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttrib1hNV" );
}

static void REGAL_CALL loader_glVertexAttrib1hNV(GLuint index, GLhalfNV x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1hNV, "glVertexAttrib1hNV");
   if ( !driverTbl.glVertexAttrib1hNV ) {
      driverTbl.glVertexAttrib1hNV = missing_glVertexAttrib1hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1hNV == loader_glVertexAttrib1hNV) {
      rCtx->dsp.emuTbl.glVertexAttrib1hNV = driverTbl.glVertexAttrib1hNV;
   }
   driverTbl.glVertexAttrib1hNV(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1hvNV(GLuint index, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib1hvNV" );
}

static void REGAL_CALL loader_glVertexAttrib1hvNV(GLuint index, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib1hvNV, "glVertexAttrib1hvNV");
   if ( !driverTbl.glVertexAttrib1hvNV ) {
      driverTbl.glVertexAttrib1hvNV = missing_glVertexAttrib1hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib1hvNV == loader_glVertexAttrib1hvNV) {
      rCtx->dsp.emuTbl.glVertexAttrib1hvNV = driverTbl.glVertexAttrib1hvNV;
   }
   driverTbl.glVertexAttrib1hvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttrib2hNV" );
}

static void REGAL_CALL loader_glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2hNV, "glVertexAttrib2hNV");
   if ( !driverTbl.glVertexAttrib2hNV ) {
      driverTbl.glVertexAttrib2hNV = missing_glVertexAttrib2hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2hNV == loader_glVertexAttrib2hNV) {
      rCtx->dsp.emuTbl.glVertexAttrib2hNV = driverTbl.glVertexAttrib2hNV;
   }
   driverTbl.glVertexAttrib2hNV(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2hvNV(GLuint index, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib2hvNV" );
}

static void REGAL_CALL loader_glVertexAttrib2hvNV(GLuint index, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib2hvNV, "glVertexAttrib2hvNV");
   if ( !driverTbl.glVertexAttrib2hvNV ) {
      driverTbl.glVertexAttrib2hvNV = missing_glVertexAttrib2hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib2hvNV == loader_glVertexAttrib2hvNV) {
      rCtx->dsp.emuTbl.glVertexAttrib2hvNV = driverTbl.glVertexAttrib2hvNV;
   }
   driverTbl.glVertexAttrib2hvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttrib3hNV" );
}

static void REGAL_CALL loader_glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3hNV, "glVertexAttrib3hNV");
   if ( !driverTbl.glVertexAttrib3hNV ) {
      driverTbl.glVertexAttrib3hNV = missing_glVertexAttrib3hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3hNV == loader_glVertexAttrib3hNV) {
      rCtx->dsp.emuTbl.glVertexAttrib3hNV = driverTbl.glVertexAttrib3hNV;
   }
   driverTbl.glVertexAttrib3hNV(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3hvNV(GLuint index, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib3hvNV" );
}

static void REGAL_CALL loader_glVertexAttrib3hvNV(GLuint index, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib3hvNV, "glVertexAttrib3hvNV");
   if ( !driverTbl.glVertexAttrib3hvNV ) {
      driverTbl.glVertexAttrib3hvNV = missing_glVertexAttrib3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib3hvNV == loader_glVertexAttrib3hvNV) {
      rCtx->dsp.emuTbl.glVertexAttrib3hvNV = driverTbl.glVertexAttrib3hvNV;
   }
   driverTbl.glVertexAttrib3hvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttrib4hNV" );
}

static void REGAL_CALL loader_glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4hNV, "glVertexAttrib4hNV");
   if ( !driverTbl.glVertexAttrib4hNV ) {
      driverTbl.glVertexAttrib4hNV = missing_glVertexAttrib4hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4hNV == loader_glVertexAttrib4hNV) {
      rCtx->dsp.emuTbl.glVertexAttrib4hNV = driverTbl.glVertexAttrib4hNV;
   }
   driverTbl.glVertexAttrib4hNV(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4hvNV(GLuint index, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttrib4hvNV" );
}

static void REGAL_CALL loader_glVertexAttrib4hvNV(GLuint index, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttrib4hvNV, "glVertexAttrib4hvNV");
   if ( !driverTbl.glVertexAttrib4hvNV ) {
      driverTbl.glVertexAttrib4hvNV = missing_glVertexAttrib4hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttrib4hvNV == loader_glVertexAttrib4hvNV) {
      rCtx->dsp.emuTbl.glVertexAttrib4hvNV = driverTbl.glVertexAttrib4hvNV;
   }
   driverTbl.glVertexAttrib4hvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribs1hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs1hvNV" );
}

static void REGAL_CALL loader_glVertexAttribs1hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs1hvNV, "glVertexAttribs1hvNV");
   if ( !driverTbl.glVertexAttribs1hvNV ) {
      driverTbl.glVertexAttribs1hvNV = missing_glVertexAttribs1hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs1hvNV == loader_glVertexAttribs1hvNV) {
      rCtx->dsp.emuTbl.glVertexAttribs1hvNV = driverTbl.glVertexAttribs1hvNV;
   }
   driverTbl.glVertexAttribs1hvNV(index, count, v);
}

static void REGAL_CALL missing_glVertexAttribs2hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs2hvNV" );
}

static void REGAL_CALL loader_glVertexAttribs2hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs2hvNV, "glVertexAttribs2hvNV");
   if ( !driverTbl.glVertexAttribs2hvNV ) {
      driverTbl.glVertexAttribs2hvNV = missing_glVertexAttribs2hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs2hvNV == loader_glVertexAttribs2hvNV) {
      rCtx->dsp.emuTbl.glVertexAttribs2hvNV = driverTbl.glVertexAttribs2hvNV;
   }
   driverTbl.glVertexAttribs2hvNV(index, count, v);
}

static void REGAL_CALL missing_glVertexAttribs3hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs3hvNV" );
}

static void REGAL_CALL loader_glVertexAttribs3hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs3hvNV, "glVertexAttribs3hvNV");
   if ( !driverTbl.glVertexAttribs3hvNV ) {
      driverTbl.glVertexAttribs3hvNV = missing_glVertexAttribs3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs3hvNV == loader_glVertexAttribs3hvNV) {
      rCtx->dsp.emuTbl.glVertexAttribs3hvNV = driverTbl.glVertexAttribs3hvNV;
   }
   driverTbl.glVertexAttribs3hvNV(index, count, v);
}

static void REGAL_CALL missing_glVertexAttribs4hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribs4hvNV" );
}

static void REGAL_CALL loader_glVertexAttribs4hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribs4hvNV, "glVertexAttribs4hvNV");
   if ( !driverTbl.glVertexAttribs4hvNV ) {
      driverTbl.glVertexAttribs4hvNV = missing_glVertexAttribs4hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribs4hvNV == loader_glVertexAttribs4hvNV) {
      rCtx->dsp.emuTbl.glVertexAttribs4hvNV = driverTbl.glVertexAttribs4hvNV;
   }
   driverTbl.glVertexAttribs4hvNV(index, count, v);
}

// GL_NV_pixel_data_range

static void REGAL_CALL missing_glPixelDataRangeNV(GLenum target, GLsizei size, const GLvoid *pointer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glPixelDataRangeNV" );
}

static void REGAL_CALL loader_glPixelDataRangeNV(GLenum target, GLsizei size, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPixelDataRangeNV, "glPixelDataRangeNV");
   if ( !driverTbl.glPixelDataRangeNV ) {
      driverTbl.glPixelDataRangeNV = missing_glPixelDataRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPixelDataRangeNV == loader_glPixelDataRangeNV) {
      rCtx->dsp.emuTbl.glPixelDataRangeNV = driverTbl.glPixelDataRangeNV;
   }
   driverTbl.glPixelDataRangeNV(target, size, pointer);
}

static void REGAL_CALL missing_glFlushPixelDataRangeNV(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glFlushPixelDataRangeNV" );
}

static void REGAL_CALL loader_glFlushPixelDataRangeNV(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFlushPixelDataRangeNV, "glFlushPixelDataRangeNV");
   if ( !driverTbl.glFlushPixelDataRangeNV ) {
      driverTbl.glFlushPixelDataRangeNV = missing_glFlushPixelDataRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFlushPixelDataRangeNV == loader_glFlushPixelDataRangeNV) {
      rCtx->dsp.emuTbl.glFlushPixelDataRangeNV = driverTbl.glFlushPixelDataRangeNV;
   }
   driverTbl.glFlushPixelDataRangeNV(target);
}

// GL_NV_primitive_restart

static void REGAL_CALL missing_glPrimitiveRestartNV(void)
{
   Warning( "Called missing function glPrimitiveRestartNV" );
}

static void REGAL_CALL loader_glPrimitiveRestartNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPrimitiveRestartNV, "glPrimitiveRestartNV");
   if ( !driverTbl.glPrimitiveRestartNV ) {
      driverTbl.glPrimitiveRestartNV = missing_glPrimitiveRestartNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPrimitiveRestartNV == loader_glPrimitiveRestartNV) {
      rCtx->dsp.emuTbl.glPrimitiveRestartNV = driverTbl.glPrimitiveRestartNV;
   }
   driverTbl.glPrimitiveRestartNV();
}

static void REGAL_CALL missing_glPrimitiveRestartIndexNV(GLuint index)
{
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glPrimitiveRestartIndexNV" );
}

static void REGAL_CALL loader_glPrimitiveRestartIndexNV(GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPrimitiveRestartIndexNV, "glPrimitiveRestartIndexNV");
   if ( !driverTbl.glPrimitiveRestartIndexNV ) {
      driverTbl.glPrimitiveRestartIndexNV = missing_glPrimitiveRestartIndexNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPrimitiveRestartIndexNV == loader_glPrimitiveRestartIndexNV) {
      rCtx->dsp.emuTbl.glPrimitiveRestartIndexNV = driverTbl.glPrimitiveRestartIndexNV;
   }
   driverTbl.glPrimitiveRestartIndexNV(index);
}

// GL_ATI_map_object_buffer

static GLvoid *REGAL_CALL missing_glMapObjectBufferATI(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glMapObjectBufferATI" );
  GLvoid * ret = NULL;
  return ret;
}

static GLvoid *REGAL_CALL loader_glMapObjectBufferATI(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapObjectBufferATI, "glMapObjectBufferATI");
   if ( !driverTbl.glMapObjectBufferATI ) {
      driverTbl.glMapObjectBufferATI = missing_glMapObjectBufferATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapObjectBufferATI == loader_glMapObjectBufferATI) {
      rCtx->dsp.emuTbl.glMapObjectBufferATI = driverTbl.glMapObjectBufferATI;
   }
   return driverTbl.glMapObjectBufferATI(buffer);
}

static void REGAL_CALL missing_glUnmapObjectBufferATI(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glUnmapObjectBufferATI" );
}

static void REGAL_CALL loader_glUnmapObjectBufferATI(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUnmapObjectBufferATI, "glUnmapObjectBufferATI");
   if ( !driverTbl.glUnmapObjectBufferATI ) {
      driverTbl.glUnmapObjectBufferATI = missing_glUnmapObjectBufferATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUnmapObjectBufferATI == loader_glUnmapObjectBufferATI) {
      rCtx->dsp.emuTbl.glUnmapObjectBufferATI = driverTbl.glUnmapObjectBufferATI;
   }
   driverTbl.glUnmapObjectBufferATI(buffer);
}

// GL_ATI_separate_stencil

static void REGAL_CALL missing_glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(sfail);
   UNUSED_PARAMETER(dpfail);
   UNUSED_PARAMETER(dppass);
   Warning( "Called missing function glStencilOpSeparateATI" );
}

static void REGAL_CALL loader_glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStencilOpSeparateATI, "glStencilOpSeparateATI");
   if ( !driverTbl.glStencilOpSeparateATI ) {
      driverTbl.glStencilOpSeparateATI = missing_glStencilOpSeparateATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStencilOpSeparateATI == loader_glStencilOpSeparateATI) {
      rCtx->dsp.emuTbl.glStencilOpSeparateATI = driverTbl.glStencilOpSeparateATI;
   }
   driverTbl.glStencilOpSeparateATI(face, sfail, dpfail, dppass);
}

static void REGAL_CALL missing_glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
{
   UNUSED_PARAMETER(frontfunc);
   UNUSED_PARAMETER(backfunc);
   UNUSED_PARAMETER(ref);
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glStencilFuncSeparateATI" );
}

static void REGAL_CALL loader_glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStencilFuncSeparateATI, "glStencilFuncSeparateATI");
   if ( !driverTbl.glStencilFuncSeparateATI ) {
      driverTbl.glStencilFuncSeparateATI = missing_glStencilFuncSeparateATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStencilFuncSeparateATI == loader_glStencilFuncSeparateATI) {
      rCtx->dsp.emuTbl.glStencilFuncSeparateATI = driverTbl.glStencilFuncSeparateATI;
   }
   driverTbl.glStencilFuncSeparateATI(frontfunc, backfunc, ref, mask);
}

// GL_ATI_vertex_attrib_array_object

static void REGAL_CALL missing_glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   Warning( "Called missing function glVertexAttribArrayObjectATI" );
}

static void REGAL_CALL loader_glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribArrayObjectATI, "glVertexAttribArrayObjectATI");
   if ( !driverTbl.glVertexAttribArrayObjectATI ) {
      driverTbl.glVertexAttribArrayObjectATI = missing_glVertexAttribArrayObjectATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribArrayObjectATI == loader_glVertexAttribArrayObjectATI) {
      rCtx->dsp.emuTbl.glVertexAttribArrayObjectATI = driverTbl.glVertexAttribArrayObjectATI;
   }
   driverTbl.glVertexAttribArrayObjectATI(index, size, type, normalized, stride, buffer, offset);
}

static void REGAL_CALL missing_glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribArrayObjectfvATI" );
}

static void REGAL_CALL loader_glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribArrayObjectfvATI, "glGetVertexAttribArrayObjectfvATI");
   if ( !driverTbl.glGetVertexAttribArrayObjectfvATI ) {
      driverTbl.glGetVertexAttribArrayObjectfvATI = missing_glGetVertexAttribArrayObjectfvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribArrayObjectfvATI == loader_glGetVertexAttribArrayObjectfvATI) {
      rCtx->dsp.emuTbl.glGetVertexAttribArrayObjectfvATI = driverTbl.glGetVertexAttribArrayObjectfvATI;
   }
   driverTbl.glGetVertexAttribArrayObjectfvATI(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribArrayObjectivATI" );
}

static void REGAL_CALL loader_glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribArrayObjectivATI, "glGetVertexAttribArrayObjectivATI");
   if ( !driverTbl.glGetVertexAttribArrayObjectivATI ) {
      driverTbl.glGetVertexAttribArrayObjectivATI = missing_glGetVertexAttribArrayObjectivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribArrayObjectivATI == loader_glGetVertexAttribArrayObjectivATI) {
      rCtx->dsp.emuTbl.glGetVertexAttribArrayObjectivATI = driverTbl.glGetVertexAttribArrayObjectivATI;
   }
   driverTbl.glGetVertexAttribArrayObjectivATI(index, pname, params);
}

// GL_EXT_depth_bounds_test

static void REGAL_CALL missing_glDepthBoundsEXT(GLclampd zmin, GLclampd zmax)
{
   UNUSED_PARAMETER(zmin);
   UNUSED_PARAMETER(zmax);
   Warning( "Called missing function glDepthBoundsEXT" );
}

static void REGAL_CALL loader_glDepthBoundsEXT(GLclampd zmin, GLclampd zmax)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDepthBoundsEXT, "glDepthBoundsEXT");
   if ( !driverTbl.glDepthBoundsEXT ) {
      driverTbl.glDepthBoundsEXT = missing_glDepthBoundsEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDepthBoundsEXT == loader_glDepthBoundsEXT) {
      rCtx->dsp.emuTbl.glDepthBoundsEXT = driverTbl.glDepthBoundsEXT;
   }
   driverTbl.glDepthBoundsEXT(zmin, zmax);
}

// GL_EXT_blend_equation_separate

static void REGAL_CALL missing_glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha)
{
   UNUSED_PARAMETER(modeRGB);
   UNUSED_PARAMETER(modeAlpha);
   Warning( "Called missing function glBlendEquationSeparateEXT" );
}

static void REGAL_CALL loader_glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendEquationSeparateEXT, "glBlendEquationSeparateEXT");
   if ( !driverTbl.glBlendEquationSeparateEXT ) {
      driverTbl.glBlendEquationSeparateEXT = missing_glBlendEquationSeparateEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendEquationSeparateEXT == loader_glBlendEquationSeparateEXT) {
      rCtx->dsp.emuTbl.glBlendEquationSeparateEXT = driverTbl.glBlendEquationSeparateEXT;
   }
   driverTbl.glBlendEquationSeparateEXT(modeRGB, modeAlpha);
}

// GL_EXT_framebuffer_object

static GLboolean REGAL_CALL missing_glIsRenderbufferEXT(GLuint renderbuffer)
{
   UNUSED_PARAMETER(renderbuffer);
   Warning( "Called missing function glIsRenderbufferEXT" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsRenderbufferEXT(GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsRenderbufferEXT, "glIsRenderbufferEXT");
   if ( !driverTbl.glIsRenderbufferEXT ) {
      driverTbl.glIsRenderbufferEXT = missing_glIsRenderbufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsRenderbufferEXT == loader_glIsRenderbufferEXT) {
      rCtx->dsp.emuTbl.glIsRenderbufferEXT = driverTbl.glIsRenderbufferEXT;
   }
   return driverTbl.glIsRenderbufferEXT(renderbuffer);
}

static void REGAL_CALL missing_glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "Called missing function glBindRenderbufferEXT" );
}

static void REGAL_CALL loader_glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindRenderbufferEXT, "glBindRenderbufferEXT");
   if ( !driverTbl.glBindRenderbufferEXT ) {
      driverTbl.glBindRenderbufferEXT = missing_glBindRenderbufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindRenderbufferEXT == loader_glBindRenderbufferEXT) {
      rCtx->dsp.emuTbl.glBindRenderbufferEXT = driverTbl.glBindRenderbufferEXT;
   }
   driverTbl.glBindRenderbufferEXT(target, renderbuffer);
}

static void REGAL_CALL missing_glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(renderbuffers);
   Warning( "Called missing function glDeleteRenderbuffersEXT" );
}

static void REGAL_CALL loader_glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteRenderbuffersEXT, "glDeleteRenderbuffersEXT");
   if ( !driverTbl.glDeleteRenderbuffersEXT ) {
      driverTbl.glDeleteRenderbuffersEXT = missing_glDeleteRenderbuffersEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteRenderbuffersEXT == loader_glDeleteRenderbuffersEXT) {
      rCtx->dsp.emuTbl.glDeleteRenderbuffersEXT = driverTbl.glDeleteRenderbuffersEXT;
   }
   driverTbl.glDeleteRenderbuffersEXT(n, renderbuffers);
}

static void REGAL_CALL missing_glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(renderbuffers);
   Warning( "Called missing function glGenRenderbuffersEXT" );
}

static void REGAL_CALL loader_glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenRenderbuffersEXT, "glGenRenderbuffersEXT");
   if ( !driverTbl.glGenRenderbuffersEXT ) {
      driverTbl.glGenRenderbuffersEXT = missing_glGenRenderbuffersEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenRenderbuffersEXT == loader_glGenRenderbuffersEXT) {
      rCtx->dsp.emuTbl.glGenRenderbuffersEXT = driverTbl.glGenRenderbuffersEXT;
   }
   driverTbl.glGenRenderbuffersEXT(n, renderbuffers);
}

static void REGAL_CALL missing_glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glRenderbufferStorageEXT" );
}

static void REGAL_CALL loader_glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRenderbufferStorageEXT, "glRenderbufferStorageEXT");
   if ( !driverTbl.glRenderbufferStorageEXT ) {
      driverTbl.glRenderbufferStorageEXT = missing_glRenderbufferStorageEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRenderbufferStorageEXT == loader_glRenderbufferStorageEXT) {
      rCtx->dsp.emuTbl.glRenderbufferStorageEXT = driverTbl.glRenderbufferStorageEXT;
   }
   driverTbl.glRenderbufferStorageEXT(target, internalformat, width, height);
}

static void REGAL_CALL missing_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetRenderbufferParameterivEXT" );
}

static void REGAL_CALL loader_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetRenderbufferParameterivEXT, "glGetRenderbufferParameterivEXT");
   if ( !driverTbl.glGetRenderbufferParameterivEXT ) {
      driverTbl.glGetRenderbufferParameterivEXT = missing_glGetRenderbufferParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetRenderbufferParameterivEXT == loader_glGetRenderbufferParameterivEXT) {
      rCtx->dsp.emuTbl.glGetRenderbufferParameterivEXT = driverTbl.glGetRenderbufferParameterivEXT;
   }
   driverTbl.glGetRenderbufferParameterivEXT(target, pname, params);
}

static GLboolean REGAL_CALL missing_glIsFramebufferEXT(GLuint framebuffer)
{
   UNUSED_PARAMETER(framebuffer);
   Warning( "Called missing function glIsFramebufferEXT" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsFramebufferEXT(GLuint framebuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsFramebufferEXT, "glIsFramebufferEXT");
   if ( !driverTbl.glIsFramebufferEXT ) {
      driverTbl.glIsFramebufferEXT = missing_glIsFramebufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsFramebufferEXT == loader_glIsFramebufferEXT) {
      rCtx->dsp.emuTbl.glIsFramebufferEXT = driverTbl.glIsFramebufferEXT;
   }
   return driverTbl.glIsFramebufferEXT(framebuffer);
}

static void REGAL_CALL missing_glBindFramebufferEXT(GLenum target, GLuint framebuffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(framebuffer);
   Warning( "Called missing function glBindFramebufferEXT" );
}

static void REGAL_CALL loader_glBindFramebufferEXT(GLenum target, GLuint framebuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindFramebufferEXT, "glBindFramebufferEXT");
   if ( !driverTbl.glBindFramebufferEXT ) {
      driverTbl.glBindFramebufferEXT = missing_glBindFramebufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindFramebufferEXT == loader_glBindFramebufferEXT) {
      rCtx->dsp.emuTbl.glBindFramebufferEXT = driverTbl.glBindFramebufferEXT;
   }
   driverTbl.glBindFramebufferEXT(target, framebuffer);
}

static void REGAL_CALL missing_glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(framebuffers);
   Warning( "Called missing function glDeleteFramebuffersEXT" );
}

static void REGAL_CALL loader_glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteFramebuffersEXT, "glDeleteFramebuffersEXT");
   if ( !driverTbl.glDeleteFramebuffersEXT ) {
      driverTbl.glDeleteFramebuffersEXT = missing_glDeleteFramebuffersEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteFramebuffersEXT == loader_glDeleteFramebuffersEXT) {
      rCtx->dsp.emuTbl.glDeleteFramebuffersEXT = driverTbl.glDeleteFramebuffersEXT;
   }
   driverTbl.glDeleteFramebuffersEXT(n, framebuffers);
}

static void REGAL_CALL missing_glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(framebuffers);
   Warning( "Called missing function glGenFramebuffersEXT" );
}

static void REGAL_CALL loader_glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenFramebuffersEXT, "glGenFramebuffersEXT");
   if ( !driverTbl.glGenFramebuffersEXT ) {
      driverTbl.glGenFramebuffersEXT = missing_glGenFramebuffersEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenFramebuffersEXT == loader_glGenFramebuffersEXT) {
      rCtx->dsp.emuTbl.glGenFramebuffersEXT = driverTbl.glGenFramebuffersEXT;
   }
   driverTbl.glGenFramebuffersEXT(n, framebuffers);
}

static GLenum REGAL_CALL missing_glCheckFramebufferStatusEXT(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glCheckFramebufferStatusEXT" );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glCheckFramebufferStatusEXT(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCheckFramebufferStatusEXT, "glCheckFramebufferStatusEXT");
   if ( !driverTbl.glCheckFramebufferStatusEXT ) {
      driverTbl.glCheckFramebufferStatusEXT = missing_glCheckFramebufferStatusEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCheckFramebufferStatusEXT == loader_glCheckFramebufferStatusEXT) {
      rCtx->dsp.emuTbl.glCheckFramebufferStatusEXT = driverTbl.glCheckFramebufferStatusEXT;
   }
   return driverTbl.glCheckFramebufferStatusEXT(target);
}

static void REGAL_CALL missing_glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "Called missing function glFramebufferTexture1DEXT" );
}

static void REGAL_CALL loader_glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTexture1DEXT, "glFramebufferTexture1DEXT");
   if ( !driverTbl.glFramebufferTexture1DEXT ) {
      driverTbl.glFramebufferTexture1DEXT = missing_glFramebufferTexture1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTexture1DEXT == loader_glFramebufferTexture1DEXT) {
      rCtx->dsp.emuTbl.glFramebufferTexture1DEXT = driverTbl.glFramebufferTexture1DEXT;
   }
   driverTbl.glFramebufferTexture1DEXT(target, attachment, textarget, texture, level);
}

static void REGAL_CALL missing_glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "Called missing function glFramebufferTexture2DEXT" );
}

static void REGAL_CALL loader_glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTexture2DEXT, "glFramebufferTexture2DEXT");
   if ( !driverTbl.glFramebufferTexture2DEXT ) {
      driverTbl.glFramebufferTexture2DEXT = missing_glFramebufferTexture2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTexture2DEXT == loader_glFramebufferTexture2DEXT) {
      rCtx->dsp.emuTbl.glFramebufferTexture2DEXT = driverTbl.glFramebufferTexture2DEXT;
   }
   driverTbl.glFramebufferTexture2DEXT(target, attachment, textarget, texture, level);
}

static void REGAL_CALL missing_glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(zoffset);
   Warning( "Called missing function glFramebufferTexture3DEXT" );
}

static void REGAL_CALL loader_glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTexture3DEXT, "glFramebufferTexture3DEXT");
   if ( !driverTbl.glFramebufferTexture3DEXT ) {
      driverTbl.glFramebufferTexture3DEXT = missing_glFramebufferTexture3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTexture3DEXT == loader_glFramebufferTexture3DEXT) {
      rCtx->dsp.emuTbl.glFramebufferTexture3DEXT = driverTbl.glFramebufferTexture3DEXT;
   }
   driverTbl.glFramebufferTexture3DEXT(target, attachment, textarget, texture, level, zoffset);
}

static void REGAL_CALL missing_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(renderbuffertarget);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "Called missing function glFramebufferRenderbufferEXT" );
}

static void REGAL_CALL loader_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferRenderbufferEXT, "glFramebufferRenderbufferEXT");
   if ( !driverTbl.glFramebufferRenderbufferEXT ) {
      driverTbl.glFramebufferRenderbufferEXT = missing_glFramebufferRenderbufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferRenderbufferEXT == loader_glFramebufferRenderbufferEXT) {
      rCtx->dsp.emuTbl.glFramebufferRenderbufferEXT = driverTbl.glFramebufferRenderbufferEXT;
   }
   driverTbl.glFramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);
}

static void REGAL_CALL missing_glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFramebufferAttachmentParameterivEXT" );
}

static void REGAL_CALL loader_glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFramebufferAttachmentParameterivEXT, "glGetFramebufferAttachmentParameterivEXT");
   if ( !driverTbl.glGetFramebufferAttachmentParameterivEXT ) {
      driverTbl.glGetFramebufferAttachmentParameterivEXT = missing_glGetFramebufferAttachmentParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFramebufferAttachmentParameterivEXT == loader_glGetFramebufferAttachmentParameterivEXT) {
      rCtx->dsp.emuTbl.glGetFramebufferAttachmentParameterivEXT = driverTbl.glGetFramebufferAttachmentParameterivEXT;
   }
   driverTbl.glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, params);
}

static void REGAL_CALL missing_glGenerateMipmapEXT(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glGenerateMipmapEXT" );
}

static void REGAL_CALL loader_glGenerateMipmapEXT(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenerateMipmapEXT, "glGenerateMipmapEXT");
   if ( !driverTbl.glGenerateMipmapEXT ) {
      driverTbl.glGenerateMipmapEXT = missing_glGenerateMipmapEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenerateMipmapEXT == loader_glGenerateMipmapEXT) {
      rCtx->dsp.emuTbl.glGenerateMipmapEXT = driverTbl.glGenerateMipmapEXT;
   }
   driverTbl.glGenerateMipmapEXT(target);
}

// GL_GREMEDY_string_marker

static void REGAL_CALL missing_glStringMarkerGREMEDY(GLsizei len, const GLvoid *string)
{
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(string);
   Warning( "Called missing function glStringMarkerGREMEDY" );
}

static void REGAL_CALL loader_glStringMarkerGREMEDY(GLsizei len, const GLvoid *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStringMarkerGREMEDY, "glStringMarkerGREMEDY");
   if ( !driverTbl.glStringMarkerGREMEDY ) {
      driverTbl.glStringMarkerGREMEDY = missing_glStringMarkerGREMEDY;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStringMarkerGREMEDY == loader_glStringMarkerGREMEDY) {
      rCtx->dsp.emuTbl.glStringMarkerGREMEDY = driverTbl.glStringMarkerGREMEDY;
   }
   driverTbl.glStringMarkerGREMEDY(len, string);
}

// GL_EXT_stencil_clear_tag

static void REGAL_CALL missing_glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag)
{
   UNUSED_PARAMETER(stencilTagBits);
   UNUSED_PARAMETER(stencilClearTag);
   Warning( "Called missing function glStencilClearTagEXT" );
}

static void REGAL_CALL loader_glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStencilClearTagEXT, "glStencilClearTagEXT");
   if ( !driverTbl.glStencilClearTagEXT ) {
      driverTbl.glStencilClearTagEXT = missing_glStencilClearTagEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStencilClearTagEXT == loader_glStencilClearTagEXT) {
      rCtx->dsp.emuTbl.glStencilClearTagEXT = driverTbl.glStencilClearTagEXT;
   }
   driverTbl.glStencilClearTagEXT(stencilTagBits, stencilClearTag);
}

// GL_EXT_framebuffer_blit

static void REGAL_CALL missing_glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
   UNUSED_PARAMETER(srcX0);
   UNUSED_PARAMETER(srcY0);
   UNUSED_PARAMETER(srcX1);
   UNUSED_PARAMETER(srcY1);
   UNUSED_PARAMETER(dstX0);
   UNUSED_PARAMETER(dstY0);
   UNUSED_PARAMETER(dstX1);
   UNUSED_PARAMETER(dstY1);
   UNUSED_PARAMETER(mask);
   UNUSED_PARAMETER(filter);
   Warning( "Called missing function glBlitFramebufferEXT" );
}

static void REGAL_CALL loader_glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlitFramebufferEXT, "glBlitFramebufferEXT");
   if ( !driverTbl.glBlitFramebufferEXT ) {
      driverTbl.glBlitFramebufferEXT = missing_glBlitFramebufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlitFramebufferEXT == loader_glBlitFramebufferEXT) {
      rCtx->dsp.emuTbl.glBlitFramebufferEXT = driverTbl.glBlitFramebufferEXT;
   }
   driverTbl.glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

// GL_EXT_framebuffer_multisample

static void REGAL_CALL missing_glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glRenderbufferStorageMultisampleEXT" );
}

static void REGAL_CALL loader_glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRenderbufferStorageMultisampleEXT, "glRenderbufferStorageMultisampleEXT");
   if ( !driverTbl.glRenderbufferStorageMultisampleEXT ) {
      driverTbl.glRenderbufferStorageMultisampleEXT = missing_glRenderbufferStorageMultisampleEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRenderbufferStorageMultisampleEXT == loader_glRenderbufferStorageMultisampleEXT) {
      rCtx->dsp.emuTbl.glRenderbufferStorageMultisampleEXT = driverTbl.glRenderbufferStorageMultisampleEXT;
   }
   driverTbl.glRenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height);
}

// GL_EXT_timer_query

static void REGAL_CALL missing_glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetQueryObjecti64vEXT" );
}

static void REGAL_CALL loader_glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetQueryObjecti64vEXT, "glGetQueryObjecti64vEXT");
   if ( !driverTbl.glGetQueryObjecti64vEXT ) {
      driverTbl.glGetQueryObjecti64vEXT = missing_glGetQueryObjecti64vEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetQueryObjecti64vEXT == loader_glGetQueryObjecti64vEXT) {
      rCtx->dsp.emuTbl.glGetQueryObjecti64vEXT = driverTbl.glGetQueryObjecti64vEXT;
   }
   driverTbl.glGetQueryObjecti64vEXT(id, pname, params);
}

static void REGAL_CALL missing_glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetQueryObjectui64vEXT" );
}

static void REGAL_CALL loader_glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetQueryObjectui64vEXT, "glGetQueryObjectui64vEXT");
   if ( !driverTbl.glGetQueryObjectui64vEXT ) {
      driverTbl.glGetQueryObjectui64vEXT = missing_glGetQueryObjectui64vEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetQueryObjectui64vEXT == loader_glGetQueryObjectui64vEXT) {
      rCtx->dsp.emuTbl.glGetQueryObjectui64vEXT = driverTbl.glGetQueryObjectui64vEXT;
   }
   driverTbl.glGetQueryObjectui64vEXT(id, pname, params);
}

// GL_EXT_gpu_program_parameters

static void REGAL_CALL missing_glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramEnvParameters4fvEXT" );
}

static void REGAL_CALL loader_glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramEnvParameters4fvEXT, "glProgramEnvParameters4fvEXT");
   if ( !driverTbl.glProgramEnvParameters4fvEXT ) {
      driverTbl.glProgramEnvParameters4fvEXT = missing_glProgramEnvParameters4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramEnvParameters4fvEXT == loader_glProgramEnvParameters4fvEXT) {
      rCtx->dsp.emuTbl.glProgramEnvParameters4fvEXT = driverTbl.glProgramEnvParameters4fvEXT;
   }
   driverTbl.glProgramEnvParameters4fvEXT(target, index, count, params);
}

static void REGAL_CALL missing_glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramLocalParameters4fvEXT" );
}

static void REGAL_CALL loader_glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramLocalParameters4fvEXT, "glProgramLocalParameters4fvEXT");
   if ( !driverTbl.glProgramLocalParameters4fvEXT ) {
      driverTbl.glProgramLocalParameters4fvEXT = missing_glProgramLocalParameters4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramLocalParameters4fvEXT == loader_glProgramLocalParameters4fvEXT) {
      rCtx->dsp.emuTbl.glProgramLocalParameters4fvEXT = driverTbl.glProgramLocalParameters4fvEXT;
   }
   driverTbl.glProgramLocalParameters4fvEXT(target, index, count, params);
}

// GL_APPLE_flush_buffer_range

static void REGAL_CALL missing_glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glBufferParameteriAPPLE" );
}

static void REGAL_CALL loader_glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBufferParameteriAPPLE, "glBufferParameteriAPPLE");
   if ( !driverTbl.glBufferParameteriAPPLE ) {
      driverTbl.glBufferParameteriAPPLE = missing_glBufferParameteriAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBufferParameteriAPPLE == loader_glBufferParameteriAPPLE) {
      rCtx->dsp.emuTbl.glBufferParameteriAPPLE = driverTbl.glBufferParameteriAPPLE;
   }
   driverTbl.glBufferParameteriAPPLE(target, pname, param);
}

static void REGAL_CALL missing_glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   Warning( "Called missing function glFlushMappedBufferRangeAPPLE" );
}

static void REGAL_CALL loader_glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFlushMappedBufferRangeAPPLE, "glFlushMappedBufferRangeAPPLE");
   if ( !driverTbl.glFlushMappedBufferRangeAPPLE ) {
      driverTbl.glFlushMappedBufferRangeAPPLE = missing_glFlushMappedBufferRangeAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFlushMappedBufferRangeAPPLE == loader_glFlushMappedBufferRangeAPPLE) {
      rCtx->dsp.emuTbl.glFlushMappedBufferRangeAPPLE = driverTbl.glFlushMappedBufferRangeAPPLE;
   }
   driverTbl.glFlushMappedBufferRangeAPPLE(target, offset, size);
}

// GL_NV_gpu_program4

static void REGAL_CALL missing_glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramLocalParameterI4iNV" );
}

static void REGAL_CALL loader_glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramLocalParameterI4iNV, "glProgramLocalParameterI4iNV");
   if ( !driverTbl.glProgramLocalParameterI4iNV ) {
      driverTbl.glProgramLocalParameterI4iNV = missing_glProgramLocalParameterI4iNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramLocalParameterI4iNV == loader_glProgramLocalParameterI4iNV) {
      rCtx->dsp.emuTbl.glProgramLocalParameterI4iNV = driverTbl.glProgramLocalParameterI4iNV;
   }
   driverTbl.glProgramLocalParameterI4iNV(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramLocalParameterI4ivNV" );
}

static void REGAL_CALL loader_glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramLocalParameterI4ivNV, "glProgramLocalParameterI4ivNV");
   if ( !driverTbl.glProgramLocalParameterI4ivNV ) {
      driverTbl.glProgramLocalParameterI4ivNV = missing_glProgramLocalParameterI4ivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramLocalParameterI4ivNV == loader_glProgramLocalParameterI4ivNV) {
      rCtx->dsp.emuTbl.glProgramLocalParameterI4ivNV = driverTbl.glProgramLocalParameterI4ivNV;
   }
   driverTbl.glProgramLocalParameterI4ivNV(target, index, params);
}

static void REGAL_CALL missing_glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramLocalParametersI4ivNV" );
}

static void REGAL_CALL loader_glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramLocalParametersI4ivNV, "glProgramLocalParametersI4ivNV");
   if ( !driverTbl.glProgramLocalParametersI4ivNV ) {
      driverTbl.glProgramLocalParametersI4ivNV = missing_glProgramLocalParametersI4ivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramLocalParametersI4ivNV == loader_glProgramLocalParametersI4ivNV) {
      rCtx->dsp.emuTbl.glProgramLocalParametersI4ivNV = driverTbl.glProgramLocalParametersI4ivNV;
   }
   driverTbl.glProgramLocalParametersI4ivNV(target, index, count, params);
}

static void REGAL_CALL missing_glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramLocalParameterI4uiNV" );
}

static void REGAL_CALL loader_glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramLocalParameterI4uiNV, "glProgramLocalParameterI4uiNV");
   if ( !driverTbl.glProgramLocalParameterI4uiNV ) {
      driverTbl.glProgramLocalParameterI4uiNV = missing_glProgramLocalParameterI4uiNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramLocalParameterI4uiNV == loader_glProgramLocalParameterI4uiNV) {
      rCtx->dsp.emuTbl.glProgramLocalParameterI4uiNV = driverTbl.glProgramLocalParameterI4uiNV;
   }
   driverTbl.glProgramLocalParameterI4uiNV(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramLocalParameterI4uivNV" );
}

static void REGAL_CALL loader_glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramLocalParameterI4uivNV, "glProgramLocalParameterI4uivNV");
   if ( !driverTbl.glProgramLocalParameterI4uivNV ) {
      driverTbl.glProgramLocalParameterI4uivNV = missing_glProgramLocalParameterI4uivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramLocalParameterI4uivNV == loader_glProgramLocalParameterI4uivNV) {
      rCtx->dsp.emuTbl.glProgramLocalParameterI4uivNV = driverTbl.glProgramLocalParameterI4uivNV;
   }
   driverTbl.glProgramLocalParameterI4uivNV(target, index, params);
}

static void REGAL_CALL missing_glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramLocalParametersI4uivNV" );
}

static void REGAL_CALL loader_glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramLocalParametersI4uivNV, "glProgramLocalParametersI4uivNV");
   if ( !driverTbl.glProgramLocalParametersI4uivNV ) {
      driverTbl.glProgramLocalParametersI4uivNV = missing_glProgramLocalParametersI4uivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramLocalParametersI4uivNV == loader_glProgramLocalParametersI4uivNV) {
      rCtx->dsp.emuTbl.glProgramLocalParametersI4uivNV = driverTbl.glProgramLocalParametersI4uivNV;
   }
   driverTbl.glProgramLocalParametersI4uivNV(target, index, count, params);
}

static void REGAL_CALL missing_glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramEnvParameterI4iNV" );
}

static void REGAL_CALL loader_glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramEnvParameterI4iNV, "glProgramEnvParameterI4iNV");
   if ( !driverTbl.glProgramEnvParameterI4iNV ) {
      driverTbl.glProgramEnvParameterI4iNV = missing_glProgramEnvParameterI4iNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramEnvParameterI4iNV == loader_glProgramEnvParameterI4iNV) {
      rCtx->dsp.emuTbl.glProgramEnvParameterI4iNV = driverTbl.glProgramEnvParameterI4iNV;
   }
   driverTbl.glProgramEnvParameterI4iNV(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramEnvParameterI4ivNV" );
}

static void REGAL_CALL loader_glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramEnvParameterI4ivNV, "glProgramEnvParameterI4ivNV");
   if ( !driverTbl.glProgramEnvParameterI4ivNV ) {
      driverTbl.glProgramEnvParameterI4ivNV = missing_glProgramEnvParameterI4ivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramEnvParameterI4ivNV == loader_glProgramEnvParameterI4ivNV) {
      rCtx->dsp.emuTbl.glProgramEnvParameterI4ivNV = driverTbl.glProgramEnvParameterI4ivNV;
   }
   driverTbl.glProgramEnvParameterI4ivNV(target, index, params);
}

static void REGAL_CALL missing_glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramEnvParametersI4ivNV" );
}

static void REGAL_CALL loader_glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramEnvParametersI4ivNV, "glProgramEnvParametersI4ivNV");
   if ( !driverTbl.glProgramEnvParametersI4ivNV ) {
      driverTbl.glProgramEnvParametersI4ivNV = missing_glProgramEnvParametersI4ivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramEnvParametersI4ivNV == loader_glProgramEnvParametersI4ivNV) {
      rCtx->dsp.emuTbl.glProgramEnvParametersI4ivNV = driverTbl.glProgramEnvParametersI4ivNV;
   }
   driverTbl.glProgramEnvParametersI4ivNV(target, index, count, params);
}

static void REGAL_CALL missing_glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramEnvParameterI4uiNV" );
}

static void REGAL_CALL loader_glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramEnvParameterI4uiNV, "glProgramEnvParameterI4uiNV");
   if ( !driverTbl.glProgramEnvParameterI4uiNV ) {
      driverTbl.glProgramEnvParameterI4uiNV = missing_glProgramEnvParameterI4uiNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramEnvParameterI4uiNV == loader_glProgramEnvParameterI4uiNV) {
      rCtx->dsp.emuTbl.glProgramEnvParameterI4uiNV = driverTbl.glProgramEnvParameterI4uiNV;
   }
   driverTbl.glProgramEnvParameterI4uiNV(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramEnvParameterI4uivNV" );
}

static void REGAL_CALL loader_glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramEnvParameterI4uivNV, "glProgramEnvParameterI4uivNV");
   if ( !driverTbl.glProgramEnvParameterI4uivNV ) {
      driverTbl.glProgramEnvParameterI4uivNV = missing_glProgramEnvParameterI4uivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramEnvParameterI4uivNV == loader_glProgramEnvParameterI4uivNV) {
      rCtx->dsp.emuTbl.glProgramEnvParameterI4uivNV = driverTbl.glProgramEnvParameterI4uivNV;
   }
   driverTbl.glProgramEnvParameterI4uivNV(target, index, params);
}

static void REGAL_CALL missing_glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramEnvParametersI4uivNV" );
}

static void REGAL_CALL loader_glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramEnvParametersI4uivNV, "glProgramEnvParametersI4uivNV");
   if ( !driverTbl.glProgramEnvParametersI4uivNV ) {
      driverTbl.glProgramEnvParametersI4uivNV = missing_glProgramEnvParametersI4uivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramEnvParametersI4uivNV == loader_glProgramEnvParametersI4uivNV) {
      rCtx->dsp.emuTbl.glProgramEnvParametersI4uivNV = driverTbl.glProgramEnvParametersI4uivNV;
   }
   driverTbl.glProgramEnvParametersI4uivNV(target, index, count, params);
}

static void REGAL_CALL missing_glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramLocalParameterIivNV" );
}

static void REGAL_CALL loader_glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramLocalParameterIivNV, "glGetProgramLocalParameterIivNV");
   if ( !driverTbl.glGetProgramLocalParameterIivNV ) {
      driverTbl.glGetProgramLocalParameterIivNV = missing_glGetProgramLocalParameterIivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramLocalParameterIivNV == loader_glGetProgramLocalParameterIivNV) {
      rCtx->dsp.emuTbl.glGetProgramLocalParameterIivNV = driverTbl.glGetProgramLocalParameterIivNV;
   }
   driverTbl.glGetProgramLocalParameterIivNV(target, index, params);
}

static void REGAL_CALL missing_glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramLocalParameterIuivNV" );
}

static void REGAL_CALL loader_glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramLocalParameterIuivNV, "glGetProgramLocalParameterIuivNV");
   if ( !driverTbl.glGetProgramLocalParameterIuivNV ) {
      driverTbl.glGetProgramLocalParameterIuivNV = missing_glGetProgramLocalParameterIuivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramLocalParameterIuivNV == loader_glGetProgramLocalParameterIuivNV) {
      rCtx->dsp.emuTbl.glGetProgramLocalParameterIuivNV = driverTbl.glGetProgramLocalParameterIuivNV;
   }
   driverTbl.glGetProgramLocalParameterIuivNV(target, index, params);
}

static void REGAL_CALL missing_glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramEnvParameterIivNV" );
}

static void REGAL_CALL loader_glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramEnvParameterIivNV, "glGetProgramEnvParameterIivNV");
   if ( !driverTbl.glGetProgramEnvParameterIivNV ) {
      driverTbl.glGetProgramEnvParameterIivNV = missing_glGetProgramEnvParameterIivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramEnvParameterIivNV == loader_glGetProgramEnvParameterIivNV) {
      rCtx->dsp.emuTbl.glGetProgramEnvParameterIivNV = driverTbl.glGetProgramEnvParameterIivNV;
   }
   driverTbl.glGetProgramEnvParameterIivNV(target, index, params);
}

static void REGAL_CALL missing_glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetProgramEnvParameterIuivNV" );
}

static void REGAL_CALL loader_glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetProgramEnvParameterIuivNV, "glGetProgramEnvParameterIuivNV");
   if ( !driverTbl.glGetProgramEnvParameterIuivNV ) {
      driverTbl.glGetProgramEnvParameterIuivNV = missing_glGetProgramEnvParameterIuivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetProgramEnvParameterIuivNV == loader_glGetProgramEnvParameterIuivNV) {
      rCtx->dsp.emuTbl.glGetProgramEnvParameterIuivNV = driverTbl.glGetProgramEnvParameterIuivNV;
   }
   driverTbl.glGetProgramEnvParameterIuivNV(target, index, params);
}

// GL_NV_geometry_program4

static void REGAL_CALL missing_glProgramVertexLimitNV(GLenum target, GLint limit)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(limit);
   Warning( "Called missing function glProgramVertexLimitNV" );
}

static void REGAL_CALL loader_glProgramVertexLimitNV(GLenum target, GLint limit)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramVertexLimitNV, "glProgramVertexLimitNV");
   if ( !driverTbl.glProgramVertexLimitNV ) {
      driverTbl.glProgramVertexLimitNV = missing_glProgramVertexLimitNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramVertexLimitNV == loader_glProgramVertexLimitNV) {
      rCtx->dsp.emuTbl.glProgramVertexLimitNV = driverTbl.glProgramVertexLimitNV;
   }
   driverTbl.glProgramVertexLimitNV(target, limit);
}

static void REGAL_CALL missing_glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "Called missing function glFramebufferTextureEXT" );
}

static void REGAL_CALL loader_glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTextureEXT, "glFramebufferTextureEXT");
   if ( !driverTbl.glFramebufferTextureEXT ) {
      driverTbl.glFramebufferTextureEXT = missing_glFramebufferTextureEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTextureEXT == loader_glFramebufferTextureEXT) {
      rCtx->dsp.emuTbl.glFramebufferTextureEXT = driverTbl.glFramebufferTextureEXT;
   }
   driverTbl.glFramebufferTextureEXT(target, attachment, texture, level);
}

static void REGAL_CALL missing_glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(face);
   Warning( "Called missing function glFramebufferTextureFaceEXT" );
}

static void REGAL_CALL loader_glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTextureFaceEXT, "glFramebufferTextureFaceEXT");
   if ( !driverTbl.glFramebufferTextureFaceEXT ) {
      driverTbl.glFramebufferTextureFaceEXT = missing_glFramebufferTextureFaceEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTextureFaceEXT == loader_glFramebufferTextureFaceEXT) {
      rCtx->dsp.emuTbl.glFramebufferTextureFaceEXT = driverTbl.glFramebufferTextureFaceEXT;
   }
   driverTbl.glFramebufferTextureFaceEXT(target, attachment, texture, level, face);
}

// GL_EXT_geometry_shader4

static void REGAL_CALL missing_glProgramParameteriEXT(GLuint program, GLenum pname, GLint value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramParameteriEXT" );
}

static void REGAL_CALL loader_glProgramParameteriEXT(GLuint program, GLenum pname, GLint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramParameteriEXT, "glProgramParameteriEXT");
   if ( !driverTbl.glProgramParameteriEXT ) {
      driverTbl.glProgramParameteriEXT = missing_glProgramParameteriEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramParameteriEXT == loader_glProgramParameteriEXT) {
      rCtx->dsp.emuTbl.glProgramParameteriEXT = driverTbl.glProgramParameteriEXT;
   }
   driverTbl.glProgramParameteriEXT(program, pname, value);
}

// GL_NV_vertex_program4

static void REGAL_CALL missing_glVertexAttribI1iEXT(GLuint index, GLint x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttribI1iEXT" );
}

static void REGAL_CALL loader_glVertexAttribI1iEXT(GLuint index, GLint x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI1iEXT, "glVertexAttribI1iEXT");
   if ( !driverTbl.glVertexAttribI1iEXT ) {
      driverTbl.glVertexAttribI1iEXT = missing_glVertexAttribI1iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI1iEXT == loader_glVertexAttribI1iEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI1iEXT = driverTbl.glVertexAttribI1iEXT;
   }
   driverTbl.glVertexAttribI1iEXT(index, x);
}

static void REGAL_CALL missing_glVertexAttribI2iEXT(GLuint index, GLint x, GLint y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttribI2iEXT" );
}

static void REGAL_CALL loader_glVertexAttribI2iEXT(GLuint index, GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI2iEXT, "glVertexAttribI2iEXT");
   if ( !driverTbl.glVertexAttribI2iEXT ) {
      driverTbl.glVertexAttribI2iEXT = missing_glVertexAttribI2iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI2iEXT == loader_glVertexAttribI2iEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI2iEXT = driverTbl.glVertexAttribI2iEXT;
   }
   driverTbl.glVertexAttribI2iEXT(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttribI3iEXT" );
}

static void REGAL_CALL loader_glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI3iEXT, "glVertexAttribI3iEXT");
   if ( !driverTbl.glVertexAttribI3iEXT ) {
      driverTbl.glVertexAttribI3iEXT = missing_glVertexAttribI3iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI3iEXT == loader_glVertexAttribI3iEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI3iEXT = driverTbl.glVertexAttribI3iEXT;
   }
   driverTbl.glVertexAttribI3iEXT(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttribI4iEXT" );
}

static void REGAL_CALL loader_glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4iEXT, "glVertexAttribI4iEXT");
   if ( !driverTbl.glVertexAttribI4iEXT ) {
      driverTbl.glVertexAttribI4iEXT = missing_glVertexAttribI4iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4iEXT == loader_glVertexAttribI4iEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI4iEXT = driverTbl.glVertexAttribI4iEXT;
   }
   driverTbl.glVertexAttribI4iEXT(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribI1uiEXT(GLuint index, GLuint x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttribI1uiEXT" );
}

static void REGAL_CALL loader_glVertexAttribI1uiEXT(GLuint index, GLuint x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI1uiEXT, "glVertexAttribI1uiEXT");
   if ( !driverTbl.glVertexAttribI1uiEXT ) {
      driverTbl.glVertexAttribI1uiEXT = missing_glVertexAttribI1uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI1uiEXT == loader_glVertexAttribI1uiEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI1uiEXT = driverTbl.glVertexAttribI1uiEXT;
   }
   driverTbl.glVertexAttribI1uiEXT(index, x);
}

static void REGAL_CALL missing_glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttribI2uiEXT" );
}

static void REGAL_CALL loader_glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI2uiEXT, "glVertexAttribI2uiEXT");
   if ( !driverTbl.glVertexAttribI2uiEXT ) {
      driverTbl.glVertexAttribI2uiEXT = missing_glVertexAttribI2uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI2uiEXT == loader_glVertexAttribI2uiEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI2uiEXT = driverTbl.glVertexAttribI2uiEXT;
   }
   driverTbl.glVertexAttribI2uiEXT(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttribI3uiEXT" );
}

static void REGAL_CALL loader_glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI3uiEXT, "glVertexAttribI3uiEXT");
   if ( !driverTbl.glVertexAttribI3uiEXT ) {
      driverTbl.glVertexAttribI3uiEXT = missing_glVertexAttribI3uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI3uiEXT == loader_glVertexAttribI3uiEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI3uiEXT = driverTbl.glVertexAttribI3uiEXT;
   }
   driverTbl.glVertexAttribI3uiEXT(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttribI4uiEXT" );
}

static void REGAL_CALL loader_glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4uiEXT, "glVertexAttribI4uiEXT");
   if ( !driverTbl.glVertexAttribI4uiEXT ) {
      driverTbl.glVertexAttribI4uiEXT = missing_glVertexAttribI4uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4uiEXT == loader_glVertexAttribI4uiEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI4uiEXT = driverTbl.glVertexAttribI4uiEXT;
   }
   driverTbl.glVertexAttribI4uiEXT(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribI1ivEXT(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI1ivEXT" );
}

static void REGAL_CALL loader_glVertexAttribI1ivEXT(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI1ivEXT, "glVertexAttribI1ivEXT");
   if ( !driverTbl.glVertexAttribI1ivEXT ) {
      driverTbl.glVertexAttribI1ivEXT = missing_glVertexAttribI1ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI1ivEXT == loader_glVertexAttribI1ivEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI1ivEXT = driverTbl.glVertexAttribI1ivEXT;
   }
   driverTbl.glVertexAttribI1ivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI2ivEXT(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI2ivEXT" );
}

static void REGAL_CALL loader_glVertexAttribI2ivEXT(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI2ivEXT, "glVertexAttribI2ivEXT");
   if ( !driverTbl.glVertexAttribI2ivEXT ) {
      driverTbl.glVertexAttribI2ivEXT = missing_glVertexAttribI2ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI2ivEXT == loader_glVertexAttribI2ivEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI2ivEXT = driverTbl.glVertexAttribI2ivEXT;
   }
   driverTbl.glVertexAttribI2ivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI3ivEXT(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI3ivEXT" );
}

static void REGAL_CALL loader_glVertexAttribI3ivEXT(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI3ivEXT, "glVertexAttribI3ivEXT");
   if ( !driverTbl.glVertexAttribI3ivEXT ) {
      driverTbl.glVertexAttribI3ivEXT = missing_glVertexAttribI3ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI3ivEXT == loader_glVertexAttribI3ivEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI3ivEXT = driverTbl.glVertexAttribI3ivEXT;
   }
   driverTbl.glVertexAttribI3ivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4ivEXT(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI4ivEXT" );
}

static void REGAL_CALL loader_glVertexAttribI4ivEXT(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4ivEXT, "glVertexAttribI4ivEXT");
   if ( !driverTbl.glVertexAttribI4ivEXT ) {
      driverTbl.glVertexAttribI4ivEXT = missing_glVertexAttribI4ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4ivEXT == loader_glVertexAttribI4ivEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI4ivEXT = driverTbl.glVertexAttribI4ivEXT;
   }
   driverTbl.glVertexAttribI4ivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI1uivEXT(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI1uivEXT" );
}

static void REGAL_CALL loader_glVertexAttribI1uivEXT(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI1uivEXT, "glVertexAttribI1uivEXT");
   if ( !driverTbl.glVertexAttribI1uivEXT ) {
      driverTbl.glVertexAttribI1uivEXT = missing_glVertexAttribI1uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI1uivEXT == loader_glVertexAttribI1uivEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI1uivEXT = driverTbl.glVertexAttribI1uivEXT;
   }
   driverTbl.glVertexAttribI1uivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI2uivEXT(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI2uivEXT" );
}

static void REGAL_CALL loader_glVertexAttribI2uivEXT(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI2uivEXT, "glVertexAttribI2uivEXT");
   if ( !driverTbl.glVertexAttribI2uivEXT ) {
      driverTbl.glVertexAttribI2uivEXT = missing_glVertexAttribI2uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI2uivEXT == loader_glVertexAttribI2uivEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI2uivEXT = driverTbl.glVertexAttribI2uivEXT;
   }
   driverTbl.glVertexAttribI2uivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI3uivEXT(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI3uivEXT" );
}

static void REGAL_CALL loader_glVertexAttribI3uivEXT(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI3uivEXT, "glVertexAttribI3uivEXT");
   if ( !driverTbl.glVertexAttribI3uivEXT ) {
      driverTbl.glVertexAttribI3uivEXT = missing_glVertexAttribI3uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI3uivEXT == loader_glVertexAttribI3uivEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI3uivEXT = driverTbl.glVertexAttribI3uivEXT;
   }
   driverTbl.glVertexAttribI3uivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4uivEXT(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI4uivEXT" );
}

static void REGAL_CALL loader_glVertexAttribI4uivEXT(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4uivEXT, "glVertexAttribI4uivEXT");
   if ( !driverTbl.glVertexAttribI4uivEXT ) {
      driverTbl.glVertexAttribI4uivEXT = missing_glVertexAttribI4uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4uivEXT == loader_glVertexAttribI4uivEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI4uivEXT = driverTbl.glVertexAttribI4uivEXT;
   }
   driverTbl.glVertexAttribI4uivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4bvEXT(GLuint index, const GLbyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI4bvEXT" );
}

static void REGAL_CALL loader_glVertexAttribI4bvEXT(GLuint index, const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4bvEXT, "glVertexAttribI4bvEXT");
   if ( !driverTbl.glVertexAttribI4bvEXT ) {
      driverTbl.glVertexAttribI4bvEXT = missing_glVertexAttribI4bvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4bvEXT == loader_glVertexAttribI4bvEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI4bvEXT = driverTbl.glVertexAttribI4bvEXT;
   }
   driverTbl.glVertexAttribI4bvEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4svEXT(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI4svEXT" );
}

static void REGAL_CALL loader_glVertexAttribI4svEXT(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4svEXT, "glVertexAttribI4svEXT");
   if ( !driverTbl.glVertexAttribI4svEXT ) {
      driverTbl.glVertexAttribI4svEXT = missing_glVertexAttribI4svEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4svEXT == loader_glVertexAttribI4svEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI4svEXT = driverTbl.glVertexAttribI4svEXT;
   }
   driverTbl.glVertexAttribI4svEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI4ubvEXT" );
}

static void REGAL_CALL loader_glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4ubvEXT, "glVertexAttribI4ubvEXT");
   if ( !driverTbl.glVertexAttribI4ubvEXT ) {
      driverTbl.glVertexAttribI4ubvEXT = missing_glVertexAttribI4ubvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4ubvEXT == loader_glVertexAttribI4ubvEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI4ubvEXT = driverTbl.glVertexAttribI4ubvEXT;
   }
   driverTbl.glVertexAttribI4ubvEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4usvEXT(GLuint index, const GLushort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribI4usvEXT" );
}

static void REGAL_CALL loader_glVertexAttribI4usvEXT(GLuint index, const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribI4usvEXT, "glVertexAttribI4usvEXT");
   if ( !driverTbl.glVertexAttribI4usvEXT ) {
      driverTbl.glVertexAttribI4usvEXT = missing_glVertexAttribI4usvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribI4usvEXT == loader_glVertexAttribI4usvEXT) {
      rCtx->dsp.emuTbl.glVertexAttribI4usvEXT = driverTbl.glVertexAttribI4usvEXT;
   }
   driverTbl.glVertexAttribI4usvEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glVertexAttribIPointerEXT" );
}

static void REGAL_CALL loader_glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribIPointerEXT, "glVertexAttribIPointerEXT");
   if ( !driverTbl.glVertexAttribIPointerEXT ) {
      driverTbl.glVertexAttribIPointerEXT = missing_glVertexAttribIPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribIPointerEXT == loader_glVertexAttribIPointerEXT) {
      rCtx->dsp.emuTbl.glVertexAttribIPointerEXT = driverTbl.glVertexAttribIPointerEXT;
   }
   driverTbl.glVertexAttribIPointerEXT(index, size, type, stride, pointer);
}

static void REGAL_CALL missing_glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribIivEXT" );
}

static void REGAL_CALL loader_glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribIivEXT, "glGetVertexAttribIivEXT");
   if ( !driverTbl.glGetVertexAttribIivEXT ) {
      driverTbl.glGetVertexAttribIivEXT = missing_glGetVertexAttribIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribIivEXT == loader_glGetVertexAttribIivEXT) {
      rCtx->dsp.emuTbl.glGetVertexAttribIivEXT = driverTbl.glGetVertexAttribIivEXT;
   }
   driverTbl.glGetVertexAttribIivEXT(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribIuivEXT" );
}

static void REGAL_CALL loader_glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribIuivEXT, "glGetVertexAttribIuivEXT");
   if ( !driverTbl.glGetVertexAttribIuivEXT ) {
      driverTbl.glGetVertexAttribIuivEXT = missing_glGetVertexAttribIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribIuivEXT == loader_glGetVertexAttribIuivEXT) {
      rCtx->dsp.emuTbl.glGetVertexAttribIuivEXT = driverTbl.glGetVertexAttribIuivEXT;
   }
   driverTbl.glGetVertexAttribIuivEXT(index, pname, params);
}

// GL_EXT_gpu_shader4

static void REGAL_CALL missing_glGetUniformuivEXT(GLuint program, GLint location, GLuint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetUniformuivEXT" );
}

static void REGAL_CALL loader_glGetUniformuivEXT(GLuint program, GLint location, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformuivEXT, "glGetUniformuivEXT");
   if ( !driverTbl.glGetUniformuivEXT ) {
      driverTbl.glGetUniformuivEXT = missing_glGetUniformuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformuivEXT == loader_glGetUniformuivEXT) {
      rCtx->dsp.emuTbl.glGetUniformuivEXT = driverTbl.glGetUniformuivEXT;
   }
   driverTbl.glGetUniformuivEXT(program, location, params);
}

static void REGAL_CALL missing_glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(color);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glBindFragDataLocationEXT" );
}

static void REGAL_CALL loader_glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindFragDataLocationEXT, "glBindFragDataLocationEXT");
   if ( !driverTbl.glBindFragDataLocationEXT ) {
      driverTbl.glBindFragDataLocationEXT = missing_glBindFragDataLocationEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindFragDataLocationEXT == loader_glBindFragDataLocationEXT) {
      rCtx->dsp.emuTbl.glBindFragDataLocationEXT = driverTbl.glBindFragDataLocationEXT;
   }
   driverTbl.glBindFragDataLocationEXT(program, color, name);
}

static GLint REGAL_CALL missing_glGetFragDataLocationEXT(GLuint program, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetFragDataLocationEXT" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetFragDataLocationEXT(GLuint program, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFragDataLocationEXT, "glGetFragDataLocationEXT");
   if ( !driverTbl.glGetFragDataLocationEXT ) {
      driverTbl.glGetFragDataLocationEXT = missing_glGetFragDataLocationEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFragDataLocationEXT == loader_glGetFragDataLocationEXT) {
      rCtx->dsp.emuTbl.glGetFragDataLocationEXT = driverTbl.glGetFragDataLocationEXT;
   }
   return driverTbl.glGetFragDataLocationEXT(program, name);
}

static void REGAL_CALL missing_glUniform1uiEXT(GLint location, GLuint v0)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "Called missing function glUniform1uiEXT" );
}

static void REGAL_CALL loader_glUniform1uiEXT(GLint location, GLuint v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1uiEXT, "glUniform1uiEXT");
   if ( !driverTbl.glUniform1uiEXT ) {
      driverTbl.glUniform1uiEXT = missing_glUniform1uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1uiEXT == loader_glUniform1uiEXT) {
      rCtx->dsp.emuTbl.glUniform1uiEXT = driverTbl.glUniform1uiEXT;
   }
   driverTbl.glUniform1uiEXT(location, v0);
}

static void REGAL_CALL missing_glUniform2uiEXT(GLint location, GLuint v0, GLuint v1)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "Called missing function glUniform2uiEXT" );
}

static void REGAL_CALL loader_glUniform2uiEXT(GLint location, GLuint v0, GLuint v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2uiEXT, "glUniform2uiEXT");
   if ( !driverTbl.glUniform2uiEXT ) {
      driverTbl.glUniform2uiEXT = missing_glUniform2uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2uiEXT == loader_glUniform2uiEXT) {
      rCtx->dsp.emuTbl.glUniform2uiEXT = driverTbl.glUniform2uiEXT;
   }
   driverTbl.glUniform2uiEXT(location, v0, v1);
}

static void REGAL_CALL missing_glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glUniform3uiEXT" );
}

static void REGAL_CALL loader_glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3uiEXT, "glUniform3uiEXT");
   if ( !driverTbl.glUniform3uiEXT ) {
      driverTbl.glUniform3uiEXT = missing_glUniform3uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3uiEXT == loader_glUniform3uiEXT) {
      rCtx->dsp.emuTbl.glUniform3uiEXT = driverTbl.glUniform3uiEXT;
   }
   driverTbl.glUniform3uiEXT(location, v0, v1, v2);
}

static void REGAL_CALL missing_glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "Called missing function glUniform4uiEXT" );
}

static void REGAL_CALL loader_glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4uiEXT, "glUniform4uiEXT");
   if ( !driverTbl.glUniform4uiEXT ) {
      driverTbl.glUniform4uiEXT = missing_glUniform4uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4uiEXT == loader_glUniform4uiEXT) {
      rCtx->dsp.emuTbl.glUniform4uiEXT = driverTbl.glUniform4uiEXT;
   }
   driverTbl.glUniform4uiEXT(location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform1uivEXT" );
}

static void REGAL_CALL loader_glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1uivEXT, "glUniform1uivEXT");
   if ( !driverTbl.glUniform1uivEXT ) {
      driverTbl.glUniform1uivEXT = missing_glUniform1uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1uivEXT == loader_glUniform1uivEXT) {
      rCtx->dsp.emuTbl.glUniform1uivEXT = driverTbl.glUniform1uivEXT;
   }
   driverTbl.glUniform1uivEXT(location, count, value);
}

static void REGAL_CALL missing_glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform2uivEXT" );
}

static void REGAL_CALL loader_glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2uivEXT, "glUniform2uivEXT");
   if ( !driverTbl.glUniform2uivEXT ) {
      driverTbl.glUniform2uivEXT = missing_glUniform2uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2uivEXT == loader_glUniform2uivEXT) {
      rCtx->dsp.emuTbl.glUniform2uivEXT = driverTbl.glUniform2uivEXT;
   }
   driverTbl.glUniform2uivEXT(location, count, value);
}

static void REGAL_CALL missing_glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform3uivEXT" );
}

static void REGAL_CALL loader_glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3uivEXT, "glUniform3uivEXT");
   if ( !driverTbl.glUniform3uivEXT ) {
      driverTbl.glUniform3uivEXT = missing_glUniform3uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3uivEXT == loader_glUniform3uivEXT) {
      rCtx->dsp.emuTbl.glUniform3uivEXT = driverTbl.glUniform3uivEXT;
   }
   driverTbl.glUniform3uivEXT(location, count, value);
}

static void REGAL_CALL missing_glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform4uivEXT" );
}

static void REGAL_CALL loader_glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4uivEXT, "glUniform4uivEXT");
   if ( !driverTbl.glUniform4uivEXT ) {
      driverTbl.glUniform4uivEXT = missing_glUniform4uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4uivEXT == loader_glUniform4uivEXT) {
      rCtx->dsp.emuTbl.glUniform4uivEXT = driverTbl.glUniform4uivEXT;
   }
   driverTbl.glUniform4uivEXT(location, count, value);
}

// GL_EXT_draw_instanced

static void REGAL_CALL missing_glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   Warning( "Called missing function glDrawArraysInstancedEXT" );
}

static void REGAL_CALL loader_glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawArraysInstancedEXT, "glDrawArraysInstancedEXT");
   if ( !driverTbl.glDrawArraysInstancedEXT ) {
      driverTbl.glDrawArraysInstancedEXT = missing_glDrawArraysInstancedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawArraysInstancedEXT == loader_glDrawArraysInstancedEXT) {
      rCtx->dsp.emuTbl.glDrawArraysInstancedEXT = driverTbl.glDrawArraysInstancedEXT;
   }
   driverTbl.glDrawArraysInstancedEXT(mode, start, count, primcount);
}

static void REGAL_CALL missing_glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   Warning( "Called missing function glDrawElementsInstancedEXT" );
}

static void REGAL_CALL loader_glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawElementsInstancedEXT, "glDrawElementsInstancedEXT");
   if ( !driverTbl.glDrawElementsInstancedEXT ) {
      driverTbl.glDrawElementsInstancedEXT = missing_glDrawElementsInstancedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawElementsInstancedEXT == loader_glDrawElementsInstancedEXT) {
      rCtx->dsp.emuTbl.glDrawElementsInstancedEXT = driverTbl.glDrawElementsInstancedEXT;
   }
   driverTbl.glDrawElementsInstancedEXT(mode, count, type, indices, primcount);
}

// GL_EXT_texture_array

static void REGAL_CALL missing_glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layer);
   Warning( "Called missing function glFramebufferTextureLayerEXT" );
}

static void REGAL_CALL loader_glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferTextureLayerEXT, "glFramebufferTextureLayerEXT");
   if ( !driverTbl.glFramebufferTextureLayerEXT ) {
      driverTbl.glFramebufferTextureLayerEXT = missing_glFramebufferTextureLayerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferTextureLayerEXT == loader_glFramebufferTextureLayerEXT) {
      rCtx->dsp.emuTbl.glFramebufferTextureLayerEXT = driverTbl.glFramebufferTextureLayerEXT;
   }
   driverTbl.glFramebufferTextureLayerEXT(target, attachment, texture, level, layer);
}

// GL_EXT_texture_buffer_object

static void REGAL_CALL missing_glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glTexBufferEXT" );
}

static void REGAL_CALL loader_glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexBufferEXT, "glTexBufferEXT");
   if ( !driverTbl.glTexBufferEXT ) {
      driverTbl.glTexBufferEXT = missing_glTexBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexBufferEXT == loader_glTexBufferEXT) {
      rCtx->dsp.emuTbl.glTexBufferEXT = driverTbl.glTexBufferEXT;
   }
   driverTbl.glTexBufferEXT(target, internalformat, buffer);
}

// GL_NV_depth_buffer_float

static void REGAL_CALL missing_glDepthRangedNV(GLdouble zNear, GLdouble zFar)
{
   UNUSED_PARAMETER(zNear);
   UNUSED_PARAMETER(zFar);
   Warning( "Called missing function glDepthRangedNV" );
}

static void REGAL_CALL loader_glDepthRangedNV(GLdouble zNear, GLdouble zFar)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDepthRangedNV, "glDepthRangedNV");
   if ( !driverTbl.glDepthRangedNV ) {
      driverTbl.glDepthRangedNV = missing_glDepthRangedNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDepthRangedNV == loader_glDepthRangedNV) {
      rCtx->dsp.emuTbl.glDepthRangedNV = driverTbl.glDepthRangedNV;
   }
   driverTbl.glDepthRangedNV(zNear, zFar);
}

static void REGAL_CALL missing_glClearDepthdNV(GLdouble depth)
{
   UNUSED_PARAMETER(depth);
   Warning( "Called missing function glClearDepthdNV" );
}

static void REGAL_CALL loader_glClearDepthdNV(GLdouble depth)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClearDepthdNV, "glClearDepthdNV");
   if ( !driverTbl.glClearDepthdNV ) {
      driverTbl.glClearDepthdNV = missing_glClearDepthdNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClearDepthdNV == loader_glClearDepthdNV) {
      rCtx->dsp.emuTbl.glClearDepthdNV = driverTbl.glClearDepthdNV;
   }
   driverTbl.glClearDepthdNV(depth);
}

static void REGAL_CALL missing_glDepthBoundsdNV(GLdouble zmin, GLdouble zmax)
{
   UNUSED_PARAMETER(zmin);
   UNUSED_PARAMETER(zmax);
   Warning( "Called missing function glDepthBoundsdNV" );
}

static void REGAL_CALL loader_glDepthBoundsdNV(GLdouble zmin, GLdouble zmax)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDepthBoundsdNV, "glDepthBoundsdNV");
   if ( !driverTbl.glDepthBoundsdNV ) {
      driverTbl.glDepthBoundsdNV = missing_glDepthBoundsdNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDepthBoundsdNV == loader_glDepthBoundsdNV) {
      rCtx->dsp.emuTbl.glDepthBoundsdNV = driverTbl.glDepthBoundsdNV;
   }
   driverTbl.glDepthBoundsdNV(zmin, zmax);
}

// GL_NV_framebuffer_multisample_coverage

static void REGAL_CALL missing_glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(coverageSamples);
   UNUSED_PARAMETER(colorSamples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glRenderbufferStorageMultisampleCoverageNV" );
}

static void REGAL_CALL loader_glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glRenderbufferStorageMultisampleCoverageNV, "glRenderbufferStorageMultisampleCoverageNV");
   if ( !driverTbl.glRenderbufferStorageMultisampleCoverageNV ) {
      driverTbl.glRenderbufferStorageMultisampleCoverageNV = missing_glRenderbufferStorageMultisampleCoverageNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glRenderbufferStorageMultisampleCoverageNV == loader_glRenderbufferStorageMultisampleCoverageNV) {
      rCtx->dsp.emuTbl.glRenderbufferStorageMultisampleCoverageNV = driverTbl.glRenderbufferStorageMultisampleCoverageNV;
   }
   driverTbl.glRenderbufferStorageMultisampleCoverageNV(target, coverageSamples, colorSamples, internalformat, width, height);
}

// GL_NV_parameter_buffer_object

static void REGAL_CALL missing_glProgramBufferParametersfvNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramBufferParametersfvNV" );
}

static void REGAL_CALL loader_glProgramBufferParametersfvNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramBufferParametersfvNV, "glProgramBufferParametersfvNV");
   if ( !driverTbl.glProgramBufferParametersfvNV ) {
      driverTbl.glProgramBufferParametersfvNV = missing_glProgramBufferParametersfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramBufferParametersfvNV == loader_glProgramBufferParametersfvNV) {
      rCtx->dsp.emuTbl.glProgramBufferParametersfvNV = driverTbl.glProgramBufferParametersfvNV;
   }
   driverTbl.glProgramBufferParametersfvNV(target, buffer, index, count, params);
}

static void REGAL_CALL missing_glProgramBufferParametersIivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramBufferParametersIivNV" );
}

static void REGAL_CALL loader_glProgramBufferParametersIivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramBufferParametersIivNV, "glProgramBufferParametersIivNV");
   if ( !driverTbl.glProgramBufferParametersIivNV ) {
      driverTbl.glProgramBufferParametersIivNV = missing_glProgramBufferParametersIivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramBufferParametersIivNV == loader_glProgramBufferParametersIivNV) {
      rCtx->dsp.emuTbl.glProgramBufferParametersIivNV = driverTbl.glProgramBufferParametersIivNV;
   }
   driverTbl.glProgramBufferParametersIivNV(target, buffer, index, count, params);
}

static void REGAL_CALL missing_glProgramBufferParametersIuivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glProgramBufferParametersIuivNV" );
}

static void REGAL_CALL loader_glProgramBufferParametersIuivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramBufferParametersIuivNV, "glProgramBufferParametersIuivNV");
   if ( !driverTbl.glProgramBufferParametersIuivNV ) {
      driverTbl.glProgramBufferParametersIuivNV = missing_glProgramBufferParametersIuivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramBufferParametersIuivNV == loader_glProgramBufferParametersIuivNV) {
      rCtx->dsp.emuTbl.glProgramBufferParametersIuivNV = driverTbl.glProgramBufferParametersIuivNV;
   }
   driverTbl.glProgramBufferParametersIuivNV(target, buffer, index, count, params);
}

// GL_EXT_draw_buffers2

static void REGAL_CALL missing_glColorMaskIndexedEXT(GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   Warning( "Called missing function glColorMaskIndexedEXT" );
}

static void REGAL_CALL loader_glColorMaskIndexedEXT(GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorMaskIndexedEXT, "glColorMaskIndexedEXT");
   if ( !driverTbl.glColorMaskIndexedEXT ) {
      driverTbl.glColorMaskIndexedEXT = missing_glColorMaskIndexedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorMaskIndexedEXT == loader_glColorMaskIndexedEXT) {
      rCtx->dsp.emuTbl.glColorMaskIndexedEXT = driverTbl.glColorMaskIndexedEXT;
   }
   driverTbl.glColorMaskIndexedEXT(buf, r, g, b, a);
}

static void REGAL_CALL missing_glGetBooleanIndexedvEXT(GLenum value, GLuint index, GLboolean *data)
{
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetBooleanIndexedvEXT" );
}

static void REGAL_CALL loader_glGetBooleanIndexedvEXT(GLenum value, GLuint index, GLboolean *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetBooleanIndexedvEXT, "glGetBooleanIndexedvEXT");
   if ( !driverTbl.glGetBooleanIndexedvEXT ) {
      driverTbl.glGetBooleanIndexedvEXT = missing_glGetBooleanIndexedvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetBooleanIndexedvEXT == loader_glGetBooleanIndexedvEXT) {
      rCtx->dsp.emuTbl.glGetBooleanIndexedvEXT = driverTbl.glGetBooleanIndexedvEXT;
   }
   driverTbl.glGetBooleanIndexedvEXT(value, index, data);
}

static void REGAL_CALL missing_glGetIntegerIndexedvEXT(GLenum value, GLuint index, GLint *data)
{
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetIntegerIndexedvEXT" );
}

static void REGAL_CALL loader_glGetIntegerIndexedvEXT(GLenum value, GLuint index, GLint *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetIntegerIndexedvEXT, "glGetIntegerIndexedvEXT");
   if ( !driverTbl.glGetIntegerIndexedvEXT ) {
      driverTbl.glGetIntegerIndexedvEXT = missing_glGetIntegerIndexedvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetIntegerIndexedvEXT == loader_glGetIntegerIndexedvEXT) {
      rCtx->dsp.emuTbl.glGetIntegerIndexedvEXT = driverTbl.glGetIntegerIndexedvEXT;
   }
   driverTbl.glGetIntegerIndexedvEXT(value, index, data);
}

static void REGAL_CALL missing_glEnableIndexedEXT(GLenum target, GLuint index)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glEnableIndexedEXT" );
}

static void REGAL_CALL loader_glEnableIndexedEXT(GLenum target, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEnableIndexedEXT, "glEnableIndexedEXT");
   if ( !driverTbl.glEnableIndexedEXT ) {
      driverTbl.glEnableIndexedEXT = missing_glEnableIndexedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEnableIndexedEXT == loader_glEnableIndexedEXT) {
      rCtx->dsp.emuTbl.glEnableIndexedEXT = driverTbl.glEnableIndexedEXT;
   }
   driverTbl.glEnableIndexedEXT(target, index);
}

static void REGAL_CALL missing_glDisableIndexedEXT(GLenum target, GLuint index)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glDisableIndexedEXT" );
}

static void REGAL_CALL loader_glDisableIndexedEXT(GLenum target, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDisableIndexedEXT, "glDisableIndexedEXT");
   if ( !driverTbl.glDisableIndexedEXT ) {
      driverTbl.glDisableIndexedEXT = missing_glDisableIndexedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDisableIndexedEXT == loader_glDisableIndexedEXT) {
      rCtx->dsp.emuTbl.glDisableIndexedEXT = driverTbl.glDisableIndexedEXT;
   }
   driverTbl.glDisableIndexedEXT(target, index);
}

static GLboolean REGAL_CALL missing_glIsEnabledIndexedEXT(GLenum target, GLuint index)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glIsEnabledIndexedEXT" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsEnabledIndexedEXT(GLenum target, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsEnabledIndexedEXT, "glIsEnabledIndexedEXT");
   if ( !driverTbl.glIsEnabledIndexedEXT ) {
      driverTbl.glIsEnabledIndexedEXT = missing_glIsEnabledIndexedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsEnabledIndexedEXT == loader_glIsEnabledIndexedEXT) {
      rCtx->dsp.emuTbl.glIsEnabledIndexedEXT = driverTbl.glIsEnabledIndexedEXT;
   }
   return driverTbl.glIsEnabledIndexedEXT(target, index);
}

// GL_NV_transform_feedback

static void REGAL_CALL missing_glBeginTransformFeedbackNV(GLenum primitiveMode)
{
   UNUSED_PARAMETER(primitiveMode);
   Warning( "Called missing function glBeginTransformFeedbackNV" );
}

static void REGAL_CALL loader_glBeginTransformFeedbackNV(GLenum primitiveMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBeginTransformFeedbackNV, "glBeginTransformFeedbackNV");
   if ( !driverTbl.glBeginTransformFeedbackNV ) {
      driverTbl.glBeginTransformFeedbackNV = missing_glBeginTransformFeedbackNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBeginTransformFeedbackNV == loader_glBeginTransformFeedbackNV) {
      rCtx->dsp.emuTbl.glBeginTransformFeedbackNV = driverTbl.glBeginTransformFeedbackNV;
   }
   driverTbl.glBeginTransformFeedbackNV(primitiveMode);
}

static void REGAL_CALL missing_glEndTransformFeedbackNV(void)
{
   Warning( "Called missing function glEndTransformFeedbackNV" );
}

static void REGAL_CALL loader_glEndTransformFeedbackNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndTransformFeedbackNV, "glEndTransformFeedbackNV");
   if ( !driverTbl.glEndTransformFeedbackNV ) {
      driverTbl.glEndTransformFeedbackNV = missing_glEndTransformFeedbackNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndTransformFeedbackNV == loader_glEndTransformFeedbackNV) {
      rCtx->dsp.emuTbl.glEndTransformFeedbackNV = driverTbl.glEndTransformFeedbackNV;
   }
   driverTbl.glEndTransformFeedbackNV();
}

static void REGAL_CALL missing_glTransformFeedbackAttribsNV(GLuint count, const GLint *attribs, GLenum bufferMode)
{
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(attribs);
   UNUSED_PARAMETER(bufferMode);
   Warning( "Called missing function glTransformFeedbackAttribsNV" );
}

static void REGAL_CALL loader_glTransformFeedbackAttribsNV(GLuint count, const GLint *attribs, GLenum bufferMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTransformFeedbackAttribsNV, "glTransformFeedbackAttribsNV");
   if ( !driverTbl.glTransformFeedbackAttribsNV ) {
      driverTbl.glTransformFeedbackAttribsNV = missing_glTransformFeedbackAttribsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTransformFeedbackAttribsNV == loader_glTransformFeedbackAttribsNV) {
      rCtx->dsp.emuTbl.glTransformFeedbackAttribsNV = driverTbl.glTransformFeedbackAttribsNV;
   }
   driverTbl.glTransformFeedbackAttribsNV(count, attribs, bufferMode);
}

static void REGAL_CALL missing_glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   Warning( "Called missing function glBindBufferRangeNV" );
}

static void REGAL_CALL loader_glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindBufferRangeNV, "glBindBufferRangeNV");
   if ( !driverTbl.glBindBufferRangeNV ) {
      driverTbl.glBindBufferRangeNV = missing_glBindBufferRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindBufferRangeNV == loader_glBindBufferRangeNV) {
      rCtx->dsp.emuTbl.glBindBufferRangeNV = driverTbl.glBindBufferRangeNV;
   }
   driverTbl.glBindBufferRangeNV(target, index, buffer, offset, size);
}

static void REGAL_CALL missing_glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   Warning( "Called missing function glBindBufferOffsetNV" );
}

static void REGAL_CALL loader_glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindBufferOffsetNV, "glBindBufferOffsetNV");
   if ( !driverTbl.glBindBufferOffsetNV ) {
      driverTbl.glBindBufferOffsetNV = missing_glBindBufferOffsetNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindBufferOffsetNV == loader_glBindBufferOffsetNV) {
      rCtx->dsp.emuTbl.glBindBufferOffsetNV = driverTbl.glBindBufferOffsetNV;
   }
   driverTbl.glBindBufferOffsetNV(target, index, buffer, offset);
}

static void REGAL_CALL missing_glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glBindBufferBaseNV" );
}

static void REGAL_CALL loader_glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindBufferBaseNV, "glBindBufferBaseNV");
   if ( !driverTbl.glBindBufferBaseNV ) {
      driverTbl.glBindBufferBaseNV = missing_glBindBufferBaseNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindBufferBaseNV == loader_glBindBufferBaseNV) {
      rCtx->dsp.emuTbl.glBindBufferBaseNV = driverTbl.glBindBufferBaseNV;
   }
   driverTbl.glBindBufferBaseNV(target, index, buffer);
}

static void REGAL_CALL missing_glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(locations);
   UNUSED_PARAMETER(bufferMode);
   Warning( "Called missing function glTransformFeedbackVaryingsNV" );
}

static void REGAL_CALL loader_glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTransformFeedbackVaryingsNV, "glTransformFeedbackVaryingsNV");
   if ( !driverTbl.glTransformFeedbackVaryingsNV ) {
      driverTbl.glTransformFeedbackVaryingsNV = missing_glTransformFeedbackVaryingsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTransformFeedbackVaryingsNV == loader_glTransformFeedbackVaryingsNV) {
      rCtx->dsp.emuTbl.glTransformFeedbackVaryingsNV = driverTbl.glTransformFeedbackVaryingsNV;
   }
   driverTbl.glTransformFeedbackVaryingsNV(program, count, locations, bufferMode);
}

static void REGAL_CALL missing_glActiveVaryingNV(GLuint program, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glActiveVaryingNV" );
}

static void REGAL_CALL loader_glActiveVaryingNV(GLuint program, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glActiveVaryingNV, "glActiveVaryingNV");
   if ( !driverTbl.glActiveVaryingNV ) {
      driverTbl.glActiveVaryingNV = missing_glActiveVaryingNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glActiveVaryingNV == loader_glActiveVaryingNV) {
      rCtx->dsp.emuTbl.glActiveVaryingNV = driverTbl.glActiveVaryingNV;
   }
   driverTbl.glActiveVaryingNV(program, name);
}

static GLint REGAL_CALL missing_glGetVaryingLocationNV(GLuint program, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetVaryingLocationNV" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetVaryingLocationNV(GLuint program, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVaryingLocationNV, "glGetVaryingLocationNV");
   if ( !driverTbl.glGetVaryingLocationNV ) {
      driverTbl.glGetVaryingLocationNV = missing_glGetVaryingLocationNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVaryingLocationNV == loader_glGetVaryingLocationNV) {
      rCtx->dsp.emuTbl.glGetVaryingLocationNV = driverTbl.glGetVaryingLocationNV;
   }
   return driverTbl.glGetVaryingLocationNV(program, name);
}

static void REGAL_CALL missing_glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetActiveVaryingNV" );
}

static void REGAL_CALL loader_glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetActiveVaryingNV, "glGetActiveVaryingNV");
   if ( !driverTbl.glGetActiveVaryingNV ) {
      driverTbl.glGetActiveVaryingNV = missing_glGetActiveVaryingNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetActiveVaryingNV == loader_glGetActiveVaryingNV) {
      rCtx->dsp.emuTbl.glGetActiveVaryingNV = driverTbl.glGetActiveVaryingNV;
   }
   driverTbl.glGetActiveVaryingNV(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL missing_glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint *location)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(location);
   Warning( "Called missing function glGetTransformFeedbackVaryingNV" );
}

static void REGAL_CALL loader_glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint *location)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTransformFeedbackVaryingNV, "glGetTransformFeedbackVaryingNV");
   if ( !driverTbl.glGetTransformFeedbackVaryingNV ) {
      driverTbl.glGetTransformFeedbackVaryingNV = missing_glGetTransformFeedbackVaryingNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTransformFeedbackVaryingNV == loader_glGetTransformFeedbackVaryingNV) {
      rCtx->dsp.emuTbl.glGetTransformFeedbackVaryingNV = driverTbl.glGetTransformFeedbackVaryingNV;
   }
   driverTbl.glGetTransformFeedbackVaryingNV(program, index, location);
}

// GL_EXT_bindable_uniform

static void REGAL_CALL missing_glUniformBufferEXT(GLuint program, GLint location, GLuint buffer)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glUniformBufferEXT" );
}

static void REGAL_CALL loader_glUniformBufferEXT(GLuint program, GLint location, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformBufferEXT, "glUniformBufferEXT");
   if ( !driverTbl.glUniformBufferEXT ) {
      driverTbl.glUniformBufferEXT = missing_glUniformBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformBufferEXT == loader_glUniformBufferEXT) {
      rCtx->dsp.emuTbl.glUniformBufferEXT = driverTbl.glUniformBufferEXT;
   }
   driverTbl.glUniformBufferEXT(program, location, buffer);
}

static GLint REGAL_CALL missing_glGetUniformBufferSizeEXT(GLuint program, GLint location)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   Warning( "Called missing function glGetUniformBufferSizeEXT" );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetUniformBufferSizeEXT(GLuint program, GLint location)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformBufferSizeEXT, "glGetUniformBufferSizeEXT");
   if ( !driverTbl.glGetUniformBufferSizeEXT ) {
      driverTbl.glGetUniformBufferSizeEXT = missing_glGetUniformBufferSizeEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformBufferSizeEXT == loader_glGetUniformBufferSizeEXT) {
      rCtx->dsp.emuTbl.glGetUniformBufferSizeEXT = driverTbl.glGetUniformBufferSizeEXT;
   }
   return driverTbl.glGetUniformBufferSizeEXT(program, location);
}

static GLintptr REGAL_CALL missing_glGetUniformOffsetEXT(GLuint program, GLint location)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   Warning( "Called missing function glGetUniformOffsetEXT" );
  GLintptr  ret = (GLintptr )0;
  return ret;
}

static GLintptr REGAL_CALL loader_glGetUniformOffsetEXT(GLuint program, GLint location)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformOffsetEXT, "glGetUniformOffsetEXT");
   if ( !driverTbl.glGetUniformOffsetEXT ) {
      driverTbl.glGetUniformOffsetEXT = missing_glGetUniformOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformOffsetEXT == loader_glGetUniformOffsetEXT) {
      rCtx->dsp.emuTbl.glGetUniformOffsetEXT = driverTbl.glGetUniformOffsetEXT;
   }
   return driverTbl.glGetUniformOffsetEXT(program, location);
}

// GL_EXT_texture_integer

static void REGAL_CALL missing_glTexParameterIivEXT(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glTexParameterIivEXT" );
}

static void REGAL_CALL loader_glTexParameterIivEXT(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexParameterIivEXT, "glTexParameterIivEXT");
   if ( !driverTbl.glTexParameterIivEXT ) {
      driverTbl.glTexParameterIivEXT = missing_glTexParameterIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexParameterIivEXT == loader_glTexParameterIivEXT) {
      rCtx->dsp.emuTbl.glTexParameterIivEXT = driverTbl.glTexParameterIivEXT;
   }
   driverTbl.glTexParameterIivEXT(target, pname, params);
}

static void REGAL_CALL missing_glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glTexParameterIuivEXT" );
}

static void REGAL_CALL loader_glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexParameterIuivEXT, "glTexParameterIuivEXT");
   if ( !driverTbl.glTexParameterIuivEXT ) {
      driverTbl.glTexParameterIuivEXT = missing_glTexParameterIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexParameterIuivEXT == loader_glTexParameterIuivEXT) {
      rCtx->dsp.emuTbl.glTexParameterIuivEXT = driverTbl.glTexParameterIuivEXT;
   }
   driverTbl.glTexParameterIuivEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTexParameterIivEXT" );
}

static void REGAL_CALL loader_glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexParameterIivEXT, "glGetTexParameterIivEXT");
   if ( !driverTbl.glGetTexParameterIivEXT ) {
      driverTbl.glGetTexParameterIivEXT = missing_glGetTexParameterIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexParameterIivEXT == loader_glGetTexParameterIivEXT) {
      rCtx->dsp.emuTbl.glGetTexParameterIivEXT = driverTbl.glGetTexParameterIivEXT;
   }
   driverTbl.glGetTexParameterIivEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTexParameterIuivEXT" );
}

static void REGAL_CALL loader_glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexParameterIuivEXT, "glGetTexParameterIuivEXT");
   if ( !driverTbl.glGetTexParameterIuivEXT ) {
      driverTbl.glGetTexParameterIuivEXT = missing_glGetTexParameterIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexParameterIuivEXT == loader_glGetTexParameterIuivEXT) {
      rCtx->dsp.emuTbl.glGetTexParameterIuivEXT = driverTbl.glGetTexParameterIuivEXT;
   }
   driverTbl.glGetTexParameterIuivEXT(target, pname, params);
}

static void REGAL_CALL missing_glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glClearColorIiEXT" );
}

static void REGAL_CALL loader_glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClearColorIiEXT, "glClearColorIiEXT");
   if ( !driverTbl.glClearColorIiEXT ) {
      driverTbl.glClearColorIiEXT = missing_glClearColorIiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClearColorIiEXT == loader_glClearColorIiEXT) {
      rCtx->dsp.emuTbl.glClearColorIiEXT = driverTbl.glClearColorIiEXT;
   }
   driverTbl.glClearColorIiEXT(red, green, blue, alpha);
}

static void REGAL_CALL missing_glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "Called missing function glClearColorIuiEXT" );
}

static void REGAL_CALL loader_glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClearColorIuiEXT, "glClearColorIuiEXT");
   if ( !driverTbl.glClearColorIuiEXT ) {
      driverTbl.glClearColorIuiEXT = missing_glClearColorIuiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClearColorIuiEXT == loader_glClearColorIuiEXT) {
      rCtx->dsp.emuTbl.glClearColorIuiEXT = driverTbl.glClearColorIuiEXT;
   }
   driverTbl.glClearColorIuiEXT(red, green, blue, alpha);
}

// GL_GREMEDY_frame_terminator

static void REGAL_CALL missing_glFrameTerminatorGREMEDY(void)
{
   Warning( "Called missing function glFrameTerminatorGREMEDY" );
}

static void REGAL_CALL loader_glFrameTerminatorGREMEDY(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFrameTerminatorGREMEDY, "glFrameTerminatorGREMEDY");
   if ( !driverTbl.glFrameTerminatorGREMEDY ) {
      driverTbl.glFrameTerminatorGREMEDY = missing_glFrameTerminatorGREMEDY;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFrameTerminatorGREMEDY == loader_glFrameTerminatorGREMEDY) {
      rCtx->dsp.emuTbl.glFrameTerminatorGREMEDY = driverTbl.glFrameTerminatorGREMEDY;
   }
   driverTbl.glFrameTerminatorGREMEDY();
}

// GL_NV_conditional_render

static void REGAL_CALL missing_glBeginConditionalRenderNV(GLuint id, GLenum mode)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glBeginConditionalRenderNV" );
}

static void REGAL_CALL loader_glBeginConditionalRenderNV(GLuint id, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBeginConditionalRenderNV, "glBeginConditionalRenderNV");
   if ( !driverTbl.glBeginConditionalRenderNV ) {
      driverTbl.glBeginConditionalRenderNV = missing_glBeginConditionalRenderNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBeginConditionalRenderNV == loader_glBeginConditionalRenderNV) {
      rCtx->dsp.emuTbl.glBeginConditionalRenderNV = driverTbl.glBeginConditionalRenderNV;
   }
   driverTbl.glBeginConditionalRenderNV(id, mode);
}

static void REGAL_CALL missing_glEndConditionalRenderNV(void)
{
   Warning( "Called missing function glEndConditionalRenderNV" );
}

static void REGAL_CALL loader_glEndConditionalRenderNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndConditionalRenderNV, "glEndConditionalRenderNV");
   if ( !driverTbl.glEndConditionalRenderNV ) {
      driverTbl.glEndConditionalRenderNV = missing_glEndConditionalRenderNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndConditionalRenderNV == loader_glEndConditionalRenderNV) {
      rCtx->dsp.emuTbl.glEndConditionalRenderNV = driverTbl.glEndConditionalRenderNV;
   }
   driverTbl.glEndConditionalRenderNV();
}

// GL_NV_present_video

static void REGAL_CALL missing_glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1)
{
   UNUSED_PARAMETER(video_slot);
   UNUSED_PARAMETER(minPresentTime);
   UNUSED_PARAMETER(beginPresentTimeId);
   UNUSED_PARAMETER(presentDurationId);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(target0);
   UNUSED_PARAMETER(fill0);
   UNUSED_PARAMETER(key0);
   UNUSED_PARAMETER(target1);
   UNUSED_PARAMETER(fill1);
   UNUSED_PARAMETER(key1);
   Warning( "Called missing function glPresentFrameKeyedNV" );
}

static void REGAL_CALL loader_glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPresentFrameKeyedNV, "glPresentFrameKeyedNV");
   if ( !driverTbl.glPresentFrameKeyedNV ) {
      driverTbl.glPresentFrameKeyedNV = missing_glPresentFrameKeyedNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPresentFrameKeyedNV == loader_glPresentFrameKeyedNV) {
      rCtx->dsp.emuTbl.glPresentFrameKeyedNV = driverTbl.glPresentFrameKeyedNV;
   }
   driverTbl.glPresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
}

static void REGAL_CALL missing_glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3)
{
   UNUSED_PARAMETER(video_slot);
   UNUSED_PARAMETER(minPresentTime);
   UNUSED_PARAMETER(beginPresentTimeId);
   UNUSED_PARAMETER(presentDurationId);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(target0);
   UNUSED_PARAMETER(fill0);
   UNUSED_PARAMETER(target1);
   UNUSED_PARAMETER(fill1);
   UNUSED_PARAMETER(target2);
   UNUSED_PARAMETER(fill2);
   UNUSED_PARAMETER(target3);
   UNUSED_PARAMETER(fill3);
   Warning( "Called missing function glPresentFrameDualFillNV" );
}

static void REGAL_CALL loader_glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPresentFrameDualFillNV, "glPresentFrameDualFillNV");
   if ( !driverTbl.glPresentFrameDualFillNV ) {
      driverTbl.glPresentFrameDualFillNV = missing_glPresentFrameDualFillNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPresentFrameDualFillNV == loader_glPresentFrameDualFillNV) {
      rCtx->dsp.emuTbl.glPresentFrameDualFillNV = driverTbl.glPresentFrameDualFillNV;
   }
   driverTbl.glPresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
}

static void REGAL_CALL missing_glGetVideoivNV(GLuint video_slot, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(video_slot);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVideoivNV" );
}

static void REGAL_CALL loader_glGetVideoivNV(GLuint video_slot, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVideoivNV, "glGetVideoivNV");
   if ( !driverTbl.glGetVideoivNV ) {
      driverTbl.glGetVideoivNV = missing_glGetVideoivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVideoivNV == loader_glGetVideoivNV) {
      rCtx->dsp.emuTbl.glGetVideoivNV = driverTbl.glGetVideoivNV;
   }
   driverTbl.glGetVideoivNV(video_slot, pname, params);
}

static void REGAL_CALL missing_glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(video_slot);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVideouivNV" );
}

static void REGAL_CALL loader_glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVideouivNV, "glGetVideouivNV");
   if ( !driverTbl.glGetVideouivNV ) {
      driverTbl.glGetVideouivNV = missing_glGetVideouivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVideouivNV == loader_glGetVideouivNV) {
      rCtx->dsp.emuTbl.glGetVideouivNV = driverTbl.glGetVideouivNV;
   }
   driverTbl.glGetVideouivNV(video_slot, pname, params);
}

static void REGAL_CALL missing_glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT *params)
{
   UNUSED_PARAMETER(video_slot);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVideoi64vNV" );
}

static void REGAL_CALL loader_glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVideoi64vNV, "glGetVideoi64vNV");
   if ( !driverTbl.glGetVideoi64vNV ) {
      driverTbl.glGetVideoi64vNV = missing_glGetVideoi64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVideoi64vNV == loader_glGetVideoi64vNV) {
      rCtx->dsp.emuTbl.glGetVideoi64vNV = driverTbl.glGetVideoi64vNV;
   }
   driverTbl.glGetVideoi64vNV(video_slot, pname, params);
}

static void REGAL_CALL missing_glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT *params)
{
   UNUSED_PARAMETER(video_slot);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVideoui64vNV" );
}

static void REGAL_CALL loader_glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVideoui64vNV, "glGetVideoui64vNV");
   if ( !driverTbl.glGetVideoui64vNV ) {
      driverTbl.glGetVideoui64vNV = missing_glGetVideoui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVideoui64vNV == loader_glGetVideoui64vNV) {
      rCtx->dsp.emuTbl.glGetVideoui64vNV = driverTbl.glGetVideoui64vNV;
   }
   driverTbl.glGetVideoui64vNV(video_slot, pname, params);
}

// GL_EXT_transform_feedback

static void REGAL_CALL missing_glBeginTransformFeedbackEXT(GLenum primitiveMode)
{
   UNUSED_PARAMETER(primitiveMode);
   Warning( "Called missing function glBeginTransformFeedbackEXT" );
}

static void REGAL_CALL loader_glBeginTransformFeedbackEXT(GLenum primitiveMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBeginTransformFeedbackEXT, "glBeginTransformFeedbackEXT");
   if ( !driverTbl.glBeginTransformFeedbackEXT ) {
      driverTbl.glBeginTransformFeedbackEXT = missing_glBeginTransformFeedbackEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBeginTransformFeedbackEXT == loader_glBeginTransformFeedbackEXT) {
      rCtx->dsp.emuTbl.glBeginTransformFeedbackEXT = driverTbl.glBeginTransformFeedbackEXT;
   }
   driverTbl.glBeginTransformFeedbackEXT(primitiveMode);
}

static void REGAL_CALL missing_glEndTransformFeedbackEXT(void)
{
   Warning( "Called missing function glEndTransformFeedbackEXT" );
}

static void REGAL_CALL loader_glEndTransformFeedbackEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndTransformFeedbackEXT, "glEndTransformFeedbackEXT");
   if ( !driverTbl.glEndTransformFeedbackEXT ) {
      driverTbl.glEndTransformFeedbackEXT = missing_glEndTransformFeedbackEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndTransformFeedbackEXT == loader_glEndTransformFeedbackEXT) {
      rCtx->dsp.emuTbl.glEndTransformFeedbackEXT = driverTbl.glEndTransformFeedbackEXT;
   }
   driverTbl.glEndTransformFeedbackEXT();
}

static void REGAL_CALL missing_glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   Warning( "Called missing function glBindBufferRangeEXT" );
}

static void REGAL_CALL loader_glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindBufferRangeEXT, "glBindBufferRangeEXT");
   if ( !driverTbl.glBindBufferRangeEXT ) {
      driverTbl.glBindBufferRangeEXT = missing_glBindBufferRangeEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindBufferRangeEXT == loader_glBindBufferRangeEXT) {
      rCtx->dsp.emuTbl.glBindBufferRangeEXT = driverTbl.glBindBufferRangeEXT;
   }
   driverTbl.glBindBufferRangeEXT(target, index, buffer, offset, size);
}

static void REGAL_CALL missing_glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   Warning( "Called missing function glBindBufferOffsetEXT" );
}

static void REGAL_CALL loader_glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindBufferOffsetEXT, "glBindBufferOffsetEXT");
   if ( !driverTbl.glBindBufferOffsetEXT ) {
      driverTbl.glBindBufferOffsetEXT = missing_glBindBufferOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindBufferOffsetEXT == loader_glBindBufferOffsetEXT) {
      rCtx->dsp.emuTbl.glBindBufferOffsetEXT = driverTbl.glBindBufferOffsetEXT;
   }
   driverTbl.glBindBufferOffsetEXT(target, index, buffer, offset);
}

static void REGAL_CALL missing_glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glBindBufferBaseEXT" );
}

static void REGAL_CALL loader_glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindBufferBaseEXT, "glBindBufferBaseEXT");
   if ( !driverTbl.glBindBufferBaseEXT ) {
      driverTbl.glBindBufferBaseEXT = missing_glBindBufferBaseEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindBufferBaseEXT == loader_glBindBufferBaseEXT) {
      rCtx->dsp.emuTbl.glBindBufferBaseEXT = driverTbl.glBindBufferBaseEXT;
   }
   driverTbl.glBindBufferBaseEXT(target, index, buffer);
}

static void REGAL_CALL missing_glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar **varyings, GLenum bufferMode)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(varyings);
   UNUSED_PARAMETER(bufferMode);
   Warning( "Called missing function glTransformFeedbackVaryingsEXT" );
}

static void REGAL_CALL loader_glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar **varyings, GLenum bufferMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTransformFeedbackVaryingsEXT, "glTransformFeedbackVaryingsEXT");
   if ( !driverTbl.glTransformFeedbackVaryingsEXT ) {
      driverTbl.glTransformFeedbackVaryingsEXT = missing_glTransformFeedbackVaryingsEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTransformFeedbackVaryingsEXT == loader_glTransformFeedbackVaryingsEXT) {
      rCtx->dsp.emuTbl.glTransformFeedbackVaryingsEXT = driverTbl.glTransformFeedbackVaryingsEXT;
   }
   driverTbl.glTransformFeedbackVaryingsEXT(program, count, varyings, bufferMode);
}

static void REGAL_CALL missing_glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glGetTransformFeedbackVaryingEXT" );
}

static void REGAL_CALL loader_glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTransformFeedbackVaryingEXT, "glGetTransformFeedbackVaryingEXT");
   if ( !driverTbl.glGetTransformFeedbackVaryingEXT ) {
      driverTbl.glGetTransformFeedbackVaryingEXT = missing_glGetTransformFeedbackVaryingEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTransformFeedbackVaryingEXT == loader_glGetTransformFeedbackVaryingEXT) {
      rCtx->dsp.emuTbl.glGetTransformFeedbackVaryingEXT = driverTbl.glGetTransformFeedbackVaryingEXT;
   }
   driverTbl.glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size, type, name);
}

// GL_EXT_direct_state_access

static void REGAL_CALL missing_glClientAttribDefaultEXT(GLbitfield mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glClientAttribDefaultEXT" );
}

static void REGAL_CALL loader_glClientAttribDefaultEXT(GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glClientAttribDefaultEXT, "glClientAttribDefaultEXT");
   if ( !driverTbl.glClientAttribDefaultEXT ) {
      driverTbl.glClientAttribDefaultEXT = missing_glClientAttribDefaultEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glClientAttribDefaultEXT == loader_glClientAttribDefaultEXT) {
      rCtx->dsp.emuTbl.glClientAttribDefaultEXT = driverTbl.glClientAttribDefaultEXT;
   }
   driverTbl.glClientAttribDefaultEXT(mask);
}

static void REGAL_CALL missing_glPushClientAttribDefaultEXT(GLbitfield mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glPushClientAttribDefaultEXT" );
}

static void REGAL_CALL loader_glPushClientAttribDefaultEXT(GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPushClientAttribDefaultEXT, "glPushClientAttribDefaultEXT");
   if ( !driverTbl.glPushClientAttribDefaultEXT ) {
      driverTbl.glPushClientAttribDefaultEXT = missing_glPushClientAttribDefaultEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPushClientAttribDefaultEXT == loader_glPushClientAttribDefaultEXT) {
      rCtx->dsp.emuTbl.glPushClientAttribDefaultEXT = driverTbl.glPushClientAttribDefaultEXT;
   }
   driverTbl.glPushClientAttribDefaultEXT(mask);
}

static void REGAL_CALL missing_glMatrixLoadfEXT(GLenum mode, const GLfloat *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glMatrixLoadfEXT" );
}

static void REGAL_CALL loader_glMatrixLoadfEXT(GLenum mode, const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixLoadfEXT, "glMatrixLoadfEXT");
   if ( !driverTbl.glMatrixLoadfEXT ) {
      driverTbl.glMatrixLoadfEXT = missing_glMatrixLoadfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixLoadfEXT == loader_glMatrixLoadfEXT) {
      rCtx->dsp.emuTbl.glMatrixLoadfEXT = driverTbl.glMatrixLoadfEXT;
   }
   driverTbl.glMatrixLoadfEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixLoaddEXT(GLenum mode, const GLdouble *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glMatrixLoaddEXT" );
}

static void REGAL_CALL loader_glMatrixLoaddEXT(GLenum mode, const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixLoaddEXT, "glMatrixLoaddEXT");
   if ( !driverTbl.glMatrixLoaddEXT ) {
      driverTbl.glMatrixLoaddEXT = missing_glMatrixLoaddEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixLoaddEXT == loader_glMatrixLoaddEXT) {
      rCtx->dsp.emuTbl.glMatrixLoaddEXT = driverTbl.glMatrixLoaddEXT;
   }
   driverTbl.glMatrixLoaddEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixMultfEXT(GLenum mode, const GLfloat *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glMatrixMultfEXT" );
}

static void REGAL_CALL loader_glMatrixMultfEXT(GLenum mode, const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixMultfEXT, "glMatrixMultfEXT");
   if ( !driverTbl.glMatrixMultfEXT ) {
      driverTbl.glMatrixMultfEXT = missing_glMatrixMultfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixMultfEXT == loader_glMatrixMultfEXT) {
      rCtx->dsp.emuTbl.glMatrixMultfEXT = driverTbl.glMatrixMultfEXT;
   }
   driverTbl.glMatrixMultfEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixMultdEXT(GLenum mode, const GLdouble *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glMatrixMultdEXT" );
}

static void REGAL_CALL loader_glMatrixMultdEXT(GLenum mode, const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixMultdEXT, "glMatrixMultdEXT");
   if ( !driverTbl.glMatrixMultdEXT ) {
      driverTbl.glMatrixMultdEXT = missing_glMatrixMultdEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixMultdEXT == loader_glMatrixMultdEXT) {
      rCtx->dsp.emuTbl.glMatrixMultdEXT = driverTbl.glMatrixMultdEXT;
   }
   driverTbl.glMatrixMultdEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixLoadIdentityEXT(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glMatrixLoadIdentityEXT" );
}

static void REGAL_CALL loader_glMatrixLoadIdentityEXT(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixLoadIdentityEXT, "glMatrixLoadIdentityEXT");
   if ( !driverTbl.glMatrixLoadIdentityEXT ) {
      driverTbl.glMatrixLoadIdentityEXT = missing_glMatrixLoadIdentityEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixLoadIdentityEXT == loader_glMatrixLoadIdentityEXT) {
      rCtx->dsp.emuTbl.glMatrixLoadIdentityEXT = driverTbl.glMatrixLoadIdentityEXT;
   }
   driverTbl.glMatrixLoadIdentityEXT(mode);
}

static void REGAL_CALL missing_glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(angle);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glMatrixRotatefEXT" );
}

static void REGAL_CALL loader_glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixRotatefEXT, "glMatrixRotatefEXT");
   if ( !driverTbl.glMatrixRotatefEXT ) {
      driverTbl.glMatrixRotatefEXT = missing_glMatrixRotatefEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixRotatefEXT == loader_glMatrixRotatefEXT) {
      rCtx->dsp.emuTbl.glMatrixRotatefEXT = driverTbl.glMatrixRotatefEXT;
   }
   driverTbl.glMatrixRotatefEXT(mode, angle, x, y, z);
}

static void REGAL_CALL missing_glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(angle);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glMatrixRotatedEXT" );
}

static void REGAL_CALL loader_glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixRotatedEXT, "glMatrixRotatedEXT");
   if ( !driverTbl.glMatrixRotatedEXT ) {
      driverTbl.glMatrixRotatedEXT = missing_glMatrixRotatedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixRotatedEXT == loader_glMatrixRotatedEXT) {
      rCtx->dsp.emuTbl.glMatrixRotatedEXT = driverTbl.glMatrixRotatedEXT;
   }
   driverTbl.glMatrixRotatedEXT(mode, angle, x, y, z);
}

static void REGAL_CALL missing_glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glMatrixScalefEXT" );
}

static void REGAL_CALL loader_glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixScalefEXT, "glMatrixScalefEXT");
   if ( !driverTbl.glMatrixScalefEXT ) {
      driverTbl.glMatrixScalefEXT = missing_glMatrixScalefEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixScalefEXT == loader_glMatrixScalefEXT) {
      rCtx->dsp.emuTbl.glMatrixScalefEXT = driverTbl.glMatrixScalefEXT;
   }
   driverTbl.glMatrixScalefEXT(mode, x, y, z);
}

static void REGAL_CALL missing_glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glMatrixScaledEXT" );
}

static void REGAL_CALL loader_glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixScaledEXT, "glMatrixScaledEXT");
   if ( !driverTbl.glMatrixScaledEXT ) {
      driverTbl.glMatrixScaledEXT = missing_glMatrixScaledEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixScaledEXT == loader_glMatrixScaledEXT) {
      rCtx->dsp.emuTbl.glMatrixScaledEXT = driverTbl.glMatrixScaledEXT;
   }
   driverTbl.glMatrixScaledEXT(mode, x, y, z);
}

static void REGAL_CALL missing_glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glMatrixTranslatefEXT" );
}

static void REGAL_CALL loader_glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixTranslatefEXT, "glMatrixTranslatefEXT");
   if ( !driverTbl.glMatrixTranslatefEXT ) {
      driverTbl.glMatrixTranslatefEXT = missing_glMatrixTranslatefEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixTranslatefEXT == loader_glMatrixTranslatefEXT) {
      rCtx->dsp.emuTbl.glMatrixTranslatefEXT = driverTbl.glMatrixTranslatefEXT;
   }
   driverTbl.glMatrixTranslatefEXT(mode, x, y, z);
}

static void REGAL_CALL missing_glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glMatrixTranslatedEXT" );
}

static void REGAL_CALL loader_glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixTranslatedEXT, "glMatrixTranslatedEXT");
   if ( !driverTbl.glMatrixTranslatedEXT ) {
      driverTbl.glMatrixTranslatedEXT = missing_glMatrixTranslatedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixTranslatedEXT == loader_glMatrixTranslatedEXT) {
      rCtx->dsp.emuTbl.glMatrixTranslatedEXT = driverTbl.glMatrixTranslatedEXT;
   }
   driverTbl.glMatrixTranslatedEXT(mode, x, y, z);
}

static void REGAL_CALL missing_glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(left);
   UNUSED_PARAMETER(right);
   UNUSED_PARAMETER(bottom);
   UNUSED_PARAMETER(top);
   UNUSED_PARAMETER(zNear);
   UNUSED_PARAMETER(zFar);
   Warning( "Called missing function glMatrixFrustumEXT" );
}

static void REGAL_CALL loader_glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixFrustumEXT, "glMatrixFrustumEXT");
   if ( !driverTbl.glMatrixFrustumEXT ) {
      driverTbl.glMatrixFrustumEXT = missing_glMatrixFrustumEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixFrustumEXT == loader_glMatrixFrustumEXT) {
      rCtx->dsp.emuTbl.glMatrixFrustumEXT = driverTbl.glMatrixFrustumEXT;
   }
   driverTbl.glMatrixFrustumEXT(mode, left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL missing_glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(left);
   UNUSED_PARAMETER(right);
   UNUSED_PARAMETER(bottom);
   UNUSED_PARAMETER(top);
   UNUSED_PARAMETER(zNear);
   UNUSED_PARAMETER(zFar);
   Warning( "Called missing function glMatrixOrthoEXT" );
}

static void REGAL_CALL loader_glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixOrthoEXT, "glMatrixOrthoEXT");
   if ( !driverTbl.glMatrixOrthoEXT ) {
      driverTbl.glMatrixOrthoEXT = missing_glMatrixOrthoEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixOrthoEXT == loader_glMatrixOrthoEXT) {
      rCtx->dsp.emuTbl.glMatrixOrthoEXT = driverTbl.glMatrixOrthoEXT;
   }
   driverTbl.glMatrixOrthoEXT(mode, left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL missing_glMatrixPopEXT(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glMatrixPopEXT" );
}

static void REGAL_CALL loader_glMatrixPopEXT(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixPopEXT, "glMatrixPopEXT");
   if ( !driverTbl.glMatrixPopEXT ) {
      driverTbl.glMatrixPopEXT = missing_glMatrixPopEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixPopEXT == loader_glMatrixPopEXT) {
      rCtx->dsp.emuTbl.glMatrixPopEXT = driverTbl.glMatrixPopEXT;
   }
   driverTbl.glMatrixPopEXT(mode);
}

static void REGAL_CALL missing_glMatrixPushEXT(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glMatrixPushEXT" );
}

static void REGAL_CALL loader_glMatrixPushEXT(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixPushEXT, "glMatrixPushEXT");
   if ( !driverTbl.glMatrixPushEXT ) {
      driverTbl.glMatrixPushEXT = missing_glMatrixPushEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixPushEXT == loader_glMatrixPushEXT) {
      rCtx->dsp.emuTbl.glMatrixPushEXT = driverTbl.glMatrixPushEXT;
   }
   driverTbl.glMatrixPushEXT(mode);
}

static void REGAL_CALL missing_glMatrixLoadTransposefEXT(GLenum mode, const GLfloat *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glMatrixLoadTransposefEXT" );
}

static void REGAL_CALL loader_glMatrixLoadTransposefEXT(GLenum mode, const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixLoadTransposefEXT, "glMatrixLoadTransposefEXT");
   if ( !driverTbl.glMatrixLoadTransposefEXT ) {
      driverTbl.glMatrixLoadTransposefEXT = missing_glMatrixLoadTransposefEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixLoadTransposefEXT == loader_glMatrixLoadTransposefEXT) {
      rCtx->dsp.emuTbl.glMatrixLoadTransposefEXT = driverTbl.glMatrixLoadTransposefEXT;
   }
   driverTbl.glMatrixLoadTransposefEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixLoadTransposedEXT(GLenum mode, const GLdouble *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glMatrixLoadTransposedEXT" );
}

static void REGAL_CALL loader_glMatrixLoadTransposedEXT(GLenum mode, const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixLoadTransposedEXT, "glMatrixLoadTransposedEXT");
   if ( !driverTbl.glMatrixLoadTransposedEXT ) {
      driverTbl.glMatrixLoadTransposedEXT = missing_glMatrixLoadTransposedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixLoadTransposedEXT == loader_glMatrixLoadTransposedEXT) {
      rCtx->dsp.emuTbl.glMatrixLoadTransposedEXT = driverTbl.glMatrixLoadTransposedEXT;
   }
   driverTbl.glMatrixLoadTransposedEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixMultTransposefEXT(GLenum mode, const GLfloat *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glMatrixMultTransposefEXT" );
}

static void REGAL_CALL loader_glMatrixMultTransposefEXT(GLenum mode, const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixMultTransposefEXT, "glMatrixMultTransposefEXT");
   if ( !driverTbl.glMatrixMultTransposefEXT ) {
      driverTbl.glMatrixMultTransposefEXT = missing_glMatrixMultTransposefEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixMultTransposefEXT == loader_glMatrixMultTransposefEXT) {
      rCtx->dsp.emuTbl.glMatrixMultTransposefEXT = driverTbl.glMatrixMultTransposefEXT;
   }
   driverTbl.glMatrixMultTransposefEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixMultTransposedEXT(GLenum mode, const GLdouble *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "Called missing function glMatrixMultTransposedEXT" );
}

static void REGAL_CALL loader_glMatrixMultTransposedEXT(GLenum mode, const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMatrixMultTransposedEXT, "glMatrixMultTransposedEXT");
   if ( !driverTbl.glMatrixMultTransposedEXT ) {
      driverTbl.glMatrixMultTransposedEXT = missing_glMatrixMultTransposedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMatrixMultTransposedEXT == loader_glMatrixMultTransposedEXT) {
      rCtx->dsp.emuTbl.glMatrixMultTransposedEXT = driverTbl.glMatrixMultTransposedEXT;
   }
   driverTbl.glMatrixMultTransposedEXT(mode, m);
}

static void REGAL_CALL missing_glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glTextureParameterfEXT" );
}

static void REGAL_CALL loader_glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureParameterfEXT, "glTextureParameterfEXT");
   if ( !driverTbl.glTextureParameterfEXT ) {
      driverTbl.glTextureParameterfEXT = missing_glTextureParameterfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureParameterfEXT == loader_glTextureParameterfEXT) {
      rCtx->dsp.emuTbl.glTextureParameterfEXT = driverTbl.glTextureParameterfEXT;
   }
   driverTbl.glTextureParameterfEXT(texture, target, pname, param);
}

static void REGAL_CALL missing_glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat *param)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glTextureParameterfvEXT" );
}

static void REGAL_CALL loader_glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureParameterfvEXT, "glTextureParameterfvEXT");
   if ( !driverTbl.glTextureParameterfvEXT ) {
      driverTbl.glTextureParameterfvEXT = missing_glTextureParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureParameterfvEXT == loader_glTextureParameterfvEXT) {
      rCtx->dsp.emuTbl.glTextureParameterfvEXT = driverTbl.glTextureParameterfvEXT;
   }
   driverTbl.glTextureParameterfvEXT(texture, target, pname, param);
}

static void REGAL_CALL missing_glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glTextureParameteriEXT" );
}

static void REGAL_CALL loader_glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureParameteriEXT, "glTextureParameteriEXT");
   if ( !driverTbl.glTextureParameteriEXT ) {
      driverTbl.glTextureParameteriEXT = missing_glTextureParameteriEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureParameteriEXT == loader_glTextureParameteriEXT) {
      rCtx->dsp.emuTbl.glTextureParameteriEXT = driverTbl.glTextureParameteriEXT;
   }
   driverTbl.glTextureParameteriEXT(texture, target, pname, param);
}

static void REGAL_CALL missing_glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *param)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glTextureParameterivEXT" );
}

static void REGAL_CALL loader_glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureParameterivEXT, "glTextureParameterivEXT");
   if ( !driverTbl.glTextureParameterivEXT ) {
      driverTbl.glTextureParameterivEXT = missing_glTextureParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureParameterivEXT == loader_glTextureParameterivEXT) {
      rCtx->dsp.emuTbl.glTextureParameterivEXT = driverTbl.glTextureParameterivEXT;
   }
   driverTbl.glTextureParameterivEXT(texture, target, pname, param);
}

static void REGAL_CALL missing_glTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTextureImage1DEXT" );
}

static void REGAL_CALL loader_glTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureImage1DEXT, "glTextureImage1DEXT");
   if ( !driverTbl.glTextureImage1DEXT ) {
      driverTbl.glTextureImage1DEXT = missing_glTextureImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureImage1DEXT == loader_glTextureImage1DEXT) {
      rCtx->dsp.emuTbl.glTextureImage1DEXT = driverTbl.glTextureImage1DEXT;
   }
   driverTbl.glTextureImage1DEXT(texture, target, level, internalformat, width, border, format, type, pixels);
}

static void REGAL_CALL missing_glTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTextureImage2DEXT" );
}

static void REGAL_CALL loader_glTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureImage2DEXT, "glTextureImage2DEXT");
   if ( !driverTbl.glTextureImage2DEXT ) {
      driverTbl.glTextureImage2DEXT = missing_glTextureImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureImage2DEXT == loader_glTextureImage2DEXT) {
      rCtx->dsp.emuTbl.glTextureImage2DEXT = driverTbl.glTextureImage2DEXT;
   }
   driverTbl.glTextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, type, pixels);
}

static void REGAL_CALL missing_glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTextureSubImage1DEXT" );
}

static void REGAL_CALL loader_glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureSubImage1DEXT, "glTextureSubImage1DEXT");
   if ( !driverTbl.glTextureSubImage1DEXT ) {
      driverTbl.glTextureSubImage1DEXT = missing_glTextureSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureSubImage1DEXT == loader_glTextureSubImage1DEXT) {
      rCtx->dsp.emuTbl.glTextureSubImage1DEXT = driverTbl.glTextureSubImage1DEXT;
   }
   driverTbl.glTextureSubImage1DEXT(texture, target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL missing_glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTextureSubImage2DEXT" );
}

static void REGAL_CALL loader_glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureSubImage2DEXT, "glTextureSubImage2DEXT");
   if ( !driverTbl.glTextureSubImage2DEXT ) {
      driverTbl.glTextureSubImage2DEXT = missing_glTextureSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureSubImage2DEXT == loader_glTextureSubImage2DEXT) {
      rCtx->dsp.emuTbl.glTextureSubImage2DEXT = driverTbl.glTextureSubImage2DEXT;
   }
   driverTbl.glTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL missing_glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   Warning( "Called missing function glCopyTextureImage1DEXT" );
}

static void REGAL_CALL loader_glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTextureImage1DEXT, "glCopyTextureImage1DEXT");
   if ( !driverTbl.glCopyTextureImage1DEXT ) {
      driverTbl.glCopyTextureImage1DEXT = missing_glCopyTextureImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTextureImage1DEXT == loader_glCopyTextureImage1DEXT) {
      rCtx->dsp.emuTbl.glCopyTextureImage1DEXT = driverTbl.glCopyTextureImage1DEXT;
   }
   driverTbl.glCopyTextureImage1DEXT(texture, target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL missing_glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   Warning( "Called missing function glCopyTextureImage2DEXT" );
}

static void REGAL_CALL loader_glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTextureImage2DEXT, "glCopyTextureImage2DEXT");
   if ( !driverTbl.glCopyTextureImage2DEXT ) {
      driverTbl.glCopyTextureImage2DEXT = missing_glCopyTextureImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTextureImage2DEXT == loader_glCopyTextureImage2DEXT) {
      rCtx->dsp.emuTbl.glCopyTextureImage2DEXT = driverTbl.glCopyTextureImage2DEXT;
   }
   driverTbl.glCopyTextureImage2DEXT(texture, target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL missing_glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "Called missing function glCopyTextureSubImage1DEXT" );
}

static void REGAL_CALL loader_glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTextureSubImage1DEXT, "glCopyTextureSubImage1DEXT");
   if ( !driverTbl.glCopyTextureSubImage1DEXT ) {
      driverTbl.glCopyTextureSubImage1DEXT = missing_glCopyTextureSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTextureSubImage1DEXT == loader_glCopyTextureSubImage1DEXT) {
      rCtx->dsp.emuTbl.glCopyTextureSubImage1DEXT = driverTbl.glCopyTextureSubImage1DEXT;
   }
   driverTbl.glCopyTextureSubImage1DEXT(texture, target, level, xoffset, x, y, width);
}

static void REGAL_CALL missing_glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glCopyTextureSubImage2DEXT" );
}

static void REGAL_CALL loader_glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTextureSubImage2DEXT, "glCopyTextureSubImage2DEXT");
   if ( !driverTbl.glCopyTextureSubImage2DEXT ) {
      driverTbl.glCopyTextureSubImage2DEXT = missing_glCopyTextureSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTextureSubImage2DEXT == loader_glCopyTextureSubImage2DEXT) {
      rCtx->dsp.emuTbl.glCopyTextureSubImage2DEXT = driverTbl.glCopyTextureSubImage2DEXT;
   }
   driverTbl.glCopyTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL missing_glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glGetTextureImageEXT" );
}

static void REGAL_CALL loader_glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTextureImageEXT, "glGetTextureImageEXT");
   if ( !driverTbl.glGetTextureImageEXT ) {
      driverTbl.glGetTextureImageEXT = missing_glGetTextureImageEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTextureImageEXT == loader_glGetTextureImageEXT) {
      rCtx->dsp.emuTbl.glGetTextureImageEXT = driverTbl.glGetTextureImageEXT;
   }
   driverTbl.glGetTextureImageEXT(texture, target, level, format, type, pixels);
}

static void REGAL_CALL missing_glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTextureParameterfvEXT" );
}

static void REGAL_CALL loader_glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTextureParameterfvEXT, "glGetTextureParameterfvEXT");
   if ( !driverTbl.glGetTextureParameterfvEXT ) {
      driverTbl.glGetTextureParameterfvEXT = missing_glGetTextureParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTextureParameterfvEXT == loader_glGetTextureParameterfvEXT) {
      rCtx->dsp.emuTbl.glGetTextureParameterfvEXT = driverTbl.glGetTextureParameterfvEXT;
   }
   driverTbl.glGetTextureParameterfvEXT(texture, target, pname, params);
}

static void REGAL_CALL missing_glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTextureParameterivEXT" );
}

static void REGAL_CALL loader_glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTextureParameterivEXT, "glGetTextureParameterivEXT");
   if ( !driverTbl.glGetTextureParameterivEXT ) {
      driverTbl.glGetTextureParameterivEXT = missing_glGetTextureParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTextureParameterivEXT == loader_glGetTextureParameterivEXT) {
      rCtx->dsp.emuTbl.glGetTextureParameterivEXT = driverTbl.glGetTextureParameterivEXT;
   }
   driverTbl.glGetTextureParameterivEXT(texture, target, pname, params);
}

static void REGAL_CALL missing_glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTextureLevelParameterfvEXT" );
}

static void REGAL_CALL loader_glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTextureLevelParameterfvEXT, "glGetTextureLevelParameterfvEXT");
   if ( !driverTbl.glGetTextureLevelParameterfvEXT ) {
      driverTbl.glGetTextureLevelParameterfvEXT = missing_glGetTextureLevelParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTextureLevelParameterfvEXT == loader_glGetTextureLevelParameterfvEXT) {
      rCtx->dsp.emuTbl.glGetTextureLevelParameterfvEXT = driverTbl.glGetTextureLevelParameterfvEXT;
   }
   driverTbl.glGetTextureLevelParameterfvEXT(texture, target, level, pname, params);
}

static void REGAL_CALL missing_glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTextureLevelParameterivEXT" );
}

static void REGAL_CALL loader_glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTextureLevelParameterivEXT, "glGetTextureLevelParameterivEXT");
   if ( !driverTbl.glGetTextureLevelParameterivEXT ) {
      driverTbl.glGetTextureLevelParameterivEXT = missing_glGetTextureLevelParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTextureLevelParameterivEXT == loader_glGetTextureLevelParameterivEXT) {
      rCtx->dsp.emuTbl.glGetTextureLevelParameterivEXT = driverTbl.glGetTextureLevelParameterivEXT;
   }
   driverTbl.glGetTextureLevelParameterivEXT(texture, target, level, pname, params);
}

static void REGAL_CALL missing_glTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTextureImage3DEXT" );
}

static void REGAL_CALL loader_glTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureImage3DEXT, "glTextureImage3DEXT");
   if ( !driverTbl.glTextureImage3DEXT ) {
      driverTbl.glTextureImage3DEXT = missing_glTextureImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureImage3DEXT == loader_glTextureImage3DEXT) {
      rCtx->dsp.emuTbl.glTextureImage3DEXT = driverTbl.glTextureImage3DEXT;
   }
   driverTbl.glTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
}

static void REGAL_CALL missing_glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glTextureSubImage3DEXT" );
}

static void REGAL_CALL loader_glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureSubImage3DEXT, "glTextureSubImage3DEXT");
   if ( !driverTbl.glTextureSubImage3DEXT ) {
      driverTbl.glTextureSubImage3DEXT = missing_glTextureSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureSubImage3DEXT == loader_glTextureSubImage3DEXT) {
      rCtx->dsp.emuTbl.glTextureSubImage3DEXT = driverTbl.glTextureSubImage3DEXT;
   }
   driverTbl.glTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

static void REGAL_CALL missing_glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glCopyTextureSubImage3DEXT" );
}

static void REGAL_CALL loader_glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyTextureSubImage3DEXT, "glCopyTextureSubImage3DEXT");
   if ( !driverTbl.glCopyTextureSubImage3DEXT ) {
      driverTbl.glCopyTextureSubImage3DEXT = missing_glCopyTextureSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyTextureSubImage3DEXT == loader_glCopyTextureSubImage3DEXT) {
      rCtx->dsp.emuTbl.glCopyTextureSubImage3DEXT = driverTbl.glCopyTextureSubImage3DEXT;
   }
   driverTbl.glCopyTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

static void REGAL_CALL missing_glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glMultiTexParameterfEXT" );
}

static void REGAL_CALL loader_glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexParameterfEXT, "glMultiTexParameterfEXT");
   if ( !driverTbl.glMultiTexParameterfEXT ) {
      driverTbl.glMultiTexParameterfEXT = missing_glMultiTexParameterfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexParameterfEXT == loader_glMultiTexParameterfEXT) {
      rCtx->dsp.emuTbl.glMultiTexParameterfEXT = driverTbl.glMultiTexParameterfEXT;
   }
   driverTbl.glMultiTexParameterfEXT(texunit, target, pname, param);
}

static void REGAL_CALL missing_glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glMultiTexParameterfvEXT" );
}

static void REGAL_CALL loader_glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexParameterfvEXT, "glMultiTexParameterfvEXT");
   if ( !driverTbl.glMultiTexParameterfvEXT ) {
      driverTbl.glMultiTexParameterfvEXT = missing_glMultiTexParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexParameterfvEXT == loader_glMultiTexParameterfvEXT) {
      rCtx->dsp.emuTbl.glMultiTexParameterfvEXT = driverTbl.glMultiTexParameterfvEXT;
   }
   driverTbl.glMultiTexParameterfvEXT(texunit, target, pname, param);
}

static void REGAL_CALL missing_glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glMultiTexParameteriEXT" );
}

static void REGAL_CALL loader_glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexParameteriEXT, "glMultiTexParameteriEXT");
   if ( !driverTbl.glMultiTexParameteriEXT ) {
      driverTbl.glMultiTexParameteriEXT = missing_glMultiTexParameteriEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexParameteriEXT == loader_glMultiTexParameteriEXT) {
      rCtx->dsp.emuTbl.glMultiTexParameteriEXT = driverTbl.glMultiTexParameteriEXT;
   }
   driverTbl.glMultiTexParameteriEXT(texunit, target, pname, param);
}

static void REGAL_CALL missing_glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glMultiTexParameterivEXT" );
}

static void REGAL_CALL loader_glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexParameterivEXT, "glMultiTexParameterivEXT");
   if ( !driverTbl.glMultiTexParameterivEXT ) {
      driverTbl.glMultiTexParameterivEXT = missing_glMultiTexParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexParameterivEXT == loader_glMultiTexParameterivEXT) {
      rCtx->dsp.emuTbl.glMultiTexParameterivEXT = driverTbl.glMultiTexParameterivEXT;
   }
   driverTbl.glMultiTexParameterivEXT(texunit, target, pname, param);
}

static void REGAL_CALL missing_glMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glMultiTexImage1DEXT" );
}

static void REGAL_CALL loader_glMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexImage1DEXT, "glMultiTexImage1DEXT");
   if ( !driverTbl.glMultiTexImage1DEXT ) {
      driverTbl.glMultiTexImage1DEXT = missing_glMultiTexImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexImage1DEXT == loader_glMultiTexImage1DEXT) {
      rCtx->dsp.emuTbl.glMultiTexImage1DEXT = driverTbl.glMultiTexImage1DEXT;
   }
   driverTbl.glMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, type, pixels);
}

static void REGAL_CALL missing_glMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glMultiTexImage2DEXT" );
}

static void REGAL_CALL loader_glMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexImage2DEXT, "glMultiTexImage2DEXT");
   if ( !driverTbl.glMultiTexImage2DEXT ) {
      driverTbl.glMultiTexImage2DEXT = missing_glMultiTexImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexImage2DEXT == loader_glMultiTexImage2DEXT) {
      rCtx->dsp.emuTbl.glMultiTexImage2DEXT = driverTbl.glMultiTexImage2DEXT;
   }
   driverTbl.glMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, type, pixels);
}

static void REGAL_CALL missing_glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glMultiTexSubImage1DEXT" );
}

static void REGAL_CALL loader_glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexSubImage1DEXT, "glMultiTexSubImage1DEXT");
   if ( !driverTbl.glMultiTexSubImage1DEXT ) {
      driverTbl.glMultiTexSubImage1DEXT = missing_glMultiTexSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexSubImage1DEXT == loader_glMultiTexSubImage1DEXT) {
      rCtx->dsp.emuTbl.glMultiTexSubImage1DEXT = driverTbl.glMultiTexSubImage1DEXT;
   }
   driverTbl.glMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL missing_glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glMultiTexSubImage2DEXT" );
}

static void REGAL_CALL loader_glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexSubImage2DEXT, "glMultiTexSubImage2DEXT");
   if ( !driverTbl.glMultiTexSubImage2DEXT ) {
      driverTbl.glMultiTexSubImage2DEXT = missing_glMultiTexSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexSubImage2DEXT == loader_glMultiTexSubImage2DEXT) {
      rCtx->dsp.emuTbl.glMultiTexSubImage2DEXT = driverTbl.glMultiTexSubImage2DEXT;
   }
   driverTbl.glMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL missing_glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   Warning( "Called missing function glCopyMultiTexImage1DEXT" );
}

static void REGAL_CALL loader_glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyMultiTexImage1DEXT, "glCopyMultiTexImage1DEXT");
   if ( !driverTbl.glCopyMultiTexImage1DEXT ) {
      driverTbl.glCopyMultiTexImage1DEXT = missing_glCopyMultiTexImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyMultiTexImage1DEXT == loader_glCopyMultiTexImage1DEXT) {
      rCtx->dsp.emuTbl.glCopyMultiTexImage1DEXT = driverTbl.glCopyMultiTexImage1DEXT;
   }
   driverTbl.glCopyMultiTexImage1DEXT(texunit, target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL missing_glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   Warning( "Called missing function glCopyMultiTexImage2DEXT" );
}

static void REGAL_CALL loader_glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyMultiTexImage2DEXT, "glCopyMultiTexImage2DEXT");
   if ( !driverTbl.glCopyMultiTexImage2DEXT ) {
      driverTbl.glCopyMultiTexImage2DEXT = missing_glCopyMultiTexImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyMultiTexImage2DEXT == loader_glCopyMultiTexImage2DEXT) {
      rCtx->dsp.emuTbl.glCopyMultiTexImage2DEXT = driverTbl.glCopyMultiTexImage2DEXT;
   }
   driverTbl.glCopyMultiTexImage2DEXT(texunit, target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL missing_glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "Called missing function glCopyMultiTexSubImage1DEXT" );
}

static void REGAL_CALL loader_glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyMultiTexSubImage1DEXT, "glCopyMultiTexSubImage1DEXT");
   if ( !driverTbl.glCopyMultiTexSubImage1DEXT ) {
      driverTbl.glCopyMultiTexSubImage1DEXT = missing_glCopyMultiTexSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyMultiTexSubImage1DEXT == loader_glCopyMultiTexSubImage1DEXT) {
      rCtx->dsp.emuTbl.glCopyMultiTexSubImage1DEXT = driverTbl.glCopyMultiTexSubImage1DEXT;
   }
   driverTbl.glCopyMultiTexSubImage1DEXT(texunit, target, level, xoffset, x, y, width);
}

static void REGAL_CALL missing_glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glCopyMultiTexSubImage2DEXT" );
}

static void REGAL_CALL loader_glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyMultiTexSubImage2DEXT, "glCopyMultiTexSubImage2DEXT");
   if ( !driverTbl.glCopyMultiTexSubImage2DEXT ) {
      driverTbl.glCopyMultiTexSubImage2DEXT = missing_glCopyMultiTexSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyMultiTexSubImage2DEXT == loader_glCopyMultiTexSubImage2DEXT) {
      rCtx->dsp.emuTbl.glCopyMultiTexSubImage2DEXT = driverTbl.glCopyMultiTexSubImage2DEXT;
   }
   driverTbl.glCopyMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL missing_glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glGetMultiTexImageEXT" );
}

static void REGAL_CALL loader_glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMultiTexImageEXT, "glGetMultiTexImageEXT");
   if ( !driverTbl.glGetMultiTexImageEXT ) {
      driverTbl.glGetMultiTexImageEXT = missing_glGetMultiTexImageEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMultiTexImageEXT == loader_glGetMultiTexImageEXT) {
      rCtx->dsp.emuTbl.glGetMultiTexImageEXT = driverTbl.glGetMultiTexImageEXT;
   }
   driverTbl.glGetMultiTexImageEXT(texunit, target, level, format, type, pixels);
}

static void REGAL_CALL missing_glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMultiTexParameterfvEXT" );
}

static void REGAL_CALL loader_glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMultiTexParameterfvEXT, "glGetMultiTexParameterfvEXT");
   if ( !driverTbl.glGetMultiTexParameterfvEXT ) {
      driverTbl.glGetMultiTexParameterfvEXT = missing_glGetMultiTexParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMultiTexParameterfvEXT == loader_glGetMultiTexParameterfvEXT) {
      rCtx->dsp.emuTbl.glGetMultiTexParameterfvEXT = driverTbl.glGetMultiTexParameterfvEXT;
   }
   driverTbl.glGetMultiTexParameterfvEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMultiTexParameterivEXT" );
}

static void REGAL_CALL loader_glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMultiTexParameterivEXT, "glGetMultiTexParameterivEXT");
   if ( !driverTbl.glGetMultiTexParameterivEXT ) {
      driverTbl.glGetMultiTexParameterivEXT = missing_glGetMultiTexParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMultiTexParameterivEXT == loader_glGetMultiTexParameterivEXT) {
      rCtx->dsp.emuTbl.glGetMultiTexParameterivEXT = driverTbl.glGetMultiTexParameterivEXT;
   }
   driverTbl.glGetMultiTexParameterivEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMultiTexLevelParameterfvEXT" );
}

static void REGAL_CALL loader_glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMultiTexLevelParameterfvEXT, "glGetMultiTexLevelParameterfvEXT");
   if ( !driverTbl.glGetMultiTexLevelParameterfvEXT ) {
      driverTbl.glGetMultiTexLevelParameterfvEXT = missing_glGetMultiTexLevelParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMultiTexLevelParameterfvEXT == loader_glGetMultiTexLevelParameterfvEXT) {
      rCtx->dsp.emuTbl.glGetMultiTexLevelParameterfvEXT = driverTbl.glGetMultiTexLevelParameterfvEXT;
   }
   driverTbl.glGetMultiTexLevelParameterfvEXT(texunit, target, level, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMultiTexLevelParameterivEXT" );
}

static void REGAL_CALL loader_glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMultiTexLevelParameterivEXT, "glGetMultiTexLevelParameterivEXT");
   if ( !driverTbl.glGetMultiTexLevelParameterivEXT ) {
      driverTbl.glGetMultiTexLevelParameterivEXT = missing_glGetMultiTexLevelParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMultiTexLevelParameterivEXT == loader_glGetMultiTexLevelParameterivEXT) {
      rCtx->dsp.emuTbl.glGetMultiTexLevelParameterivEXT = driverTbl.glGetMultiTexLevelParameterivEXT;
   }
   driverTbl.glGetMultiTexLevelParameterivEXT(texunit, target, level, pname, params);
}

static void REGAL_CALL missing_glMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glMultiTexImage3DEXT" );
}

static void REGAL_CALL loader_glMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexImage3DEXT, "glMultiTexImage3DEXT");
   if ( !driverTbl.glMultiTexImage3DEXT ) {
      driverTbl.glMultiTexImage3DEXT = missing_glMultiTexImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexImage3DEXT == loader_glMultiTexImage3DEXT) {
      rCtx->dsp.emuTbl.glMultiTexImage3DEXT = driverTbl.glMultiTexImage3DEXT;
   }
   driverTbl.glMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
}

static void REGAL_CALL missing_glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glMultiTexSubImage3DEXT" );
}

static void REGAL_CALL loader_glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexSubImage3DEXT, "glMultiTexSubImage3DEXT");
   if ( !driverTbl.glMultiTexSubImage3DEXT ) {
      driverTbl.glMultiTexSubImage3DEXT = missing_glMultiTexSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexSubImage3DEXT == loader_glMultiTexSubImage3DEXT) {
      rCtx->dsp.emuTbl.glMultiTexSubImage3DEXT = driverTbl.glMultiTexSubImage3DEXT;
   }
   driverTbl.glMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

static void REGAL_CALL missing_glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glCopyMultiTexSubImage3DEXT" );
}

static void REGAL_CALL loader_glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyMultiTexSubImage3DEXT, "glCopyMultiTexSubImage3DEXT");
   if ( !driverTbl.glCopyMultiTexSubImage3DEXT ) {
      driverTbl.glCopyMultiTexSubImage3DEXT = missing_glCopyMultiTexSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyMultiTexSubImage3DEXT == loader_glCopyMultiTexSubImage3DEXT) {
      rCtx->dsp.emuTbl.glCopyMultiTexSubImage3DEXT = driverTbl.glCopyMultiTexSubImage3DEXT;
   }
   driverTbl.glCopyMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

static void REGAL_CALL missing_glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(texture);
   Warning( "Called missing function glBindMultiTextureEXT" );
}

static void REGAL_CALL loader_glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindMultiTextureEXT, "glBindMultiTextureEXT");
   if ( !driverTbl.glBindMultiTextureEXT ) {
      driverTbl.glBindMultiTextureEXT = missing_glBindMultiTextureEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindMultiTextureEXT == loader_glBindMultiTextureEXT) {
      rCtx->dsp.emuTbl.glBindMultiTextureEXT = driverTbl.glBindMultiTextureEXT;
   }
   driverTbl.glBindMultiTextureEXT(texunit, target, texture);
}

static void REGAL_CALL missing_glEnableClientStateIndexedEXT(GLenum array, GLuint index)
{
   UNUSED_PARAMETER(array);
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glEnableClientStateIndexedEXT" );
}

static void REGAL_CALL loader_glEnableClientStateIndexedEXT(GLenum array, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEnableClientStateIndexedEXT, "glEnableClientStateIndexedEXT");
   if ( !driverTbl.glEnableClientStateIndexedEXT ) {
      driverTbl.glEnableClientStateIndexedEXT = missing_glEnableClientStateIndexedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEnableClientStateIndexedEXT == loader_glEnableClientStateIndexedEXT) {
      rCtx->dsp.emuTbl.glEnableClientStateIndexedEXT = driverTbl.glEnableClientStateIndexedEXT;
   }
   driverTbl.glEnableClientStateIndexedEXT(array, index);
}

static void REGAL_CALL missing_glDisableClientStateIndexedEXT(GLenum array, GLuint index)
{
   UNUSED_PARAMETER(array);
   UNUSED_PARAMETER(index);
   Warning( "Called missing function glDisableClientStateIndexedEXT" );
}

static void REGAL_CALL loader_glDisableClientStateIndexedEXT(GLenum array, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDisableClientStateIndexedEXT, "glDisableClientStateIndexedEXT");
   if ( !driverTbl.glDisableClientStateIndexedEXT ) {
      driverTbl.glDisableClientStateIndexedEXT = missing_glDisableClientStateIndexedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDisableClientStateIndexedEXT == loader_glDisableClientStateIndexedEXT) {
      rCtx->dsp.emuTbl.glDisableClientStateIndexedEXT = driverTbl.glDisableClientStateIndexedEXT;
   }
   driverTbl.glDisableClientStateIndexedEXT(array, index);
}

static void REGAL_CALL missing_glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glMultiTexCoordPointerEXT" );
}

static void REGAL_CALL loader_glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexCoordPointerEXT, "glMultiTexCoordPointerEXT");
   if ( !driverTbl.glMultiTexCoordPointerEXT ) {
      driverTbl.glMultiTexCoordPointerEXT = missing_glMultiTexCoordPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexCoordPointerEXT == loader_glMultiTexCoordPointerEXT) {
      rCtx->dsp.emuTbl.glMultiTexCoordPointerEXT = driverTbl.glMultiTexCoordPointerEXT;
   }
   driverTbl.glMultiTexCoordPointerEXT(texunit, size, type, stride, pointer);
}

static void REGAL_CALL missing_glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glMultiTexEnvfEXT" );
}

static void REGAL_CALL loader_glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexEnvfEXT, "glMultiTexEnvfEXT");
   if ( !driverTbl.glMultiTexEnvfEXT ) {
      driverTbl.glMultiTexEnvfEXT = missing_glMultiTexEnvfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexEnvfEXT == loader_glMultiTexEnvfEXT) {
      rCtx->dsp.emuTbl.glMultiTexEnvfEXT = driverTbl.glMultiTexEnvfEXT;
   }
   driverTbl.glMultiTexEnvfEXT(texunit, target, pname, param);
}

static void REGAL_CALL missing_glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glMultiTexEnvfvEXT" );
}

static void REGAL_CALL loader_glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexEnvfvEXT, "glMultiTexEnvfvEXT");
   if ( !driverTbl.glMultiTexEnvfvEXT ) {
      driverTbl.glMultiTexEnvfvEXT = missing_glMultiTexEnvfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexEnvfvEXT == loader_glMultiTexEnvfvEXT) {
      rCtx->dsp.emuTbl.glMultiTexEnvfvEXT = driverTbl.glMultiTexEnvfvEXT;
   }
   driverTbl.glMultiTexEnvfvEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glMultiTexEnviEXT" );
}

static void REGAL_CALL loader_glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexEnviEXT, "glMultiTexEnviEXT");
   if ( !driverTbl.glMultiTexEnviEXT ) {
      driverTbl.glMultiTexEnviEXT = missing_glMultiTexEnviEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexEnviEXT == loader_glMultiTexEnviEXT) {
      rCtx->dsp.emuTbl.glMultiTexEnviEXT = driverTbl.glMultiTexEnviEXT;
   }
   driverTbl.glMultiTexEnviEXT(texunit, target, pname, param);
}

static void REGAL_CALL missing_glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glMultiTexEnvivEXT" );
}

static void REGAL_CALL loader_glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexEnvivEXT, "glMultiTexEnvivEXT");
   if ( !driverTbl.glMultiTexEnvivEXT ) {
      driverTbl.glMultiTexEnvivEXT = missing_glMultiTexEnvivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexEnvivEXT == loader_glMultiTexEnvivEXT) {
      rCtx->dsp.emuTbl.glMultiTexEnvivEXT = driverTbl.glMultiTexEnvivEXT;
   }
   driverTbl.glMultiTexEnvivEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glMultiTexGendEXT" );
}

static void REGAL_CALL loader_glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexGendEXT, "glMultiTexGendEXT");
   if ( !driverTbl.glMultiTexGendEXT ) {
      driverTbl.glMultiTexGendEXT = missing_glMultiTexGendEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexGendEXT == loader_glMultiTexGendEXT) {
      rCtx->dsp.emuTbl.glMultiTexGendEXT = driverTbl.glMultiTexGendEXT;
   }
   driverTbl.glMultiTexGendEXT(texunit, coord, pname, param);
}

static void REGAL_CALL missing_glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glMultiTexGendvEXT" );
}

static void REGAL_CALL loader_glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexGendvEXT, "glMultiTexGendvEXT");
   if ( !driverTbl.glMultiTexGendvEXT ) {
      driverTbl.glMultiTexGendvEXT = missing_glMultiTexGendvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexGendvEXT == loader_glMultiTexGendvEXT) {
      rCtx->dsp.emuTbl.glMultiTexGendvEXT = driverTbl.glMultiTexGendvEXT;
   }
   driverTbl.glMultiTexGendvEXT(texunit, coord, pname, params);
}

static void REGAL_CALL missing_glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glMultiTexGenfEXT" );
}

static void REGAL_CALL loader_glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexGenfEXT, "glMultiTexGenfEXT");
   if ( !driverTbl.glMultiTexGenfEXT ) {
      driverTbl.glMultiTexGenfEXT = missing_glMultiTexGenfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexGenfEXT == loader_glMultiTexGenfEXT) {
      rCtx->dsp.emuTbl.glMultiTexGenfEXT = driverTbl.glMultiTexGenfEXT;
   }
   driverTbl.glMultiTexGenfEXT(texunit, coord, pname, param);
}

static void REGAL_CALL missing_glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glMultiTexGenfvEXT" );
}

static void REGAL_CALL loader_glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexGenfvEXT, "glMultiTexGenfvEXT");
   if ( !driverTbl.glMultiTexGenfvEXT ) {
      driverTbl.glMultiTexGenfvEXT = missing_glMultiTexGenfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexGenfvEXT == loader_glMultiTexGenfvEXT) {
      rCtx->dsp.emuTbl.glMultiTexGenfvEXT = driverTbl.glMultiTexGenfvEXT;
   }
   driverTbl.glMultiTexGenfvEXT(texunit, coord, pname, params);
}

static void REGAL_CALL missing_glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glMultiTexGeniEXT" );
}

static void REGAL_CALL loader_glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexGeniEXT, "glMultiTexGeniEXT");
   if ( !driverTbl.glMultiTexGeniEXT ) {
      driverTbl.glMultiTexGeniEXT = missing_glMultiTexGeniEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexGeniEXT == loader_glMultiTexGeniEXT) {
      rCtx->dsp.emuTbl.glMultiTexGeniEXT = driverTbl.glMultiTexGeniEXT;
   }
   driverTbl.glMultiTexGeniEXT(texunit, coord, pname, param);
}

static void REGAL_CALL missing_glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glMultiTexGenivEXT" );
}

static void REGAL_CALL loader_glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexGenivEXT, "glMultiTexGenivEXT");
   if ( !driverTbl.glMultiTexGenivEXT ) {
      driverTbl.glMultiTexGenivEXT = missing_glMultiTexGenivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexGenivEXT == loader_glMultiTexGenivEXT) {
      rCtx->dsp.emuTbl.glMultiTexGenivEXT = driverTbl.glMultiTexGenivEXT;
   }
   driverTbl.glMultiTexGenivEXT(texunit, coord, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMultiTexEnvfvEXT" );
}

static void REGAL_CALL loader_glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMultiTexEnvfvEXT, "glGetMultiTexEnvfvEXT");
   if ( !driverTbl.glGetMultiTexEnvfvEXT ) {
      driverTbl.glGetMultiTexEnvfvEXT = missing_glGetMultiTexEnvfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMultiTexEnvfvEXT == loader_glGetMultiTexEnvfvEXT) {
      rCtx->dsp.emuTbl.glGetMultiTexEnvfvEXT = driverTbl.glGetMultiTexEnvfvEXT;
   }
   driverTbl.glGetMultiTexEnvfvEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMultiTexEnvivEXT" );
}

static void REGAL_CALL loader_glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMultiTexEnvivEXT, "glGetMultiTexEnvivEXT");
   if ( !driverTbl.glGetMultiTexEnvivEXT ) {
      driverTbl.glGetMultiTexEnvivEXT = missing_glGetMultiTexEnvivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMultiTexEnvivEXT == loader_glGetMultiTexEnvivEXT) {
      rCtx->dsp.emuTbl.glGetMultiTexEnvivEXT = driverTbl.glGetMultiTexEnvivEXT;
   }
   driverTbl.glGetMultiTexEnvivEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMultiTexGendvEXT" );
}

static void REGAL_CALL loader_glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMultiTexGendvEXT, "glGetMultiTexGendvEXT");
   if ( !driverTbl.glGetMultiTexGendvEXT ) {
      driverTbl.glGetMultiTexGendvEXT = missing_glGetMultiTexGendvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMultiTexGendvEXT == loader_glGetMultiTexGendvEXT) {
      rCtx->dsp.emuTbl.glGetMultiTexGendvEXT = driverTbl.glGetMultiTexGendvEXT;
   }
   driverTbl.glGetMultiTexGendvEXT(texunit, coord, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMultiTexGenfvEXT" );
}

static void REGAL_CALL loader_glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMultiTexGenfvEXT, "glGetMultiTexGenfvEXT");
   if ( !driverTbl.glGetMultiTexGenfvEXT ) {
      driverTbl.glGetMultiTexGenfvEXT = missing_glGetMultiTexGenfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMultiTexGenfvEXT == loader_glGetMultiTexGenfvEXT) {
      rCtx->dsp.emuTbl.glGetMultiTexGenfvEXT = driverTbl.glGetMultiTexGenfvEXT;
   }
   driverTbl.glGetMultiTexGenfvEXT(texunit, coord, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMultiTexGenivEXT" );
}

static void REGAL_CALL loader_glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMultiTexGenivEXT, "glGetMultiTexGenivEXT");
   if ( !driverTbl.glGetMultiTexGenivEXT ) {
      driverTbl.glGetMultiTexGenivEXT = missing_glGetMultiTexGenivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMultiTexGenivEXT == loader_glGetMultiTexGenivEXT) {
      rCtx->dsp.emuTbl.glGetMultiTexGenivEXT = driverTbl.glGetMultiTexGenivEXT;
   }
   driverTbl.glGetMultiTexGenivEXT(texunit, coord, pname, params);
}

static void REGAL_CALL missing_glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetFloatIndexedvEXT" );
}

static void REGAL_CALL loader_glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFloatIndexedvEXT, "glGetFloatIndexedvEXT");
   if ( !driverTbl.glGetFloatIndexedvEXT ) {
      driverTbl.glGetFloatIndexedvEXT = missing_glGetFloatIndexedvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFloatIndexedvEXT == loader_glGetFloatIndexedvEXT) {
      rCtx->dsp.emuTbl.glGetFloatIndexedvEXT = driverTbl.glGetFloatIndexedvEXT;
   }
   driverTbl.glGetFloatIndexedvEXT(target, index, data);
}

static void REGAL_CALL missing_glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetDoubleIndexedvEXT" );
}

static void REGAL_CALL loader_glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetDoubleIndexedvEXT, "glGetDoubleIndexedvEXT");
   if ( !driverTbl.glGetDoubleIndexedvEXT ) {
      driverTbl.glGetDoubleIndexedvEXT = missing_glGetDoubleIndexedvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetDoubleIndexedvEXT == loader_glGetDoubleIndexedvEXT) {
      rCtx->dsp.emuTbl.glGetDoubleIndexedvEXT = driverTbl.glGetDoubleIndexedvEXT;
   }
   driverTbl.glGetDoubleIndexedvEXT(target, index, data);
}

static void REGAL_CALL missing_glGetPointerIndexedvEXT(GLenum target, GLuint index, GLvoid **data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetPointerIndexedvEXT" );
}

static void REGAL_CALL loader_glGetPointerIndexedvEXT(GLenum target, GLuint index, GLvoid **data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPointerIndexedvEXT, "glGetPointerIndexedvEXT");
   if ( !driverTbl.glGetPointerIndexedvEXT ) {
      driverTbl.glGetPointerIndexedvEXT = missing_glGetPointerIndexedvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPointerIndexedvEXT == loader_glGetPointerIndexedvEXT) {
      rCtx->dsp.emuTbl.glGetPointerIndexedvEXT = driverTbl.glGetPointerIndexedvEXT;
   }
   driverTbl.glGetPointerIndexedvEXT(target, index, data);
}

static void REGAL_CALL missing_glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "Called missing function glCompressedTextureImage3DEXT" );
}

static void REGAL_CALL loader_glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTextureImage3DEXT, "glCompressedTextureImage3DEXT");
   if ( !driverTbl.glCompressedTextureImage3DEXT ) {
      driverTbl.glCompressedTextureImage3DEXT = missing_glCompressedTextureImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTextureImage3DEXT == loader_glCompressedTextureImage3DEXT) {
      rCtx->dsp.emuTbl.glCompressedTextureImage3DEXT = driverTbl.glCompressedTextureImage3DEXT;
   }
   driverTbl.glCompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
}

static void REGAL_CALL missing_glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "Called missing function glCompressedTextureImage2DEXT" );
}

static void REGAL_CALL loader_glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTextureImage2DEXT, "glCompressedTextureImage2DEXT");
   if ( !driverTbl.glCompressedTextureImage2DEXT ) {
      driverTbl.glCompressedTextureImage2DEXT = missing_glCompressedTextureImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTextureImage2DEXT == loader_glCompressedTextureImage2DEXT) {
      rCtx->dsp.emuTbl.glCompressedTextureImage2DEXT = driverTbl.glCompressedTextureImage2DEXT;
   }
   driverTbl.glCompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits);
}

static void REGAL_CALL missing_glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "Called missing function glCompressedTextureImage1DEXT" );
}

static void REGAL_CALL loader_glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTextureImage1DEXT, "glCompressedTextureImage1DEXT");
   if ( !driverTbl.glCompressedTextureImage1DEXT ) {
      driverTbl.glCompressedTextureImage1DEXT = missing_glCompressedTextureImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTextureImage1DEXT == loader_glCompressedTextureImage1DEXT) {
      rCtx->dsp.emuTbl.glCompressedTextureImage1DEXT = driverTbl.glCompressedTextureImage1DEXT;
   }
   driverTbl.glCompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits);
}

static void REGAL_CALL missing_glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "Called missing function glCompressedTextureSubImage3DEXT" );
}

static void REGAL_CALL loader_glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTextureSubImage3DEXT, "glCompressedTextureSubImage3DEXT");
   if ( !driverTbl.glCompressedTextureSubImage3DEXT ) {
      driverTbl.glCompressedTextureSubImage3DEXT = missing_glCompressedTextureSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTextureSubImage3DEXT == loader_glCompressedTextureSubImage3DEXT) {
      rCtx->dsp.emuTbl.glCompressedTextureSubImage3DEXT = driverTbl.glCompressedTextureSubImage3DEXT;
   }
   driverTbl.glCompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
}

static void REGAL_CALL missing_glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "Called missing function glCompressedTextureSubImage2DEXT" );
}

static void REGAL_CALL loader_glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTextureSubImage2DEXT, "glCompressedTextureSubImage2DEXT");
   if ( !driverTbl.glCompressedTextureSubImage2DEXT ) {
      driverTbl.glCompressedTextureSubImage2DEXT = missing_glCompressedTextureSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTextureSubImage2DEXT == loader_glCompressedTextureSubImage2DEXT) {
      rCtx->dsp.emuTbl.glCompressedTextureSubImage2DEXT = driverTbl.glCompressedTextureSubImage2DEXT;
   }
   driverTbl.glCompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
}

static void REGAL_CALL missing_glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "Called missing function glCompressedTextureSubImage1DEXT" );
}

static void REGAL_CALL loader_glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedTextureSubImage1DEXT, "glCompressedTextureSubImage1DEXT");
   if ( !driverTbl.glCompressedTextureSubImage1DEXT ) {
      driverTbl.glCompressedTextureSubImage1DEXT = missing_glCompressedTextureSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedTextureSubImage1DEXT == loader_glCompressedTextureSubImage1DEXT) {
      rCtx->dsp.emuTbl.glCompressedTextureSubImage1DEXT = driverTbl.glCompressedTextureSubImage1DEXT;
   }
   driverTbl.glCompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits);
}

static void REGAL_CALL missing_glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, GLvoid *img)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(lod);
   UNUSED_PARAMETER(img);
   Warning( "Called missing function glGetCompressedTextureImageEXT" );
}

static void REGAL_CALL loader_glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, GLvoid *img)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetCompressedTextureImageEXT, "glGetCompressedTextureImageEXT");
   if ( !driverTbl.glGetCompressedTextureImageEXT ) {
      driverTbl.glGetCompressedTextureImageEXT = missing_glGetCompressedTextureImageEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetCompressedTextureImageEXT == loader_glGetCompressedTextureImageEXT) {
      rCtx->dsp.emuTbl.glGetCompressedTextureImageEXT = driverTbl.glGetCompressedTextureImageEXT;
   }
   driverTbl.glGetCompressedTextureImageEXT(texture, target, lod, img);
}

static void REGAL_CALL missing_glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "Called missing function glCompressedMultiTexImage3DEXT" );
}

static void REGAL_CALL loader_glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedMultiTexImage3DEXT, "glCompressedMultiTexImage3DEXT");
   if ( !driverTbl.glCompressedMultiTexImage3DEXT ) {
      driverTbl.glCompressedMultiTexImage3DEXT = missing_glCompressedMultiTexImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedMultiTexImage3DEXT == loader_glCompressedMultiTexImage3DEXT) {
      rCtx->dsp.emuTbl.glCompressedMultiTexImage3DEXT = driverTbl.glCompressedMultiTexImage3DEXT;
   }
   driverTbl.glCompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
}

static void REGAL_CALL missing_glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "Called missing function glCompressedMultiTexImage2DEXT" );
}

static void REGAL_CALL loader_glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedMultiTexImage2DEXT, "glCompressedMultiTexImage2DEXT");
   if ( !driverTbl.glCompressedMultiTexImage2DEXT ) {
      driverTbl.glCompressedMultiTexImage2DEXT = missing_glCompressedMultiTexImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedMultiTexImage2DEXT == loader_glCompressedMultiTexImage2DEXT) {
      rCtx->dsp.emuTbl.glCompressedMultiTexImage2DEXT = driverTbl.glCompressedMultiTexImage2DEXT;
   }
   driverTbl.glCompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits);
}

static void REGAL_CALL missing_glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedMultiTexImage1DEXT" );
}

static void REGAL_CALL loader_glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedMultiTexImage1DEXT, "glCompressedMultiTexImage1DEXT");
   if ( !driverTbl.glCompressedMultiTexImage1DEXT ) {
      driverTbl.glCompressedMultiTexImage1DEXT = missing_glCompressedMultiTexImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedMultiTexImage1DEXT == loader_glCompressedMultiTexImage1DEXT) {
      rCtx->dsp.emuTbl.glCompressedMultiTexImage1DEXT = driverTbl.glCompressedMultiTexImage1DEXT;
   }
   driverTbl.glCompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, data);
}

static void REGAL_CALL missing_glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedMultiTexSubImage3DEXT" );
}

static void REGAL_CALL loader_glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedMultiTexSubImage3DEXT, "glCompressedMultiTexSubImage3DEXT");
   if ( !driverTbl.glCompressedMultiTexSubImage3DEXT ) {
      driverTbl.glCompressedMultiTexSubImage3DEXT = missing_glCompressedMultiTexSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedMultiTexSubImage3DEXT == loader_glCompressedMultiTexSubImage3DEXT) {
      rCtx->dsp.emuTbl.glCompressedMultiTexSubImage3DEXT = driverTbl.glCompressedMultiTexSubImage3DEXT;
   }
   driverTbl.glCompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

static void REGAL_CALL missing_glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedMultiTexSubImage2DEXT" );
}

static void REGAL_CALL loader_glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedMultiTexSubImage2DEXT, "glCompressedMultiTexSubImage2DEXT");
   if ( !driverTbl.glCompressedMultiTexSubImage2DEXT ) {
      driverTbl.glCompressedMultiTexSubImage2DEXT = missing_glCompressedMultiTexSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedMultiTexSubImage2DEXT == loader_glCompressedMultiTexSubImage2DEXT) {
      rCtx->dsp.emuTbl.glCompressedMultiTexSubImage2DEXT = driverTbl.glCompressedMultiTexSubImage2DEXT;
   }
   driverTbl.glCompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

static void REGAL_CALL missing_glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glCompressedMultiTexSubImage1DEXT" );
}

static void REGAL_CALL loader_glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCompressedMultiTexSubImage1DEXT, "glCompressedMultiTexSubImage1DEXT");
   if ( !driverTbl.glCompressedMultiTexSubImage1DEXT ) {
      driverTbl.glCompressedMultiTexSubImage1DEXT = missing_glCompressedMultiTexSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCompressedMultiTexSubImage1DEXT == loader_glCompressedMultiTexSubImage1DEXT) {
      rCtx->dsp.emuTbl.glCompressedMultiTexSubImage1DEXT = driverTbl.glCompressedMultiTexSubImage1DEXT;
   }
   driverTbl.glCompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, data);
}

static void REGAL_CALL missing_glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, GLvoid *img)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(lod);
   UNUSED_PARAMETER(img);
   Warning( "Called missing function glGetCompressedMultiTexImageEXT" );
}

static void REGAL_CALL loader_glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, GLvoid *img)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetCompressedMultiTexImageEXT, "glGetCompressedMultiTexImageEXT");
   if ( !driverTbl.glGetCompressedMultiTexImageEXT ) {
      driverTbl.glGetCompressedMultiTexImageEXT = missing_glGetCompressedMultiTexImageEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetCompressedMultiTexImageEXT == loader_glGetCompressedMultiTexImageEXT) {
      rCtx->dsp.emuTbl.glGetCompressedMultiTexImageEXT = driverTbl.glGetCompressedMultiTexImageEXT;
   }
   driverTbl.glGetCompressedMultiTexImageEXT(texunit, target, lod, img);
}

static void REGAL_CALL missing_glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(string);
   Warning( "Called missing function glNamedProgramStringEXT" );
}

static void REGAL_CALL loader_glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedProgramStringEXT, "glNamedProgramStringEXT");
   if ( !driverTbl.glNamedProgramStringEXT ) {
      driverTbl.glNamedProgramStringEXT = missing_glNamedProgramStringEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedProgramStringEXT == loader_glNamedProgramStringEXT) {
      rCtx->dsp.emuTbl.glNamedProgramStringEXT = driverTbl.glNamedProgramStringEXT;
   }
   driverTbl.glNamedProgramStringEXT(program, target, format, len, string);
}

static void REGAL_CALL missing_glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glNamedProgramLocalParameter4dEXT" );
}

static void REGAL_CALL loader_glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedProgramLocalParameter4dEXT, "glNamedProgramLocalParameter4dEXT");
   if ( !driverTbl.glNamedProgramLocalParameter4dEXT ) {
      driverTbl.glNamedProgramLocalParameter4dEXT = missing_glNamedProgramLocalParameter4dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedProgramLocalParameter4dEXT == loader_glNamedProgramLocalParameter4dEXT) {
      rCtx->dsp.emuTbl.glNamedProgramLocalParameter4dEXT = driverTbl.glNamedProgramLocalParameter4dEXT;
   }
   driverTbl.glNamedProgramLocalParameter4dEXT(program, target, index, x, y, z, w);
}

static void REGAL_CALL missing_glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glNamedProgramLocalParameter4dvEXT" );
}

static void REGAL_CALL loader_glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedProgramLocalParameter4dvEXT, "glNamedProgramLocalParameter4dvEXT");
   if ( !driverTbl.glNamedProgramLocalParameter4dvEXT ) {
      driverTbl.glNamedProgramLocalParameter4dvEXT = missing_glNamedProgramLocalParameter4dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedProgramLocalParameter4dvEXT == loader_glNamedProgramLocalParameter4dvEXT) {
      rCtx->dsp.emuTbl.glNamedProgramLocalParameter4dvEXT = driverTbl.glNamedProgramLocalParameter4dvEXT;
   }
   driverTbl.glNamedProgramLocalParameter4dvEXT(program, target, index, params);
}

static void REGAL_CALL missing_glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glNamedProgramLocalParameter4fEXT" );
}

static void REGAL_CALL loader_glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedProgramLocalParameter4fEXT, "glNamedProgramLocalParameter4fEXT");
   if ( !driverTbl.glNamedProgramLocalParameter4fEXT ) {
      driverTbl.glNamedProgramLocalParameter4fEXT = missing_glNamedProgramLocalParameter4fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedProgramLocalParameter4fEXT == loader_glNamedProgramLocalParameter4fEXT) {
      rCtx->dsp.emuTbl.glNamedProgramLocalParameter4fEXT = driverTbl.glNamedProgramLocalParameter4fEXT;
   }
   driverTbl.glNamedProgramLocalParameter4fEXT(program, target, index, x, y, z, w);
}

static void REGAL_CALL missing_glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glNamedProgramLocalParameter4fvEXT" );
}

static void REGAL_CALL loader_glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedProgramLocalParameter4fvEXT, "glNamedProgramLocalParameter4fvEXT");
   if ( !driverTbl.glNamedProgramLocalParameter4fvEXT ) {
      driverTbl.glNamedProgramLocalParameter4fvEXT = missing_glNamedProgramLocalParameter4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedProgramLocalParameter4fvEXT == loader_glNamedProgramLocalParameter4fvEXT) {
      rCtx->dsp.emuTbl.glNamedProgramLocalParameter4fvEXT = driverTbl.glNamedProgramLocalParameter4fvEXT;
   }
   driverTbl.glNamedProgramLocalParameter4fvEXT(program, target, index, params);
}

static void REGAL_CALL missing_glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetNamedProgramLocalParameterdvEXT" );
}

static void REGAL_CALL loader_glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetNamedProgramLocalParameterdvEXT, "glGetNamedProgramLocalParameterdvEXT");
   if ( !driverTbl.glGetNamedProgramLocalParameterdvEXT ) {
      driverTbl.glGetNamedProgramLocalParameterdvEXT = missing_glGetNamedProgramLocalParameterdvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetNamedProgramLocalParameterdvEXT == loader_glGetNamedProgramLocalParameterdvEXT) {
      rCtx->dsp.emuTbl.glGetNamedProgramLocalParameterdvEXT = driverTbl.glGetNamedProgramLocalParameterdvEXT;
   }
   driverTbl.glGetNamedProgramLocalParameterdvEXT(program, target, index, params);
}

static void REGAL_CALL missing_glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetNamedProgramLocalParameterfvEXT" );
}

static void REGAL_CALL loader_glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetNamedProgramLocalParameterfvEXT, "glGetNamedProgramLocalParameterfvEXT");
   if ( !driverTbl.glGetNamedProgramLocalParameterfvEXT ) {
      driverTbl.glGetNamedProgramLocalParameterfvEXT = missing_glGetNamedProgramLocalParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetNamedProgramLocalParameterfvEXT == loader_glGetNamedProgramLocalParameterfvEXT) {
      rCtx->dsp.emuTbl.glGetNamedProgramLocalParameterfvEXT = driverTbl.glGetNamedProgramLocalParameterfvEXT;
   }
   driverTbl.glGetNamedProgramLocalParameterfvEXT(program, target, index, params);
}

static void REGAL_CALL missing_glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetNamedProgramivEXT" );
}

static void REGAL_CALL loader_glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetNamedProgramivEXT, "glGetNamedProgramivEXT");
   if ( !driverTbl.glGetNamedProgramivEXT ) {
      driverTbl.glGetNamedProgramivEXT = missing_glGetNamedProgramivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetNamedProgramivEXT == loader_glGetNamedProgramivEXT) {
      rCtx->dsp.emuTbl.glGetNamedProgramivEXT = driverTbl.glGetNamedProgramivEXT;
   }
   driverTbl.glGetNamedProgramivEXT(program, target, pname, params);
}

static void REGAL_CALL missing_glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, GLvoid *string)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(string);
   Warning( "Called missing function glGetNamedProgramStringEXT" );
}

static void REGAL_CALL loader_glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, GLvoid *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetNamedProgramStringEXT, "glGetNamedProgramStringEXT");
   if ( !driverTbl.glGetNamedProgramStringEXT ) {
      driverTbl.glGetNamedProgramStringEXT = missing_glGetNamedProgramStringEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetNamedProgramStringEXT == loader_glGetNamedProgramStringEXT) {
      rCtx->dsp.emuTbl.glGetNamedProgramStringEXT = driverTbl.glGetNamedProgramStringEXT;
   }
   driverTbl.glGetNamedProgramStringEXT(program, target, pname, string);
}

static void REGAL_CALL missing_glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glNamedProgramLocalParameters4fvEXT" );
}

static void REGAL_CALL loader_glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedProgramLocalParameters4fvEXT, "glNamedProgramLocalParameters4fvEXT");
   if ( !driverTbl.glNamedProgramLocalParameters4fvEXT ) {
      driverTbl.glNamedProgramLocalParameters4fvEXT = missing_glNamedProgramLocalParameters4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedProgramLocalParameters4fvEXT == loader_glNamedProgramLocalParameters4fvEXT) {
      rCtx->dsp.emuTbl.glNamedProgramLocalParameters4fvEXT = driverTbl.glNamedProgramLocalParameters4fvEXT;
   }
   driverTbl.glNamedProgramLocalParameters4fvEXT(program, target, index, count, params);
}

static void REGAL_CALL missing_glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glNamedProgramLocalParameterI4iEXT" );
}

static void REGAL_CALL loader_glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedProgramLocalParameterI4iEXT, "glNamedProgramLocalParameterI4iEXT");
   if ( !driverTbl.glNamedProgramLocalParameterI4iEXT ) {
      driverTbl.glNamedProgramLocalParameterI4iEXT = missing_glNamedProgramLocalParameterI4iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedProgramLocalParameterI4iEXT == loader_glNamedProgramLocalParameterI4iEXT) {
      rCtx->dsp.emuTbl.glNamedProgramLocalParameterI4iEXT = driverTbl.glNamedProgramLocalParameterI4iEXT;
   }
   driverTbl.glNamedProgramLocalParameterI4iEXT(program, target, index, x, y, z, w);
}

static void REGAL_CALL missing_glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glNamedProgramLocalParameterI4ivEXT" );
}

static void REGAL_CALL loader_glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedProgramLocalParameterI4ivEXT, "glNamedProgramLocalParameterI4ivEXT");
   if ( !driverTbl.glNamedProgramLocalParameterI4ivEXT ) {
      driverTbl.glNamedProgramLocalParameterI4ivEXT = missing_glNamedProgramLocalParameterI4ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedProgramLocalParameterI4ivEXT == loader_glNamedProgramLocalParameterI4ivEXT) {
      rCtx->dsp.emuTbl.glNamedProgramLocalParameterI4ivEXT = driverTbl.glNamedProgramLocalParameterI4ivEXT;
   }
   driverTbl.glNamedProgramLocalParameterI4ivEXT(program, target, index, params);
}

static void REGAL_CALL missing_glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glNamedProgramLocalParametersI4ivEXT" );
}

static void REGAL_CALL loader_glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedProgramLocalParametersI4ivEXT, "glNamedProgramLocalParametersI4ivEXT");
   if ( !driverTbl.glNamedProgramLocalParametersI4ivEXT ) {
      driverTbl.glNamedProgramLocalParametersI4ivEXT = missing_glNamedProgramLocalParametersI4ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedProgramLocalParametersI4ivEXT == loader_glNamedProgramLocalParametersI4ivEXT) {
      rCtx->dsp.emuTbl.glNamedProgramLocalParametersI4ivEXT = driverTbl.glNamedProgramLocalParametersI4ivEXT;
   }
   driverTbl.glNamedProgramLocalParametersI4ivEXT(program, target, index, count, params);
}

static void REGAL_CALL missing_glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glNamedProgramLocalParameterI4uiEXT" );
}

static void REGAL_CALL loader_glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedProgramLocalParameterI4uiEXT, "glNamedProgramLocalParameterI4uiEXT");
   if ( !driverTbl.glNamedProgramLocalParameterI4uiEXT ) {
      driverTbl.glNamedProgramLocalParameterI4uiEXT = missing_glNamedProgramLocalParameterI4uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedProgramLocalParameterI4uiEXT == loader_glNamedProgramLocalParameterI4uiEXT) {
      rCtx->dsp.emuTbl.glNamedProgramLocalParameterI4uiEXT = driverTbl.glNamedProgramLocalParameterI4uiEXT;
   }
   driverTbl.glNamedProgramLocalParameterI4uiEXT(program, target, index, x, y, z, w);
}

static void REGAL_CALL missing_glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glNamedProgramLocalParameterI4uivEXT" );
}

static void REGAL_CALL loader_glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedProgramLocalParameterI4uivEXT, "glNamedProgramLocalParameterI4uivEXT");
   if ( !driverTbl.glNamedProgramLocalParameterI4uivEXT ) {
      driverTbl.glNamedProgramLocalParameterI4uivEXT = missing_glNamedProgramLocalParameterI4uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedProgramLocalParameterI4uivEXT == loader_glNamedProgramLocalParameterI4uivEXT) {
      rCtx->dsp.emuTbl.glNamedProgramLocalParameterI4uivEXT = driverTbl.glNamedProgramLocalParameterI4uivEXT;
   }
   driverTbl.glNamedProgramLocalParameterI4uivEXT(program, target, index, params);
}

static void REGAL_CALL missing_glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glNamedProgramLocalParametersI4uivEXT" );
}

static void REGAL_CALL loader_glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedProgramLocalParametersI4uivEXT, "glNamedProgramLocalParametersI4uivEXT");
   if ( !driverTbl.glNamedProgramLocalParametersI4uivEXT ) {
      driverTbl.glNamedProgramLocalParametersI4uivEXT = missing_glNamedProgramLocalParametersI4uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedProgramLocalParametersI4uivEXT == loader_glNamedProgramLocalParametersI4uivEXT) {
      rCtx->dsp.emuTbl.glNamedProgramLocalParametersI4uivEXT = driverTbl.glNamedProgramLocalParametersI4uivEXT;
   }
   driverTbl.glNamedProgramLocalParametersI4uivEXT(program, target, index, count, params);
}

static void REGAL_CALL missing_glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetNamedProgramLocalParameterIivEXT" );
}

static void REGAL_CALL loader_glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetNamedProgramLocalParameterIivEXT, "glGetNamedProgramLocalParameterIivEXT");
   if ( !driverTbl.glGetNamedProgramLocalParameterIivEXT ) {
      driverTbl.glGetNamedProgramLocalParameterIivEXT = missing_glGetNamedProgramLocalParameterIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetNamedProgramLocalParameterIivEXT == loader_glGetNamedProgramLocalParameterIivEXT) {
      rCtx->dsp.emuTbl.glGetNamedProgramLocalParameterIivEXT = driverTbl.glGetNamedProgramLocalParameterIivEXT;
   }
   driverTbl.glGetNamedProgramLocalParameterIivEXT(program, target, index, params);
}

static void REGAL_CALL missing_glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetNamedProgramLocalParameterIuivEXT" );
}

static void REGAL_CALL loader_glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetNamedProgramLocalParameterIuivEXT, "glGetNamedProgramLocalParameterIuivEXT");
   if ( !driverTbl.glGetNamedProgramLocalParameterIuivEXT ) {
      driverTbl.glGetNamedProgramLocalParameterIuivEXT = missing_glGetNamedProgramLocalParameterIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetNamedProgramLocalParameterIuivEXT == loader_glGetNamedProgramLocalParameterIuivEXT) {
      rCtx->dsp.emuTbl.glGetNamedProgramLocalParameterIuivEXT = driverTbl.glGetNamedProgramLocalParameterIuivEXT;
   }
   driverTbl.glGetNamedProgramLocalParameterIuivEXT(program, target, index, params);
}

static void REGAL_CALL missing_glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glTextureParameterIivEXT" );
}

static void REGAL_CALL loader_glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureParameterIivEXT, "glTextureParameterIivEXT");
   if ( !driverTbl.glTextureParameterIivEXT ) {
      driverTbl.glTextureParameterIivEXT = missing_glTextureParameterIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureParameterIivEXT == loader_glTextureParameterIivEXT) {
      rCtx->dsp.emuTbl.glTextureParameterIivEXT = driverTbl.glTextureParameterIivEXT;
   }
   driverTbl.glTextureParameterIivEXT(texture, target, pname, params);
}

static void REGAL_CALL missing_glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glTextureParameterIuivEXT" );
}

static void REGAL_CALL loader_glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureParameterIuivEXT, "glTextureParameterIuivEXT");
   if ( !driverTbl.glTextureParameterIuivEXT ) {
      driverTbl.glTextureParameterIuivEXT = missing_glTextureParameterIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureParameterIuivEXT == loader_glTextureParameterIuivEXT) {
      rCtx->dsp.emuTbl.glTextureParameterIuivEXT = driverTbl.glTextureParameterIuivEXT;
   }
   driverTbl.glTextureParameterIuivEXT(texture, target, pname, params);
}

static void REGAL_CALL missing_glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTextureParameterIivEXT" );
}

static void REGAL_CALL loader_glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTextureParameterIivEXT, "glGetTextureParameterIivEXT");
   if ( !driverTbl.glGetTextureParameterIivEXT ) {
      driverTbl.glGetTextureParameterIivEXT = missing_glGetTextureParameterIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTextureParameterIivEXT == loader_glGetTextureParameterIivEXT) {
      rCtx->dsp.emuTbl.glGetTextureParameterIivEXT = driverTbl.glGetTextureParameterIivEXT;
   }
   driverTbl.glGetTextureParameterIivEXT(texture, target, pname, params);
}

static void REGAL_CALL missing_glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTextureParameterIuivEXT" );
}

static void REGAL_CALL loader_glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTextureParameterIuivEXT, "glGetTextureParameterIuivEXT");
   if ( !driverTbl.glGetTextureParameterIuivEXT ) {
      driverTbl.glGetTextureParameterIuivEXT = missing_glGetTextureParameterIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTextureParameterIuivEXT == loader_glGetTextureParameterIuivEXT) {
      rCtx->dsp.emuTbl.glGetTextureParameterIuivEXT = driverTbl.glGetTextureParameterIuivEXT;
   }
   driverTbl.glGetTextureParameterIuivEXT(texture, target, pname, params);
}

static void REGAL_CALL missing_glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glMultiTexParameterIivEXT" );
}

static void REGAL_CALL loader_glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexParameterIivEXT, "glMultiTexParameterIivEXT");
   if ( !driverTbl.glMultiTexParameterIivEXT ) {
      driverTbl.glMultiTexParameterIivEXT = missing_glMultiTexParameterIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexParameterIivEXT == loader_glMultiTexParameterIivEXT) {
      rCtx->dsp.emuTbl.glMultiTexParameterIivEXT = driverTbl.glMultiTexParameterIivEXT;
   }
   driverTbl.glMultiTexParameterIivEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glMultiTexParameterIuivEXT" );
}

static void REGAL_CALL loader_glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexParameterIuivEXT, "glMultiTexParameterIuivEXT");
   if ( !driverTbl.glMultiTexParameterIuivEXT ) {
      driverTbl.glMultiTexParameterIuivEXT = missing_glMultiTexParameterIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexParameterIuivEXT == loader_glMultiTexParameterIuivEXT) {
      rCtx->dsp.emuTbl.glMultiTexParameterIuivEXT = driverTbl.glMultiTexParameterIuivEXT;
   }
   driverTbl.glMultiTexParameterIuivEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMultiTexParameterIivEXT" );
}

static void REGAL_CALL loader_glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMultiTexParameterIivEXT, "glGetMultiTexParameterIivEXT");
   if ( !driverTbl.glGetMultiTexParameterIivEXT ) {
      driverTbl.glGetMultiTexParameterIivEXT = missing_glGetMultiTexParameterIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMultiTexParameterIivEXT == loader_glGetMultiTexParameterIivEXT) {
      rCtx->dsp.emuTbl.glGetMultiTexParameterIivEXT = driverTbl.glGetMultiTexParameterIivEXT;
   }
   driverTbl.glGetMultiTexParameterIivEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetMultiTexParameterIuivEXT" );
}

static void REGAL_CALL loader_glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMultiTexParameterIuivEXT, "glGetMultiTexParameterIuivEXT");
   if ( !driverTbl.glGetMultiTexParameterIuivEXT ) {
      driverTbl.glGetMultiTexParameterIuivEXT = missing_glGetMultiTexParameterIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMultiTexParameterIuivEXT == loader_glGetMultiTexParameterIuivEXT) {
      rCtx->dsp.emuTbl.glGetMultiTexParameterIuivEXT = driverTbl.glGetMultiTexParameterIuivEXT;
   }
   driverTbl.glGetMultiTexParameterIuivEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "Called missing function glProgramUniform1fEXT" );
}

static void REGAL_CALL loader_glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1fEXT, "glProgramUniform1fEXT");
   if ( !driverTbl.glProgramUniform1fEXT ) {
      driverTbl.glProgramUniform1fEXT = missing_glProgramUniform1fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1fEXT == loader_glProgramUniform1fEXT) {
      rCtx->dsp.emuTbl.glProgramUniform1fEXT = driverTbl.glProgramUniform1fEXT;
   }
   driverTbl.glProgramUniform1fEXT(program, location, v0);
}

static void REGAL_CALL missing_glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "Called missing function glProgramUniform2fEXT" );
}

static void REGAL_CALL loader_glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2fEXT, "glProgramUniform2fEXT");
   if ( !driverTbl.glProgramUniform2fEXT ) {
      driverTbl.glProgramUniform2fEXT = missing_glProgramUniform2fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2fEXT == loader_glProgramUniform2fEXT) {
      rCtx->dsp.emuTbl.glProgramUniform2fEXT = driverTbl.glProgramUniform2fEXT;
   }
   driverTbl.glProgramUniform2fEXT(program, location, v0, v1);
}

static void REGAL_CALL missing_glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glProgramUniform3fEXT" );
}

static void REGAL_CALL loader_glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3fEXT, "glProgramUniform3fEXT");
   if ( !driverTbl.glProgramUniform3fEXT ) {
      driverTbl.glProgramUniform3fEXT = missing_glProgramUniform3fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3fEXT == loader_glProgramUniform3fEXT) {
      rCtx->dsp.emuTbl.glProgramUniform3fEXT = driverTbl.glProgramUniform3fEXT;
   }
   driverTbl.glProgramUniform3fEXT(program, location, v0, v1, v2);
}

static void REGAL_CALL missing_glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "Called missing function glProgramUniform4fEXT" );
}

static void REGAL_CALL loader_glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4fEXT, "glProgramUniform4fEXT");
   if ( !driverTbl.glProgramUniform4fEXT ) {
      driverTbl.glProgramUniform4fEXT = missing_glProgramUniform4fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4fEXT == loader_glProgramUniform4fEXT) {
      rCtx->dsp.emuTbl.glProgramUniform4fEXT = driverTbl.glProgramUniform4fEXT;
   }
   driverTbl.glProgramUniform4fEXT(program, location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glProgramUniform1iEXT(GLuint program, GLint location, GLint v0)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "Called missing function glProgramUniform1iEXT" );
}

static void REGAL_CALL loader_glProgramUniform1iEXT(GLuint program, GLint location, GLint v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1iEXT, "glProgramUniform1iEXT");
   if ( !driverTbl.glProgramUniform1iEXT ) {
      driverTbl.glProgramUniform1iEXT = missing_glProgramUniform1iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1iEXT == loader_glProgramUniform1iEXT) {
      rCtx->dsp.emuTbl.glProgramUniform1iEXT = driverTbl.glProgramUniform1iEXT;
   }
   driverTbl.glProgramUniform1iEXT(program, location, v0);
}

static void REGAL_CALL missing_glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "Called missing function glProgramUniform2iEXT" );
}

static void REGAL_CALL loader_glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2iEXT, "glProgramUniform2iEXT");
   if ( !driverTbl.glProgramUniform2iEXT ) {
      driverTbl.glProgramUniform2iEXT = missing_glProgramUniform2iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2iEXT == loader_glProgramUniform2iEXT) {
      rCtx->dsp.emuTbl.glProgramUniform2iEXT = driverTbl.glProgramUniform2iEXT;
   }
   driverTbl.glProgramUniform2iEXT(program, location, v0, v1);
}

static void REGAL_CALL missing_glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glProgramUniform3iEXT" );
}

static void REGAL_CALL loader_glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3iEXT, "glProgramUniform3iEXT");
   if ( !driverTbl.glProgramUniform3iEXT ) {
      driverTbl.glProgramUniform3iEXT = missing_glProgramUniform3iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3iEXT == loader_glProgramUniform3iEXT) {
      rCtx->dsp.emuTbl.glProgramUniform3iEXT = driverTbl.glProgramUniform3iEXT;
   }
   driverTbl.glProgramUniform3iEXT(program, location, v0, v1, v2);
}

static void REGAL_CALL missing_glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "Called missing function glProgramUniform4iEXT" );
}

static void REGAL_CALL loader_glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4iEXT, "glProgramUniform4iEXT");
   if ( !driverTbl.glProgramUniform4iEXT ) {
      driverTbl.glProgramUniform4iEXT = missing_glProgramUniform4iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4iEXT == loader_glProgramUniform4iEXT) {
      rCtx->dsp.emuTbl.glProgramUniform4iEXT = driverTbl.glProgramUniform4iEXT;
   }
   driverTbl.glProgramUniform4iEXT(program, location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform1fvEXT" );
}

static void REGAL_CALL loader_glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1fvEXT, "glProgramUniform1fvEXT");
   if ( !driverTbl.glProgramUniform1fvEXT ) {
      driverTbl.glProgramUniform1fvEXT = missing_glProgramUniform1fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1fvEXT == loader_glProgramUniform1fvEXT) {
      rCtx->dsp.emuTbl.glProgramUniform1fvEXT = driverTbl.glProgramUniform1fvEXT;
   }
   driverTbl.glProgramUniform1fvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform2fvEXT" );
}

static void REGAL_CALL loader_glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2fvEXT, "glProgramUniform2fvEXT");
   if ( !driverTbl.glProgramUniform2fvEXT ) {
      driverTbl.glProgramUniform2fvEXT = missing_glProgramUniform2fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2fvEXT == loader_glProgramUniform2fvEXT) {
      rCtx->dsp.emuTbl.glProgramUniform2fvEXT = driverTbl.glProgramUniform2fvEXT;
   }
   driverTbl.glProgramUniform2fvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform3fvEXT" );
}

static void REGAL_CALL loader_glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3fvEXT, "glProgramUniform3fvEXT");
   if ( !driverTbl.glProgramUniform3fvEXT ) {
      driverTbl.glProgramUniform3fvEXT = missing_glProgramUniform3fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3fvEXT == loader_glProgramUniform3fvEXT) {
      rCtx->dsp.emuTbl.glProgramUniform3fvEXT = driverTbl.glProgramUniform3fvEXT;
   }
   driverTbl.glProgramUniform3fvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform4fvEXT" );
}

static void REGAL_CALL loader_glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4fvEXT, "glProgramUniform4fvEXT");
   if ( !driverTbl.glProgramUniform4fvEXT ) {
      driverTbl.glProgramUniform4fvEXT = missing_glProgramUniform4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4fvEXT == loader_glProgramUniform4fvEXT) {
      rCtx->dsp.emuTbl.glProgramUniform4fvEXT = driverTbl.glProgramUniform4fvEXT;
   }
   driverTbl.glProgramUniform4fvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform1ivEXT" );
}

static void REGAL_CALL loader_glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1ivEXT, "glProgramUniform1ivEXT");
   if ( !driverTbl.glProgramUniform1ivEXT ) {
      driverTbl.glProgramUniform1ivEXT = missing_glProgramUniform1ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1ivEXT == loader_glProgramUniform1ivEXT) {
      rCtx->dsp.emuTbl.glProgramUniform1ivEXT = driverTbl.glProgramUniform1ivEXT;
   }
   driverTbl.glProgramUniform1ivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform2ivEXT" );
}

static void REGAL_CALL loader_glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2ivEXT, "glProgramUniform2ivEXT");
   if ( !driverTbl.glProgramUniform2ivEXT ) {
      driverTbl.glProgramUniform2ivEXT = missing_glProgramUniform2ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2ivEXT == loader_glProgramUniform2ivEXT) {
      rCtx->dsp.emuTbl.glProgramUniform2ivEXT = driverTbl.glProgramUniform2ivEXT;
   }
   driverTbl.glProgramUniform2ivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform3ivEXT" );
}

static void REGAL_CALL loader_glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3ivEXT, "glProgramUniform3ivEXT");
   if ( !driverTbl.glProgramUniform3ivEXT ) {
      driverTbl.glProgramUniform3ivEXT = missing_glProgramUniform3ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3ivEXT == loader_glProgramUniform3ivEXT) {
      rCtx->dsp.emuTbl.glProgramUniform3ivEXT = driverTbl.glProgramUniform3ivEXT;
   }
   driverTbl.glProgramUniform3ivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform4ivEXT" );
}

static void REGAL_CALL loader_glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4ivEXT, "glProgramUniform4ivEXT");
   if ( !driverTbl.glProgramUniform4ivEXT ) {
      driverTbl.glProgramUniform4ivEXT = missing_glProgramUniform4ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4ivEXT == loader_glProgramUniform4ivEXT) {
      rCtx->dsp.emuTbl.glProgramUniform4ivEXT = driverTbl.glProgramUniform4ivEXT;
   }
   driverTbl.glProgramUniform4ivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix2fvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix2fvEXT, "glProgramUniformMatrix2fvEXT");
   if ( !driverTbl.glProgramUniformMatrix2fvEXT ) {
      driverTbl.glProgramUniformMatrix2fvEXT = missing_glProgramUniformMatrix2fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix2fvEXT == loader_glProgramUniformMatrix2fvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix2fvEXT = driverTbl.glProgramUniformMatrix2fvEXT;
   }
   driverTbl.glProgramUniformMatrix2fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix3fvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix3fvEXT, "glProgramUniformMatrix3fvEXT");
   if ( !driverTbl.glProgramUniformMatrix3fvEXT ) {
      driverTbl.glProgramUniformMatrix3fvEXT = missing_glProgramUniformMatrix3fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix3fvEXT == loader_glProgramUniformMatrix3fvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix3fvEXT = driverTbl.glProgramUniformMatrix3fvEXT;
   }
   driverTbl.glProgramUniformMatrix3fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix4fvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix4fvEXT, "glProgramUniformMatrix4fvEXT");
   if ( !driverTbl.glProgramUniformMatrix4fvEXT ) {
      driverTbl.glProgramUniformMatrix4fvEXT = missing_glProgramUniformMatrix4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix4fvEXT == loader_glProgramUniformMatrix4fvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix4fvEXT = driverTbl.glProgramUniformMatrix4fvEXT;
   }
   driverTbl.glProgramUniformMatrix4fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix2x3fvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix2x3fvEXT, "glProgramUniformMatrix2x3fvEXT");
   if ( !driverTbl.glProgramUniformMatrix2x3fvEXT ) {
      driverTbl.glProgramUniformMatrix2x3fvEXT = missing_glProgramUniformMatrix2x3fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix2x3fvEXT == loader_glProgramUniformMatrix2x3fvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix2x3fvEXT = driverTbl.glProgramUniformMatrix2x3fvEXT;
   }
   driverTbl.glProgramUniformMatrix2x3fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix3x2fvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix3x2fvEXT, "glProgramUniformMatrix3x2fvEXT");
   if ( !driverTbl.glProgramUniformMatrix3x2fvEXT ) {
      driverTbl.glProgramUniformMatrix3x2fvEXT = missing_glProgramUniformMatrix3x2fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix3x2fvEXT == loader_glProgramUniformMatrix3x2fvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix3x2fvEXT = driverTbl.glProgramUniformMatrix3x2fvEXT;
   }
   driverTbl.glProgramUniformMatrix3x2fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix2x4fvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix2x4fvEXT, "glProgramUniformMatrix2x4fvEXT");
   if ( !driverTbl.glProgramUniformMatrix2x4fvEXT ) {
      driverTbl.glProgramUniformMatrix2x4fvEXT = missing_glProgramUniformMatrix2x4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix2x4fvEXT == loader_glProgramUniformMatrix2x4fvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix2x4fvEXT = driverTbl.glProgramUniformMatrix2x4fvEXT;
   }
   driverTbl.glProgramUniformMatrix2x4fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix4x2fvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix4x2fvEXT, "glProgramUniformMatrix4x2fvEXT");
   if ( !driverTbl.glProgramUniformMatrix4x2fvEXT ) {
      driverTbl.glProgramUniformMatrix4x2fvEXT = missing_glProgramUniformMatrix4x2fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix4x2fvEXT == loader_glProgramUniformMatrix4x2fvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix4x2fvEXT = driverTbl.glProgramUniformMatrix4x2fvEXT;
   }
   driverTbl.glProgramUniformMatrix4x2fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix3x4fvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix3x4fvEXT, "glProgramUniformMatrix3x4fvEXT");
   if ( !driverTbl.glProgramUniformMatrix3x4fvEXT ) {
      driverTbl.glProgramUniformMatrix3x4fvEXT = missing_glProgramUniformMatrix3x4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix3x4fvEXT == loader_glProgramUniformMatrix3x4fvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix3x4fvEXT = driverTbl.glProgramUniformMatrix3x4fvEXT;
   }
   driverTbl.glProgramUniformMatrix3x4fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix4x3fvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix4x3fvEXT, "glProgramUniformMatrix4x3fvEXT");
   if ( !driverTbl.glProgramUniformMatrix4x3fvEXT ) {
      driverTbl.glProgramUniformMatrix4x3fvEXT = missing_glProgramUniformMatrix4x3fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix4x3fvEXT == loader_glProgramUniformMatrix4x3fvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix4x3fvEXT = driverTbl.glProgramUniformMatrix4x3fvEXT;
   }
   driverTbl.glProgramUniformMatrix4x3fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "Called missing function glProgramUniform1uiEXT" );
}

static void REGAL_CALL loader_glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1uiEXT, "glProgramUniform1uiEXT");
   if ( !driverTbl.glProgramUniform1uiEXT ) {
      driverTbl.glProgramUniform1uiEXT = missing_glProgramUniform1uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1uiEXT == loader_glProgramUniform1uiEXT) {
      rCtx->dsp.emuTbl.glProgramUniform1uiEXT = driverTbl.glProgramUniform1uiEXT;
   }
   driverTbl.glProgramUniform1uiEXT(program, location, v0);
}

static void REGAL_CALL missing_glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "Called missing function glProgramUniform2uiEXT" );
}

static void REGAL_CALL loader_glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2uiEXT, "glProgramUniform2uiEXT");
   if ( !driverTbl.glProgramUniform2uiEXT ) {
      driverTbl.glProgramUniform2uiEXT = missing_glProgramUniform2uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2uiEXT == loader_glProgramUniform2uiEXT) {
      rCtx->dsp.emuTbl.glProgramUniform2uiEXT = driverTbl.glProgramUniform2uiEXT;
   }
   driverTbl.glProgramUniform2uiEXT(program, location, v0, v1);
}

static void REGAL_CALL missing_glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "Called missing function glProgramUniform3uiEXT" );
}

static void REGAL_CALL loader_glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3uiEXT, "glProgramUniform3uiEXT");
   if ( !driverTbl.glProgramUniform3uiEXT ) {
      driverTbl.glProgramUniform3uiEXT = missing_glProgramUniform3uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3uiEXT == loader_glProgramUniform3uiEXT) {
      rCtx->dsp.emuTbl.glProgramUniform3uiEXT = driverTbl.glProgramUniform3uiEXT;
   }
   driverTbl.glProgramUniform3uiEXT(program, location, v0, v1, v2);
}

static void REGAL_CALL missing_glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "Called missing function glProgramUniform4uiEXT" );
}

static void REGAL_CALL loader_glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4uiEXT, "glProgramUniform4uiEXT");
   if ( !driverTbl.glProgramUniform4uiEXT ) {
      driverTbl.glProgramUniform4uiEXT = missing_glProgramUniform4uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4uiEXT == loader_glProgramUniform4uiEXT) {
      rCtx->dsp.emuTbl.glProgramUniform4uiEXT = driverTbl.glProgramUniform4uiEXT;
   }
   driverTbl.glProgramUniform4uiEXT(program, location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform1uivEXT" );
}

static void REGAL_CALL loader_glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1uivEXT, "glProgramUniform1uivEXT");
   if ( !driverTbl.glProgramUniform1uivEXT ) {
      driverTbl.glProgramUniform1uivEXT = missing_glProgramUniform1uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1uivEXT == loader_glProgramUniform1uivEXT) {
      rCtx->dsp.emuTbl.glProgramUniform1uivEXT = driverTbl.glProgramUniform1uivEXT;
   }
   driverTbl.glProgramUniform1uivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform2uivEXT" );
}

static void REGAL_CALL loader_glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2uivEXT, "glProgramUniform2uivEXT");
   if ( !driverTbl.glProgramUniform2uivEXT ) {
      driverTbl.glProgramUniform2uivEXT = missing_glProgramUniform2uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2uivEXT == loader_glProgramUniform2uivEXT) {
      rCtx->dsp.emuTbl.glProgramUniform2uivEXT = driverTbl.glProgramUniform2uivEXT;
   }
   driverTbl.glProgramUniform2uivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform3uivEXT" );
}

static void REGAL_CALL loader_glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3uivEXT, "glProgramUniform3uivEXT");
   if ( !driverTbl.glProgramUniform3uivEXT ) {
      driverTbl.glProgramUniform3uivEXT = missing_glProgramUniform3uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3uivEXT == loader_glProgramUniform3uivEXT) {
      rCtx->dsp.emuTbl.glProgramUniform3uivEXT = driverTbl.glProgramUniform3uivEXT;
   }
   driverTbl.glProgramUniform3uivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform4uivEXT" );
}

static void REGAL_CALL loader_glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4uivEXT, "glProgramUniform4uivEXT");
   if ( !driverTbl.glProgramUniform4uivEXT ) {
      driverTbl.glProgramUniform4uivEXT = missing_glProgramUniform4uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4uivEXT == loader_glProgramUniform4uivEXT) {
      rCtx->dsp.emuTbl.glProgramUniform4uivEXT = driverTbl.glProgramUniform4uivEXT;
   }
   driverTbl.glProgramUniform4uivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   UNUSED_PARAMETER(usage);
   Warning( "Called missing function glNamedBufferDataEXT" );
}

static void REGAL_CALL loader_glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedBufferDataEXT, "glNamedBufferDataEXT");
   if ( !driverTbl.glNamedBufferDataEXT ) {
      driverTbl.glNamedBufferDataEXT = missing_glNamedBufferDataEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedBufferDataEXT == loader_glNamedBufferDataEXT) {
      rCtx->dsp.emuTbl.glNamedBufferDataEXT = driverTbl.glNamedBufferDataEXT;
   }
   driverTbl.glNamedBufferDataEXT(buffer, size, data, usage);
}

static void REGAL_CALL missing_glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glNamedBufferSubDataEXT" );
}

static void REGAL_CALL loader_glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedBufferSubDataEXT, "glNamedBufferSubDataEXT");
   if ( !driverTbl.glNamedBufferSubDataEXT ) {
      driverTbl.glNamedBufferSubDataEXT = missing_glNamedBufferSubDataEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedBufferSubDataEXT == loader_glNamedBufferSubDataEXT) {
      rCtx->dsp.emuTbl.glNamedBufferSubDataEXT = driverTbl.glNamedBufferSubDataEXT;
   }
   driverTbl.glNamedBufferSubDataEXT(buffer, offset, size, data);
}

static GLvoid *REGAL_CALL missing_glMapNamedBufferEXT(GLuint buffer, GLenum access)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(access);
   Warning( "Called missing function glMapNamedBufferEXT" );
  GLvoid * ret = NULL;
  return ret;
}

static GLvoid *REGAL_CALL loader_glMapNamedBufferEXT(GLuint buffer, GLenum access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapNamedBufferEXT, "glMapNamedBufferEXT");
   if ( !driverTbl.glMapNamedBufferEXT ) {
      driverTbl.glMapNamedBufferEXT = missing_glMapNamedBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapNamedBufferEXT == loader_glMapNamedBufferEXT) {
      rCtx->dsp.emuTbl.glMapNamedBufferEXT = driverTbl.glMapNamedBufferEXT;
   }
   return driverTbl.glMapNamedBufferEXT(buffer, access);
}

static GLboolean REGAL_CALL missing_glUnmapNamedBufferEXT(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glUnmapNamedBufferEXT" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glUnmapNamedBufferEXT(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUnmapNamedBufferEXT, "glUnmapNamedBufferEXT");
   if ( !driverTbl.glUnmapNamedBufferEXT ) {
      driverTbl.glUnmapNamedBufferEXT = missing_glUnmapNamedBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUnmapNamedBufferEXT == loader_glUnmapNamedBufferEXT) {
      rCtx->dsp.emuTbl.glUnmapNamedBufferEXT = driverTbl.glUnmapNamedBufferEXT;
   }
   return driverTbl.glUnmapNamedBufferEXT(buffer);
}

static void REGAL_CALL missing_glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetNamedBufferParameterivEXT" );
}

static void REGAL_CALL loader_glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetNamedBufferParameterivEXT, "glGetNamedBufferParameterivEXT");
   if ( !driverTbl.glGetNamedBufferParameterivEXT ) {
      driverTbl.glGetNamedBufferParameterivEXT = missing_glGetNamedBufferParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetNamedBufferParameterivEXT == loader_glGetNamedBufferParameterivEXT) {
      rCtx->dsp.emuTbl.glGetNamedBufferParameterivEXT = driverTbl.glGetNamedBufferParameterivEXT;
   }
   driverTbl.glGetNamedBufferParameterivEXT(buffer, pname, params);
}

static void REGAL_CALL missing_glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, GLvoid **params)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetNamedBufferPointervEXT" );
}

static void REGAL_CALL loader_glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, GLvoid **params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetNamedBufferPointervEXT, "glGetNamedBufferPointervEXT");
   if ( !driverTbl.glGetNamedBufferPointervEXT ) {
      driverTbl.glGetNamedBufferPointervEXT = missing_glGetNamedBufferPointervEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetNamedBufferPointervEXT == loader_glGetNamedBufferPointervEXT) {
      rCtx->dsp.emuTbl.glGetNamedBufferPointervEXT = driverTbl.glGetNamedBufferPointervEXT;
   }
   driverTbl.glGetNamedBufferPointervEXT(buffer, pname, params);
}

static void REGAL_CALL missing_glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetNamedBufferSubDataEXT" );
}

static void REGAL_CALL loader_glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetNamedBufferSubDataEXT, "glGetNamedBufferSubDataEXT");
   if ( !driverTbl.glGetNamedBufferSubDataEXT ) {
      driverTbl.glGetNamedBufferSubDataEXT = missing_glGetNamedBufferSubDataEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetNamedBufferSubDataEXT == loader_glGetNamedBufferSubDataEXT) {
      rCtx->dsp.emuTbl.glGetNamedBufferSubDataEXT = driverTbl.glGetNamedBufferSubDataEXT;
   }
   driverTbl.glGetNamedBufferSubDataEXT(buffer, offset, size, data);
}

static void REGAL_CALL missing_glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glTextureBufferEXT" );
}

static void REGAL_CALL loader_glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureBufferEXT, "glTextureBufferEXT");
   if ( !driverTbl.glTextureBufferEXT ) {
      driverTbl.glTextureBufferEXT = missing_glTextureBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureBufferEXT == loader_glTextureBufferEXT) {
      rCtx->dsp.emuTbl.glTextureBufferEXT = driverTbl.glTextureBufferEXT;
   }
   driverTbl.glTextureBufferEXT(texture, target, internalformat, buffer);
}

static void REGAL_CALL missing_glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glMultiTexBufferEXT" );
}

static void REGAL_CALL loader_glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexBufferEXT, "glMultiTexBufferEXT");
   if ( !driverTbl.glMultiTexBufferEXT ) {
      driverTbl.glMultiTexBufferEXT = missing_glMultiTexBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexBufferEXT == loader_glMultiTexBufferEXT) {
      rCtx->dsp.emuTbl.glMultiTexBufferEXT = driverTbl.glMultiTexBufferEXT;
   }
   driverTbl.glMultiTexBufferEXT(texunit, target, internalformat, buffer);
}

static void REGAL_CALL missing_glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(renderbuffer);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glNamedRenderbufferStorageEXT" );
}

static void REGAL_CALL loader_glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedRenderbufferStorageEXT, "glNamedRenderbufferStorageEXT");
   if ( !driverTbl.glNamedRenderbufferStorageEXT ) {
      driverTbl.glNamedRenderbufferStorageEXT = missing_glNamedRenderbufferStorageEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedRenderbufferStorageEXT == loader_glNamedRenderbufferStorageEXT) {
      rCtx->dsp.emuTbl.glNamedRenderbufferStorageEXT = driverTbl.glNamedRenderbufferStorageEXT;
   }
   driverTbl.glNamedRenderbufferStorageEXT(renderbuffer, internalformat, width, height);
}

static void REGAL_CALL missing_glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(renderbuffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetNamedRenderbufferParameterivEXT" );
}

static void REGAL_CALL loader_glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetNamedRenderbufferParameterivEXT, "glGetNamedRenderbufferParameterivEXT");
   if ( !driverTbl.glGetNamedRenderbufferParameterivEXT ) {
      driverTbl.glGetNamedRenderbufferParameterivEXT = missing_glGetNamedRenderbufferParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetNamedRenderbufferParameterivEXT == loader_glGetNamedRenderbufferParameterivEXT) {
      rCtx->dsp.emuTbl.glGetNamedRenderbufferParameterivEXT = driverTbl.glGetNamedRenderbufferParameterivEXT;
   }
   driverTbl.glGetNamedRenderbufferParameterivEXT(renderbuffer, pname, params);
}

static GLenum REGAL_CALL missing_glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glCheckNamedFramebufferStatusEXT" );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCheckNamedFramebufferStatusEXT, "glCheckNamedFramebufferStatusEXT");
   if ( !driverTbl.glCheckNamedFramebufferStatusEXT ) {
      driverTbl.glCheckNamedFramebufferStatusEXT = missing_glCheckNamedFramebufferStatusEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCheckNamedFramebufferStatusEXT == loader_glCheckNamedFramebufferStatusEXT) {
      rCtx->dsp.emuTbl.glCheckNamedFramebufferStatusEXT = driverTbl.glCheckNamedFramebufferStatusEXT;
   }
   return driverTbl.glCheckNamedFramebufferStatusEXT(framebuffer, target);
}

static void REGAL_CALL missing_glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "Called missing function glNamedFramebufferTexture1DEXT" );
}

static void REGAL_CALL loader_glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedFramebufferTexture1DEXT, "glNamedFramebufferTexture1DEXT");
   if ( !driverTbl.glNamedFramebufferTexture1DEXT ) {
      driverTbl.glNamedFramebufferTexture1DEXT = missing_glNamedFramebufferTexture1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedFramebufferTexture1DEXT == loader_glNamedFramebufferTexture1DEXT) {
      rCtx->dsp.emuTbl.glNamedFramebufferTexture1DEXT = driverTbl.glNamedFramebufferTexture1DEXT;
   }
   driverTbl.glNamedFramebufferTexture1DEXT(framebuffer, attachment, textarget, texture, level);
}

static void REGAL_CALL missing_glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "Called missing function glNamedFramebufferTexture2DEXT" );
}

static void REGAL_CALL loader_glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedFramebufferTexture2DEXT, "glNamedFramebufferTexture2DEXT");
   if ( !driverTbl.glNamedFramebufferTexture2DEXT ) {
      driverTbl.glNamedFramebufferTexture2DEXT = missing_glNamedFramebufferTexture2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedFramebufferTexture2DEXT == loader_glNamedFramebufferTexture2DEXT) {
      rCtx->dsp.emuTbl.glNamedFramebufferTexture2DEXT = driverTbl.glNamedFramebufferTexture2DEXT;
   }
   driverTbl.glNamedFramebufferTexture2DEXT(framebuffer, attachment, textarget, texture, level);
}

static void REGAL_CALL missing_glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(zoffset);
   Warning( "Called missing function glNamedFramebufferTexture3DEXT" );
}

static void REGAL_CALL loader_glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedFramebufferTexture3DEXT, "glNamedFramebufferTexture3DEXT");
   if ( !driverTbl.glNamedFramebufferTexture3DEXT ) {
      driverTbl.glNamedFramebufferTexture3DEXT = missing_glNamedFramebufferTexture3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedFramebufferTexture3DEXT == loader_glNamedFramebufferTexture3DEXT) {
      rCtx->dsp.emuTbl.glNamedFramebufferTexture3DEXT = driverTbl.glNamedFramebufferTexture3DEXT;
   }
   driverTbl.glNamedFramebufferTexture3DEXT(framebuffer, attachment, textarget, texture, level, zoffset);
}

static void REGAL_CALL missing_glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(renderbuffertarget);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "Called missing function glNamedFramebufferRenderbufferEXT" );
}

static void REGAL_CALL loader_glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedFramebufferRenderbufferEXT, "glNamedFramebufferRenderbufferEXT");
   if ( !driverTbl.glNamedFramebufferRenderbufferEXT ) {
      driverTbl.glNamedFramebufferRenderbufferEXT = missing_glNamedFramebufferRenderbufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedFramebufferRenderbufferEXT == loader_glNamedFramebufferRenderbufferEXT) {
      rCtx->dsp.emuTbl.glNamedFramebufferRenderbufferEXT = driverTbl.glNamedFramebufferRenderbufferEXT;
   }
   driverTbl.glNamedFramebufferRenderbufferEXT(framebuffer, attachment, renderbuffertarget, renderbuffer);
}

static void REGAL_CALL missing_glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetNamedFramebufferAttachmentParameterivEXT" );
}

static void REGAL_CALL loader_glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetNamedFramebufferAttachmentParameterivEXT, "glGetNamedFramebufferAttachmentParameterivEXT");
   if ( !driverTbl.glGetNamedFramebufferAttachmentParameterivEXT ) {
      driverTbl.glGetNamedFramebufferAttachmentParameterivEXT = missing_glGetNamedFramebufferAttachmentParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetNamedFramebufferAttachmentParameterivEXT == loader_glGetNamedFramebufferAttachmentParameterivEXT) {
      rCtx->dsp.emuTbl.glGetNamedFramebufferAttachmentParameterivEXT = driverTbl.glGetNamedFramebufferAttachmentParameterivEXT;
   }
   driverTbl.glGetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, params);
}

static void REGAL_CALL missing_glGenerateTextureMipmapEXT(GLuint texture, GLenum target)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glGenerateTextureMipmapEXT" );
}

static void REGAL_CALL loader_glGenerateTextureMipmapEXT(GLuint texture, GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenerateTextureMipmapEXT, "glGenerateTextureMipmapEXT");
   if ( !driverTbl.glGenerateTextureMipmapEXT ) {
      driverTbl.glGenerateTextureMipmapEXT = missing_glGenerateTextureMipmapEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenerateTextureMipmapEXT == loader_glGenerateTextureMipmapEXT) {
      rCtx->dsp.emuTbl.glGenerateTextureMipmapEXT = driverTbl.glGenerateTextureMipmapEXT;
   }
   driverTbl.glGenerateTextureMipmapEXT(texture, target);
}

static void REGAL_CALL missing_glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glGenerateMultiTexMipmapEXT" );
}

static void REGAL_CALL loader_glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenerateMultiTexMipmapEXT, "glGenerateMultiTexMipmapEXT");
   if ( !driverTbl.glGenerateMultiTexMipmapEXT ) {
      driverTbl.glGenerateMultiTexMipmapEXT = missing_glGenerateMultiTexMipmapEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenerateMultiTexMipmapEXT == loader_glGenerateMultiTexMipmapEXT) {
      rCtx->dsp.emuTbl.glGenerateMultiTexMipmapEXT = driverTbl.glGenerateMultiTexMipmapEXT;
   }
   driverTbl.glGenerateMultiTexMipmapEXT(texunit, target);
}

static void REGAL_CALL missing_glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glFramebufferDrawBufferEXT" );
}

static void REGAL_CALL loader_glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferDrawBufferEXT, "glFramebufferDrawBufferEXT");
   if ( !driverTbl.glFramebufferDrawBufferEXT ) {
      driverTbl.glFramebufferDrawBufferEXT = missing_glFramebufferDrawBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferDrawBufferEXT == loader_glFramebufferDrawBufferEXT) {
      rCtx->dsp.emuTbl.glFramebufferDrawBufferEXT = driverTbl.glFramebufferDrawBufferEXT;
   }
   driverTbl.glFramebufferDrawBufferEXT(framebuffer, mode);
}

static void REGAL_CALL missing_glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum *bufs)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(bufs);
   Warning( "Called missing function glFramebufferDrawBuffersEXT" );
}

static void REGAL_CALL loader_glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum *bufs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferDrawBuffersEXT, "glFramebufferDrawBuffersEXT");
   if ( !driverTbl.glFramebufferDrawBuffersEXT ) {
      driverTbl.glFramebufferDrawBuffersEXT = missing_glFramebufferDrawBuffersEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferDrawBuffersEXT == loader_glFramebufferDrawBuffersEXT) {
      rCtx->dsp.emuTbl.glFramebufferDrawBuffersEXT = driverTbl.glFramebufferDrawBuffersEXT;
   }
   driverTbl.glFramebufferDrawBuffersEXT(framebuffer, n, bufs);
}

static void REGAL_CALL missing_glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glFramebufferReadBufferEXT" );
}

static void REGAL_CALL loader_glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFramebufferReadBufferEXT, "glFramebufferReadBufferEXT");
   if ( !driverTbl.glFramebufferReadBufferEXT ) {
      driverTbl.glFramebufferReadBufferEXT = missing_glFramebufferReadBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFramebufferReadBufferEXT == loader_glFramebufferReadBufferEXT) {
      rCtx->dsp.emuTbl.glFramebufferReadBufferEXT = driverTbl.glFramebufferReadBufferEXT;
   }
   driverTbl.glFramebufferReadBufferEXT(framebuffer, mode);
}

static void REGAL_CALL missing_glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFramebufferParameterivEXT" );
}

static void REGAL_CALL loader_glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFramebufferParameterivEXT, "glGetFramebufferParameterivEXT");
   if ( !driverTbl.glGetFramebufferParameterivEXT ) {
      driverTbl.glGetFramebufferParameterivEXT = missing_glGetFramebufferParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFramebufferParameterivEXT == loader_glGetFramebufferParameterivEXT) {
      rCtx->dsp.emuTbl.glGetFramebufferParameterivEXT = driverTbl.glGetFramebufferParameterivEXT;
   }
   driverTbl.glGetFramebufferParameterivEXT(framebuffer, pname, params);
}

static void REGAL_CALL missing_glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(renderbuffer);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glNamedRenderbufferStorageMultisampleEXT" );
}

static void REGAL_CALL loader_glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedRenderbufferStorageMultisampleEXT, "glNamedRenderbufferStorageMultisampleEXT");
   if ( !driverTbl.glNamedRenderbufferStorageMultisampleEXT ) {
      driverTbl.glNamedRenderbufferStorageMultisampleEXT = missing_glNamedRenderbufferStorageMultisampleEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedRenderbufferStorageMultisampleEXT == loader_glNamedRenderbufferStorageMultisampleEXT) {
      rCtx->dsp.emuTbl.glNamedRenderbufferStorageMultisampleEXT = driverTbl.glNamedRenderbufferStorageMultisampleEXT;
   }
   driverTbl.glNamedRenderbufferStorageMultisampleEXT(renderbuffer, samples, internalformat, width, height);
}

static void REGAL_CALL missing_glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(renderbuffer);
   UNUSED_PARAMETER(coverageSamples);
   UNUSED_PARAMETER(colorSamples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glNamedRenderbufferStorageMultisampleCoverageEXT" );
}

static void REGAL_CALL loader_glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedRenderbufferStorageMultisampleCoverageEXT, "glNamedRenderbufferStorageMultisampleCoverageEXT");
   if ( !driverTbl.glNamedRenderbufferStorageMultisampleCoverageEXT ) {
      driverTbl.glNamedRenderbufferStorageMultisampleCoverageEXT = missing_glNamedRenderbufferStorageMultisampleCoverageEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedRenderbufferStorageMultisampleCoverageEXT == loader_glNamedRenderbufferStorageMultisampleCoverageEXT) {
      rCtx->dsp.emuTbl.glNamedRenderbufferStorageMultisampleCoverageEXT = driverTbl.glNamedRenderbufferStorageMultisampleCoverageEXT;
   }
   driverTbl.glNamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
}

static void REGAL_CALL missing_glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "Called missing function glNamedFramebufferTextureEXT" );
}

static void REGAL_CALL loader_glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedFramebufferTextureEXT, "glNamedFramebufferTextureEXT");
   if ( !driverTbl.glNamedFramebufferTextureEXT ) {
      driverTbl.glNamedFramebufferTextureEXT = missing_glNamedFramebufferTextureEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedFramebufferTextureEXT == loader_glNamedFramebufferTextureEXT) {
      rCtx->dsp.emuTbl.glNamedFramebufferTextureEXT = driverTbl.glNamedFramebufferTextureEXT;
   }
   driverTbl.glNamedFramebufferTextureEXT(framebuffer, attachment, texture, level);
}

static void REGAL_CALL missing_glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layer);
   Warning( "Called missing function glNamedFramebufferTextureLayerEXT" );
}

static void REGAL_CALL loader_glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedFramebufferTextureLayerEXT, "glNamedFramebufferTextureLayerEXT");
   if ( !driverTbl.glNamedFramebufferTextureLayerEXT ) {
      driverTbl.glNamedFramebufferTextureLayerEXT = missing_glNamedFramebufferTextureLayerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedFramebufferTextureLayerEXT == loader_glNamedFramebufferTextureLayerEXT) {
      rCtx->dsp.emuTbl.glNamedFramebufferTextureLayerEXT = driverTbl.glNamedFramebufferTextureLayerEXT;
   }
   driverTbl.glNamedFramebufferTextureLayerEXT(framebuffer, attachment, texture, level, layer);
}

static void REGAL_CALL missing_glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(face);
   Warning( "Called missing function glNamedFramebufferTextureFaceEXT" );
}

static void REGAL_CALL loader_glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedFramebufferTextureFaceEXT, "glNamedFramebufferTextureFaceEXT");
   if ( !driverTbl.glNamedFramebufferTextureFaceEXT ) {
      driverTbl.glNamedFramebufferTextureFaceEXT = missing_glNamedFramebufferTextureFaceEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedFramebufferTextureFaceEXT == loader_glNamedFramebufferTextureFaceEXT) {
      rCtx->dsp.emuTbl.glNamedFramebufferTextureFaceEXT = driverTbl.glNamedFramebufferTextureFaceEXT;
   }
   driverTbl.glNamedFramebufferTextureFaceEXT(framebuffer, attachment, texture, level, face);
}

static void REGAL_CALL missing_glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "Called missing function glTextureRenderbufferEXT" );
}

static void REGAL_CALL loader_glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureRenderbufferEXT, "glTextureRenderbufferEXT");
   if ( !driverTbl.glTextureRenderbufferEXT ) {
      driverTbl.glTextureRenderbufferEXT = missing_glTextureRenderbufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureRenderbufferEXT == loader_glTextureRenderbufferEXT) {
      rCtx->dsp.emuTbl.glTextureRenderbufferEXT = driverTbl.glTextureRenderbufferEXT;
   }
   driverTbl.glTextureRenderbufferEXT(texture, target, renderbuffer);
}

static void REGAL_CALL missing_glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "Called missing function glMultiTexRenderbufferEXT" );
}

static void REGAL_CALL loader_glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiTexRenderbufferEXT, "glMultiTexRenderbufferEXT");
   if ( !driverTbl.glMultiTexRenderbufferEXT ) {
      driverTbl.glMultiTexRenderbufferEXT = missing_glMultiTexRenderbufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiTexRenderbufferEXT == loader_glMultiTexRenderbufferEXT) {
      rCtx->dsp.emuTbl.glMultiTexRenderbufferEXT = driverTbl.glMultiTexRenderbufferEXT;
   }
   driverTbl.glMultiTexRenderbufferEXT(texunit, target, renderbuffer);
}

static GLvoid *REGAL_CALL missing_glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(access);
   Warning( "Called missing function glMapNamedBufferRangeEXT" );
  GLvoid * ret = NULL;
  return ret;
}

static GLvoid *REGAL_CALL loader_glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapNamedBufferRangeEXT, "glMapNamedBufferRangeEXT");
   if ( !driverTbl.glMapNamedBufferRangeEXT ) {
      driverTbl.glMapNamedBufferRangeEXT = missing_glMapNamedBufferRangeEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapNamedBufferRangeEXT == loader_glMapNamedBufferRangeEXT) {
      rCtx->dsp.emuTbl.glMapNamedBufferRangeEXT = driverTbl.glMapNamedBufferRangeEXT;
   }
   return driverTbl.glMapNamedBufferRangeEXT(buffer, offset, length, access);
}

static void REGAL_CALL missing_glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(length);
   Warning( "Called missing function glFlushMappedNamedBufferRangeEXT" );
}

static void REGAL_CALL loader_glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFlushMappedNamedBufferRangeEXT, "glFlushMappedNamedBufferRangeEXT");
   if ( !driverTbl.glFlushMappedNamedBufferRangeEXT ) {
      driverTbl.glFlushMappedNamedBufferRangeEXT = missing_glFlushMappedNamedBufferRangeEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFlushMappedNamedBufferRangeEXT == loader_glFlushMappedNamedBufferRangeEXT) {
      rCtx->dsp.emuTbl.glFlushMappedNamedBufferRangeEXT = driverTbl.glFlushMappedNamedBufferRangeEXT;
   }
   driverTbl.glFlushMappedNamedBufferRangeEXT(buffer, offset, length);
}

static void REGAL_CALL missing_glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
   UNUSED_PARAMETER(readBuffer);
   UNUSED_PARAMETER(writeBuffer);
   UNUSED_PARAMETER(readOffset);
   UNUSED_PARAMETER(writeOffset);
   UNUSED_PARAMETER(size);
   Warning( "Called missing function glNamedCopyBufferSubDataEXT" );
}

static void REGAL_CALL loader_glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNamedCopyBufferSubDataEXT, "glNamedCopyBufferSubDataEXT");
   if ( !driverTbl.glNamedCopyBufferSubDataEXT ) {
      driverTbl.glNamedCopyBufferSubDataEXT = missing_glNamedCopyBufferSubDataEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNamedCopyBufferSubDataEXT == loader_glNamedCopyBufferSubDataEXT) {
      rCtx->dsp.emuTbl.glNamedCopyBufferSubDataEXT = driverTbl.glNamedCopyBufferSubDataEXT;
   }
   driverTbl.glNamedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size);
}

static void REGAL_CALL missing_glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glProgramUniform1dEXT" );
}

static void REGAL_CALL loader_glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1dEXT, "glProgramUniform1dEXT");
   if ( !driverTbl.glProgramUniform1dEXT ) {
      driverTbl.glProgramUniform1dEXT = missing_glProgramUniform1dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1dEXT == loader_glProgramUniform1dEXT) {
      rCtx->dsp.emuTbl.glProgramUniform1dEXT = driverTbl.glProgramUniform1dEXT;
   }
   driverTbl.glProgramUniform1dEXT(program, location, x);
}

static void REGAL_CALL missing_glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glProgramUniform2dEXT" );
}

static void REGAL_CALL loader_glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2dEXT, "glProgramUniform2dEXT");
   if ( !driverTbl.glProgramUniform2dEXT ) {
      driverTbl.glProgramUniform2dEXT = missing_glProgramUniform2dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2dEXT == loader_glProgramUniform2dEXT) {
      rCtx->dsp.emuTbl.glProgramUniform2dEXT = driverTbl.glProgramUniform2dEXT;
   }
   driverTbl.glProgramUniform2dEXT(program, location, x, y);
}

static void REGAL_CALL missing_glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glProgramUniform3dEXT" );
}

static void REGAL_CALL loader_glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3dEXT, "glProgramUniform3dEXT");
   if ( !driverTbl.glProgramUniform3dEXT ) {
      driverTbl.glProgramUniform3dEXT = missing_glProgramUniform3dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3dEXT == loader_glProgramUniform3dEXT) {
      rCtx->dsp.emuTbl.glProgramUniform3dEXT = driverTbl.glProgramUniform3dEXT;
   }
   driverTbl.glProgramUniform3dEXT(program, location, x, y, z);
}

static void REGAL_CALL missing_glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramUniform4dEXT" );
}

static void REGAL_CALL loader_glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4dEXT, "glProgramUniform4dEXT");
   if ( !driverTbl.glProgramUniform4dEXT ) {
      driverTbl.glProgramUniform4dEXT = missing_glProgramUniform4dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4dEXT == loader_glProgramUniform4dEXT) {
      rCtx->dsp.emuTbl.glProgramUniform4dEXT = driverTbl.glProgramUniform4dEXT;
   }
   driverTbl.glProgramUniform4dEXT(program, location, x, y, z, w);
}

static void REGAL_CALL missing_glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform1dvEXT" );
}

static void REGAL_CALL loader_glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1dvEXT, "glProgramUniform1dvEXT");
   if ( !driverTbl.glProgramUniform1dvEXT ) {
      driverTbl.glProgramUniform1dvEXT = missing_glProgramUniform1dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1dvEXT == loader_glProgramUniform1dvEXT) {
      rCtx->dsp.emuTbl.glProgramUniform1dvEXT = driverTbl.glProgramUniform1dvEXT;
   }
   driverTbl.glProgramUniform1dvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform2dvEXT" );
}

static void REGAL_CALL loader_glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2dvEXT, "glProgramUniform2dvEXT");
   if ( !driverTbl.glProgramUniform2dvEXT ) {
      driverTbl.glProgramUniform2dvEXT = missing_glProgramUniform2dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2dvEXT == loader_glProgramUniform2dvEXT) {
      rCtx->dsp.emuTbl.glProgramUniform2dvEXT = driverTbl.glProgramUniform2dvEXT;
   }
   driverTbl.glProgramUniform2dvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform3dvEXT" );
}

static void REGAL_CALL loader_glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3dvEXT, "glProgramUniform3dvEXT");
   if ( !driverTbl.glProgramUniform3dvEXT ) {
      driverTbl.glProgramUniform3dvEXT = missing_glProgramUniform3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3dvEXT == loader_glProgramUniform3dvEXT) {
      rCtx->dsp.emuTbl.glProgramUniform3dvEXT = driverTbl.glProgramUniform3dvEXT;
   }
   driverTbl.glProgramUniform3dvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform4dvEXT" );
}

static void REGAL_CALL loader_glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4dvEXT, "glProgramUniform4dvEXT");
   if ( !driverTbl.glProgramUniform4dvEXT ) {
      driverTbl.glProgramUniform4dvEXT = missing_glProgramUniform4dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4dvEXT == loader_glProgramUniform4dvEXT) {
      rCtx->dsp.emuTbl.glProgramUniform4dvEXT = driverTbl.glProgramUniform4dvEXT;
   }
   driverTbl.glProgramUniform4dvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix2dvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix2dvEXT, "glProgramUniformMatrix2dvEXT");
   if ( !driverTbl.glProgramUniformMatrix2dvEXT ) {
      driverTbl.glProgramUniformMatrix2dvEXT = missing_glProgramUniformMatrix2dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix2dvEXT == loader_glProgramUniformMatrix2dvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix2dvEXT = driverTbl.glProgramUniformMatrix2dvEXT;
   }
   driverTbl.glProgramUniformMatrix2dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix3dvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix3dvEXT, "glProgramUniformMatrix3dvEXT");
   if ( !driverTbl.glProgramUniformMatrix3dvEXT ) {
      driverTbl.glProgramUniformMatrix3dvEXT = missing_glProgramUniformMatrix3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix3dvEXT == loader_glProgramUniformMatrix3dvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix3dvEXT = driverTbl.glProgramUniformMatrix3dvEXT;
   }
   driverTbl.glProgramUniformMatrix3dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix4dvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix4dvEXT, "glProgramUniformMatrix4dvEXT");
   if ( !driverTbl.glProgramUniformMatrix4dvEXT ) {
      driverTbl.glProgramUniformMatrix4dvEXT = missing_glProgramUniformMatrix4dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix4dvEXT == loader_glProgramUniformMatrix4dvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix4dvEXT = driverTbl.glProgramUniformMatrix4dvEXT;
   }
   driverTbl.glProgramUniformMatrix4dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix2x3dvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix2x3dvEXT, "glProgramUniformMatrix2x3dvEXT");
   if ( !driverTbl.glProgramUniformMatrix2x3dvEXT ) {
      driverTbl.glProgramUniformMatrix2x3dvEXT = missing_glProgramUniformMatrix2x3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix2x3dvEXT == loader_glProgramUniformMatrix2x3dvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix2x3dvEXT = driverTbl.glProgramUniformMatrix2x3dvEXT;
   }
   driverTbl.glProgramUniformMatrix2x3dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix2x4dvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix2x4dvEXT, "glProgramUniformMatrix2x4dvEXT");
   if ( !driverTbl.glProgramUniformMatrix2x4dvEXT ) {
      driverTbl.glProgramUniformMatrix2x4dvEXT = missing_glProgramUniformMatrix2x4dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix2x4dvEXT == loader_glProgramUniformMatrix2x4dvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix2x4dvEXT = driverTbl.glProgramUniformMatrix2x4dvEXT;
   }
   driverTbl.glProgramUniformMatrix2x4dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix3x2dvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix3x2dvEXT, "glProgramUniformMatrix3x2dvEXT");
   if ( !driverTbl.glProgramUniformMatrix3x2dvEXT ) {
      driverTbl.glProgramUniformMatrix3x2dvEXT = missing_glProgramUniformMatrix3x2dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix3x2dvEXT == loader_glProgramUniformMatrix3x2dvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix3x2dvEXT = driverTbl.glProgramUniformMatrix3x2dvEXT;
   }
   driverTbl.glProgramUniformMatrix3x2dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix3x4dvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix3x4dvEXT, "glProgramUniformMatrix3x4dvEXT");
   if ( !driverTbl.glProgramUniformMatrix3x4dvEXT ) {
      driverTbl.glProgramUniformMatrix3x4dvEXT = missing_glProgramUniformMatrix3x4dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix3x4dvEXT == loader_glProgramUniformMatrix3x4dvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix3x4dvEXT = driverTbl.glProgramUniformMatrix3x4dvEXT;
   }
   driverTbl.glProgramUniformMatrix3x4dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix4x2dvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix4x2dvEXT, "glProgramUniformMatrix4x2dvEXT");
   if ( !driverTbl.glProgramUniformMatrix4x2dvEXT ) {
      driverTbl.glProgramUniformMatrix4x2dvEXT = missing_glProgramUniformMatrix4x2dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix4x2dvEXT == loader_glProgramUniformMatrix4x2dvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix4x2dvEXT = driverTbl.glProgramUniformMatrix4x2dvEXT;
   }
   driverTbl.glProgramUniformMatrix4x2dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformMatrix4x3dvEXT" );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformMatrix4x3dvEXT, "glProgramUniformMatrix4x3dvEXT");
   if ( !driverTbl.glProgramUniformMatrix4x3dvEXT ) {
      driverTbl.glProgramUniformMatrix4x3dvEXT = missing_glProgramUniformMatrix4x3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformMatrix4x3dvEXT == loader_glProgramUniformMatrix4x3dvEXT) {
      rCtx->dsp.emuTbl.glProgramUniformMatrix4x3dvEXT = driverTbl.glProgramUniformMatrix4x3dvEXT;
   }
   driverTbl.glProgramUniformMatrix4x3dvEXT(program, location, count, transpose, value);
}

// GL_NV_explicit_multisample

static void REGAL_CALL missing_glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat *val)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(val);
   Warning( "Called missing function glGetMultisamplefvNV" );
}

static void REGAL_CALL loader_glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat *val)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetMultisamplefvNV, "glGetMultisamplefvNV");
   if ( !driverTbl.glGetMultisamplefvNV ) {
      driverTbl.glGetMultisamplefvNV = missing_glGetMultisamplefvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetMultisamplefvNV == loader_glGetMultisamplefvNV) {
      rCtx->dsp.emuTbl.glGetMultisamplefvNV = driverTbl.glGetMultisamplefvNV;
   }
   driverTbl.glGetMultisamplefvNV(pname, index, val);
}

static void REGAL_CALL missing_glSampleMaskIndexedNV(GLuint index, GLbitfield mask)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glSampleMaskIndexedNV" );
}

static void REGAL_CALL loader_glSampleMaskIndexedNV(GLuint index, GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSampleMaskIndexedNV, "glSampleMaskIndexedNV");
   if ( !driverTbl.glSampleMaskIndexedNV ) {
      driverTbl.glSampleMaskIndexedNV = missing_glSampleMaskIndexedNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSampleMaskIndexedNV == loader_glSampleMaskIndexedNV) {
      rCtx->dsp.emuTbl.glSampleMaskIndexedNV = driverTbl.glSampleMaskIndexedNV;
   }
   driverTbl.glSampleMaskIndexedNV(index, mask);
}

static void REGAL_CALL missing_glTexRenderbufferNV(GLenum target, GLuint renderbuffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "Called missing function glTexRenderbufferNV" );
}

static void REGAL_CALL loader_glTexRenderbufferNV(GLenum target, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexRenderbufferNV, "glTexRenderbufferNV");
   if ( !driverTbl.glTexRenderbufferNV ) {
      driverTbl.glTexRenderbufferNV = missing_glTexRenderbufferNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexRenderbufferNV == loader_glTexRenderbufferNV) {
      rCtx->dsp.emuTbl.glTexRenderbufferNV = driverTbl.glTexRenderbufferNV;
   }
   driverTbl.glTexRenderbufferNV(target, renderbuffer);
}

// GL_NV_transform_feedback2

static void REGAL_CALL missing_glBindTransformFeedbackNV(GLenum target, GLuint id)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glBindTransformFeedbackNV" );
}

static void REGAL_CALL loader_glBindTransformFeedbackNV(GLenum target, GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindTransformFeedbackNV, "glBindTransformFeedbackNV");
   if ( !driverTbl.glBindTransformFeedbackNV ) {
      driverTbl.glBindTransformFeedbackNV = missing_glBindTransformFeedbackNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindTransformFeedbackNV == loader_glBindTransformFeedbackNV) {
      rCtx->dsp.emuTbl.glBindTransformFeedbackNV = driverTbl.glBindTransformFeedbackNV;
   }
   driverTbl.glBindTransformFeedbackNV(target, id);
}

static void REGAL_CALL missing_glDeleteTransformFeedbacksNV(GLsizei n, const GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "Called missing function glDeleteTransformFeedbacksNV" );
}

static void REGAL_CALL loader_glDeleteTransformFeedbacksNV(GLsizei n, const GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteTransformFeedbacksNV, "glDeleteTransformFeedbacksNV");
   if ( !driverTbl.glDeleteTransformFeedbacksNV ) {
      driverTbl.glDeleteTransformFeedbacksNV = missing_glDeleteTransformFeedbacksNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteTransformFeedbacksNV == loader_glDeleteTransformFeedbacksNV) {
      rCtx->dsp.emuTbl.glDeleteTransformFeedbacksNV = driverTbl.glDeleteTransformFeedbacksNV;
   }
   driverTbl.glDeleteTransformFeedbacksNV(n, ids);
}

static void REGAL_CALL missing_glGenTransformFeedbacksNV(GLsizei n, GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "Called missing function glGenTransformFeedbacksNV" );
}

static void REGAL_CALL loader_glGenTransformFeedbacksNV(GLsizei n, GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenTransformFeedbacksNV, "glGenTransformFeedbacksNV");
   if ( !driverTbl.glGenTransformFeedbacksNV ) {
      driverTbl.glGenTransformFeedbacksNV = missing_glGenTransformFeedbacksNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenTransformFeedbacksNV == loader_glGenTransformFeedbacksNV) {
      rCtx->dsp.emuTbl.glGenTransformFeedbacksNV = driverTbl.glGenTransformFeedbacksNV;
   }
   driverTbl.glGenTransformFeedbacksNV(n, ids);
}

static GLboolean REGAL_CALL missing_glIsTransformFeedbackNV(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "Called missing function glIsTransformFeedbackNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsTransformFeedbackNV(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsTransformFeedbackNV, "glIsTransformFeedbackNV");
   if ( !driverTbl.glIsTransformFeedbackNV ) {
      driverTbl.glIsTransformFeedbackNV = missing_glIsTransformFeedbackNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsTransformFeedbackNV == loader_glIsTransformFeedbackNV) {
      rCtx->dsp.emuTbl.glIsTransformFeedbackNV = driverTbl.glIsTransformFeedbackNV;
   }
   return driverTbl.glIsTransformFeedbackNV(id);
}

static void REGAL_CALL missing_glPauseTransformFeedbackNV(void)
{
   Warning( "Called missing function glPauseTransformFeedbackNV" );
}

static void REGAL_CALL loader_glPauseTransformFeedbackNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPauseTransformFeedbackNV, "glPauseTransformFeedbackNV");
   if ( !driverTbl.glPauseTransformFeedbackNV ) {
      driverTbl.glPauseTransformFeedbackNV = missing_glPauseTransformFeedbackNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPauseTransformFeedbackNV == loader_glPauseTransformFeedbackNV) {
      rCtx->dsp.emuTbl.glPauseTransformFeedbackNV = driverTbl.glPauseTransformFeedbackNV;
   }
   driverTbl.glPauseTransformFeedbackNV();
}

static void REGAL_CALL missing_glResumeTransformFeedbackNV(void)
{
   Warning( "Called missing function glResumeTransformFeedbackNV" );
}

static void REGAL_CALL loader_glResumeTransformFeedbackNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glResumeTransformFeedbackNV, "glResumeTransformFeedbackNV");
   if ( !driverTbl.glResumeTransformFeedbackNV ) {
      driverTbl.glResumeTransformFeedbackNV = missing_glResumeTransformFeedbackNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glResumeTransformFeedbackNV == loader_glResumeTransformFeedbackNV) {
      rCtx->dsp.emuTbl.glResumeTransformFeedbackNV = driverTbl.glResumeTransformFeedbackNV;
   }
   driverTbl.glResumeTransformFeedbackNV();
}

static void REGAL_CALL missing_glDrawTransformFeedbackNV(GLenum mode, GLuint name)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glDrawTransformFeedbackNV" );
}

static void REGAL_CALL loader_glDrawTransformFeedbackNV(GLenum mode, GLuint name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawTransformFeedbackNV, "glDrawTransformFeedbackNV");
   if ( !driverTbl.glDrawTransformFeedbackNV ) {
      driverTbl.glDrawTransformFeedbackNV = missing_glDrawTransformFeedbackNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawTransformFeedbackNV == loader_glDrawTransformFeedbackNV) {
      rCtx->dsp.emuTbl.glDrawTransformFeedbackNV = driverTbl.glDrawTransformFeedbackNV;
   }
   driverTbl.glDrawTransformFeedbackNV(mode, name);
}

// GL_AMD_performance_monitor

static void REGAL_CALL missing_glGetPerfMonitorGroupsAMD(GLint *numGroups, GLsizei groupsSize, GLuint *groups)
{
   UNUSED_PARAMETER(numGroups);
   UNUSED_PARAMETER(groupsSize);
   UNUSED_PARAMETER(groups);
   Warning( "Called missing function glGetPerfMonitorGroupsAMD" );
}

static void REGAL_CALL loader_glGetPerfMonitorGroupsAMD(GLint *numGroups, GLsizei groupsSize, GLuint *groups)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPerfMonitorGroupsAMD, "glGetPerfMonitorGroupsAMD");
   if ( !driverTbl.glGetPerfMonitorGroupsAMD ) {
      driverTbl.glGetPerfMonitorGroupsAMD = missing_glGetPerfMonitorGroupsAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPerfMonitorGroupsAMD == loader_glGetPerfMonitorGroupsAMD) {
      rCtx->dsp.emuTbl.glGetPerfMonitorGroupsAMD = driverTbl.glGetPerfMonitorGroupsAMD;
   }
   driverTbl.glGetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
}

static void REGAL_CALL missing_glGetPerfMonitorCountersAMD(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters)
{
   UNUSED_PARAMETER(group);
   UNUSED_PARAMETER(numCounters);
   UNUSED_PARAMETER(maxActiveCounters);
   UNUSED_PARAMETER(countersSize);
   UNUSED_PARAMETER(counters);
   Warning( "Called missing function glGetPerfMonitorCountersAMD" );
}

static void REGAL_CALL loader_glGetPerfMonitorCountersAMD(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPerfMonitorCountersAMD, "glGetPerfMonitorCountersAMD");
   if ( !driverTbl.glGetPerfMonitorCountersAMD ) {
      driverTbl.glGetPerfMonitorCountersAMD = missing_glGetPerfMonitorCountersAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPerfMonitorCountersAMD == loader_glGetPerfMonitorCountersAMD) {
      rCtx->dsp.emuTbl.glGetPerfMonitorCountersAMD = driverTbl.glGetPerfMonitorCountersAMD;
   }
   driverTbl.glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, countersSize, counters);
}

static void REGAL_CALL missing_glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString)
{
   UNUSED_PARAMETER(group);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(groupString);
   Warning( "Called missing function glGetPerfMonitorGroupStringAMD" );
}

static void REGAL_CALL loader_glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPerfMonitorGroupStringAMD, "glGetPerfMonitorGroupStringAMD");
   if ( !driverTbl.glGetPerfMonitorGroupStringAMD ) {
      driverTbl.glGetPerfMonitorGroupStringAMD = missing_glGetPerfMonitorGroupStringAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPerfMonitorGroupStringAMD == loader_glGetPerfMonitorGroupStringAMD) {
      rCtx->dsp.emuTbl.glGetPerfMonitorGroupStringAMD = driverTbl.glGetPerfMonitorGroupStringAMD;
   }
   driverTbl.glGetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
}

static void REGAL_CALL missing_glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString)
{
   UNUSED_PARAMETER(group);
   UNUSED_PARAMETER(counter);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(counterString);
   Warning( "Called missing function glGetPerfMonitorCounterStringAMD" );
}

static void REGAL_CALL loader_glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPerfMonitorCounterStringAMD, "glGetPerfMonitorCounterStringAMD");
   if ( !driverTbl.glGetPerfMonitorCounterStringAMD ) {
      driverTbl.glGetPerfMonitorCounterStringAMD = missing_glGetPerfMonitorCounterStringAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPerfMonitorCounterStringAMD == loader_glGetPerfMonitorCounterStringAMD) {
      rCtx->dsp.emuTbl.glGetPerfMonitorCounterStringAMD = driverTbl.glGetPerfMonitorCounterStringAMD;
   }
   driverTbl.glGetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
}

static void REGAL_CALL missing_glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid *data)
{
   UNUSED_PARAMETER(group);
   UNUSED_PARAMETER(counter);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetPerfMonitorCounterInfoAMD" );
}

static void REGAL_CALL loader_glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPerfMonitorCounterInfoAMD, "glGetPerfMonitorCounterInfoAMD");
   if ( !driverTbl.glGetPerfMonitorCounterInfoAMD ) {
      driverTbl.glGetPerfMonitorCounterInfoAMD = missing_glGetPerfMonitorCounterInfoAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPerfMonitorCounterInfoAMD == loader_glGetPerfMonitorCounterInfoAMD) {
      rCtx->dsp.emuTbl.glGetPerfMonitorCounterInfoAMD = driverTbl.glGetPerfMonitorCounterInfoAMD;
   }
   driverTbl.glGetPerfMonitorCounterInfoAMD(group, counter, pname, data);
}

static void REGAL_CALL missing_glGenPerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(monitors);
   Warning( "Called missing function glGenPerfMonitorsAMD" );
}

static void REGAL_CALL loader_glGenPerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenPerfMonitorsAMD, "glGenPerfMonitorsAMD");
   if ( !driverTbl.glGenPerfMonitorsAMD ) {
      driverTbl.glGenPerfMonitorsAMD = missing_glGenPerfMonitorsAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenPerfMonitorsAMD == loader_glGenPerfMonitorsAMD) {
      rCtx->dsp.emuTbl.glGenPerfMonitorsAMD = driverTbl.glGenPerfMonitorsAMD;
   }
   driverTbl.glGenPerfMonitorsAMD(n, monitors);
}

static void REGAL_CALL missing_glDeletePerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(monitors);
   Warning( "Called missing function glDeletePerfMonitorsAMD" );
}

static void REGAL_CALL loader_glDeletePerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeletePerfMonitorsAMD, "glDeletePerfMonitorsAMD");
   if ( !driverTbl.glDeletePerfMonitorsAMD ) {
      driverTbl.glDeletePerfMonitorsAMD = missing_glDeletePerfMonitorsAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeletePerfMonitorsAMD == loader_glDeletePerfMonitorsAMD) {
      rCtx->dsp.emuTbl.glDeletePerfMonitorsAMD = driverTbl.glDeletePerfMonitorsAMD;
   }
   driverTbl.glDeletePerfMonitorsAMD(n, monitors);
}

static void REGAL_CALL missing_glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList)
{
   UNUSED_PARAMETER(monitor);
   UNUSED_PARAMETER(enable);
   UNUSED_PARAMETER(group);
   UNUSED_PARAMETER(numCounters);
   UNUSED_PARAMETER(counterList);
   Warning( "Called missing function glSelectPerfMonitorCountersAMD" );
}

static void REGAL_CALL loader_glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSelectPerfMonitorCountersAMD, "glSelectPerfMonitorCountersAMD");
   if ( !driverTbl.glSelectPerfMonitorCountersAMD ) {
      driverTbl.glSelectPerfMonitorCountersAMD = missing_glSelectPerfMonitorCountersAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSelectPerfMonitorCountersAMD == loader_glSelectPerfMonitorCountersAMD) {
      rCtx->dsp.emuTbl.glSelectPerfMonitorCountersAMD = driverTbl.glSelectPerfMonitorCountersAMD;
   }
   driverTbl.glSelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);
}

static void REGAL_CALL missing_glBeginPerfMonitorAMD(GLuint monitor)
{
   UNUSED_PARAMETER(monitor);
   Warning( "Called missing function glBeginPerfMonitorAMD" );
}

static void REGAL_CALL loader_glBeginPerfMonitorAMD(GLuint monitor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBeginPerfMonitorAMD, "glBeginPerfMonitorAMD");
   if ( !driverTbl.glBeginPerfMonitorAMD ) {
      driverTbl.glBeginPerfMonitorAMD = missing_glBeginPerfMonitorAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBeginPerfMonitorAMD == loader_glBeginPerfMonitorAMD) {
      rCtx->dsp.emuTbl.glBeginPerfMonitorAMD = driverTbl.glBeginPerfMonitorAMD;
   }
   driverTbl.glBeginPerfMonitorAMD(monitor);
}

static void REGAL_CALL missing_glEndPerfMonitorAMD(GLuint monitor)
{
   UNUSED_PARAMETER(monitor);
   Warning( "Called missing function glEndPerfMonitorAMD" );
}

static void REGAL_CALL loader_glEndPerfMonitorAMD(GLuint monitor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndPerfMonitorAMD, "glEndPerfMonitorAMD");
   if ( !driverTbl.glEndPerfMonitorAMD ) {
      driverTbl.glEndPerfMonitorAMD = missing_glEndPerfMonitorAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndPerfMonitorAMD == loader_glEndPerfMonitorAMD) {
      rCtx->dsp.emuTbl.glEndPerfMonitorAMD = driverTbl.glEndPerfMonitorAMD;
   }
   driverTbl.glEndPerfMonitorAMD(monitor);
}

static void REGAL_CALL missing_glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten)
{
   UNUSED_PARAMETER(monitor);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(dataSize);
   UNUSED_PARAMETER(data);
   UNUSED_PARAMETER(bytesWritten);
   Warning( "Called missing function glGetPerfMonitorCounterDataAMD" );
}

static void REGAL_CALL loader_glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPerfMonitorCounterDataAMD, "glGetPerfMonitorCounterDataAMD");
   if ( !driverTbl.glGetPerfMonitorCounterDataAMD ) {
      driverTbl.glGetPerfMonitorCounterDataAMD = missing_glGetPerfMonitorCounterDataAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPerfMonitorCounterDataAMD == loader_glGetPerfMonitorCounterDataAMD) {
      rCtx->dsp.emuTbl.glGetPerfMonitorCounterDataAMD = driverTbl.glGetPerfMonitorCounterDataAMD;
   }
   driverTbl.glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
}

// GL_AMD_vertex_shader_tessellator

static void REGAL_CALL missing_glTessellationFactorAMD(GLfloat factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "Called missing function glTessellationFactorAMD" );
}

static void REGAL_CALL loader_glTessellationFactorAMD(GLfloat factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTessellationFactorAMD, "glTessellationFactorAMD");
   if ( !driverTbl.glTessellationFactorAMD ) {
      driverTbl.glTessellationFactorAMD = missing_glTessellationFactorAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTessellationFactorAMD == loader_glTessellationFactorAMD) {
      rCtx->dsp.emuTbl.glTessellationFactorAMD = driverTbl.glTessellationFactorAMD;
   }
   driverTbl.glTessellationFactorAMD(factor);
}

static void REGAL_CALL missing_glTessellationModeAMD(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glTessellationModeAMD" );
}

static void REGAL_CALL loader_glTessellationModeAMD(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTessellationModeAMD, "glTessellationModeAMD");
   if ( !driverTbl.glTessellationModeAMD ) {
      driverTbl.glTessellationModeAMD = missing_glTessellationModeAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTessellationModeAMD == loader_glTessellationModeAMD) {
      rCtx->dsp.emuTbl.glTessellationModeAMD = driverTbl.glTessellationModeAMD;
   }
   driverTbl.glTessellationModeAMD(mode);
}

// GL_EXT_provoking_vertex

static void REGAL_CALL missing_glProvokingVertexEXT(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glProvokingVertexEXT" );
}

static void REGAL_CALL loader_glProvokingVertexEXT(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProvokingVertexEXT, "glProvokingVertexEXT");
   if ( !driverTbl.glProvokingVertexEXT ) {
      driverTbl.glProvokingVertexEXT = missing_glProvokingVertexEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProvokingVertexEXT == loader_glProvokingVertexEXT) {
      rCtx->dsp.emuTbl.glProvokingVertexEXT = driverTbl.glProvokingVertexEXT;
   }
   driverTbl.glProvokingVertexEXT(mode);
}

// GL_AMD_draw_buffers_blend

static void REGAL_CALL missing_glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(src);
   UNUSED_PARAMETER(dst);
   Warning( "Called missing function glBlendFuncIndexedAMD" );
}

static void REGAL_CALL loader_glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendFuncIndexedAMD, "glBlendFuncIndexedAMD");
   if ( !driverTbl.glBlendFuncIndexedAMD ) {
      driverTbl.glBlendFuncIndexedAMD = missing_glBlendFuncIndexedAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendFuncIndexedAMD == loader_glBlendFuncIndexedAMD) {
      rCtx->dsp.emuTbl.glBlendFuncIndexedAMD = driverTbl.glBlendFuncIndexedAMD;
   }
   driverTbl.glBlendFuncIndexedAMD(buf, src, dst);
}

static void REGAL_CALL missing_glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(srcRGB);
   UNUSED_PARAMETER(dstRGB);
   UNUSED_PARAMETER(srcAlpha);
   UNUSED_PARAMETER(dstAlpha);
   Warning( "Called missing function glBlendFuncSeparateIndexedAMD" );
}

static void REGAL_CALL loader_glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendFuncSeparateIndexedAMD, "glBlendFuncSeparateIndexedAMD");
   if ( !driverTbl.glBlendFuncSeparateIndexedAMD ) {
      driverTbl.glBlendFuncSeparateIndexedAMD = missing_glBlendFuncSeparateIndexedAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendFuncSeparateIndexedAMD == loader_glBlendFuncSeparateIndexedAMD) {
      rCtx->dsp.emuTbl.glBlendFuncSeparateIndexedAMD = driverTbl.glBlendFuncSeparateIndexedAMD;
   }
   driverTbl.glBlendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

static void REGAL_CALL missing_glBlendEquationIndexedAMD(GLuint buf, GLenum mode)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glBlendEquationIndexedAMD" );
}

static void REGAL_CALL loader_glBlendEquationIndexedAMD(GLuint buf, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendEquationIndexedAMD, "glBlendEquationIndexedAMD");
   if ( !driverTbl.glBlendEquationIndexedAMD ) {
      driverTbl.glBlendEquationIndexedAMD = missing_glBlendEquationIndexedAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendEquationIndexedAMD == loader_glBlendEquationIndexedAMD) {
      rCtx->dsp.emuTbl.glBlendEquationIndexedAMD = driverTbl.glBlendEquationIndexedAMD;
   }
   driverTbl.glBlendEquationIndexedAMD(buf, mode);
}

static void REGAL_CALL missing_glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(modeRGB);
   UNUSED_PARAMETER(modeAlpha);
   Warning( "Called missing function glBlendEquationSeparateIndexedAMD" );
}

static void REGAL_CALL loader_glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBlendEquationSeparateIndexedAMD, "glBlendEquationSeparateIndexedAMD");
   if ( !driverTbl.glBlendEquationSeparateIndexedAMD ) {
      driverTbl.glBlendEquationSeparateIndexedAMD = missing_glBlendEquationSeparateIndexedAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBlendEquationSeparateIndexedAMD == loader_glBlendEquationSeparateIndexedAMD) {
      rCtx->dsp.emuTbl.glBlendEquationSeparateIndexedAMD = driverTbl.glBlendEquationSeparateIndexedAMD;
   }
   driverTbl.glBlendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha);
}

// GL_APPLE_texture_range

static void REGAL_CALL missing_glTextureRangeAPPLE(GLenum target, GLsizei length, GLvoid *pointer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glTextureRangeAPPLE" );
}

static void REGAL_CALL loader_glTextureRangeAPPLE(GLenum target, GLsizei length, GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureRangeAPPLE, "glTextureRangeAPPLE");
   if ( !driverTbl.glTextureRangeAPPLE ) {
      driverTbl.glTextureRangeAPPLE = missing_glTextureRangeAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureRangeAPPLE == loader_glTextureRangeAPPLE) {
      rCtx->dsp.emuTbl.glTextureRangeAPPLE = driverTbl.glTextureRangeAPPLE;
   }
   driverTbl.glTextureRangeAPPLE(target, length, pointer);
}

static void REGAL_CALL missing_glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetTexParameterPointervAPPLE" );
}

static void REGAL_CALL loader_glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTexParameterPointervAPPLE, "glGetTexParameterPointervAPPLE");
   if ( !driverTbl.glGetTexParameterPointervAPPLE ) {
      driverTbl.glGetTexParameterPointervAPPLE = missing_glGetTexParameterPointervAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTexParameterPointervAPPLE == loader_glGetTexParameterPointervAPPLE) {
      rCtx->dsp.emuTbl.glGetTexParameterPointervAPPLE = driverTbl.glGetTexParameterPointervAPPLE;
   }
   driverTbl.glGetTexParameterPointervAPPLE(target, pname, params);
}

// GL_APPLE_vertex_program_evaluators

static void REGAL_CALL missing_glEnableVertexAttribAPPLE(GLuint index, GLenum pname)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   Warning( "Called missing function glEnableVertexAttribAPPLE" );
}

static void REGAL_CALL loader_glEnableVertexAttribAPPLE(GLuint index, GLenum pname)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEnableVertexAttribAPPLE, "glEnableVertexAttribAPPLE");
   if ( !driverTbl.glEnableVertexAttribAPPLE ) {
      driverTbl.glEnableVertexAttribAPPLE = missing_glEnableVertexAttribAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEnableVertexAttribAPPLE == loader_glEnableVertexAttribAPPLE) {
      rCtx->dsp.emuTbl.glEnableVertexAttribAPPLE = driverTbl.glEnableVertexAttribAPPLE;
   }
   driverTbl.glEnableVertexAttribAPPLE(index, pname);
}

static void REGAL_CALL missing_glDisableVertexAttribAPPLE(GLuint index, GLenum pname)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   Warning( "Called missing function glDisableVertexAttribAPPLE" );
}

static void REGAL_CALL loader_glDisableVertexAttribAPPLE(GLuint index, GLenum pname)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDisableVertexAttribAPPLE, "glDisableVertexAttribAPPLE");
   if ( !driverTbl.glDisableVertexAttribAPPLE ) {
      driverTbl.glDisableVertexAttribAPPLE = missing_glDisableVertexAttribAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDisableVertexAttribAPPLE == loader_glDisableVertexAttribAPPLE) {
      rCtx->dsp.emuTbl.glDisableVertexAttribAPPLE = driverTbl.glDisableVertexAttribAPPLE;
   }
   driverTbl.glDisableVertexAttribAPPLE(index, pname);
}

static GLboolean REGAL_CALL missing_glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   Warning( "Called missing function glIsVertexAttribEnabledAPPLE" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsVertexAttribEnabledAPPLE, "glIsVertexAttribEnabledAPPLE");
   if ( !driverTbl.glIsVertexAttribEnabledAPPLE ) {
      driverTbl.glIsVertexAttribEnabledAPPLE = missing_glIsVertexAttribEnabledAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsVertexAttribEnabledAPPLE == loader_glIsVertexAttribEnabledAPPLE) {
      rCtx->dsp.emuTbl.glIsVertexAttribEnabledAPPLE = driverTbl.glIsVertexAttribEnabledAPPLE;
   }
   return driverTbl.glIsVertexAttribEnabledAPPLE(index, pname);
}

static void REGAL_CALL missing_glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(order);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glMapVertexAttrib1dAPPLE" );
}

static void REGAL_CALL loader_glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapVertexAttrib1dAPPLE, "glMapVertexAttrib1dAPPLE");
   if ( !driverTbl.glMapVertexAttrib1dAPPLE ) {
      driverTbl.glMapVertexAttrib1dAPPLE = missing_glMapVertexAttrib1dAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapVertexAttrib1dAPPLE == loader_glMapVertexAttrib1dAPPLE) {
      rCtx->dsp.emuTbl.glMapVertexAttrib1dAPPLE = driverTbl.glMapVertexAttrib1dAPPLE;
   }
   driverTbl.glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);
}

static void REGAL_CALL missing_glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(order);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glMapVertexAttrib1fAPPLE" );
}

static void REGAL_CALL loader_glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapVertexAttrib1fAPPLE, "glMapVertexAttrib1fAPPLE");
   if ( !driverTbl.glMapVertexAttrib1fAPPLE ) {
      driverTbl.glMapVertexAttrib1fAPPLE = missing_glMapVertexAttrib1fAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapVertexAttrib1fAPPLE == loader_glMapVertexAttrib1fAPPLE) {
      rCtx->dsp.emuTbl.glMapVertexAttrib1fAPPLE = driverTbl.glMapVertexAttrib1fAPPLE;
   }
   driverTbl.glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);
}

static void REGAL_CALL missing_glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(uorder);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(vorder);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glMapVertexAttrib2dAPPLE" );
}

static void REGAL_CALL loader_glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapVertexAttrib2dAPPLE, "glMapVertexAttrib2dAPPLE");
   if ( !driverTbl.glMapVertexAttrib2dAPPLE ) {
      driverTbl.glMapVertexAttrib2dAPPLE = missing_glMapVertexAttrib2dAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapVertexAttrib2dAPPLE == loader_glMapVertexAttrib2dAPPLE) {
      rCtx->dsp.emuTbl.glMapVertexAttrib2dAPPLE = driverTbl.glMapVertexAttrib2dAPPLE;
   }
   driverTbl.glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

static void REGAL_CALL missing_glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(uorder);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(vorder);
   UNUSED_PARAMETER(points);
   Warning( "Called missing function glMapVertexAttrib2fAPPLE" );
}

static void REGAL_CALL loader_glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMapVertexAttrib2fAPPLE, "glMapVertexAttrib2fAPPLE");
   if ( !driverTbl.glMapVertexAttrib2fAPPLE ) {
      driverTbl.glMapVertexAttrib2fAPPLE = missing_glMapVertexAttrib2fAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMapVertexAttrib2fAPPLE == loader_glMapVertexAttrib2fAPPLE) {
      rCtx->dsp.emuTbl.glMapVertexAttrib2fAPPLE = driverTbl.glMapVertexAttrib2fAPPLE;
   }
   driverTbl.glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

// GL_APPLE_object_purgeable

static GLenum REGAL_CALL missing_glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
   UNUSED_PARAMETER(objectType);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(option);
   Warning( "Called missing function glObjectPurgeableAPPLE" );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glObjectPurgeableAPPLE, "glObjectPurgeableAPPLE");
   if ( !driverTbl.glObjectPurgeableAPPLE ) {
      driverTbl.glObjectPurgeableAPPLE = missing_glObjectPurgeableAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glObjectPurgeableAPPLE == loader_glObjectPurgeableAPPLE) {
      rCtx->dsp.emuTbl.glObjectPurgeableAPPLE = driverTbl.glObjectPurgeableAPPLE;
   }
   return driverTbl.glObjectPurgeableAPPLE(objectType, name, option);
}

static GLenum REGAL_CALL missing_glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
   UNUSED_PARAMETER(objectType);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(option);
   Warning( "Called missing function glObjectUnpurgeableAPPLE" );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glObjectUnpurgeableAPPLE, "glObjectUnpurgeableAPPLE");
   if ( !driverTbl.glObjectUnpurgeableAPPLE ) {
      driverTbl.glObjectUnpurgeableAPPLE = missing_glObjectUnpurgeableAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glObjectUnpurgeableAPPLE == loader_glObjectUnpurgeableAPPLE) {
      rCtx->dsp.emuTbl.glObjectUnpurgeableAPPLE = driverTbl.glObjectUnpurgeableAPPLE;
   }
   return driverTbl.glObjectUnpurgeableAPPLE(objectType, name, option);
}

static void REGAL_CALL missing_glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(objectType);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetObjectParameterivAPPLE" );
}

static void REGAL_CALL loader_glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetObjectParameterivAPPLE, "glGetObjectParameterivAPPLE");
   if ( !driverTbl.glGetObjectParameterivAPPLE ) {
      driverTbl.glGetObjectParameterivAPPLE = missing_glGetObjectParameterivAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetObjectParameterivAPPLE == loader_glGetObjectParameterivAPPLE) {
      rCtx->dsp.emuTbl.glGetObjectParameterivAPPLE = driverTbl.glGetObjectParameterivAPPLE;
   }
   driverTbl.glGetObjectParameterivAPPLE(objectType, name, pname, params);
}

// GL_NV_video_capture

static void REGAL_CALL missing_glBeginVideoCaptureNV(GLuint video_capture_slot)
{
   UNUSED_PARAMETER(video_capture_slot);
   Warning( "Called missing function glBeginVideoCaptureNV" );
}

static void REGAL_CALL loader_glBeginVideoCaptureNV(GLuint video_capture_slot)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBeginVideoCaptureNV, "glBeginVideoCaptureNV");
   if ( !driverTbl.glBeginVideoCaptureNV ) {
      driverTbl.glBeginVideoCaptureNV = missing_glBeginVideoCaptureNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBeginVideoCaptureNV == loader_glBeginVideoCaptureNV) {
      rCtx->dsp.emuTbl.glBeginVideoCaptureNV = driverTbl.glBeginVideoCaptureNV;
   }
   driverTbl.glBeginVideoCaptureNV(video_capture_slot);
}

static void REGAL_CALL missing_glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptr offset)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(frame_region);
   UNUSED_PARAMETER(offset);
   Warning( "Called missing function glBindVideoCaptureStreamBufferNV" );
}

static void REGAL_CALL loader_glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindVideoCaptureStreamBufferNV, "glBindVideoCaptureStreamBufferNV");
   if ( !driverTbl.glBindVideoCaptureStreamBufferNV ) {
      driverTbl.glBindVideoCaptureStreamBufferNV = missing_glBindVideoCaptureStreamBufferNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindVideoCaptureStreamBufferNV == loader_glBindVideoCaptureStreamBufferNV) {
      rCtx->dsp.emuTbl.glBindVideoCaptureStreamBufferNV = driverTbl.glBindVideoCaptureStreamBufferNV;
   }
   driverTbl.glBindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
}

static void REGAL_CALL missing_glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(frame_region);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(texture);
   Warning( "Called missing function glBindVideoCaptureStreamTextureNV" );
}

static void REGAL_CALL loader_glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindVideoCaptureStreamTextureNV, "glBindVideoCaptureStreamTextureNV");
   if ( !driverTbl.glBindVideoCaptureStreamTextureNV ) {
      driverTbl.glBindVideoCaptureStreamTextureNV = missing_glBindVideoCaptureStreamTextureNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindVideoCaptureStreamTextureNV == loader_glBindVideoCaptureStreamTextureNV) {
      rCtx->dsp.emuTbl.glBindVideoCaptureStreamTextureNV = driverTbl.glBindVideoCaptureStreamTextureNV;
   }
   driverTbl.glBindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
}

static void REGAL_CALL missing_glEndVideoCaptureNV(GLuint video_capture_slot)
{
   UNUSED_PARAMETER(video_capture_slot);
   Warning( "Called missing function glEndVideoCaptureNV" );
}

static void REGAL_CALL loader_glEndVideoCaptureNV(GLuint video_capture_slot)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEndVideoCaptureNV, "glEndVideoCaptureNV");
   if ( !driverTbl.glEndVideoCaptureNV ) {
      driverTbl.glEndVideoCaptureNV = missing_glEndVideoCaptureNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEndVideoCaptureNV == loader_glEndVideoCaptureNV) {
      rCtx->dsp.emuTbl.glEndVideoCaptureNV = driverTbl.glEndVideoCaptureNV;
   }
   driverTbl.glEndVideoCaptureNV(video_capture_slot);
}

static void REGAL_CALL missing_glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVideoCaptureivNV" );
}

static void REGAL_CALL loader_glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVideoCaptureivNV, "glGetVideoCaptureivNV");
   if ( !driverTbl.glGetVideoCaptureivNV ) {
      driverTbl.glGetVideoCaptureivNV = missing_glGetVideoCaptureivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVideoCaptureivNV == loader_glGetVideoCaptureivNV) {
      rCtx->dsp.emuTbl.glGetVideoCaptureivNV = driverTbl.glGetVideoCaptureivNV;
   }
   driverTbl.glGetVideoCaptureivNV(video_capture_slot, pname, params);
}

static void REGAL_CALL missing_glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVideoCaptureStreamivNV" );
}

static void REGAL_CALL loader_glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVideoCaptureStreamivNV, "glGetVideoCaptureStreamivNV");
   if ( !driverTbl.glGetVideoCaptureStreamivNV ) {
      driverTbl.glGetVideoCaptureStreamivNV = missing_glGetVideoCaptureStreamivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVideoCaptureStreamivNV == loader_glGetVideoCaptureStreamivNV) {
      rCtx->dsp.emuTbl.glGetVideoCaptureStreamivNV = driverTbl.glGetVideoCaptureStreamivNV;
   }
   driverTbl.glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL missing_glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVideoCaptureStreamfvNV" );
}

static void REGAL_CALL loader_glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVideoCaptureStreamfvNV, "glGetVideoCaptureStreamfvNV");
   if ( !driverTbl.glGetVideoCaptureStreamfvNV ) {
      driverTbl.glGetVideoCaptureStreamfvNV = missing_glGetVideoCaptureStreamfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVideoCaptureStreamfvNV == loader_glGetVideoCaptureStreamfvNV) {
      rCtx->dsp.emuTbl.glGetVideoCaptureStreamfvNV = driverTbl.glGetVideoCaptureStreamfvNV;
   }
   driverTbl.glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL missing_glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVideoCaptureStreamdvNV" );
}

static void REGAL_CALL loader_glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVideoCaptureStreamdvNV, "glGetVideoCaptureStreamdvNV");
   if ( !driverTbl.glGetVideoCaptureStreamdvNV ) {
      driverTbl.glGetVideoCaptureStreamdvNV = missing_glGetVideoCaptureStreamdvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVideoCaptureStreamdvNV == loader_glGetVideoCaptureStreamdvNV) {
      rCtx->dsp.emuTbl.glGetVideoCaptureStreamdvNV = driverTbl.glGetVideoCaptureStreamdvNV;
   }
   driverTbl.glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, params);
}

static GLenum REGAL_CALL missing_glVideoCaptureNV(GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(sequence_num);
   UNUSED_PARAMETER(capture_time);
   Warning( "Called missing function glVideoCaptureNV" );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glVideoCaptureNV(GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVideoCaptureNV, "glVideoCaptureNV");
   if ( !driverTbl.glVideoCaptureNV ) {
      driverTbl.glVideoCaptureNV = missing_glVideoCaptureNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVideoCaptureNV == loader_glVideoCaptureNV) {
      rCtx->dsp.emuTbl.glVideoCaptureNV = driverTbl.glVideoCaptureNV;
   }
   return driverTbl.glVideoCaptureNV(video_capture_slot, sequence_num, capture_time);
}

static void REGAL_CALL missing_glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glVideoCaptureStreamParameterivNV" );
}

static void REGAL_CALL loader_glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVideoCaptureStreamParameterivNV, "glVideoCaptureStreamParameterivNV");
   if ( !driverTbl.glVideoCaptureStreamParameterivNV ) {
      driverTbl.glVideoCaptureStreamParameterivNV = missing_glVideoCaptureStreamParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVideoCaptureStreamParameterivNV == loader_glVideoCaptureStreamParameterivNV) {
      rCtx->dsp.emuTbl.glVideoCaptureStreamParameterivNV = driverTbl.glVideoCaptureStreamParameterivNV;
   }
   driverTbl.glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL missing_glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glVideoCaptureStreamParameterfvNV" );
}

static void REGAL_CALL loader_glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVideoCaptureStreamParameterfvNV, "glVideoCaptureStreamParameterfvNV");
   if ( !driverTbl.glVideoCaptureStreamParameterfvNV ) {
      driverTbl.glVideoCaptureStreamParameterfvNV = missing_glVideoCaptureStreamParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVideoCaptureStreamParameterfvNV == loader_glVideoCaptureStreamParameterfvNV) {
      rCtx->dsp.emuTbl.glVideoCaptureStreamParameterfvNV = driverTbl.glVideoCaptureStreamParameterfvNV;
   }
   driverTbl.glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL missing_glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glVideoCaptureStreamParameterdvNV" );
}

static void REGAL_CALL loader_glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVideoCaptureStreamParameterdvNV, "glVideoCaptureStreamParameterdvNV");
   if ( !driverTbl.glVideoCaptureStreamParameterdvNV ) {
      driverTbl.glVideoCaptureStreamParameterdvNV = missing_glVideoCaptureStreamParameterdvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVideoCaptureStreamParameterdvNV == loader_glVideoCaptureStreamParameterdvNV) {
      rCtx->dsp.emuTbl.glVideoCaptureStreamParameterdvNV = driverTbl.glVideoCaptureStreamParameterdvNV;
   }
   driverTbl.glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, params);
}

// GL_NV_copy_image

static void REGAL_CALL missing_glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
   UNUSED_PARAMETER(srcName);
   UNUSED_PARAMETER(srcTarget);
   UNUSED_PARAMETER(srcLevel);
   UNUSED_PARAMETER(srcX);
   UNUSED_PARAMETER(srcY);
   UNUSED_PARAMETER(srcZ);
   UNUSED_PARAMETER(dstName);
   UNUSED_PARAMETER(dstTarget);
   UNUSED_PARAMETER(dstLevel);
   UNUSED_PARAMETER(dstX);
   UNUSED_PARAMETER(dstY);
   UNUSED_PARAMETER(dstZ);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   Warning( "Called missing function glCopyImageSubDataNV" );
}

static void REGAL_CALL loader_glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyImageSubDataNV, "glCopyImageSubDataNV");
   if ( !driverTbl.glCopyImageSubDataNV ) {
      driverTbl.glCopyImageSubDataNV = missing_glCopyImageSubDataNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyImageSubDataNV == loader_glCopyImageSubDataNV) {
      rCtx->dsp.emuTbl.glCopyImageSubDataNV = driverTbl.glCopyImageSubDataNV;
   }
   driverTbl.glCopyImageSubDataNV(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
}

// GL_EXT_separate_shader_objects

static void REGAL_CALL missing_glUseShaderProgramEXT(GLenum type, GLuint program)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(program);
   Warning( "Called missing function glUseShaderProgramEXT" );
}

static void REGAL_CALL loader_glUseShaderProgramEXT(GLenum type, GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUseShaderProgramEXT, "glUseShaderProgramEXT");
   if ( !driverTbl.glUseShaderProgramEXT ) {
      driverTbl.glUseShaderProgramEXT = missing_glUseShaderProgramEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUseShaderProgramEXT == loader_glUseShaderProgramEXT) {
      rCtx->dsp.emuTbl.glUseShaderProgramEXT = driverTbl.glUseShaderProgramEXT;
   }
   driverTbl.glUseShaderProgramEXT(type, program);
}

static void REGAL_CALL missing_glActiveProgramEXT(GLuint program)
{
   UNUSED_PARAMETER(program);
   Warning( "Called missing function glActiveProgramEXT" );
}

static void REGAL_CALL loader_glActiveProgramEXT(GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glActiveProgramEXT, "glActiveProgramEXT");
   if ( !driverTbl.glActiveProgramEXT ) {
      driverTbl.glActiveProgramEXT = missing_glActiveProgramEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glActiveProgramEXT == loader_glActiveProgramEXT) {
      rCtx->dsp.emuTbl.glActiveProgramEXT = driverTbl.glActiveProgramEXT;
   }
   driverTbl.glActiveProgramEXT(program);
}

static GLuint REGAL_CALL missing_glCreateShaderProgramEXT(GLenum type, const GLchar *string)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(string);
   Warning( "Called missing function glCreateShaderProgramEXT" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glCreateShaderProgramEXT(GLenum type, const GLchar *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCreateShaderProgramEXT, "glCreateShaderProgramEXT");
   if ( !driverTbl.glCreateShaderProgramEXT ) {
      driverTbl.glCreateShaderProgramEXT = missing_glCreateShaderProgramEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCreateShaderProgramEXT == loader_glCreateShaderProgramEXT) {
      rCtx->dsp.emuTbl.glCreateShaderProgramEXT = driverTbl.glCreateShaderProgramEXT;
   }
   return driverTbl.glCreateShaderProgramEXT(type, string);
}

// GL_NV_shader_buffer_load

static void REGAL_CALL missing_glMakeBufferResidentNV(GLenum target, GLenum access)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(access);
   Warning( "Called missing function glMakeBufferResidentNV" );
}

static void REGAL_CALL loader_glMakeBufferResidentNV(GLenum target, GLenum access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMakeBufferResidentNV, "glMakeBufferResidentNV");
   if ( !driverTbl.glMakeBufferResidentNV ) {
      driverTbl.glMakeBufferResidentNV = missing_glMakeBufferResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMakeBufferResidentNV == loader_glMakeBufferResidentNV) {
      rCtx->dsp.emuTbl.glMakeBufferResidentNV = driverTbl.glMakeBufferResidentNV;
   }
   driverTbl.glMakeBufferResidentNV(target, access);
}

static void REGAL_CALL missing_glMakeBufferNonResidentNV(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glMakeBufferNonResidentNV" );
}

static void REGAL_CALL loader_glMakeBufferNonResidentNV(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMakeBufferNonResidentNV, "glMakeBufferNonResidentNV");
   if ( !driverTbl.glMakeBufferNonResidentNV ) {
      driverTbl.glMakeBufferNonResidentNV = missing_glMakeBufferNonResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMakeBufferNonResidentNV == loader_glMakeBufferNonResidentNV) {
      rCtx->dsp.emuTbl.glMakeBufferNonResidentNV = driverTbl.glMakeBufferNonResidentNV;
   }
   driverTbl.glMakeBufferNonResidentNV(target);
}

static GLboolean REGAL_CALL missing_glIsBufferResidentNV(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "Called missing function glIsBufferResidentNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsBufferResidentNV(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsBufferResidentNV, "glIsBufferResidentNV");
   if ( !driverTbl.glIsBufferResidentNV ) {
      driverTbl.glIsBufferResidentNV = missing_glIsBufferResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsBufferResidentNV == loader_glIsBufferResidentNV) {
      rCtx->dsp.emuTbl.glIsBufferResidentNV = driverTbl.glIsBufferResidentNV;
   }
   return driverTbl.glIsBufferResidentNV(target);
}

static void REGAL_CALL missing_glMakeNamedBufferResidentNV(GLuint buffer, GLenum access)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(access);
   Warning( "Called missing function glMakeNamedBufferResidentNV" );
}

static void REGAL_CALL loader_glMakeNamedBufferResidentNV(GLuint buffer, GLenum access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMakeNamedBufferResidentNV, "glMakeNamedBufferResidentNV");
   if ( !driverTbl.glMakeNamedBufferResidentNV ) {
      driverTbl.glMakeNamedBufferResidentNV = missing_glMakeNamedBufferResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMakeNamedBufferResidentNV == loader_glMakeNamedBufferResidentNV) {
      rCtx->dsp.emuTbl.glMakeNamedBufferResidentNV = driverTbl.glMakeNamedBufferResidentNV;
   }
   driverTbl.glMakeNamedBufferResidentNV(buffer, access);
}

static void REGAL_CALL missing_glMakeNamedBufferNonResidentNV(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glMakeNamedBufferNonResidentNV" );
}

static void REGAL_CALL loader_glMakeNamedBufferNonResidentNV(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMakeNamedBufferNonResidentNV, "glMakeNamedBufferNonResidentNV");
   if ( !driverTbl.glMakeNamedBufferNonResidentNV ) {
      driverTbl.glMakeNamedBufferNonResidentNV = missing_glMakeNamedBufferNonResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMakeNamedBufferNonResidentNV == loader_glMakeNamedBufferNonResidentNV) {
      rCtx->dsp.emuTbl.glMakeNamedBufferNonResidentNV = driverTbl.glMakeNamedBufferNonResidentNV;
   }
   driverTbl.glMakeNamedBufferNonResidentNV(buffer);
}

static GLboolean REGAL_CALL missing_glIsNamedBufferResidentNV(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "Called missing function glIsNamedBufferResidentNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsNamedBufferResidentNV(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsNamedBufferResidentNV, "glIsNamedBufferResidentNV");
   if ( !driverTbl.glIsNamedBufferResidentNV ) {
      driverTbl.glIsNamedBufferResidentNV = missing_glIsNamedBufferResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsNamedBufferResidentNV == loader_glIsNamedBufferResidentNV) {
      rCtx->dsp.emuTbl.glIsNamedBufferResidentNV = driverTbl.glIsNamedBufferResidentNV;
   }
   return driverTbl.glIsNamedBufferResidentNV(buffer);
}

static void REGAL_CALL missing_glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetBufferParameterui64vNV" );
}

static void REGAL_CALL loader_glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetBufferParameterui64vNV, "glGetBufferParameterui64vNV");
   if ( !driverTbl.glGetBufferParameterui64vNV ) {
      driverTbl.glGetBufferParameterui64vNV = missing_glGetBufferParameterui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetBufferParameterui64vNV == loader_glGetBufferParameterui64vNV) {
      rCtx->dsp.emuTbl.glGetBufferParameterui64vNV = driverTbl.glGetBufferParameterui64vNV;
   }
   driverTbl.glGetBufferParameterui64vNV(target, pname, params);
}

static void REGAL_CALL missing_glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT *params)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetNamedBufferParameterui64vNV" );
}

static void REGAL_CALL loader_glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetNamedBufferParameterui64vNV, "glGetNamedBufferParameterui64vNV");
   if ( !driverTbl.glGetNamedBufferParameterui64vNV ) {
      driverTbl.glGetNamedBufferParameterui64vNV = missing_glGetNamedBufferParameterui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetNamedBufferParameterui64vNV == loader_glGetNamedBufferParameterui64vNV) {
      rCtx->dsp.emuTbl.glGetNamedBufferParameterui64vNV = driverTbl.glGetNamedBufferParameterui64vNV;
   }
   driverTbl.glGetNamedBufferParameterui64vNV(buffer, pname, params);
}

static void REGAL_CALL missing_glGetIntegerui64vNV(GLenum target, GLuint64EXT *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetIntegerui64vNV" );
}

static void REGAL_CALL loader_glGetIntegerui64vNV(GLenum target, GLuint64EXT *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetIntegerui64vNV, "glGetIntegerui64vNV");
   if ( !driverTbl.glGetIntegerui64vNV ) {
      driverTbl.glGetIntegerui64vNV = missing_glGetIntegerui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetIntegerui64vNV == loader_glGetIntegerui64vNV) {
      rCtx->dsp.emuTbl.glGetIntegerui64vNV = driverTbl.glGetIntegerui64vNV;
   }
   driverTbl.glGetIntegerui64vNV(target, data);
}

static void REGAL_CALL missing_glUniformui64NV(GLint location, GLuint64EXT v0)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "Called missing function glUniformui64NV" );
}

static void REGAL_CALL loader_glUniformui64NV(GLint location, GLuint64EXT v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformui64NV, "glUniformui64NV");
   if ( !driverTbl.glUniformui64NV ) {
      driverTbl.glUniformui64NV = missing_glUniformui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformui64NV == loader_glUniformui64NV) {
      rCtx->dsp.emuTbl.glUniformui64NV = driverTbl.glUniformui64NV;
   }
   driverTbl.glUniformui64NV(location, v0);
}

static void REGAL_CALL missing_glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformui64vNV" );
}

static void REGAL_CALL loader_glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformui64vNV, "glUniformui64vNV");
   if ( !driverTbl.glUniformui64vNV ) {
      driverTbl.glUniformui64vNV = missing_glUniformui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformui64vNV == loader_glUniformui64vNV) {
      rCtx->dsp.emuTbl.glUniformui64vNV = driverTbl.glUniformui64vNV;
   }
   driverTbl.glUniformui64vNV(location, count, value);
}

static void REGAL_CALL missing_glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetUniformui64vNV" );
}

static void REGAL_CALL loader_glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformui64vNV, "glGetUniformui64vNV");
   if ( !driverTbl.glGetUniformui64vNV ) {
      driverTbl.glGetUniformui64vNV = missing_glGetUniformui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformui64vNV == loader_glGetUniformui64vNV) {
      rCtx->dsp.emuTbl.glGetUniformui64vNV = driverTbl.glGetUniformui64vNV;
   }
   driverTbl.glGetUniformui64vNV(program, location, params);
}

static void REGAL_CALL missing_glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT v0)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "Called missing function glProgramUniformui64NV" );
}

static void REGAL_CALL loader_glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformui64NV, "glProgramUniformui64NV");
   if ( !driverTbl.glProgramUniformui64NV ) {
      driverTbl.glProgramUniformui64NV = missing_glProgramUniformui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformui64NV == loader_glProgramUniformui64NV) {
      rCtx->dsp.emuTbl.glProgramUniformui64NV = driverTbl.glProgramUniformui64NV;
   }
   driverTbl.glProgramUniformui64NV(program, location, v0);
}

static void REGAL_CALL missing_glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformui64vNV" );
}

static void REGAL_CALL loader_glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformui64vNV, "glProgramUniformui64vNV");
   if ( !driverTbl.glProgramUniformui64vNV ) {
      driverTbl.glProgramUniformui64vNV = missing_glProgramUniformui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformui64vNV == loader_glProgramUniformui64vNV) {
      rCtx->dsp.emuTbl.glProgramUniformui64vNV = driverTbl.glProgramUniformui64vNV;
   }
   driverTbl.glProgramUniformui64vNV(program, location, count, value);
}

// GL_NV_vertex_buffer_unified_memory

static void REGAL_CALL missing_glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(address);
   UNUSED_PARAMETER(length);
   Warning( "Called missing function glBufferAddressRangeNV" );
}

static void REGAL_CALL loader_glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBufferAddressRangeNV, "glBufferAddressRangeNV");
   if ( !driverTbl.glBufferAddressRangeNV ) {
      driverTbl.glBufferAddressRangeNV = missing_glBufferAddressRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBufferAddressRangeNV == loader_glBufferAddressRangeNV) {
      rCtx->dsp.emuTbl.glBufferAddressRangeNV = driverTbl.glBufferAddressRangeNV;
   }
   driverTbl.glBufferAddressRangeNV(pname, index, address, length);
}

static void REGAL_CALL missing_glVertexFormatNV(GLint size, GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "Called missing function glVertexFormatNV" );
}

static void REGAL_CALL loader_glVertexFormatNV(GLint size, GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexFormatNV, "glVertexFormatNV");
   if ( !driverTbl.glVertexFormatNV ) {
      driverTbl.glVertexFormatNV = missing_glVertexFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexFormatNV == loader_glVertexFormatNV) {
      rCtx->dsp.emuTbl.glVertexFormatNV = driverTbl.glVertexFormatNV;
   }
   driverTbl.glVertexFormatNV(size, type, stride);
}

static void REGAL_CALL missing_glNormalFormatNV(GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "Called missing function glNormalFormatNV" );
}

static void REGAL_CALL loader_glNormalFormatNV(GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNormalFormatNV, "glNormalFormatNV");
   if ( !driverTbl.glNormalFormatNV ) {
      driverTbl.glNormalFormatNV = missing_glNormalFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNormalFormatNV == loader_glNormalFormatNV) {
      rCtx->dsp.emuTbl.glNormalFormatNV = driverTbl.glNormalFormatNV;
   }
   driverTbl.glNormalFormatNV(type, stride);
}

static void REGAL_CALL missing_glColorFormatNV(GLint size, GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "Called missing function glColorFormatNV" );
}

static void REGAL_CALL loader_glColorFormatNV(GLint size, GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glColorFormatNV, "glColorFormatNV");
   if ( !driverTbl.glColorFormatNV ) {
      driverTbl.glColorFormatNV = missing_glColorFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glColorFormatNV == loader_glColorFormatNV) {
      rCtx->dsp.emuTbl.glColorFormatNV = driverTbl.glColorFormatNV;
   }
   driverTbl.glColorFormatNV(size, type, stride);
}

static void REGAL_CALL missing_glIndexFormatNV(GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "Called missing function glIndexFormatNV" );
}

static void REGAL_CALL loader_glIndexFormatNV(GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIndexFormatNV, "glIndexFormatNV");
   if ( !driverTbl.glIndexFormatNV ) {
      driverTbl.glIndexFormatNV = missing_glIndexFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIndexFormatNV == loader_glIndexFormatNV) {
      rCtx->dsp.emuTbl.glIndexFormatNV = driverTbl.glIndexFormatNV;
   }
   driverTbl.glIndexFormatNV(type, stride);
}

static void REGAL_CALL missing_glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "Called missing function glTexCoordFormatNV" );
}

static void REGAL_CALL loader_glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexCoordFormatNV, "glTexCoordFormatNV");
   if ( !driverTbl.glTexCoordFormatNV ) {
      driverTbl.glTexCoordFormatNV = missing_glTexCoordFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexCoordFormatNV == loader_glTexCoordFormatNV) {
      rCtx->dsp.emuTbl.glTexCoordFormatNV = driverTbl.glTexCoordFormatNV;
   }
   driverTbl.glTexCoordFormatNV(size, type, stride);
}

static void REGAL_CALL missing_glEdgeFlagFormatNV(GLsizei stride)
{
   UNUSED_PARAMETER(stride);
   Warning( "Called missing function glEdgeFlagFormatNV" );
}

static void REGAL_CALL loader_glEdgeFlagFormatNV(GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glEdgeFlagFormatNV, "glEdgeFlagFormatNV");
   if ( !driverTbl.glEdgeFlagFormatNV ) {
      driverTbl.glEdgeFlagFormatNV = missing_glEdgeFlagFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glEdgeFlagFormatNV == loader_glEdgeFlagFormatNV) {
      rCtx->dsp.emuTbl.glEdgeFlagFormatNV = driverTbl.glEdgeFlagFormatNV;
   }
   driverTbl.glEdgeFlagFormatNV(stride);
}

static void REGAL_CALL missing_glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "Called missing function glSecondaryColorFormatNV" );
}

static void REGAL_CALL loader_glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSecondaryColorFormatNV, "glSecondaryColorFormatNV");
   if ( !driverTbl.glSecondaryColorFormatNV ) {
      driverTbl.glSecondaryColorFormatNV = missing_glSecondaryColorFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSecondaryColorFormatNV == loader_glSecondaryColorFormatNV) {
      rCtx->dsp.emuTbl.glSecondaryColorFormatNV = driverTbl.glSecondaryColorFormatNV;
   }
   driverTbl.glSecondaryColorFormatNV(size, type, stride);
}

static void REGAL_CALL missing_glFogCoordFormatNV(GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "Called missing function glFogCoordFormatNV" );
}

static void REGAL_CALL loader_glFogCoordFormatNV(GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFogCoordFormatNV, "glFogCoordFormatNV");
   if ( !driverTbl.glFogCoordFormatNV ) {
      driverTbl.glFogCoordFormatNV = missing_glFogCoordFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFogCoordFormatNV == loader_glFogCoordFormatNV) {
      rCtx->dsp.emuTbl.glFogCoordFormatNV = driverTbl.glFogCoordFormatNV;
   }
   driverTbl.glFogCoordFormatNV(type, stride);
}

static void REGAL_CALL missing_glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(stride);
   Warning( "Called missing function glVertexAttribFormatNV" );
}

static void REGAL_CALL loader_glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribFormatNV, "glVertexAttribFormatNV");
   if ( !driverTbl.glVertexAttribFormatNV ) {
      driverTbl.glVertexAttribFormatNV = missing_glVertexAttribFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribFormatNV == loader_glVertexAttribFormatNV) {
      rCtx->dsp.emuTbl.glVertexAttribFormatNV = driverTbl.glVertexAttribFormatNV;
   }
   driverTbl.glVertexAttribFormatNV(index, size, type, normalized, stride);
}

static void REGAL_CALL missing_glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "Called missing function glVertexAttribIFormatNV" );
}

static void REGAL_CALL loader_glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribIFormatNV, "glVertexAttribIFormatNV");
   if ( !driverTbl.glVertexAttribIFormatNV ) {
      driverTbl.glVertexAttribIFormatNV = missing_glVertexAttribIFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribIFormatNV == loader_glVertexAttribIFormatNV) {
      rCtx->dsp.emuTbl.glVertexAttribIFormatNV = driverTbl.glVertexAttribIFormatNV;
   }
   driverTbl.glVertexAttribIFormatNV(index, size, type, stride);
}

static void REGAL_CALL missing_glGetIntegerui64i_vNV(GLenum target, GLuint index, GLuint64EXT *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "Called missing function glGetIntegerui64i_vNV" );
}

static void REGAL_CALL loader_glGetIntegerui64i_vNV(GLenum target, GLuint index, GLuint64EXT *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetIntegerui64i_vNV, "glGetIntegerui64i_vNV");
   if ( !driverTbl.glGetIntegerui64i_vNV ) {
      driverTbl.glGetIntegerui64i_vNV = missing_glGetIntegerui64i_vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetIntegerui64i_vNV == loader_glGetIntegerui64i_vNV) {
      rCtx->dsp.emuTbl.glGetIntegerui64i_vNV = driverTbl.glGetIntegerui64i_vNV;
   }
   driverTbl.glGetIntegerui64i_vNV(target, index, data);
}

// GL_NV_texture_barrier

static void REGAL_CALL missing_glTextureBarrierNV(void)
{
   Warning( "Called missing function glTextureBarrierNV" );
}

static void REGAL_CALL loader_glTextureBarrierNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureBarrierNV, "glTextureBarrierNV");
   if ( !driverTbl.glTextureBarrierNV ) {
      driverTbl.glTextureBarrierNV = missing_glTextureBarrierNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureBarrierNV == loader_glTextureBarrierNV) {
      rCtx->dsp.emuTbl.glTextureBarrierNV = driverTbl.glTextureBarrierNV;
   }
   driverTbl.glTextureBarrierNV();
}

// GL_EXT_shader_image_load_store

static void REGAL_CALL missing_glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layered);
   UNUSED_PARAMETER(layer);
   UNUSED_PARAMETER(access);
   UNUSED_PARAMETER(format);
   Warning( "Called missing function glBindImageTextureEXT" );
}

static void REGAL_CALL loader_glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBindImageTextureEXT, "glBindImageTextureEXT");
   if ( !driverTbl.glBindImageTextureEXT ) {
      driverTbl.glBindImageTextureEXT = missing_glBindImageTextureEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBindImageTextureEXT == loader_glBindImageTextureEXT) {
      rCtx->dsp.emuTbl.glBindImageTextureEXT = driverTbl.glBindImageTextureEXT;
   }
   driverTbl.glBindImageTextureEXT(index, texture, level, layered, layer, access, format);
}

static void REGAL_CALL missing_glMemoryBarrierEXT(GLbitfield barriers)
{
   UNUSED_PARAMETER(barriers);
   Warning( "Called missing function glMemoryBarrierEXT" );
}

static void REGAL_CALL loader_glMemoryBarrierEXT(GLbitfield barriers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMemoryBarrierEXT, "glMemoryBarrierEXT");
   if ( !driverTbl.glMemoryBarrierEXT ) {
      driverTbl.glMemoryBarrierEXT = missing_glMemoryBarrierEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMemoryBarrierEXT == loader_glMemoryBarrierEXT) {
      rCtx->dsp.emuTbl.glMemoryBarrierEXT = driverTbl.glMemoryBarrierEXT;
   }
   driverTbl.glMemoryBarrierEXT(barriers);
}

// GL_EXT_vertex_attrib_64bit

static void REGAL_CALL missing_glVertexAttribL1dEXT(GLuint index, GLdouble x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttribL1dEXT" );
}

static void REGAL_CALL loader_glVertexAttribL1dEXT(GLuint index, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL1dEXT, "glVertexAttribL1dEXT");
   if ( !driverTbl.glVertexAttribL1dEXT ) {
      driverTbl.glVertexAttribL1dEXT = missing_glVertexAttribL1dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL1dEXT == loader_glVertexAttribL1dEXT) {
      rCtx->dsp.emuTbl.glVertexAttribL1dEXT = driverTbl.glVertexAttribL1dEXT;
   }
   driverTbl.glVertexAttribL1dEXT(index, x);
}

static void REGAL_CALL missing_glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttribL2dEXT" );
}

static void REGAL_CALL loader_glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL2dEXT, "glVertexAttribL2dEXT");
   if ( !driverTbl.glVertexAttribL2dEXT ) {
      driverTbl.glVertexAttribL2dEXT = missing_glVertexAttribL2dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL2dEXT == loader_glVertexAttribL2dEXT) {
      rCtx->dsp.emuTbl.glVertexAttribL2dEXT = driverTbl.glVertexAttribL2dEXT;
   }
   driverTbl.glVertexAttribL2dEXT(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttribL3dEXT" );
}

static void REGAL_CALL loader_glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL3dEXT, "glVertexAttribL3dEXT");
   if ( !driverTbl.glVertexAttribL3dEXT ) {
      driverTbl.glVertexAttribL3dEXT = missing_glVertexAttribL3dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL3dEXT == loader_glVertexAttribL3dEXT) {
      rCtx->dsp.emuTbl.glVertexAttribL3dEXT = driverTbl.glVertexAttribL3dEXT;
   }
   driverTbl.glVertexAttribL3dEXT(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttribL4dEXT" );
}

static void REGAL_CALL loader_glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL4dEXT, "glVertexAttribL4dEXT");
   if ( !driverTbl.glVertexAttribL4dEXT ) {
      driverTbl.glVertexAttribL4dEXT = missing_glVertexAttribL4dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL4dEXT == loader_glVertexAttribL4dEXT) {
      rCtx->dsp.emuTbl.glVertexAttribL4dEXT = driverTbl.glVertexAttribL4dEXT;
   }
   driverTbl.glVertexAttribL4dEXT(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribL1dvEXT(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL1dvEXT" );
}

static void REGAL_CALL loader_glVertexAttribL1dvEXT(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL1dvEXT, "glVertexAttribL1dvEXT");
   if ( !driverTbl.glVertexAttribL1dvEXT ) {
      driverTbl.glVertexAttribL1dvEXT = missing_glVertexAttribL1dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL1dvEXT == loader_glVertexAttribL1dvEXT) {
      rCtx->dsp.emuTbl.glVertexAttribL1dvEXT = driverTbl.glVertexAttribL1dvEXT;
   }
   driverTbl.glVertexAttribL1dvEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribL2dvEXT(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL2dvEXT" );
}

static void REGAL_CALL loader_glVertexAttribL2dvEXT(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL2dvEXT, "glVertexAttribL2dvEXT");
   if ( !driverTbl.glVertexAttribL2dvEXT ) {
      driverTbl.glVertexAttribL2dvEXT = missing_glVertexAttribL2dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL2dvEXT == loader_glVertexAttribL2dvEXT) {
      rCtx->dsp.emuTbl.glVertexAttribL2dvEXT = driverTbl.glVertexAttribL2dvEXT;
   }
   driverTbl.glVertexAttribL2dvEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribL3dvEXT(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL3dvEXT" );
}

static void REGAL_CALL loader_glVertexAttribL3dvEXT(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL3dvEXT, "glVertexAttribL3dvEXT");
   if ( !driverTbl.glVertexAttribL3dvEXT ) {
      driverTbl.glVertexAttribL3dvEXT = missing_glVertexAttribL3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL3dvEXT == loader_glVertexAttribL3dvEXT) {
      rCtx->dsp.emuTbl.glVertexAttribL3dvEXT = driverTbl.glVertexAttribL3dvEXT;
   }
   driverTbl.glVertexAttribL3dvEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribL4dvEXT(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL4dvEXT" );
}

static void REGAL_CALL loader_glVertexAttribL4dvEXT(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL4dvEXT, "glVertexAttribL4dvEXT");
   if ( !driverTbl.glVertexAttribL4dvEXT ) {
      driverTbl.glVertexAttribL4dvEXT = missing_glVertexAttribL4dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL4dvEXT == loader_glVertexAttribL4dvEXT) {
      rCtx->dsp.emuTbl.glVertexAttribL4dvEXT = driverTbl.glVertexAttribL4dvEXT;
   }
   driverTbl.glVertexAttribL4dvEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "Called missing function glVertexAttribLPointerEXT" );
}

static void REGAL_CALL loader_glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribLPointerEXT, "glVertexAttribLPointerEXT");
   if ( !driverTbl.glVertexAttribLPointerEXT ) {
      driverTbl.glVertexAttribLPointerEXT = missing_glVertexAttribLPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribLPointerEXT == loader_glVertexAttribLPointerEXT) {
      rCtx->dsp.emuTbl.glVertexAttribLPointerEXT = driverTbl.glVertexAttribLPointerEXT;
   }
   driverTbl.glVertexAttribLPointerEXT(index, size, type, stride, pointer);
}

static void REGAL_CALL missing_glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(offset);
   Warning( "Called missing function glVertexArrayVertexAttribLOffsetEXT" );
}

static void REGAL_CALL loader_glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexArrayVertexAttribLOffsetEXT, "glVertexArrayVertexAttribLOffsetEXT");
   if ( !driverTbl.glVertexArrayVertexAttribLOffsetEXT ) {
      driverTbl.glVertexArrayVertexAttribLOffsetEXT = missing_glVertexArrayVertexAttribLOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexArrayVertexAttribLOffsetEXT == loader_glVertexArrayVertexAttribLOffsetEXT) {
      rCtx->dsp.emuTbl.glVertexArrayVertexAttribLOffsetEXT = driverTbl.glVertexArrayVertexAttribLOffsetEXT;
   }
   driverTbl.glVertexArrayVertexAttribLOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
}

static void REGAL_CALL missing_glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribLdvEXT" );
}

static void REGAL_CALL loader_glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribLdvEXT, "glGetVertexAttribLdvEXT");
   if ( !driverTbl.glGetVertexAttribLdvEXT ) {
      driverTbl.glGetVertexAttribLdvEXT = missing_glGetVertexAttribLdvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribLdvEXT == loader_glGetVertexAttribLdvEXT) {
      rCtx->dsp.emuTbl.glGetVertexAttribLdvEXT = driverTbl.glGetVertexAttribLdvEXT;
   }
   driverTbl.glGetVertexAttribLdvEXT(index, pname, params);
}

// GL_NV_gpu_shader5

static void REGAL_CALL missing_glUniform1i64NV(GLint location, GLint64EXT x)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glUniform1i64NV" );
}

static void REGAL_CALL loader_glUniform1i64NV(GLint location, GLint64EXT x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1i64NV, "glUniform1i64NV");
   if ( !driverTbl.glUniform1i64NV ) {
      driverTbl.glUniform1i64NV = missing_glUniform1i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1i64NV == loader_glUniform1i64NV) {
      rCtx->dsp.emuTbl.glUniform1i64NV = driverTbl.glUniform1i64NV;
   }
   driverTbl.glUniform1i64NV(location, x);
}

static void REGAL_CALL missing_glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glUniform2i64NV" );
}

static void REGAL_CALL loader_glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2i64NV, "glUniform2i64NV");
   if ( !driverTbl.glUniform2i64NV ) {
      driverTbl.glUniform2i64NV = missing_glUniform2i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2i64NV == loader_glUniform2i64NV) {
      rCtx->dsp.emuTbl.glUniform2i64NV = driverTbl.glUniform2i64NV;
   }
   driverTbl.glUniform2i64NV(location, x, y);
}

static void REGAL_CALL missing_glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glUniform3i64NV" );
}

static void REGAL_CALL loader_glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3i64NV, "glUniform3i64NV");
   if ( !driverTbl.glUniform3i64NV ) {
      driverTbl.glUniform3i64NV = missing_glUniform3i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3i64NV == loader_glUniform3i64NV) {
      rCtx->dsp.emuTbl.glUniform3i64NV = driverTbl.glUniform3i64NV;
   }
   driverTbl.glUniform3i64NV(location, x, y, z);
}

static void REGAL_CALL missing_glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glUniform4i64NV" );
}

static void REGAL_CALL loader_glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4i64NV, "glUniform4i64NV");
   if ( !driverTbl.glUniform4i64NV ) {
      driverTbl.glUniform4i64NV = missing_glUniform4i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4i64NV == loader_glUniform4i64NV) {
      rCtx->dsp.emuTbl.glUniform4i64NV = driverTbl.glUniform4i64NV;
   }
   driverTbl.glUniform4i64NV(location, x, y, z, w);
}

static void REGAL_CALL missing_glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform1i64vNV" );
}

static void REGAL_CALL loader_glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1i64vNV, "glUniform1i64vNV");
   if ( !driverTbl.glUniform1i64vNV ) {
      driverTbl.glUniform1i64vNV = missing_glUniform1i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1i64vNV == loader_glUniform1i64vNV) {
      rCtx->dsp.emuTbl.glUniform1i64vNV = driverTbl.glUniform1i64vNV;
   }
   driverTbl.glUniform1i64vNV(location, count, value);
}

static void REGAL_CALL missing_glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform2i64vNV" );
}

static void REGAL_CALL loader_glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2i64vNV, "glUniform2i64vNV");
   if ( !driverTbl.glUniform2i64vNV ) {
      driverTbl.glUniform2i64vNV = missing_glUniform2i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2i64vNV == loader_glUniform2i64vNV) {
      rCtx->dsp.emuTbl.glUniform2i64vNV = driverTbl.glUniform2i64vNV;
   }
   driverTbl.glUniform2i64vNV(location, count, value);
}

static void REGAL_CALL missing_glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform3i64vNV" );
}

static void REGAL_CALL loader_glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3i64vNV, "glUniform3i64vNV");
   if ( !driverTbl.glUniform3i64vNV ) {
      driverTbl.glUniform3i64vNV = missing_glUniform3i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3i64vNV == loader_glUniform3i64vNV) {
      rCtx->dsp.emuTbl.glUniform3i64vNV = driverTbl.glUniform3i64vNV;
   }
   driverTbl.glUniform3i64vNV(location, count, value);
}

static void REGAL_CALL missing_glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform4i64vNV" );
}

static void REGAL_CALL loader_glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4i64vNV, "glUniform4i64vNV");
   if ( !driverTbl.glUniform4i64vNV ) {
      driverTbl.glUniform4i64vNV = missing_glUniform4i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4i64vNV == loader_glUniform4i64vNV) {
      rCtx->dsp.emuTbl.glUniform4i64vNV = driverTbl.glUniform4i64vNV;
   }
   driverTbl.glUniform4i64vNV(location, count, value);
}

static void REGAL_CALL missing_glUniform1ui64NV(GLint location, GLuint64EXT x)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glUniform1ui64NV" );
}

static void REGAL_CALL loader_glUniform1ui64NV(GLint location, GLuint64EXT x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1ui64NV, "glUniform1ui64NV");
   if ( !driverTbl.glUniform1ui64NV ) {
      driverTbl.glUniform1ui64NV = missing_glUniform1ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1ui64NV == loader_glUniform1ui64NV) {
      rCtx->dsp.emuTbl.glUniform1ui64NV = driverTbl.glUniform1ui64NV;
   }
   driverTbl.glUniform1ui64NV(location, x);
}

static void REGAL_CALL missing_glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glUniform2ui64NV" );
}

static void REGAL_CALL loader_glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2ui64NV, "glUniform2ui64NV");
   if ( !driverTbl.glUniform2ui64NV ) {
      driverTbl.glUniform2ui64NV = missing_glUniform2ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2ui64NV == loader_glUniform2ui64NV) {
      rCtx->dsp.emuTbl.glUniform2ui64NV = driverTbl.glUniform2ui64NV;
   }
   driverTbl.glUniform2ui64NV(location, x, y);
}

static void REGAL_CALL missing_glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glUniform3ui64NV" );
}

static void REGAL_CALL loader_glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3ui64NV, "glUniform3ui64NV");
   if ( !driverTbl.glUniform3ui64NV ) {
      driverTbl.glUniform3ui64NV = missing_glUniform3ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3ui64NV == loader_glUniform3ui64NV) {
      rCtx->dsp.emuTbl.glUniform3ui64NV = driverTbl.glUniform3ui64NV;
   }
   driverTbl.glUniform3ui64NV(location, x, y, z);
}

static void REGAL_CALL missing_glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glUniform4ui64NV" );
}

static void REGAL_CALL loader_glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4ui64NV, "glUniform4ui64NV");
   if ( !driverTbl.glUniform4ui64NV ) {
      driverTbl.glUniform4ui64NV = missing_glUniform4ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4ui64NV == loader_glUniform4ui64NV) {
      rCtx->dsp.emuTbl.glUniform4ui64NV = driverTbl.glUniform4ui64NV;
   }
   driverTbl.glUniform4ui64NV(location, x, y, z, w);
}

static void REGAL_CALL missing_glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform1ui64vNV" );
}

static void REGAL_CALL loader_glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform1ui64vNV, "glUniform1ui64vNV");
   if ( !driverTbl.glUniform1ui64vNV ) {
      driverTbl.glUniform1ui64vNV = missing_glUniform1ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform1ui64vNV == loader_glUniform1ui64vNV) {
      rCtx->dsp.emuTbl.glUniform1ui64vNV = driverTbl.glUniform1ui64vNV;
   }
   driverTbl.glUniform1ui64vNV(location, count, value);
}

static void REGAL_CALL missing_glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform2ui64vNV" );
}

static void REGAL_CALL loader_glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform2ui64vNV, "glUniform2ui64vNV");
   if ( !driverTbl.glUniform2ui64vNV ) {
      driverTbl.glUniform2ui64vNV = missing_glUniform2ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform2ui64vNV == loader_glUniform2ui64vNV) {
      rCtx->dsp.emuTbl.glUniform2ui64vNV = driverTbl.glUniform2ui64vNV;
   }
   driverTbl.glUniform2ui64vNV(location, count, value);
}

static void REGAL_CALL missing_glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform3ui64vNV" );
}

static void REGAL_CALL loader_glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform3ui64vNV, "glUniform3ui64vNV");
   if ( !driverTbl.glUniform3ui64vNV ) {
      driverTbl.glUniform3ui64vNV = missing_glUniform3ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform3ui64vNV == loader_glUniform3ui64vNV) {
      rCtx->dsp.emuTbl.glUniform3ui64vNV = driverTbl.glUniform3ui64vNV;
   }
   driverTbl.glUniform3ui64vNV(location, count, value);
}

static void REGAL_CALL missing_glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniform4ui64vNV" );
}

static void REGAL_CALL loader_glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniform4ui64vNV, "glUniform4ui64vNV");
   if ( !driverTbl.glUniform4ui64vNV ) {
      driverTbl.glUniform4ui64vNV = missing_glUniform4ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniform4ui64vNV == loader_glUniform4ui64vNV) {
      rCtx->dsp.emuTbl.glUniform4ui64vNV = driverTbl.glUniform4ui64vNV;
   }
   driverTbl.glUniform4ui64vNV(location, count, value);
}

static void REGAL_CALL missing_glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glProgramUniform1i64NV" );
}

static void REGAL_CALL loader_glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1i64NV, "glProgramUniform1i64NV");
   if ( !driverTbl.glProgramUniform1i64NV ) {
      driverTbl.glProgramUniform1i64NV = missing_glProgramUniform1i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1i64NV == loader_glProgramUniform1i64NV) {
      rCtx->dsp.emuTbl.glProgramUniform1i64NV = driverTbl.glProgramUniform1i64NV;
   }
   driverTbl.glProgramUniform1i64NV(program, location, x);
}

static void REGAL_CALL missing_glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glProgramUniform2i64NV" );
}

static void REGAL_CALL loader_glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2i64NV, "glProgramUniform2i64NV");
   if ( !driverTbl.glProgramUniform2i64NV ) {
      driverTbl.glProgramUniform2i64NV = missing_glProgramUniform2i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2i64NV == loader_glProgramUniform2i64NV) {
      rCtx->dsp.emuTbl.glProgramUniform2i64NV = driverTbl.glProgramUniform2i64NV;
   }
   driverTbl.glProgramUniform2i64NV(program, location, x, y);
}

static void REGAL_CALL missing_glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glProgramUniform3i64NV" );
}

static void REGAL_CALL loader_glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3i64NV, "glProgramUniform3i64NV");
   if ( !driverTbl.glProgramUniform3i64NV ) {
      driverTbl.glProgramUniform3i64NV = missing_glProgramUniform3i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3i64NV == loader_glProgramUniform3i64NV) {
      rCtx->dsp.emuTbl.glProgramUniform3i64NV = driverTbl.glProgramUniform3i64NV;
   }
   driverTbl.glProgramUniform3i64NV(program, location, x, y, z);
}

static void REGAL_CALL missing_glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramUniform4i64NV" );
}

static void REGAL_CALL loader_glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4i64NV, "glProgramUniform4i64NV");
   if ( !driverTbl.glProgramUniform4i64NV ) {
      driverTbl.glProgramUniform4i64NV = missing_glProgramUniform4i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4i64NV == loader_glProgramUniform4i64NV) {
      rCtx->dsp.emuTbl.glProgramUniform4i64NV = driverTbl.glProgramUniform4i64NV;
   }
   driverTbl.glProgramUniform4i64NV(program, location, x, y, z, w);
}

static void REGAL_CALL missing_glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform1i64vNV" );
}

static void REGAL_CALL loader_glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1i64vNV, "glProgramUniform1i64vNV");
   if ( !driverTbl.glProgramUniform1i64vNV ) {
      driverTbl.glProgramUniform1i64vNV = missing_glProgramUniform1i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1i64vNV == loader_glProgramUniform1i64vNV) {
      rCtx->dsp.emuTbl.glProgramUniform1i64vNV = driverTbl.glProgramUniform1i64vNV;
   }
   driverTbl.glProgramUniform1i64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform2i64vNV" );
}

static void REGAL_CALL loader_glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2i64vNV, "glProgramUniform2i64vNV");
   if ( !driverTbl.glProgramUniform2i64vNV ) {
      driverTbl.glProgramUniform2i64vNV = missing_glProgramUniform2i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2i64vNV == loader_glProgramUniform2i64vNV) {
      rCtx->dsp.emuTbl.glProgramUniform2i64vNV = driverTbl.glProgramUniform2i64vNV;
   }
   driverTbl.glProgramUniform2i64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform3i64vNV" );
}

static void REGAL_CALL loader_glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3i64vNV, "glProgramUniform3i64vNV");
   if ( !driverTbl.glProgramUniform3i64vNV ) {
      driverTbl.glProgramUniform3i64vNV = missing_glProgramUniform3i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3i64vNV == loader_glProgramUniform3i64vNV) {
      rCtx->dsp.emuTbl.glProgramUniform3i64vNV = driverTbl.glProgramUniform3i64vNV;
   }
   driverTbl.glProgramUniform3i64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform4i64vNV" );
}

static void REGAL_CALL loader_glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4i64vNV, "glProgramUniform4i64vNV");
   if ( !driverTbl.glProgramUniform4i64vNV ) {
      driverTbl.glProgramUniform4i64vNV = missing_glProgramUniform4i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4i64vNV == loader_glProgramUniform4i64vNV) {
      rCtx->dsp.emuTbl.glProgramUniform4i64vNV = driverTbl.glProgramUniform4i64vNV;
   }
   driverTbl.glProgramUniform4i64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glProgramUniform1ui64NV" );
}

static void REGAL_CALL loader_glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1ui64NV, "glProgramUniform1ui64NV");
   if ( !driverTbl.glProgramUniform1ui64NV ) {
      driverTbl.glProgramUniform1ui64NV = missing_glProgramUniform1ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1ui64NV == loader_glProgramUniform1ui64NV) {
      rCtx->dsp.emuTbl.glProgramUniform1ui64NV = driverTbl.glProgramUniform1ui64NV;
   }
   driverTbl.glProgramUniform1ui64NV(program, location, x);
}

static void REGAL_CALL missing_glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glProgramUniform2ui64NV" );
}

static void REGAL_CALL loader_glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2ui64NV, "glProgramUniform2ui64NV");
   if ( !driverTbl.glProgramUniform2ui64NV ) {
      driverTbl.glProgramUniform2ui64NV = missing_glProgramUniform2ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2ui64NV == loader_glProgramUniform2ui64NV) {
      rCtx->dsp.emuTbl.glProgramUniform2ui64NV = driverTbl.glProgramUniform2ui64NV;
   }
   driverTbl.glProgramUniform2ui64NV(program, location, x, y);
}

static void REGAL_CALL missing_glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glProgramUniform3ui64NV" );
}

static void REGAL_CALL loader_glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3ui64NV, "glProgramUniform3ui64NV");
   if ( !driverTbl.glProgramUniform3ui64NV ) {
      driverTbl.glProgramUniform3ui64NV = missing_glProgramUniform3ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3ui64NV == loader_glProgramUniform3ui64NV) {
      rCtx->dsp.emuTbl.glProgramUniform3ui64NV = driverTbl.glProgramUniform3ui64NV;
   }
   driverTbl.glProgramUniform3ui64NV(program, location, x, y, z);
}

static void REGAL_CALL missing_glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glProgramUniform4ui64NV" );
}

static void REGAL_CALL loader_glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4ui64NV, "glProgramUniform4ui64NV");
   if ( !driverTbl.glProgramUniform4ui64NV ) {
      driverTbl.glProgramUniform4ui64NV = missing_glProgramUniform4ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4ui64NV == loader_glProgramUniform4ui64NV) {
      rCtx->dsp.emuTbl.glProgramUniform4ui64NV = driverTbl.glProgramUniform4ui64NV;
   }
   driverTbl.glProgramUniform4ui64NV(program, location, x, y, z, w);
}

static void REGAL_CALL missing_glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform1ui64vNV" );
}

static void REGAL_CALL loader_glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform1ui64vNV, "glProgramUniform1ui64vNV");
   if ( !driverTbl.glProgramUniform1ui64vNV ) {
      driverTbl.glProgramUniform1ui64vNV = missing_glProgramUniform1ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform1ui64vNV == loader_glProgramUniform1ui64vNV) {
      rCtx->dsp.emuTbl.glProgramUniform1ui64vNV = driverTbl.glProgramUniform1ui64vNV;
   }
   driverTbl.glProgramUniform1ui64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform2ui64vNV" );
}

static void REGAL_CALL loader_glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform2ui64vNV, "glProgramUniform2ui64vNV");
   if ( !driverTbl.glProgramUniform2ui64vNV ) {
      driverTbl.glProgramUniform2ui64vNV = missing_glProgramUniform2ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform2ui64vNV == loader_glProgramUniform2ui64vNV) {
      rCtx->dsp.emuTbl.glProgramUniform2ui64vNV = driverTbl.glProgramUniform2ui64vNV;
   }
   driverTbl.glProgramUniform2ui64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform3ui64vNV" );
}

static void REGAL_CALL loader_glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform3ui64vNV, "glProgramUniform3ui64vNV");
   if ( !driverTbl.glProgramUniform3ui64vNV ) {
      driverTbl.glProgramUniform3ui64vNV = missing_glProgramUniform3ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform3ui64vNV == loader_glProgramUniform3ui64vNV) {
      rCtx->dsp.emuTbl.glProgramUniform3ui64vNV = driverTbl.glProgramUniform3ui64vNV;
   }
   driverTbl.glProgramUniform3ui64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniform4ui64vNV" );
}

static void REGAL_CALL loader_glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniform4ui64vNV, "glProgramUniform4ui64vNV");
   if ( !driverTbl.glProgramUniform4ui64vNV ) {
      driverTbl.glProgramUniform4ui64vNV = missing_glProgramUniform4ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniform4ui64vNV == loader_glProgramUniform4ui64vNV) {
      rCtx->dsp.emuTbl.glProgramUniform4ui64vNV = driverTbl.glProgramUniform4ui64vNV;
   }
   driverTbl.glProgramUniform4ui64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetUniformi64vNV" );
}

static void REGAL_CALL loader_glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetUniformi64vNV, "glGetUniformi64vNV");
   if ( !driverTbl.glGetUniformi64vNV ) {
      driverTbl.glGetUniformi64vNV = missing_glGetUniformi64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetUniformi64vNV == loader_glGetUniformi64vNV) {
      rCtx->dsp.emuTbl.glGetUniformi64vNV = driverTbl.glGetUniformi64vNV;
   }
   driverTbl.glGetUniformi64vNV(program, location, params);
}

// GL_NV_vertex_attrib_integer_64bit

static void REGAL_CALL missing_glVertexAttribL1i64NV(GLuint index, GLint64EXT x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttribL1i64NV" );
}

static void REGAL_CALL loader_glVertexAttribL1i64NV(GLuint index, GLint64EXT x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL1i64NV, "glVertexAttribL1i64NV");
   if ( !driverTbl.glVertexAttribL1i64NV ) {
      driverTbl.glVertexAttribL1i64NV = missing_glVertexAttribL1i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL1i64NV == loader_glVertexAttribL1i64NV) {
      rCtx->dsp.emuTbl.glVertexAttribL1i64NV = driverTbl.glVertexAttribL1i64NV;
   }
   driverTbl.glVertexAttribL1i64NV(index, x);
}

static void REGAL_CALL missing_glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttribL2i64NV" );
}

static void REGAL_CALL loader_glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL2i64NV, "glVertexAttribL2i64NV");
   if ( !driverTbl.glVertexAttribL2i64NV ) {
      driverTbl.glVertexAttribL2i64NV = missing_glVertexAttribL2i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL2i64NV == loader_glVertexAttribL2i64NV) {
      rCtx->dsp.emuTbl.glVertexAttribL2i64NV = driverTbl.glVertexAttribL2i64NV;
   }
   driverTbl.glVertexAttribL2i64NV(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttribL3i64NV" );
}

static void REGAL_CALL loader_glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL3i64NV, "glVertexAttribL3i64NV");
   if ( !driverTbl.glVertexAttribL3i64NV ) {
      driverTbl.glVertexAttribL3i64NV = missing_glVertexAttribL3i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL3i64NV == loader_glVertexAttribL3i64NV) {
      rCtx->dsp.emuTbl.glVertexAttribL3i64NV = driverTbl.glVertexAttribL3i64NV;
   }
   driverTbl.glVertexAttribL3i64NV(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttribL4i64NV" );
}

static void REGAL_CALL loader_glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL4i64NV, "glVertexAttribL4i64NV");
   if ( !driverTbl.glVertexAttribL4i64NV ) {
      driverTbl.glVertexAttribL4i64NV = missing_glVertexAttribL4i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL4i64NV == loader_glVertexAttribL4i64NV) {
      rCtx->dsp.emuTbl.glVertexAttribL4i64NV = driverTbl.glVertexAttribL4i64NV;
   }
   driverTbl.glVertexAttribL4i64NV(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "Called missing function glVertexAttribL1ui64NV" );
}

static void REGAL_CALL loader_glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL1ui64NV, "glVertexAttribL1ui64NV");
   if ( !driverTbl.glVertexAttribL1ui64NV ) {
      driverTbl.glVertexAttribL1ui64NV = missing_glVertexAttribL1ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL1ui64NV == loader_glVertexAttribL1ui64NV) {
      rCtx->dsp.emuTbl.glVertexAttribL1ui64NV = driverTbl.glVertexAttribL1ui64NV;
   }
   driverTbl.glVertexAttribL1ui64NV(index, x);
}

static void REGAL_CALL missing_glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glVertexAttribL2ui64NV" );
}

static void REGAL_CALL loader_glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL2ui64NV, "glVertexAttribL2ui64NV");
   if ( !driverTbl.glVertexAttribL2ui64NV ) {
      driverTbl.glVertexAttribL2ui64NV = missing_glVertexAttribL2ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL2ui64NV == loader_glVertexAttribL2ui64NV) {
      rCtx->dsp.emuTbl.glVertexAttribL2ui64NV = driverTbl.glVertexAttribL2ui64NV;
   }
   driverTbl.glVertexAttribL2ui64NV(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "Called missing function glVertexAttribL3ui64NV" );
}

static void REGAL_CALL loader_glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL3ui64NV, "glVertexAttribL3ui64NV");
   if ( !driverTbl.glVertexAttribL3ui64NV ) {
      driverTbl.glVertexAttribL3ui64NV = missing_glVertexAttribL3ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL3ui64NV == loader_glVertexAttribL3ui64NV) {
      rCtx->dsp.emuTbl.glVertexAttribL3ui64NV = driverTbl.glVertexAttribL3ui64NV;
   }
   driverTbl.glVertexAttribL3ui64NV(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "Called missing function glVertexAttribL4ui64NV" );
}

static void REGAL_CALL loader_glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL4ui64NV, "glVertexAttribL4ui64NV");
   if ( !driverTbl.glVertexAttribL4ui64NV ) {
      driverTbl.glVertexAttribL4ui64NV = missing_glVertexAttribL4ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL4ui64NV == loader_glVertexAttribL4ui64NV) {
      rCtx->dsp.emuTbl.glVertexAttribL4ui64NV = driverTbl.glVertexAttribL4ui64NV;
   }
   driverTbl.glVertexAttribL4ui64NV(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribL1i64vNV(GLuint index, const GLint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL1i64vNV" );
}

static void REGAL_CALL loader_glVertexAttribL1i64vNV(GLuint index, const GLint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL1i64vNV, "glVertexAttribL1i64vNV");
   if ( !driverTbl.glVertexAttribL1i64vNV ) {
      driverTbl.glVertexAttribL1i64vNV = missing_glVertexAttribL1i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL1i64vNV == loader_glVertexAttribL1i64vNV) {
      rCtx->dsp.emuTbl.glVertexAttribL1i64vNV = driverTbl.glVertexAttribL1i64vNV;
   }
   driverTbl.glVertexAttribL1i64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribL2i64vNV(GLuint index, const GLint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL2i64vNV" );
}

static void REGAL_CALL loader_glVertexAttribL2i64vNV(GLuint index, const GLint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL2i64vNV, "glVertexAttribL2i64vNV");
   if ( !driverTbl.glVertexAttribL2i64vNV ) {
      driverTbl.glVertexAttribL2i64vNV = missing_glVertexAttribL2i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL2i64vNV == loader_glVertexAttribL2i64vNV) {
      rCtx->dsp.emuTbl.glVertexAttribL2i64vNV = driverTbl.glVertexAttribL2i64vNV;
   }
   driverTbl.glVertexAttribL2i64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribL3i64vNV(GLuint index, const GLint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL3i64vNV" );
}

static void REGAL_CALL loader_glVertexAttribL3i64vNV(GLuint index, const GLint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL3i64vNV, "glVertexAttribL3i64vNV");
   if ( !driverTbl.glVertexAttribL3i64vNV ) {
      driverTbl.glVertexAttribL3i64vNV = missing_glVertexAttribL3i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL3i64vNV == loader_glVertexAttribL3i64vNV) {
      rCtx->dsp.emuTbl.glVertexAttribL3i64vNV = driverTbl.glVertexAttribL3i64vNV;
   }
   driverTbl.glVertexAttribL3i64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribL4i64vNV(GLuint index, const GLint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL4i64vNV" );
}

static void REGAL_CALL loader_glVertexAttribL4i64vNV(GLuint index, const GLint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL4i64vNV, "glVertexAttribL4i64vNV");
   if ( !driverTbl.glVertexAttribL4i64vNV ) {
      driverTbl.glVertexAttribL4i64vNV = missing_glVertexAttribL4i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL4i64vNV == loader_glVertexAttribL4i64vNV) {
      rCtx->dsp.emuTbl.glVertexAttribL4i64vNV = driverTbl.glVertexAttribL4i64vNV;
   }
   driverTbl.glVertexAttribL4i64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL1ui64vNV" );
}

static void REGAL_CALL loader_glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL1ui64vNV, "glVertexAttribL1ui64vNV");
   if ( !driverTbl.glVertexAttribL1ui64vNV ) {
      driverTbl.glVertexAttribL1ui64vNV = missing_glVertexAttribL1ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL1ui64vNV == loader_glVertexAttribL1ui64vNV) {
      rCtx->dsp.emuTbl.glVertexAttribL1ui64vNV = driverTbl.glVertexAttribL1ui64vNV;
   }
   driverTbl.glVertexAttribL1ui64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL2ui64vNV" );
}

static void REGAL_CALL loader_glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL2ui64vNV, "glVertexAttribL2ui64vNV");
   if ( !driverTbl.glVertexAttribL2ui64vNV ) {
      driverTbl.glVertexAttribL2ui64vNV = missing_glVertexAttribL2ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL2ui64vNV == loader_glVertexAttribL2ui64vNV) {
      rCtx->dsp.emuTbl.glVertexAttribL2ui64vNV = driverTbl.glVertexAttribL2ui64vNV;
   }
   driverTbl.glVertexAttribL2ui64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL3ui64vNV" );
}

static void REGAL_CALL loader_glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL3ui64vNV, "glVertexAttribL3ui64vNV");
   if ( !driverTbl.glVertexAttribL3ui64vNV ) {
      driverTbl.glVertexAttribL3ui64vNV = missing_glVertexAttribL3ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL3ui64vNV == loader_glVertexAttribL3ui64vNV) {
      rCtx->dsp.emuTbl.glVertexAttribL3ui64vNV = driverTbl.glVertexAttribL3ui64vNV;
   }
   driverTbl.glVertexAttribL3ui64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "Called missing function glVertexAttribL4ui64vNV" );
}

static void REGAL_CALL loader_glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribL4ui64vNV, "glVertexAttribL4ui64vNV");
   if ( !driverTbl.glVertexAttribL4ui64vNV ) {
      driverTbl.glVertexAttribL4ui64vNV = missing_glVertexAttribL4ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribL4ui64vNV == loader_glVertexAttribL4ui64vNV) {
      rCtx->dsp.emuTbl.glVertexAttribL4ui64vNV = driverTbl.glVertexAttribL4ui64vNV;
   }
   driverTbl.glVertexAttribL4ui64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "Called missing function glVertexAttribLFormatNV" );
}

static void REGAL_CALL loader_glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVertexAttribLFormatNV, "glVertexAttribLFormatNV");
   if ( !driverTbl.glVertexAttribLFormatNV ) {
      driverTbl.glVertexAttribLFormatNV = missing_glVertexAttribLFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVertexAttribLFormatNV == loader_glVertexAttribLFormatNV) {
      rCtx->dsp.emuTbl.glVertexAttribLFormatNV = driverTbl.glVertexAttribLFormatNV;
   }
   driverTbl.glVertexAttribLFormatNV(index, size, type, stride);
}

static void REGAL_CALL missing_glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribLi64vNV" );
}

static void REGAL_CALL loader_glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribLi64vNV, "glGetVertexAttribLi64vNV");
   if ( !driverTbl.glGetVertexAttribLi64vNV ) {
      driverTbl.glGetVertexAttribLi64vNV = missing_glGetVertexAttribLi64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribLi64vNV == loader_glGetVertexAttribLi64vNV) {
      rCtx->dsp.emuTbl.glGetVertexAttribLi64vNV = driverTbl.glGetVertexAttribLi64vNV;
   }
   driverTbl.glGetVertexAttribLi64vNV(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetVertexAttribLui64vNV" );
}

static void REGAL_CALL loader_glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetVertexAttribLui64vNV, "glGetVertexAttribLui64vNV");
   if ( !driverTbl.glGetVertexAttribLui64vNV ) {
      driverTbl.glGetVertexAttribLui64vNV = missing_glGetVertexAttribLui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetVertexAttribLui64vNV == loader_glGetVertexAttribLui64vNV) {
      rCtx->dsp.emuTbl.glGetVertexAttribLui64vNV = driverTbl.glGetVertexAttribLui64vNV;
   }
   driverTbl.glGetVertexAttribLui64vNV(index, pname, params);
}

// GL_NV_vdpau_interop

static void REGAL_CALL missing_glVDPAUInitNV(const GLvoid *vdpDevice, const GLvoid *getProcAddress)
{
   UNUSED_PARAMETER(vdpDevice);
   UNUSED_PARAMETER(getProcAddress);
   Warning( "Called missing function glVDPAUInitNV" );
}

static void REGAL_CALL loader_glVDPAUInitNV(const GLvoid *vdpDevice, const GLvoid *getProcAddress)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVDPAUInitNV, "glVDPAUInitNV");
   if ( !driverTbl.glVDPAUInitNV ) {
      driverTbl.glVDPAUInitNV = missing_glVDPAUInitNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVDPAUInitNV == loader_glVDPAUInitNV) {
      rCtx->dsp.emuTbl.glVDPAUInitNV = driverTbl.glVDPAUInitNV;
   }
   driverTbl.glVDPAUInitNV(vdpDevice, getProcAddress);
}

static void REGAL_CALL missing_glVDPAUFiniNV(void)
{
   Warning( "Called missing function glVDPAUFiniNV" );
}

static void REGAL_CALL loader_glVDPAUFiniNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVDPAUFiniNV, "glVDPAUFiniNV");
   if ( !driverTbl.glVDPAUFiniNV ) {
      driverTbl.glVDPAUFiniNV = missing_glVDPAUFiniNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVDPAUFiniNV == loader_glVDPAUFiniNV) {
      rCtx->dsp.emuTbl.glVDPAUFiniNV = driverTbl.glVDPAUFiniNV;
   }
   driverTbl.glVDPAUFiniNV();
}

static GLvdpauSurfaceNV REGAL_CALL missing_glVDPAURegisterVideoSurfaceNV(const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames)
{
   UNUSED_PARAMETER(vdpSurface);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(numTextureNames);
   UNUSED_PARAMETER(textureNames);
   Warning( "Called missing function glVDPAURegisterVideoSurfaceNV" );
  GLvdpauSurfaceNV  ret = (GLvdpauSurfaceNV )0;
  return ret;
}

static GLvdpauSurfaceNV REGAL_CALL loader_glVDPAURegisterVideoSurfaceNV(const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVDPAURegisterVideoSurfaceNV, "glVDPAURegisterVideoSurfaceNV");
   if ( !driverTbl.glVDPAURegisterVideoSurfaceNV ) {
      driverTbl.glVDPAURegisterVideoSurfaceNV = missing_glVDPAURegisterVideoSurfaceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVDPAURegisterVideoSurfaceNV == loader_glVDPAURegisterVideoSurfaceNV) {
      rCtx->dsp.emuTbl.glVDPAURegisterVideoSurfaceNV = driverTbl.glVDPAURegisterVideoSurfaceNV;
   }
   return driverTbl.glVDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
}

static GLvdpauSurfaceNV REGAL_CALL missing_glVDPAURegisterOutputSurfaceNV(const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames)
{
   UNUSED_PARAMETER(vdpSurface);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(numTextureNames);
   UNUSED_PARAMETER(textureNames);
   Warning( "Called missing function glVDPAURegisterOutputSurfaceNV" );
  GLvdpauSurfaceNV  ret = (GLvdpauSurfaceNV )0;
  return ret;
}

static GLvdpauSurfaceNV REGAL_CALL loader_glVDPAURegisterOutputSurfaceNV(const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVDPAURegisterOutputSurfaceNV, "glVDPAURegisterOutputSurfaceNV");
   if ( !driverTbl.glVDPAURegisterOutputSurfaceNV ) {
      driverTbl.glVDPAURegisterOutputSurfaceNV = missing_glVDPAURegisterOutputSurfaceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVDPAURegisterOutputSurfaceNV == loader_glVDPAURegisterOutputSurfaceNV) {
      rCtx->dsp.emuTbl.glVDPAURegisterOutputSurfaceNV = driverTbl.glVDPAURegisterOutputSurfaceNV;
   }
   return driverTbl.glVDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
}

static GLboolean REGAL_CALL missing_glVDPAUIsSurfaceNV(GLvdpauSurfaceNV surface)
{
   UNUSED_PARAMETER(surface);
   Warning( "Called missing function glVDPAUIsSurfaceNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glVDPAUIsSurfaceNV(GLvdpauSurfaceNV surface)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVDPAUIsSurfaceNV, "glVDPAUIsSurfaceNV");
   if ( !driverTbl.glVDPAUIsSurfaceNV ) {
      driverTbl.glVDPAUIsSurfaceNV = missing_glVDPAUIsSurfaceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVDPAUIsSurfaceNV == loader_glVDPAUIsSurfaceNV) {
      rCtx->dsp.emuTbl.glVDPAUIsSurfaceNV = driverTbl.glVDPAUIsSurfaceNV;
   }
   return driverTbl.glVDPAUIsSurfaceNV(surface);
}

static void REGAL_CALL missing_glVDPAUUnregisterSurfaceNV(GLvdpauSurfaceNV surface)
{
   UNUSED_PARAMETER(surface);
   Warning( "Called missing function glVDPAUUnregisterSurfaceNV" );
}

static void REGAL_CALL loader_glVDPAUUnregisterSurfaceNV(GLvdpauSurfaceNV surface)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVDPAUUnregisterSurfaceNV, "glVDPAUUnregisterSurfaceNV");
   if ( !driverTbl.glVDPAUUnregisterSurfaceNV ) {
      driverTbl.glVDPAUUnregisterSurfaceNV = missing_glVDPAUUnregisterSurfaceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVDPAUUnregisterSurfaceNV == loader_glVDPAUUnregisterSurfaceNV) {
      rCtx->dsp.emuTbl.glVDPAUUnregisterSurfaceNV = driverTbl.glVDPAUUnregisterSurfaceNV;
   }
   driverTbl.glVDPAUUnregisterSurfaceNV(surface);
}

static void REGAL_CALL missing_glVDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
   UNUSED_PARAMETER(surface);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glVDPAUGetSurfaceivNV" );
}

static void REGAL_CALL loader_glVDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVDPAUGetSurfaceivNV, "glVDPAUGetSurfaceivNV");
   if ( !driverTbl.glVDPAUGetSurfaceivNV ) {
      driverTbl.glVDPAUGetSurfaceivNV = missing_glVDPAUGetSurfaceivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVDPAUGetSurfaceivNV == loader_glVDPAUGetSurfaceivNV) {
      rCtx->dsp.emuTbl.glVDPAUGetSurfaceivNV = driverTbl.glVDPAUGetSurfaceivNV;
   }
   driverTbl.glVDPAUGetSurfaceivNV(surface, pname, bufSize, length, values);
}

static void REGAL_CALL missing_glVDPAUSurfaceAccessNV(GLvdpauSurfaceNV surface, GLenum access)
{
   UNUSED_PARAMETER(surface);
   UNUSED_PARAMETER(access);
   Warning( "Called missing function glVDPAUSurfaceAccessNV" );
}

static void REGAL_CALL loader_glVDPAUSurfaceAccessNV(GLvdpauSurfaceNV surface, GLenum access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVDPAUSurfaceAccessNV, "glVDPAUSurfaceAccessNV");
   if ( !driverTbl.glVDPAUSurfaceAccessNV ) {
      driverTbl.glVDPAUSurfaceAccessNV = missing_glVDPAUSurfaceAccessNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVDPAUSurfaceAccessNV == loader_glVDPAUSurfaceAccessNV) {
      rCtx->dsp.emuTbl.glVDPAUSurfaceAccessNV = driverTbl.glVDPAUSurfaceAccessNV;
   }
   driverTbl.glVDPAUSurfaceAccessNV(surface, access);
}

static void REGAL_CALL missing_glVDPAUMapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces)
{
   UNUSED_PARAMETER(numSurfaces);
   UNUSED_PARAMETER(surfaces);
   Warning( "Called missing function glVDPAUMapSurfacesNV" );
}

static void REGAL_CALL loader_glVDPAUMapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVDPAUMapSurfacesNV, "glVDPAUMapSurfacesNV");
   if ( !driverTbl.glVDPAUMapSurfacesNV ) {
      driverTbl.glVDPAUMapSurfacesNV = missing_glVDPAUMapSurfacesNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVDPAUMapSurfacesNV == loader_glVDPAUMapSurfacesNV) {
      rCtx->dsp.emuTbl.glVDPAUMapSurfacesNV = driverTbl.glVDPAUMapSurfacesNV;
   }
   driverTbl.glVDPAUMapSurfacesNV(numSurfaces, surfaces);
}

static void REGAL_CALL missing_glVDPAUUnmapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces)
{
   UNUSED_PARAMETER(numSurfaces);
   UNUSED_PARAMETER(surfaces);
   Warning( "Called missing function glVDPAUUnmapSurfacesNV" );
}

static void REGAL_CALL loader_glVDPAUUnmapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glVDPAUUnmapSurfacesNV, "glVDPAUUnmapSurfacesNV");
   if ( !driverTbl.glVDPAUUnmapSurfacesNV ) {
      driverTbl.glVDPAUUnmapSurfacesNV = missing_glVDPAUUnmapSurfacesNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glVDPAUUnmapSurfacesNV == loader_glVDPAUUnmapSurfacesNV) {
      rCtx->dsp.emuTbl.glVDPAUUnmapSurfacesNV = driverTbl.glVDPAUUnmapSurfacesNV;
   }
   driverTbl.glVDPAUUnmapSurfacesNV(numSurfaces, surfaces);
}

// GL_NV_path_rendering

static void REGAL_CALL missing_glCopyPathNV(GLuint resultPath, GLuint srcPath)
{
   UNUSED_PARAMETER(resultPath);
   UNUSED_PARAMETER(srcPath);
   Warning( "Called missing function glCopyPathNV" );
}

static void REGAL_CALL loader_glCopyPathNV(GLuint resultPath, GLuint srcPath)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCopyPathNV, "glCopyPathNV");
   if ( !driverTbl.glCopyPathNV ) {
      driverTbl.glCopyPathNV = missing_glCopyPathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCopyPathNV == loader_glCopyPathNV) {
      rCtx->dsp.emuTbl.glCopyPathNV = driverTbl.glCopyPathNV;
   }
   driverTbl.glCopyPathNV(resultPath, srcPath);
}

static void REGAL_CALL missing_glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
{
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(pathNameType);
   UNUSED_PARAMETER(paths);
   UNUSED_PARAMETER(pathBase);
   UNUSED_PARAMETER(coverMode);
   UNUSED_PARAMETER(transformType);
   UNUSED_PARAMETER(transformValues);
   Warning( "Called missing function glCoverFillPathInstancedNV" );
}

static void REGAL_CALL loader_glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCoverFillPathInstancedNV, "glCoverFillPathInstancedNV");
   if ( !driverTbl.glCoverFillPathInstancedNV ) {
      driverTbl.glCoverFillPathInstancedNV = missing_glCoverFillPathInstancedNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCoverFillPathInstancedNV == loader_glCoverFillPathInstancedNV) {
      rCtx->dsp.emuTbl.glCoverFillPathInstancedNV = driverTbl.glCoverFillPathInstancedNV;
   }
   driverTbl.glCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
}

static void REGAL_CALL missing_glCoverFillPathNV(GLuint path, GLenum coverMode)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(coverMode);
   Warning( "Called missing function glCoverFillPathNV" );
}

static void REGAL_CALL loader_glCoverFillPathNV(GLuint path, GLenum coverMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCoverFillPathNV, "glCoverFillPathNV");
   if ( !driverTbl.glCoverFillPathNV ) {
      driverTbl.glCoverFillPathNV = missing_glCoverFillPathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCoverFillPathNV == loader_glCoverFillPathNV) {
      rCtx->dsp.emuTbl.glCoverFillPathNV = driverTbl.glCoverFillPathNV;
   }
   driverTbl.glCoverFillPathNV(path, coverMode);
}

static void REGAL_CALL missing_glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
{
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(pathNameType);
   UNUSED_PARAMETER(paths);
   UNUSED_PARAMETER(pathBase);
   UNUSED_PARAMETER(coverMode);
   UNUSED_PARAMETER(transformType);
   UNUSED_PARAMETER(transformValues);
   Warning( "Called missing function glCoverStrokePathInstancedNV" );
}

static void REGAL_CALL loader_glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCoverStrokePathInstancedNV, "glCoverStrokePathInstancedNV");
   if ( !driverTbl.glCoverStrokePathInstancedNV ) {
      driverTbl.glCoverStrokePathInstancedNV = missing_glCoverStrokePathInstancedNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCoverStrokePathInstancedNV == loader_glCoverStrokePathInstancedNV) {
      rCtx->dsp.emuTbl.glCoverStrokePathInstancedNV = driverTbl.glCoverStrokePathInstancedNV;
   }
   driverTbl.glCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
}

static void REGAL_CALL missing_glCoverStrokePathNV(GLuint name, GLenum coverMode)
{
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(coverMode);
   Warning( "Called missing function glCoverStrokePathNV" );
}

static void REGAL_CALL loader_glCoverStrokePathNV(GLuint name, GLenum coverMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCoverStrokePathNV, "glCoverStrokePathNV");
   if ( !driverTbl.glCoverStrokePathNV ) {
      driverTbl.glCoverStrokePathNV = missing_glCoverStrokePathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCoverStrokePathNV == loader_glCoverStrokePathNV) {
      rCtx->dsp.emuTbl.glCoverStrokePathNV = driverTbl.glCoverStrokePathNV;
   }
   driverTbl.glCoverStrokePathNV(name, coverMode);
}

static void REGAL_CALL missing_glDeletePathsNV(GLuint path, GLsizei range)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(range);
   Warning( "Called missing function glDeletePathsNV" );
}

static void REGAL_CALL loader_glDeletePathsNV(GLuint path, GLsizei range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeletePathsNV, "glDeletePathsNV");
   if ( !driverTbl.glDeletePathsNV ) {
      driverTbl.glDeletePathsNV = missing_glDeletePathsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeletePathsNV == loader_glDeletePathsNV) {
      rCtx->dsp.emuTbl.glDeletePathsNV = driverTbl.glDeletePathsNV;
   }
   driverTbl.glDeletePathsNV(path, range);
}

static GLuint REGAL_CALL missing_glGenPathsNV(GLsizei range)
{
   UNUSED_PARAMETER(range);
   Warning( "Called missing function glGenPathsNV" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGenPathsNV(GLsizei range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenPathsNV, "glGenPathsNV");
   if ( !driverTbl.glGenPathsNV ) {
      driverTbl.glGenPathsNV = missing_glGenPathsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenPathsNV == loader_glGenPathsNV) {
      rCtx->dsp.emuTbl.glGenPathsNV = driverTbl.glGenPathsNV;
   }
   return driverTbl.glGenPathsNV(range);
}

static void REGAL_CALL missing_glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat*value)
{
   UNUSED_PARAMETER(color);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glGetPathColorGenfvNV" );
}

static void REGAL_CALL loader_glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat*value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPathColorGenfvNV, "glGetPathColorGenfvNV");
   if ( !driverTbl.glGetPathColorGenfvNV ) {
      driverTbl.glGetPathColorGenfvNV = missing_glGetPathColorGenfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPathColorGenfvNV == loader_glGetPathColorGenfvNV) {
      rCtx->dsp.emuTbl.glGetPathColorGenfvNV = driverTbl.glGetPathColorGenfvNV;
   }
   driverTbl.glGetPathColorGenfvNV(color, pname, value);
}

static void REGAL_CALL missing_glGetPathColorGenivNV(GLenum color, GLenum pname, GLint *value)
{
   UNUSED_PARAMETER(color);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glGetPathColorGenivNV" );
}

static void REGAL_CALL loader_glGetPathColorGenivNV(GLenum color, GLenum pname, GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPathColorGenivNV, "glGetPathColorGenivNV");
   if ( !driverTbl.glGetPathColorGenivNV ) {
      driverTbl.glGetPathColorGenivNV = missing_glGetPathColorGenivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPathColorGenivNV == loader_glGetPathColorGenivNV) {
      rCtx->dsp.emuTbl.glGetPathColorGenivNV = driverTbl.glGetPathColorGenivNV;
   }
   driverTbl.glGetPathColorGenivNV(color, pname, value);
}

static void REGAL_CALL missing_glGetPathCommandsNV(GLuint name, GLubyte *commands)
{
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(commands);
   Warning( "Called missing function glGetPathCommandsNV" );
}

static void REGAL_CALL loader_glGetPathCommandsNV(GLuint name, GLubyte *commands)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPathCommandsNV, "glGetPathCommandsNV");
   if ( !driverTbl.glGetPathCommandsNV ) {
      driverTbl.glGetPathCommandsNV = missing_glGetPathCommandsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPathCommandsNV == loader_glGetPathCommandsNV) {
      rCtx->dsp.emuTbl.glGetPathCommandsNV = driverTbl.glGetPathCommandsNV;
   }
   driverTbl.glGetPathCommandsNV(name, commands);
}

static void REGAL_CALL missing_glGetPathCoordsNV(GLuint name, GLfloat*coords)
{
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glGetPathCoordsNV" );
}

static void REGAL_CALL loader_glGetPathCoordsNV(GLuint name, GLfloat*coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPathCoordsNV, "glGetPathCoordsNV");
   if ( !driverTbl.glGetPathCoordsNV ) {
      driverTbl.glGetPathCoordsNV = missing_glGetPathCoordsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPathCoordsNV == loader_glGetPathCoordsNV) {
      rCtx->dsp.emuTbl.glGetPathCoordsNV = driverTbl.glGetPathCoordsNV;
   }
   driverTbl.glGetPathCoordsNV(name, coords);
}

static void REGAL_CALL missing_glGetPathDashArrayNV(GLuint name, GLfloat *dashArray)
{
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(dashArray);
   Warning( "Called missing function glGetPathDashArrayNV" );
}

static void REGAL_CALL loader_glGetPathDashArrayNV(GLuint name, GLfloat *dashArray)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPathDashArrayNV, "glGetPathDashArrayNV");
   if ( !driverTbl.glGetPathDashArrayNV ) {
      driverTbl.glGetPathDashArrayNV = missing_glGetPathDashArrayNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPathDashArrayNV == loader_glGetPathDashArrayNV) {
      rCtx->dsp.emuTbl.glGetPathDashArrayNV = driverTbl.glGetPathDashArrayNV;
   }
   driverTbl.glGetPathDashArrayNV(name, dashArray);
}

static GLfloat REGAL_CALL missing_glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(startSegment);
   UNUSED_PARAMETER(numSegments);
   Warning( "Called missing function glGetPathLengthNV" );
  GLfloat  ret = (GLfloat )0;
  return ret;
}

static GLfloat REGAL_CALL loader_glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPathLengthNV, "glGetPathLengthNV");
   if ( !driverTbl.glGetPathLengthNV ) {
      driverTbl.glGetPathLengthNV = missing_glGetPathLengthNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPathLengthNV == loader_glGetPathLengthNV) {
      rCtx->dsp.emuTbl.glGetPathLengthNV = driverTbl.glGetPathLengthNV;
   }
   return driverTbl.glGetPathLengthNV(path, startSegment, numSegments);
}

static void REGAL_CALL missing_glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint fistPathName, GLsizei numPaths, GLsizei stride, GLfloat*metrics)
{
   UNUSED_PARAMETER(metricQueryMask);
   UNUSED_PARAMETER(fistPathName);
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(metrics);
   Warning( "Called missing function glGetPathMetricRangeNV" );
}

static void REGAL_CALL loader_glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint fistPathName, GLsizei numPaths, GLsizei stride, GLfloat*metrics)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPathMetricRangeNV, "glGetPathMetricRangeNV");
   if ( !driverTbl.glGetPathMetricRangeNV ) {
      driverTbl.glGetPathMetricRangeNV = missing_glGetPathMetricRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPathMetricRangeNV == loader_glGetPathMetricRangeNV) {
      rCtx->dsp.emuTbl.glGetPathMetricRangeNV = driverTbl.glGetPathMetricRangeNV;
   }
   driverTbl.glGetPathMetricRangeNV(metricQueryMask, fistPathName, numPaths, stride, metrics);
}

static void REGAL_CALL missing_glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics)
{
   UNUSED_PARAMETER(metricQueryMask);
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(pathNameType);
   UNUSED_PARAMETER(paths);
   UNUSED_PARAMETER(pathBase);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(metrics);
   Warning( "Called missing function glGetPathMetricsNV" );
}

static void REGAL_CALL loader_glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPathMetricsNV, "glGetPathMetricsNV");
   if ( !driverTbl.glGetPathMetricsNV ) {
      driverTbl.glGetPathMetricsNV = missing_glGetPathMetricsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPathMetricsNV == loader_glGetPathMetricsNV) {
      rCtx->dsp.emuTbl.glGetPathMetricsNV = driverTbl.glGetPathMetricsNV;
   }
   driverTbl.glGetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
}

static void REGAL_CALL missing_glGetPathParameterfvNV(GLuint name, GLenum param, GLfloat*value)
{
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(param);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glGetPathParameterfvNV" );
}

static void REGAL_CALL loader_glGetPathParameterfvNV(GLuint name, GLenum param, GLfloat*value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPathParameterfvNV, "glGetPathParameterfvNV");
   if ( !driverTbl.glGetPathParameterfvNV ) {
      driverTbl.glGetPathParameterfvNV = missing_glGetPathParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPathParameterfvNV == loader_glGetPathParameterfvNV) {
      rCtx->dsp.emuTbl.glGetPathParameterfvNV = driverTbl.glGetPathParameterfvNV;
   }
   driverTbl.glGetPathParameterfvNV(name, param, value);
}

static void REGAL_CALL missing_glGetPathParameterivNV(GLuint name, GLenum param, GLint*value)
{
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(param);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glGetPathParameterivNV" );
}

static void REGAL_CALL loader_glGetPathParameterivNV(GLuint name, GLenum param, GLint*value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPathParameterivNV, "glGetPathParameterivNV");
   if ( !driverTbl.glGetPathParameterivNV ) {
      driverTbl.glGetPathParameterivNV = missing_glGetPathParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPathParameterivNV == loader_glGetPathParameterivNV) {
      rCtx->dsp.emuTbl.glGetPathParameterivNV = driverTbl.glGetPathParameterivNV;
   }
   driverTbl.glGetPathParameterivNV(name, param, value);
}

static void REGAL_CALL missing_glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing)
{
   UNUSED_PARAMETER(pathListMode);
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(pathNameType);
   UNUSED_PARAMETER(paths);
   UNUSED_PARAMETER(pathBase);
   UNUSED_PARAMETER(advanceScale);
   UNUSED_PARAMETER(kerningScale);
   UNUSED_PARAMETER(transformType);
   UNUSED_PARAMETER(returnedSpacing);
   Warning( "Called missing function glGetPathSpacingNV" );
}

static void REGAL_CALL loader_glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPathSpacingNV, "glGetPathSpacingNV");
   if ( !driverTbl.glGetPathSpacingNV ) {
      driverTbl.glGetPathSpacingNV = missing_glGetPathSpacingNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPathSpacingNV == loader_glGetPathSpacingNV) {
      rCtx->dsp.emuTbl.glGetPathSpacingNV = driverTbl.glGetPathSpacingNV;
   }
   driverTbl.glGetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
}

static void REGAL_CALL missing_glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat*value)
{
   UNUSED_PARAMETER(texCoordSet);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glGetPathTexGenfvNV" );
}

static void REGAL_CALL loader_glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat*value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPathTexGenfvNV, "glGetPathTexGenfvNV");
   if ( !driverTbl.glGetPathTexGenfvNV ) {
      driverTbl.glGetPathTexGenfvNV = missing_glGetPathTexGenfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPathTexGenfvNV == loader_glGetPathTexGenfvNV) {
      rCtx->dsp.emuTbl.glGetPathTexGenfvNV = driverTbl.glGetPathTexGenfvNV;
   }
   driverTbl.glGetPathTexGenfvNV(texCoordSet, pname, value);
}

static void REGAL_CALL missing_glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint*value)
{
   UNUSED_PARAMETER(texCoordSet);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glGetPathTexGenivNV" );
}

static void REGAL_CALL loader_glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint*value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetPathTexGenivNV, "glGetPathTexGenivNV");
   if ( !driverTbl.glGetPathTexGenivNV ) {
      driverTbl.glGetPathTexGenivNV = missing_glGetPathTexGenivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetPathTexGenivNV == loader_glGetPathTexGenivNV) {
      rCtx->dsp.emuTbl.glGetPathTexGenivNV = driverTbl.glGetPathTexGenivNV;
   }
   driverTbl.glGetPathTexGenivNV(texCoordSet, pname, value);
}

static void REGAL_CALL missing_glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight)
{
   UNUSED_PARAMETER(resultPath);
   UNUSED_PARAMETER(pathA);
   UNUSED_PARAMETER(pathB);
   UNUSED_PARAMETER(weight);
   Warning( "Called missing function glInterpolatePathsNV" );
}

static void REGAL_CALL loader_glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glInterpolatePathsNV, "glInterpolatePathsNV");
   if ( !driverTbl.glInterpolatePathsNV ) {
      driverTbl.glInterpolatePathsNV = missing_glInterpolatePathsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glInterpolatePathsNV == loader_glInterpolatePathsNV) {
      rCtx->dsp.emuTbl.glInterpolatePathsNV = driverTbl.glInterpolatePathsNV;
   }
   driverTbl.glInterpolatePathsNV(resultPath, pathA, pathB, weight);
}

static GLboolean REGAL_CALL missing_glIsPathNV(GLuint path)
{
   UNUSED_PARAMETER(path);
   Warning( "Called missing function glIsPathNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsPathNV(GLuint path)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsPathNV, "glIsPathNV");
   if ( !driverTbl.glIsPathNV ) {
      driverTbl.glIsPathNV = missing_glIsPathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsPathNV == loader_glIsPathNV) {
      rCtx->dsp.emuTbl.glIsPathNV = driverTbl.glIsPathNV;
   }
   return driverTbl.glIsPathNV(path);
}

static GLboolean REGAL_CALL missing_glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(mask);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glIsPointInFillPathNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsPointInFillPathNV, "glIsPointInFillPathNV");
   if ( !driverTbl.glIsPointInFillPathNV ) {
      driverTbl.glIsPointInFillPathNV = missing_glIsPointInFillPathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsPointInFillPathNV == loader_glIsPointInFillPathNV) {
      rCtx->dsp.emuTbl.glIsPointInFillPathNV = driverTbl.glIsPointInFillPathNV;
   }
   return driverTbl.glIsPointInFillPathNV(path, mask, x, y);
}

static GLboolean REGAL_CALL missing_glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "Called missing function glIsPointInStrokePathNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsPointInStrokePathNV, "glIsPointInStrokePathNV");
   if ( !driverTbl.glIsPointInStrokePathNV ) {
      driverTbl.glIsPointInStrokePathNV = missing_glIsPointInStrokePathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsPointInStrokePathNV == loader_glIsPointInStrokePathNV) {
      rCtx->dsp.emuTbl.glIsPointInStrokePathNV = driverTbl.glIsPointInStrokePathNV;
   }
   return driverTbl.glIsPointInStrokePathNV(path, x, y);
}

static void REGAL_CALL missing_glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs)
{
   UNUSED_PARAMETER(color);
   UNUSED_PARAMETER(genMode);
   UNUSED_PARAMETER(colorFormat);
   UNUSED_PARAMETER(coeffs);
   Warning( "Called missing function glPathColorGenNV" );
}

static void REGAL_CALL loader_glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathColorGenNV, "glPathColorGenNV");
   if ( !driverTbl.glPathColorGenNV ) {
      driverTbl.glPathColorGenNV = missing_glPathColorGenNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathColorGenNV == loader_glPathColorGenNV) {
      rCtx->dsp.emuTbl.glPathColorGenNV = driverTbl.glPathColorGenNV;
   }
   driverTbl.glPathColorGenNV(color, genMode, colorFormat, coeffs);
}

static void REGAL_CALL missing_glPathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte*commands, GLsizei numCoords, GLenum coordType, const GLvoid*coords)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(numCommands);
   UNUSED_PARAMETER(commands);
   UNUSED_PARAMETER(numCoords);
   UNUSED_PARAMETER(coordType);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glPathCommandsNV" );
}

static void REGAL_CALL loader_glPathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte*commands, GLsizei numCoords, GLenum coordType, const GLvoid*coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathCommandsNV, "glPathCommandsNV");
   if ( !driverTbl.glPathCommandsNV ) {
      driverTbl.glPathCommandsNV = missing_glPathCommandsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathCommandsNV == loader_glPathCommandsNV) {
      rCtx->dsp.emuTbl.glPathCommandsNV = driverTbl.glPathCommandsNV;
   }
   driverTbl.glPathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);
}

static void REGAL_CALL missing_glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(numCoords);
   UNUSED_PARAMETER(coordType);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glPathCoordsNV" );
}

static void REGAL_CALL loader_glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathCoordsNV, "glPathCoordsNV");
   if ( !driverTbl.glPathCoordsNV ) {
      driverTbl.glPathCoordsNV = missing_glPathCoordsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathCoordsNV == loader_glPathCoordsNV) {
      rCtx->dsp.emuTbl.glPathCoordsNV = driverTbl.glPathCoordsNV;
   }
   driverTbl.glPathCoordsNV(path, numCoords, coordType, coords);
}

static void REGAL_CALL missing_glPathCoverDepthFuncNV(GLenum zfunc)
{
   UNUSED_PARAMETER(zfunc);
   Warning( "Called missing function glPathCoverDepthFuncNV" );
}

static void REGAL_CALL loader_glPathCoverDepthFuncNV(GLenum zfunc)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathCoverDepthFuncNV, "glPathCoverDepthFuncNV");
   if ( !driverTbl.glPathCoverDepthFuncNV ) {
      driverTbl.glPathCoverDepthFuncNV = missing_glPathCoverDepthFuncNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathCoverDepthFuncNV == loader_glPathCoverDepthFuncNV) {
      rCtx->dsp.emuTbl.glPathCoverDepthFuncNV = driverTbl.glPathCoverDepthFuncNV;
   }
   driverTbl.glPathCoverDepthFuncNV(zfunc);
}

static void REGAL_CALL missing_glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat *dashArray)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(dashCount);
   UNUSED_PARAMETER(dashArray);
   Warning( "Called missing function glPathDashArrayNV" );
}

static void REGAL_CALL loader_glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat *dashArray)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathDashArrayNV, "glPathDashArrayNV");
   if ( !driverTbl.glPathDashArrayNV ) {
      driverTbl.glPathDashArrayNV = missing_glPathDashArrayNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathDashArrayNV == loader_glPathDashArrayNV) {
      rCtx->dsp.emuTbl.glPathDashArrayNV = driverTbl.glPathDashArrayNV;
   }
   driverTbl.glPathDashArrayNV(path, dashCount, dashArray);
}

static void REGAL_CALL missing_glPathFogGenNV(GLenum genMode)
{
   UNUSED_PARAMETER(genMode);
   Warning( "Called missing function glPathFogGenNV" );
}

static void REGAL_CALL loader_glPathFogGenNV(GLenum genMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathFogGenNV, "glPathFogGenNV");
   if ( !driverTbl.glPathFogGenNV ) {
      driverTbl.glPathFogGenNV = missing_glPathFogGenNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathFogGenNV == loader_glPathFogGenNV) {
      rCtx->dsp.emuTbl.glPathFogGenNV = driverTbl.glPathFogGenNV;
   }
   driverTbl.glPathFogGenNV(genMode);
}

static void REGAL_CALL missing_glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
   UNUSED_PARAMETER(firstPathName);
   UNUSED_PARAMETER(fontTarget);
   UNUSED_PARAMETER(fontName);
   UNUSED_PARAMETER(fontStyle);
   UNUSED_PARAMETER(firstGlyph);
   UNUSED_PARAMETER(numGlyphs);
   UNUSED_PARAMETER(handleMissingGlyphs);
   UNUSED_PARAMETER(pathParameterTemplate);
   UNUSED_PARAMETER(emScale);
   Warning( "Called missing function glPathGlyphRangeNV" );
}

static void REGAL_CALL loader_glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathGlyphRangeNV, "glPathGlyphRangeNV");
   if ( !driverTbl.glPathGlyphRangeNV ) {
      driverTbl.glPathGlyphRangeNV = missing_glPathGlyphRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathGlyphRangeNV == loader_glPathGlyphRangeNV) {
      rCtx->dsp.emuTbl.glPathGlyphRangeNV = driverTbl.glPathGlyphRangeNV;
   }
   driverTbl.glPathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
}

static void REGAL_CALL missing_glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid*charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
   UNUSED_PARAMETER(firstPathName);
   UNUSED_PARAMETER(fontTarget);
   UNUSED_PARAMETER(fontName);
   UNUSED_PARAMETER(fontStyle);
   UNUSED_PARAMETER(numGlyphs);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(charcodes);
   UNUSED_PARAMETER(handleMissingGlyphs);
   UNUSED_PARAMETER(pathParameterTemplate);
   UNUSED_PARAMETER(emScale);
   Warning( "Called missing function glPathGlyphsNV" );
}

static void REGAL_CALL loader_glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid*charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathGlyphsNV, "glPathGlyphsNV");
   if ( !driverTbl.glPathGlyphsNV ) {
      driverTbl.glPathGlyphsNV = missing_glPathGlyphsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathGlyphsNV == loader_glPathGlyphsNV) {
      rCtx->dsp.emuTbl.glPathGlyphsNV = driverTbl.glPathGlyphsNV;
   }
   driverTbl.glPathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
}

static void REGAL_CALL missing_glPathParameterfNV(GLuint path, GLenum pname, GLfloat value)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glPathParameterfNV" );
}

static void REGAL_CALL loader_glPathParameterfNV(GLuint path, GLenum pname, GLfloat value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathParameterfNV, "glPathParameterfNV");
   if ( !driverTbl.glPathParameterfNV ) {
      driverTbl.glPathParameterfNV = missing_glPathParameterfNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathParameterfNV == loader_glPathParameterfNV) {
      rCtx->dsp.emuTbl.glPathParameterfNV = driverTbl.glPathParameterfNV;
   }
   driverTbl.glPathParameterfNV(path, pname, value);
}

static void REGAL_CALL missing_glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat *value)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glPathParameterfvNV" );
}

static void REGAL_CALL loader_glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathParameterfvNV, "glPathParameterfvNV");
   if ( !driverTbl.glPathParameterfvNV ) {
      driverTbl.glPathParameterfvNV = missing_glPathParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathParameterfvNV == loader_glPathParameterfvNV) {
      rCtx->dsp.emuTbl.glPathParameterfvNV = driverTbl.glPathParameterfvNV;
   }
   driverTbl.glPathParameterfvNV(path, pname, value);
}

static void REGAL_CALL missing_glPathParameteriNV(GLuint path, GLenum pname, GLint value)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glPathParameteriNV" );
}

static void REGAL_CALL loader_glPathParameteriNV(GLuint path, GLenum pname, GLint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathParameteriNV, "glPathParameteriNV");
   if ( !driverTbl.glPathParameteriNV ) {
      driverTbl.glPathParameteriNV = missing_glPathParameteriNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathParameteriNV == loader_glPathParameteriNV) {
      rCtx->dsp.emuTbl.glPathParameteriNV = driverTbl.glPathParameteriNV;
   }
   driverTbl.glPathParameteriNV(path, pname, value);
}

static void REGAL_CALL missing_glPathParameterivNV(GLuint path, GLenum pname, const GLint *value)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glPathParameterivNV" );
}

static void REGAL_CALL loader_glPathParameterivNV(GLuint path, GLenum pname, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathParameterivNV, "glPathParameterivNV");
   if ( !driverTbl.glPathParameterivNV ) {
      driverTbl.glPathParameterivNV = missing_glPathParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathParameterivNV == loader_glPathParameterivNV) {
      rCtx->dsp.emuTbl.glPathParameterivNV = driverTbl.glPathParameterivNV;
   }
   driverTbl.glPathParameterivNV(path, pname, value);
}

static void REGAL_CALL missing_glPathStencilDepthOffsetNV(GLfloat factor, GLint units)
{
   UNUSED_PARAMETER(factor);
   UNUSED_PARAMETER(units);
   Warning( "Called missing function glPathStencilDepthOffsetNV" );
}

static void REGAL_CALL loader_glPathStencilDepthOffsetNV(GLfloat factor, GLint units)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathStencilDepthOffsetNV, "glPathStencilDepthOffsetNV");
   if ( !driverTbl.glPathStencilDepthOffsetNV ) {
      driverTbl.glPathStencilDepthOffsetNV = missing_glPathStencilDepthOffsetNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathStencilDepthOffsetNV == loader_glPathStencilDepthOffsetNV) {
      rCtx->dsp.emuTbl.glPathStencilDepthOffsetNV = driverTbl.glPathStencilDepthOffsetNV;
   }
   driverTbl.glPathStencilDepthOffsetNV(factor, units);
}

static void REGAL_CALL missing_glPathStencilFuncNV(GLenum func, GLint ref, GLuint mask)
{
   UNUSED_PARAMETER(func);
   UNUSED_PARAMETER(ref);
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glPathStencilFuncNV" );
}

static void REGAL_CALL loader_glPathStencilFuncNV(GLenum func, GLint ref, GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathStencilFuncNV, "glPathStencilFuncNV");
   if ( !driverTbl.glPathStencilFuncNV ) {
      driverTbl.glPathStencilFuncNV = missing_glPathStencilFuncNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathStencilFuncNV == loader_glPathStencilFuncNV) {
      rCtx->dsp.emuTbl.glPathStencilFuncNV = driverTbl.glPathStencilFuncNV;
   }
   driverTbl.glPathStencilFuncNV(func, ref, mask);
}

static void REGAL_CALL missing_glPathStringNV(GLuint path, GLenum format, GLsizei length, const GLvoid *pathString)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(pathString);
   Warning( "Called missing function glPathStringNV" );
}

static void REGAL_CALL loader_glPathStringNV(GLuint path, GLenum format, GLsizei length, const GLvoid *pathString)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathStringNV, "glPathStringNV");
   if ( !driverTbl.glPathStringNV ) {
      driverTbl.glPathStringNV = missing_glPathStringNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathStringNV == loader_glPathStringNV) {
      rCtx->dsp.emuTbl.glPathStringNV = driverTbl.glPathStringNV;
   }
   driverTbl.glPathStringNV(path, format, length, pathString);
}

static void REGAL_CALL missing_glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte*commands, GLsizei numCoords, GLenum coordType, const GLvoid*coords)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(commandStart);
   UNUSED_PARAMETER(commandsToDelete);
   UNUSED_PARAMETER(numCommands);
   UNUSED_PARAMETER(commands);
   UNUSED_PARAMETER(numCoords);
   UNUSED_PARAMETER(coordType);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glPathSubCommandsNV" );
}

static void REGAL_CALL loader_glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte*commands, GLsizei numCoords, GLenum coordType, const GLvoid*coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathSubCommandsNV, "glPathSubCommandsNV");
   if ( !driverTbl.glPathSubCommandsNV ) {
      driverTbl.glPathSubCommandsNV = missing_glPathSubCommandsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathSubCommandsNV == loader_glPathSubCommandsNV) {
      rCtx->dsp.emuTbl.glPathSubCommandsNV = driverTbl.glPathSubCommandsNV;
   }
   driverTbl.glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
}

static void REGAL_CALL missing_glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(coordStart);
   UNUSED_PARAMETER(numCoords);
   UNUSED_PARAMETER(coordType);
   UNUSED_PARAMETER(coords);
   Warning( "Called missing function glPathSubCoordsNV" );
}

static void REGAL_CALL loader_glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathSubCoordsNV, "glPathSubCoordsNV");
   if ( !driverTbl.glPathSubCoordsNV ) {
      driverTbl.glPathSubCoordsNV = missing_glPathSubCoordsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathSubCoordsNV == loader_glPathSubCoordsNV) {
      rCtx->dsp.emuTbl.glPathSubCoordsNV = driverTbl.glPathSubCoordsNV;
   }
   driverTbl.glPathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
}

static void REGAL_CALL missing_glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs)
{
   UNUSED_PARAMETER(texCoordSet);
   UNUSED_PARAMETER(genMode);
   UNUSED_PARAMETER(components);
   UNUSED_PARAMETER(coeffs);
   Warning( "Called missing function glPathTexGenNV" );
}

static void REGAL_CALL loader_glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPathTexGenNV, "glPathTexGenNV");
   if ( !driverTbl.glPathTexGenNV ) {
      driverTbl.glPathTexGenNV = missing_glPathTexGenNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPathTexGenNV == loader_glPathTexGenNV) {
      rCtx->dsp.emuTbl.glPathTexGenNV = driverTbl.glPathTexGenNV;
   }
   driverTbl.glPathTexGenNV(texCoordSet, genMode, components, coeffs);
}

static GLboolean REGAL_CALL missing_glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat*x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(startSegment);
   UNUSED_PARAMETER(numSegments);
   UNUSED_PARAMETER(distance);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(tangentX);
   UNUSED_PARAMETER(tangentY);
   Warning( "Called missing function glPointAlongPathNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat*x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPointAlongPathNV, "glPointAlongPathNV");
   if ( !driverTbl.glPointAlongPathNV ) {
      driverTbl.glPointAlongPathNV = missing_glPointAlongPathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPointAlongPathNV == loader_glPointAlongPathNV) {
      rCtx->dsp.emuTbl.glPointAlongPathNV = driverTbl.glPointAlongPathNV;
   }
   return driverTbl.glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
}

static void REGAL_CALL missing_glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues)
{
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(pathNameType);
   UNUSED_PARAMETER(paths);
   UNUSED_PARAMETER(pathBase);
   UNUSED_PARAMETER(fillMode);
   UNUSED_PARAMETER(mask);
   UNUSED_PARAMETER(transformType);
   UNUSED_PARAMETER(transformValues);
   Warning( "Called missing function glStencilFillPathInstancedNV" );
}

static void REGAL_CALL loader_glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStencilFillPathInstancedNV, "glStencilFillPathInstancedNV");
   if ( !driverTbl.glStencilFillPathInstancedNV ) {
      driverTbl.glStencilFillPathInstancedNV = missing_glStencilFillPathInstancedNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStencilFillPathInstancedNV == loader_glStencilFillPathInstancedNV) {
      rCtx->dsp.emuTbl.glStencilFillPathInstancedNV = driverTbl.glStencilFillPathInstancedNV;
   }
   driverTbl.glStencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
}

static void REGAL_CALL missing_glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(fillMode);
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glStencilFillPathNV" );
}

static void REGAL_CALL loader_glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStencilFillPathNV, "glStencilFillPathNV");
   if ( !driverTbl.glStencilFillPathNV ) {
      driverTbl.glStencilFillPathNV = missing_glStencilFillPathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStencilFillPathNV == loader_glStencilFillPathNV) {
      rCtx->dsp.emuTbl.glStencilFillPathNV = driverTbl.glStencilFillPathNV;
   }
   driverTbl.glStencilFillPathNV(path, fillMode, mask);
}

static void REGAL_CALL missing_glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues)
{
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(pathNameType);
   UNUSED_PARAMETER(paths);
   UNUSED_PARAMETER(pathBase);
   UNUSED_PARAMETER(reference);
   UNUSED_PARAMETER(mask);
   UNUSED_PARAMETER(transformType);
   UNUSED_PARAMETER(transformValues);
   Warning( "Called missing function glStencilStrokePathInstancedNV" );
}

static void REGAL_CALL loader_glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStencilStrokePathInstancedNV, "glStencilStrokePathInstancedNV");
   if ( !driverTbl.glStencilStrokePathInstancedNV ) {
      driverTbl.glStencilStrokePathInstancedNV = missing_glStencilStrokePathInstancedNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStencilStrokePathInstancedNV == loader_glStencilStrokePathInstancedNV) {
      rCtx->dsp.emuTbl.glStencilStrokePathInstancedNV = driverTbl.glStencilStrokePathInstancedNV;
   }
   driverTbl.glStencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
}

static void REGAL_CALL missing_glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(reference);
   UNUSED_PARAMETER(mask);
   Warning( "Called missing function glStencilStrokePathNV" );
}

static void REGAL_CALL loader_glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStencilStrokePathNV, "glStencilStrokePathNV");
   if ( !driverTbl.glStencilStrokePathNV ) {
      driverTbl.glStencilStrokePathNV = missing_glStencilStrokePathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStencilStrokePathNV == loader_glStencilStrokePathNV) {
      rCtx->dsp.emuTbl.glStencilStrokePathNV = driverTbl.glStencilStrokePathNV;
   }
   driverTbl.glStencilStrokePathNV(path, reference, mask);
}

static void REGAL_CALL missing_glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues)
{
   UNUSED_PARAMETER(resultPath);
   UNUSED_PARAMETER(srcPath);
   UNUSED_PARAMETER(transformType);
   UNUSED_PARAMETER(transformValues);
   Warning( "Called missing function glTransformPathNV" );
}

static void REGAL_CALL loader_glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTransformPathNV, "glTransformPathNV");
   if ( !driverTbl.glTransformPathNV ) {
      driverTbl.glTransformPathNV = missing_glTransformPathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTransformPathNV == loader_glTransformPathNV) {
      rCtx->dsp.emuTbl.glTransformPathNV = driverTbl.glTransformPathNV;
   }
   driverTbl.glTransformPathNV(resultPath, srcPath, transformType, transformValues);
}

static void REGAL_CALL missing_glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights)
{
   UNUSED_PARAMETER(resultPath);
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(paths);
   UNUSED_PARAMETER(weights);
   Warning( "Called missing function glWeightPathsNV" );
}

static void REGAL_CALL loader_glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glWeightPathsNV, "glWeightPathsNV");
   if ( !driverTbl.glWeightPathsNV ) {
      driverTbl.glWeightPathsNV = missing_glWeightPathsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glWeightPathsNV == loader_glWeightPathsNV) {
      rCtx->dsp.emuTbl.glWeightPathsNV = driverTbl.glWeightPathsNV;
   }
   driverTbl.glWeightPathsNV(resultPath, numPaths, paths, weights);
}

// GL_REGAL_extension_query

static GLboolean REGAL_CALL missing_glGetExtensionREGAL(const GLchar *ext)
{
   UNUSED_PARAMETER(ext);
   Warning( "Called missing function glGetExtensionREGAL" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glGetExtensionREGAL(const GLchar *ext)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetExtensionREGAL, "glGetExtensionREGAL");
   if ( !driverTbl.glGetExtensionREGAL ) {
      driverTbl.glGetExtensionREGAL = missing_glGetExtensionREGAL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetExtensionREGAL == loader_glGetExtensionREGAL) {
      rCtx->dsp.emuTbl.glGetExtensionREGAL = driverTbl.glGetExtensionREGAL;
   }
   return driverTbl.glGetExtensionREGAL(ext);
}

static GLboolean REGAL_CALL missing_glIsSupportedREGAL(const GLchar *ext)
{
   UNUSED_PARAMETER(ext);
   Warning( "Called missing function glIsSupportedREGAL" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsSupportedREGAL(const GLchar *ext)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsSupportedREGAL, "glIsSupportedREGAL");
   if ( !driverTbl.glIsSupportedREGAL ) {
      driverTbl.glIsSupportedREGAL = missing_glIsSupportedREGAL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsSupportedREGAL == loader_glIsSupportedREGAL) {
      rCtx->dsp.emuTbl.glIsSupportedREGAL = driverTbl.glIsSupportedREGAL;
   }
   return driverTbl.glIsSupportedREGAL(ext);
}

// GL_AMD_debug_output

static GLuint REGAL_CALL missing_glGetDebugMessageLogAMD(GLuint count, GLsizei bufsize, GLenum *categories, GLuint *severities, GLuint *ids, GLsizei *lengths, GLchar *message)
{
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(bufsize);
   UNUSED_PARAMETER(categories);
   UNUSED_PARAMETER(severities);
   UNUSED_PARAMETER(ids);
   UNUSED_PARAMETER(lengths);
   UNUSED_PARAMETER(message);
   Warning( "Called missing function glGetDebugMessageLogAMD" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGetDebugMessageLogAMD(GLuint count, GLsizei bufsize, GLenum *categories, GLuint *severities, GLuint *ids, GLsizei *lengths, GLchar *message)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetDebugMessageLogAMD, "glGetDebugMessageLogAMD");
   if ( !driverTbl.glGetDebugMessageLogAMD ) {
      driverTbl.glGetDebugMessageLogAMD = missing_glGetDebugMessageLogAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetDebugMessageLogAMD == loader_glGetDebugMessageLogAMD) {
      rCtx->dsp.emuTbl.glGetDebugMessageLogAMD = driverTbl.glGetDebugMessageLogAMD;
   }
   return driverTbl.glGetDebugMessageLogAMD(count, bufsize, categories, severities, ids, lengths, message);
}

static void REGAL_CALL missing_glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, GLvoid *userParam)
{
   UNUSED_PARAMETER(callback);
   UNUSED_PARAMETER(userParam);
   Warning( "Called missing function glDebugMessageCallbackAMD" );
}

static void REGAL_CALL loader_glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, GLvoid *userParam)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDebugMessageCallbackAMD, "glDebugMessageCallbackAMD");
   if ( !driverTbl.glDebugMessageCallbackAMD ) {
      driverTbl.glDebugMessageCallbackAMD = missing_glDebugMessageCallbackAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDebugMessageCallbackAMD == loader_glDebugMessageCallbackAMD) {
      rCtx->dsp.emuTbl.glDebugMessageCallbackAMD = driverTbl.glDebugMessageCallbackAMD;
   }
   driverTbl.glDebugMessageCallbackAMD(callback, userParam);
}

static void REGAL_CALL missing_glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
   UNUSED_PARAMETER(category);
   UNUSED_PARAMETER(severity);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(ids);
   UNUSED_PARAMETER(enabled);
   Warning( "Called missing function glDebugMessageEnableAMD" );
}

static void REGAL_CALL loader_glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDebugMessageEnableAMD, "glDebugMessageEnableAMD");
   if ( !driverTbl.glDebugMessageEnableAMD ) {
      driverTbl.glDebugMessageEnableAMD = missing_glDebugMessageEnableAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDebugMessageEnableAMD == loader_glDebugMessageEnableAMD) {
      rCtx->dsp.emuTbl.glDebugMessageEnableAMD = driverTbl.glDebugMessageEnableAMD;
   }
   driverTbl.glDebugMessageEnableAMD(category, severity, count, ids, enabled);
}

static void REGAL_CALL missing_glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf)
{
   UNUSED_PARAMETER(category);
   UNUSED_PARAMETER(severity);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(buf);
   Warning( "Called missing function glDebugMessageInsertAMD" );
}

static void REGAL_CALL loader_glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDebugMessageInsertAMD, "glDebugMessageInsertAMD");
   if ( !driverTbl.glDebugMessageInsertAMD ) {
      driverTbl.glDebugMessageInsertAMD = missing_glDebugMessageInsertAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDebugMessageInsertAMD == loader_glDebugMessageInsertAMD) {
      rCtx->dsp.emuTbl.glDebugMessageInsertAMD = driverTbl.glDebugMessageInsertAMD;
   }
   driverTbl.glDebugMessageInsertAMD(category, severity, id, length, buf);
}

// GL_AMD_multi_draw_indirect

static void REGAL_CALL missing_glMultiDrawArraysIndirectAMD(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(indirect);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(stride);
   Warning( "Called missing function glMultiDrawArraysIndirectAMD" );
}

static void REGAL_CALL loader_glMultiDrawArraysIndirectAMD(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiDrawArraysIndirectAMD, "glMultiDrawArraysIndirectAMD");
   if ( !driverTbl.glMultiDrawArraysIndirectAMD ) {
      driverTbl.glMultiDrawArraysIndirectAMD = missing_glMultiDrawArraysIndirectAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiDrawArraysIndirectAMD == loader_glMultiDrawArraysIndirectAMD) {
      rCtx->dsp.emuTbl.glMultiDrawArraysIndirectAMD = driverTbl.glMultiDrawArraysIndirectAMD;
   }
   driverTbl.glMultiDrawArraysIndirectAMD(mode, indirect, primcount, stride);
}

static void REGAL_CALL missing_glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indirect);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(stride);
   Warning( "Called missing function glMultiDrawElementsIndirectAMD" );
}

static void REGAL_CALL loader_glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMultiDrawElementsIndirectAMD, "glMultiDrawElementsIndirectAMD");
   if ( !driverTbl.glMultiDrawElementsIndirectAMD ) {
      driverTbl.glMultiDrawElementsIndirectAMD = missing_glMultiDrawElementsIndirectAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMultiDrawElementsIndirectAMD == loader_glMultiDrawElementsIndirectAMD) {
      rCtx->dsp.emuTbl.glMultiDrawElementsIndirectAMD = driverTbl.glMultiDrawElementsIndirectAMD;
   }
   driverTbl.glMultiDrawElementsIndirectAMD(mode, type, indirect, primcount, stride);
}

// GL_AMD_name_gen_delete

static GLboolean REGAL_CALL missing_glIsNameAMD(GLenum identifier, GLuint name)
{
   UNUSED_PARAMETER(identifier);
   UNUSED_PARAMETER(name);
   Warning( "Called missing function glIsNameAMD" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsNameAMD(GLenum identifier, GLuint name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsNameAMD, "glIsNameAMD");
   if ( !driverTbl.glIsNameAMD ) {
      driverTbl.glIsNameAMD = missing_glIsNameAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsNameAMD == loader_glIsNameAMD) {
      rCtx->dsp.emuTbl.glIsNameAMD = driverTbl.glIsNameAMD;
   }
   return driverTbl.glIsNameAMD(identifier, name);
}

static void REGAL_CALL missing_glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint *names)
{
   UNUSED_PARAMETER(identifier);
   UNUSED_PARAMETER(num);
   UNUSED_PARAMETER(names);
   Warning( "Called missing function glDeleteNamesAMD" );
}

static void REGAL_CALL loader_glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint *names)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteNamesAMD, "glDeleteNamesAMD");
   if ( !driverTbl.glDeleteNamesAMD ) {
      driverTbl.glDeleteNamesAMD = missing_glDeleteNamesAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteNamesAMD == loader_glDeleteNamesAMD) {
      rCtx->dsp.emuTbl.glDeleteNamesAMD = driverTbl.glDeleteNamesAMD;
   }
   driverTbl.glDeleteNamesAMD(identifier, num, names);
}

static void REGAL_CALL missing_glGenNamesAMD(GLenum identifier, GLuint num, GLuint *names)
{
   UNUSED_PARAMETER(identifier);
   UNUSED_PARAMETER(num);
   UNUSED_PARAMETER(names);
   Warning( "Called missing function glGenNamesAMD" );
}

static void REGAL_CALL loader_glGenNamesAMD(GLenum identifier, GLuint num, GLuint *names)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGenNamesAMD, "glGenNamesAMD");
   if ( !driverTbl.glGenNamesAMD ) {
      driverTbl.glGenNamesAMD = missing_glGenNamesAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGenNamesAMD == loader_glGenNamesAMD) {
      rCtx->dsp.emuTbl.glGenNamesAMD = driverTbl.glGenNamesAMD;
   }
   driverTbl.glGenNamesAMD(identifier, num, names);
}

// GL_AMD_sample_positions

static void REGAL_CALL missing_glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat *val)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(val);
   Warning( "Called missing function glSetMultisamplefvAMD" );
}

static void REGAL_CALL loader_glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat *val)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSetMultisamplefvAMD, "glSetMultisamplefvAMD");
   if ( !driverTbl.glSetMultisamplefvAMD ) {
      driverTbl.glSetMultisamplefvAMD = missing_glSetMultisamplefvAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSetMultisamplefvAMD == loader_glSetMultisamplefvAMD) {
      rCtx->dsp.emuTbl.glSetMultisamplefvAMD = driverTbl.glSetMultisamplefvAMD;
   }
   driverTbl.glSetMultisamplefvAMD(pname, index, val);
}

// GL_AMD_stencil_operation_extended

static void REGAL_CALL missing_glStencilOpValueAMD(GLenum face, GLuint value)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glStencilOpValueAMD" );
}

static void REGAL_CALL loader_glStencilOpValueAMD(GLenum face, GLuint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glStencilOpValueAMD, "glStencilOpValueAMD");
   if ( !driverTbl.glStencilOpValueAMD ) {
      driverTbl.glStencilOpValueAMD = missing_glStencilOpValueAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glStencilOpValueAMD == loader_glStencilOpValueAMD) {
      rCtx->dsp.emuTbl.glStencilOpValueAMD = driverTbl.glStencilOpValueAMD;
   }
   driverTbl.glStencilOpValueAMD(face, value);
}

// GL_ARB_base_instance

static void REGAL_CALL missing_glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(baseinstance);
   Warning( "Called missing function glDrawArraysInstancedBaseInstance" );
}

static void REGAL_CALL loader_glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawArraysInstancedBaseInstance, "glDrawArraysInstancedBaseInstance");
   if ( !driverTbl.glDrawArraysInstancedBaseInstance ) {
      driverTbl.glDrawArraysInstancedBaseInstance = missing_glDrawArraysInstancedBaseInstance;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawArraysInstancedBaseInstance == loader_glDrawArraysInstancedBaseInstance) {
      rCtx->dsp.emuTbl.glDrawArraysInstancedBaseInstance = driverTbl.glDrawArraysInstancedBaseInstance;
   }
   driverTbl.glDrawArraysInstancedBaseInstance(mode, first, count, primcount, baseinstance);
}

static void REGAL_CALL missing_glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLuint baseinstance)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(baseinstance);
   Warning( "Called missing function glDrawElementsInstancedBaseInstance" );
}

static void REGAL_CALL loader_glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLuint baseinstance)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawElementsInstancedBaseInstance, "glDrawElementsInstancedBaseInstance");
   if ( !driverTbl.glDrawElementsInstancedBaseInstance ) {
      driverTbl.glDrawElementsInstancedBaseInstance = missing_glDrawElementsInstancedBaseInstance;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawElementsInstancedBaseInstance == loader_glDrawElementsInstancedBaseInstance) {
      rCtx->dsp.emuTbl.glDrawElementsInstancedBaseInstance = driverTbl.glDrawElementsInstancedBaseInstance;
   }
   driverTbl.glDrawElementsInstancedBaseInstance(mode, count, type, indices, primcount, baseinstance);
}

static void REGAL_CALL missing_glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(basevertex);
   UNUSED_PARAMETER(baseinstance);
   Warning( "Called missing function glDrawElementsInstancedBaseVertexBaseInstance" );
}

static void REGAL_CALL loader_glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawElementsInstancedBaseVertexBaseInstance, "glDrawElementsInstancedBaseVertexBaseInstance");
   if ( !driverTbl.glDrawElementsInstancedBaseVertexBaseInstance ) {
      driverTbl.glDrawElementsInstancedBaseVertexBaseInstance = missing_glDrawElementsInstancedBaseVertexBaseInstance;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawElementsInstancedBaseVertexBaseInstance == loader_glDrawElementsInstancedBaseVertexBaseInstance) {
      rCtx->dsp.emuTbl.glDrawElementsInstancedBaseVertexBaseInstance = driverTbl.glDrawElementsInstancedBaseVertexBaseInstance;
   }
   driverTbl.glDrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, primcount, basevertex, baseinstance);
}

// GL_ARB_cl_event

static GLsync REGAL_CALL missing_glCreateSyncFromCLeventARB(cl_context context, cl_event event, GLbitfield flags)
{
   UNUSED_PARAMETER(context);
   UNUSED_PARAMETER(event);
   UNUSED_PARAMETER(flags);
   Warning( "Called missing function glCreateSyncFromCLeventARB" );
  GLsync  ret = (GLsync )0;
  return ret;
}

static GLsync REGAL_CALL loader_glCreateSyncFromCLeventARB(cl_context context, cl_event event, GLbitfield flags)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glCreateSyncFromCLeventARB, "glCreateSyncFromCLeventARB");
   if ( !driverTbl.glCreateSyncFromCLeventARB ) {
      driverTbl.glCreateSyncFromCLeventARB = missing_glCreateSyncFromCLeventARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glCreateSyncFromCLeventARB == loader_glCreateSyncFromCLeventARB) {
      rCtx->dsp.emuTbl.glCreateSyncFromCLeventARB = driverTbl.glCreateSyncFromCLeventARB;
   }
   return driverTbl.glCreateSyncFromCLeventARB(context, event, flags);
}

// GL_ARB_internalformat_query

static void REGAL_CALL missing_glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetInternalformativ" );
}

static void REGAL_CALL loader_glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetInternalformativ, "glGetInternalformativ");
   if ( !driverTbl.glGetInternalformativ ) {
      driverTbl.glGetInternalformativ = missing_glGetInternalformativ;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetInternalformativ == loader_glGetInternalformativ) {
      rCtx->dsp.emuTbl.glGetInternalformativ = driverTbl.glGetInternalformativ;
   }
   driverTbl.glGetInternalformativ(target, internalformat, pname, bufSize, params);
}

// GL_ARB_texture_storage

static void REGAL_CALL missing_glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(levels);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   Warning( "Called missing function glTexStorage1D" );
}

static void REGAL_CALL loader_glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexStorage1D, "glTexStorage1D");
   if ( !driverTbl.glTexStorage1D ) {
      driverTbl.glTexStorage1D = missing_glTexStorage1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexStorage1D == loader_glTexStorage1D) {
      rCtx->dsp.emuTbl.glTexStorage1D = driverTbl.glTexStorage1D;
   }
   driverTbl.glTexStorage1D(target, levels, internalformat, width);
}

static void REGAL_CALL missing_glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(levels);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glTexStorage2D" );
}

static void REGAL_CALL loader_glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexStorage2D, "glTexStorage2D");
   if ( !driverTbl.glTexStorage2D ) {
      driverTbl.glTexStorage2D = missing_glTexStorage2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexStorage2D == loader_glTexStorage2D) {
      rCtx->dsp.emuTbl.glTexStorage2D = driverTbl.glTexStorage2D;
   }
   driverTbl.glTexStorage2D(target, levels, internalformat, width, height);
}

static void REGAL_CALL missing_glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(levels);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   Warning( "Called missing function glTexStorage3D" );
}

static void REGAL_CALL loader_glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexStorage3D, "glTexStorage3D");
   if ( !driverTbl.glTexStorage3D ) {
      driverTbl.glTexStorage3D = missing_glTexStorage3D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexStorage3D == loader_glTexStorage3D) {
      rCtx->dsp.emuTbl.glTexStorage3D = driverTbl.glTexStorage3D;
   }
   driverTbl.glTexStorage3D(target, levels, internalformat, width, height, depth);
}

static void REGAL_CALL missing_glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(levels);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   Warning( "Called missing function glTextureStorage1DEXT" );
}

static void REGAL_CALL loader_glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureStorage1DEXT, "glTextureStorage1DEXT");
   if ( !driverTbl.glTextureStorage1DEXT ) {
      driverTbl.glTextureStorage1DEXT = missing_glTextureStorage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureStorage1DEXT == loader_glTextureStorage1DEXT) {
      rCtx->dsp.emuTbl.glTextureStorage1DEXT = driverTbl.glTextureStorage1DEXT;
   }
   driverTbl.glTextureStorage1DEXT(texture, target, levels, internalformat, width);
}

static void REGAL_CALL missing_glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(levels);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glTextureStorage2DEXT" );
}

static void REGAL_CALL loader_glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureStorage2DEXT, "glTextureStorage2DEXT");
   if ( !driverTbl.glTextureStorage2DEXT ) {
      driverTbl.glTextureStorage2DEXT = missing_glTextureStorage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureStorage2DEXT == loader_glTextureStorage2DEXT) {
      rCtx->dsp.emuTbl.glTextureStorage2DEXT = driverTbl.glTextureStorage2DEXT;
   }
   driverTbl.glTextureStorage2DEXT(texture, target, levels, internalformat, width, height);
}

static void REGAL_CALL missing_glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(levels);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   Warning( "Called missing function glTextureStorage3DEXT" );
}

static void REGAL_CALL loader_glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureStorage3DEXT, "glTextureStorage3DEXT");
   if ( !driverTbl.glTextureStorage3DEXT ) {
      driverTbl.glTextureStorage3DEXT = missing_glTextureStorage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureStorage3DEXT == loader_glTextureStorage3DEXT) {
      rCtx->dsp.emuTbl.glTextureStorage3DEXT = driverTbl.glTextureStorage3DEXT;
   }
   driverTbl.glTextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);
}

// GL_ARB_transform_feedback_instanced

static void REGAL_CALL missing_glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(primcount);
   Warning( "Called missing function glDrawTransformFeedbackInstanced" );
}

static void REGAL_CALL loader_glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawTransformFeedbackInstanced, "glDrawTransformFeedbackInstanced");
   if ( !driverTbl.glDrawTransformFeedbackInstanced ) {
      driverTbl.glDrawTransformFeedbackInstanced = missing_glDrawTransformFeedbackInstanced;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawTransformFeedbackInstanced == loader_glDrawTransformFeedbackInstanced) {
      rCtx->dsp.emuTbl.glDrawTransformFeedbackInstanced = driverTbl.glDrawTransformFeedbackInstanced;
   }
   driverTbl.glDrawTransformFeedbackInstanced(mode, id, primcount);
}

static void REGAL_CALL missing_glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(primcount);
   Warning( "Called missing function glDrawTransformFeedbackStreamInstanced" );
}

static void REGAL_CALL loader_glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawTransformFeedbackStreamInstanced, "glDrawTransformFeedbackStreamInstanced");
   if ( !driverTbl.glDrawTransformFeedbackStreamInstanced ) {
      driverTbl.glDrawTransformFeedbackStreamInstanced = missing_glDrawTransformFeedbackStreamInstanced;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawTransformFeedbackStreamInstanced == loader_glDrawTransformFeedbackStreamInstanced) {
      rCtx->dsp.emuTbl.glDrawTransformFeedbackStreamInstanced = driverTbl.glDrawTransformFeedbackStreamInstanced;
   }
   driverTbl.glDrawTransformFeedbackStreamInstanced(mode, id, stream, primcount);
}

// GL_EXT_x11_sync_object

static GLsync REGAL_CALL missing_glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags)
{
   UNUSED_PARAMETER(external_sync_type);
   UNUSED_PARAMETER(external_sync);
   UNUSED_PARAMETER(flags);
   Warning( "Called missing function glImportSyncEXT" );
  GLsync  ret = (GLsync )0;
  return ret;
}

static GLsync REGAL_CALL loader_glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glImportSyncEXT, "glImportSyncEXT");
   if ( !driverTbl.glImportSyncEXT ) {
      driverTbl.glImportSyncEXT = missing_glImportSyncEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glImportSyncEXT == loader_glImportSyncEXT) {
      rCtx->dsp.emuTbl.glImportSyncEXT = driverTbl.glImportSyncEXT;
   }
   return driverTbl.glImportSyncEXT(external_sync_type, external_sync, flags);
}

// GL_INTEL_texture_scissor

static void REGAL_CALL missing_glTexScissorFuncINTEL(GLenum target, GLenum lfunc, GLenum hfunc)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(lfunc);
   UNUSED_PARAMETER(hfunc);
   Warning( "Called missing function glTexScissorFuncINTEL" );
}

static void REGAL_CALL loader_glTexScissorFuncINTEL(GLenum target, GLenum lfunc, GLenum hfunc)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexScissorFuncINTEL, "glTexScissorFuncINTEL");
   if ( !driverTbl.glTexScissorFuncINTEL ) {
      driverTbl.glTexScissorFuncINTEL = missing_glTexScissorFuncINTEL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexScissorFuncINTEL == loader_glTexScissorFuncINTEL) {
      rCtx->dsp.emuTbl.glTexScissorFuncINTEL = driverTbl.glTexScissorFuncINTEL;
   }
   driverTbl.glTexScissorFuncINTEL(target, lfunc, hfunc);
}

static void REGAL_CALL missing_glTexScissorINTEL(GLenum target, GLclampf tlow, GLclampf thigh)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(tlow);
   UNUSED_PARAMETER(thigh);
   Warning( "Called missing function glTexScissorINTEL" );
}

static void REGAL_CALL loader_glTexScissorINTEL(GLenum target, GLclampf tlow, GLclampf thigh)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexScissorINTEL, "glTexScissorINTEL");
   if ( !driverTbl.glTexScissorINTEL ) {
      driverTbl.glTexScissorINTEL = missing_glTexScissorINTEL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexScissorINTEL == loader_glTexScissorINTEL) {
      rCtx->dsp.emuTbl.glTexScissorINTEL = driverTbl.glTexScissorINTEL;
   }
   driverTbl.glTexScissorINTEL(target, tlow, thigh);
}

// GL_NV_bindless_texture

static GLboolean REGAL_CALL missing_glIsImageHandleResidentNV(GLuint64 handle)
{
   UNUSED_PARAMETER(handle);
   Warning( "Called missing function glIsImageHandleResidentNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsImageHandleResidentNV(GLuint64 handle)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsImageHandleResidentNV, "glIsImageHandleResidentNV");
   if ( !driverTbl.glIsImageHandleResidentNV ) {
      driverTbl.glIsImageHandleResidentNV = missing_glIsImageHandleResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsImageHandleResidentNV == loader_glIsImageHandleResidentNV) {
      rCtx->dsp.emuTbl.glIsImageHandleResidentNV = driverTbl.glIsImageHandleResidentNV;
   }
   return driverTbl.glIsImageHandleResidentNV(handle);
}

static GLboolean REGAL_CALL missing_glIsTextureHandleResidentNV(GLuint64 handle)
{
   UNUSED_PARAMETER(handle);
   Warning( "Called missing function glIsTextureHandleResidentNV" );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsTextureHandleResidentNV(GLuint64 handle)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glIsTextureHandleResidentNV, "glIsTextureHandleResidentNV");
   if ( !driverTbl.glIsTextureHandleResidentNV ) {
      driverTbl.glIsTextureHandleResidentNV = missing_glIsTextureHandleResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glIsTextureHandleResidentNV == loader_glIsTextureHandleResidentNV) {
      rCtx->dsp.emuTbl.glIsTextureHandleResidentNV = driverTbl.glIsTextureHandleResidentNV;
   }
   return driverTbl.glIsTextureHandleResidentNV(handle);
}

static GLuint64 REGAL_CALL missing_glGetImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layered);
   UNUSED_PARAMETER(layer);
   UNUSED_PARAMETER(format);
   Warning( "Called missing function glGetImageHandleNV" );
  GLuint64  ret = (GLuint64 )0;
  return ret;
}

static GLuint64 REGAL_CALL loader_glGetImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetImageHandleNV, "glGetImageHandleNV");
   if ( !driverTbl.glGetImageHandleNV ) {
      driverTbl.glGetImageHandleNV = missing_glGetImageHandleNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetImageHandleNV == loader_glGetImageHandleNV) {
      rCtx->dsp.emuTbl.glGetImageHandleNV = driverTbl.glGetImageHandleNV;
   }
   return driverTbl.glGetImageHandleNV(texture, level, layered, layer, format);
}

static GLuint64 REGAL_CALL missing_glGetTextureHandleNV(GLuint texture)
{
   UNUSED_PARAMETER(texture);
   Warning( "Called missing function glGetTextureHandleNV" );
  GLuint64  ret = (GLuint64 )0;
  return ret;
}

static GLuint64 REGAL_CALL loader_glGetTextureHandleNV(GLuint texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTextureHandleNV, "glGetTextureHandleNV");
   if ( !driverTbl.glGetTextureHandleNV ) {
      driverTbl.glGetTextureHandleNV = missing_glGetTextureHandleNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTextureHandleNV == loader_glGetTextureHandleNV) {
      rCtx->dsp.emuTbl.glGetTextureHandleNV = driverTbl.glGetTextureHandleNV;
   }
   return driverTbl.glGetTextureHandleNV(texture);
}

static GLuint64 REGAL_CALL missing_glGetTextureSamplerHandleNV(GLuint texture, GLuint sampler)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(sampler);
   Warning( "Called missing function glGetTextureSamplerHandleNV" );
  GLuint64  ret = (GLuint64 )0;
  return ret;
}

static GLuint64 REGAL_CALL loader_glGetTextureSamplerHandleNV(GLuint texture, GLuint sampler)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetTextureSamplerHandleNV, "glGetTextureSamplerHandleNV");
   if ( !driverTbl.glGetTextureSamplerHandleNV ) {
      driverTbl.glGetTextureSamplerHandleNV = missing_glGetTextureSamplerHandleNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetTextureSamplerHandleNV == loader_glGetTextureSamplerHandleNV) {
      rCtx->dsp.emuTbl.glGetTextureSamplerHandleNV = driverTbl.glGetTextureSamplerHandleNV;
   }
   return driverTbl.glGetTextureSamplerHandleNV(texture, sampler);
}

static void REGAL_CALL missing_glMakeImageHandleNonResidentNV(GLuint64 handle)
{
   UNUSED_PARAMETER(handle);
   Warning( "Called missing function glMakeImageHandleNonResidentNV" );
}

static void REGAL_CALL loader_glMakeImageHandleNonResidentNV(GLuint64 handle)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMakeImageHandleNonResidentNV, "glMakeImageHandleNonResidentNV");
   if ( !driverTbl.glMakeImageHandleNonResidentNV ) {
      driverTbl.glMakeImageHandleNonResidentNV = missing_glMakeImageHandleNonResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMakeImageHandleNonResidentNV == loader_glMakeImageHandleNonResidentNV) {
      rCtx->dsp.emuTbl.glMakeImageHandleNonResidentNV = driverTbl.glMakeImageHandleNonResidentNV;
   }
   driverTbl.glMakeImageHandleNonResidentNV(handle);
}

static void REGAL_CALL missing_glMakeImageHandleResidentNV(GLuint64 handle, GLenum access)
{
   UNUSED_PARAMETER(handle);
   UNUSED_PARAMETER(access);
   Warning( "Called missing function glMakeImageHandleResidentNV" );
}

static void REGAL_CALL loader_glMakeImageHandleResidentNV(GLuint64 handle, GLenum access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMakeImageHandleResidentNV, "glMakeImageHandleResidentNV");
   if ( !driverTbl.glMakeImageHandleResidentNV ) {
      driverTbl.glMakeImageHandleResidentNV = missing_glMakeImageHandleResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMakeImageHandleResidentNV == loader_glMakeImageHandleResidentNV) {
      rCtx->dsp.emuTbl.glMakeImageHandleResidentNV = driverTbl.glMakeImageHandleResidentNV;
   }
   driverTbl.glMakeImageHandleResidentNV(handle, access);
}

static void REGAL_CALL missing_glMakeTextureHandleNonResidentNV(GLuint64 handle)
{
   UNUSED_PARAMETER(handle);
   Warning( "Called missing function glMakeTextureHandleNonResidentNV" );
}

static void REGAL_CALL loader_glMakeTextureHandleNonResidentNV(GLuint64 handle)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMakeTextureHandleNonResidentNV, "glMakeTextureHandleNonResidentNV");
   if ( !driverTbl.glMakeTextureHandleNonResidentNV ) {
      driverTbl.glMakeTextureHandleNonResidentNV = missing_glMakeTextureHandleNonResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMakeTextureHandleNonResidentNV == loader_glMakeTextureHandleNonResidentNV) {
      rCtx->dsp.emuTbl.glMakeTextureHandleNonResidentNV = driverTbl.glMakeTextureHandleNonResidentNV;
   }
   driverTbl.glMakeTextureHandleNonResidentNV(handle);
}

static void REGAL_CALL missing_glMakeTextureHandleResidentNV(GLuint64 handle)
{
   UNUSED_PARAMETER(handle);
   Warning( "Called missing function glMakeTextureHandleResidentNV" );
}

static void REGAL_CALL loader_glMakeTextureHandleResidentNV(GLuint64 handle)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glMakeTextureHandleResidentNV, "glMakeTextureHandleResidentNV");
   if ( !driverTbl.glMakeTextureHandleResidentNV ) {
      driverTbl.glMakeTextureHandleResidentNV = missing_glMakeTextureHandleResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glMakeTextureHandleResidentNV == loader_glMakeTextureHandleResidentNV) {
      rCtx->dsp.emuTbl.glMakeTextureHandleResidentNV = driverTbl.glMakeTextureHandleResidentNV;
   }
   driverTbl.glMakeTextureHandleResidentNV(handle);
}

static void REGAL_CALL missing_glProgramUniformHandleui64NV(GLuint program, GLint location, GLuint64 value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glProgramUniformHandleui64NV" );
}

static void REGAL_CALL loader_glProgramUniformHandleui64NV(GLuint program, GLint location, GLuint64 value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformHandleui64NV, "glProgramUniformHandleui64NV");
   if ( !driverTbl.glProgramUniformHandleui64NV ) {
      driverTbl.glProgramUniformHandleui64NV = missing_glProgramUniformHandleui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformHandleui64NV == loader_glProgramUniformHandleui64NV) {
      rCtx->dsp.emuTbl.glProgramUniformHandleui64NV = driverTbl.glProgramUniformHandleui64NV;
   }
   driverTbl.glProgramUniformHandleui64NV(program, location, value);
}

static void REGAL_CALL missing_glProgramUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64 *values)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(values);
   Warning( "Called missing function glProgramUniformHandleui64vNV" );
}

static void REGAL_CALL loader_glProgramUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64 *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glProgramUniformHandleui64vNV, "glProgramUniformHandleui64vNV");
   if ( !driverTbl.glProgramUniformHandleui64vNV ) {
      driverTbl.glProgramUniformHandleui64vNV = missing_glProgramUniformHandleui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glProgramUniformHandleui64vNV == loader_glProgramUniformHandleui64vNV) {
      rCtx->dsp.emuTbl.glProgramUniformHandleui64vNV = driverTbl.glProgramUniformHandleui64vNV;
   }
   driverTbl.glProgramUniformHandleui64vNV(program, location, count, values);
}

static void REGAL_CALL missing_glUniformHandleui64NV(GLint location, GLuint64 value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformHandleui64NV" );
}

static void REGAL_CALL loader_glUniformHandleui64NV(GLint location, GLuint64 value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformHandleui64NV, "glUniformHandleui64NV");
   if ( !driverTbl.glUniformHandleui64NV ) {
      driverTbl.glUniformHandleui64NV = missing_glUniformHandleui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformHandleui64NV == loader_glUniformHandleui64NV) {
      rCtx->dsp.emuTbl.glUniformHandleui64NV = driverTbl.glUniformHandleui64NV;
   }
   driverTbl.glUniformHandleui64NV(location, value);
}

static void REGAL_CALL missing_glUniformHandleui64vNV(GLint location, GLsizei count, const GLuint64 *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "Called missing function glUniformHandleui64vNV" );
}

static void REGAL_CALL loader_glUniformHandleui64vNV(GLint location, GLsizei count, const GLuint64 *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glUniformHandleui64vNV, "glUniformHandleui64vNV");
   if ( !driverTbl.glUniformHandleui64vNV ) {
      driverTbl.glUniformHandleui64vNV = missing_glUniformHandleui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glUniformHandleui64vNV == loader_glUniformHandleui64vNV) {
      rCtx->dsp.emuTbl.glUniformHandleui64vNV = driverTbl.glUniformHandleui64vNV;
   }
   driverTbl.glUniformHandleui64vNV(location, count, value);
}

// GL_NV_texture_multisample

static void REGAL_CALL missing_glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(coverageSamples);
   UNUSED_PARAMETER(colorSamples);
   UNUSED_PARAMETER(internalFormat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(fixedSampleLocations);
   Warning( "Called missing function glTexImage2DMultisampleCoverageNV" );
}

static void REGAL_CALL loader_glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexImage2DMultisampleCoverageNV, "glTexImage2DMultisampleCoverageNV");
   if ( !driverTbl.glTexImage2DMultisampleCoverageNV ) {
      driverTbl.glTexImage2DMultisampleCoverageNV = missing_glTexImage2DMultisampleCoverageNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexImage2DMultisampleCoverageNV == loader_glTexImage2DMultisampleCoverageNV) {
      rCtx->dsp.emuTbl.glTexImage2DMultisampleCoverageNV = driverTbl.glTexImage2DMultisampleCoverageNV;
   }
   driverTbl.glTexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
}

static void REGAL_CALL missing_glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(coverageSamples);
   UNUSED_PARAMETER(colorSamples);
   UNUSED_PARAMETER(internalFormat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(fixedSampleLocations);
   Warning( "Called missing function glTexImage3DMultisampleCoverageNV" );
}

static void REGAL_CALL loader_glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTexImage3DMultisampleCoverageNV, "glTexImage3DMultisampleCoverageNV");
   if ( !driverTbl.glTexImage3DMultisampleCoverageNV ) {
      driverTbl.glTexImage3DMultisampleCoverageNV = missing_glTexImage3DMultisampleCoverageNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTexImage3DMultisampleCoverageNV == loader_glTexImage3DMultisampleCoverageNV) {
      rCtx->dsp.emuTbl.glTexImage3DMultisampleCoverageNV = driverTbl.glTexImage3DMultisampleCoverageNV;
   }
   driverTbl.glTexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
}

static void REGAL_CALL missing_glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(coverageSamples);
   UNUSED_PARAMETER(colorSamples);
   UNUSED_PARAMETER(internalFormat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(fixedSampleLocations);
   Warning( "Called missing function glTextureImage2DMultisampleCoverageNV" );
}

static void REGAL_CALL loader_glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureImage2DMultisampleCoverageNV, "glTextureImage2DMultisampleCoverageNV");
   if ( !driverTbl.glTextureImage2DMultisampleCoverageNV ) {
      driverTbl.glTextureImage2DMultisampleCoverageNV = missing_glTextureImage2DMultisampleCoverageNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureImage2DMultisampleCoverageNV == loader_glTextureImage2DMultisampleCoverageNV) {
      rCtx->dsp.emuTbl.glTextureImage2DMultisampleCoverageNV = driverTbl.glTextureImage2DMultisampleCoverageNV;
   }
   driverTbl.glTextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
}

static void REGAL_CALL missing_glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalFormat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(fixedSampleLocations);
   Warning( "Called missing function glTextureImage2DMultisampleNV" );
}

static void REGAL_CALL loader_glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureImage2DMultisampleNV, "glTextureImage2DMultisampleNV");
   if ( !driverTbl.glTextureImage2DMultisampleNV ) {
      driverTbl.glTextureImage2DMultisampleNV = missing_glTextureImage2DMultisampleNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureImage2DMultisampleNV == loader_glTextureImage2DMultisampleNV) {
      rCtx->dsp.emuTbl.glTextureImage2DMultisampleNV = driverTbl.glTextureImage2DMultisampleNV;
   }
   driverTbl.glTextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
}

static void REGAL_CALL missing_glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(coverageSamples);
   UNUSED_PARAMETER(colorSamples);
   UNUSED_PARAMETER(internalFormat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(fixedSampleLocations);
   Warning( "Called missing function glTextureImage3DMultisampleCoverageNV" );
}

static void REGAL_CALL loader_glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureImage3DMultisampleCoverageNV, "glTextureImage3DMultisampleCoverageNV");
   if ( !driverTbl.glTextureImage3DMultisampleCoverageNV ) {
      driverTbl.glTextureImage3DMultisampleCoverageNV = missing_glTextureImage3DMultisampleCoverageNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureImage3DMultisampleCoverageNV == loader_glTextureImage3DMultisampleCoverageNV) {
      rCtx->dsp.emuTbl.glTextureImage3DMultisampleCoverageNV = driverTbl.glTextureImage3DMultisampleCoverageNV;
   }
   driverTbl.glTextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
}

static void REGAL_CALL missing_glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalFormat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(fixedSampleLocations);
   Warning( "Called missing function glTextureImage3DMultisampleNV" );
}

static void REGAL_CALL loader_glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureImage3DMultisampleNV, "glTextureImage3DMultisampleNV");
   if ( !driverTbl.glTextureImage3DMultisampleNV ) {
      driverTbl.glTextureImage3DMultisampleNV = missing_glTextureImage3DMultisampleNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureImage3DMultisampleNV == loader_glTextureImage3DMultisampleNV) {
      rCtx->dsp.emuTbl.glTextureImage3DMultisampleNV = driverTbl.glTextureImage3DMultisampleNV;
   }
   driverTbl.glTextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
}

// GL_SUN_read_video_pixels

static void REGAL_CALL missing_glReadVideoPixelsSUN(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "Called missing function glReadVideoPixelsSUN" );
}

static void REGAL_CALL loader_glReadVideoPixelsSUN(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReadVideoPixelsSUN, "glReadVideoPixelsSUN");
   if ( !driverTbl.glReadVideoPixelsSUN ) {
      driverTbl.glReadVideoPixelsSUN = missing_glReadVideoPixelsSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReadVideoPixelsSUN == loader_glReadVideoPixelsSUN) {
      rCtx->dsp.emuTbl.glReadVideoPixelsSUN = driverTbl.glReadVideoPixelsSUN;
   }
   driverTbl.glReadVideoPixelsSUN(x, y, width, height, format, type, pixels);
}

// GL_EXT_fragment_lighting

static void REGAL_CALL missing_glFragmentColorMaterialEXT(GLenum face, GLenum mode)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(mode);
   Warning( "Called missing function glFragmentColorMaterialEXT" );
}

static void REGAL_CALL loader_glFragmentColorMaterialEXT(GLenum face, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentColorMaterialEXT, "glFragmentColorMaterialEXT");
   if ( !driverTbl.glFragmentColorMaterialEXT ) {
      driverTbl.glFragmentColorMaterialEXT = missing_glFragmentColorMaterialEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentColorMaterialEXT == loader_glFragmentColorMaterialEXT) {
      rCtx->dsp.emuTbl.glFragmentColorMaterialEXT = driverTbl.glFragmentColorMaterialEXT;
   }
   driverTbl.glFragmentColorMaterialEXT(face, mode);
}

static void REGAL_CALL missing_glFragmentLightModelfEXT(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glFragmentLightModelfEXT" );
}

static void REGAL_CALL loader_glFragmentLightModelfEXT(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightModelfEXT, "glFragmentLightModelfEXT");
   if ( !driverTbl.glFragmentLightModelfEXT ) {
      driverTbl.glFragmentLightModelfEXT = missing_glFragmentLightModelfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightModelfEXT == loader_glFragmentLightModelfEXT) {
      rCtx->dsp.emuTbl.glFragmentLightModelfEXT = driverTbl.glFragmentLightModelfEXT;
   }
   driverTbl.glFragmentLightModelfEXT(pname, param);
}

static void REGAL_CALL missing_glFragmentLightModelfvEXT(GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glFragmentLightModelfvEXT" );
}

static void REGAL_CALL loader_glFragmentLightModelfvEXT(GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightModelfvEXT, "glFragmentLightModelfvEXT");
   if ( !driverTbl.glFragmentLightModelfvEXT ) {
      driverTbl.glFragmentLightModelfvEXT = missing_glFragmentLightModelfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightModelfvEXT == loader_glFragmentLightModelfvEXT) {
      rCtx->dsp.emuTbl.glFragmentLightModelfvEXT = driverTbl.glFragmentLightModelfvEXT;
   }
   driverTbl.glFragmentLightModelfvEXT(pname, params);
}

static void REGAL_CALL missing_glFragmentLightModeliEXT(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glFragmentLightModeliEXT" );
}

static void REGAL_CALL loader_glFragmentLightModeliEXT(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightModeliEXT, "glFragmentLightModeliEXT");
   if ( !driverTbl.glFragmentLightModeliEXT ) {
      driverTbl.glFragmentLightModeliEXT = missing_glFragmentLightModeliEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightModeliEXT == loader_glFragmentLightModeliEXT) {
      rCtx->dsp.emuTbl.glFragmentLightModeliEXT = driverTbl.glFragmentLightModeliEXT;
   }
   driverTbl.glFragmentLightModeliEXT(pname, param);
}

static void REGAL_CALL missing_glFragmentLightModelivEXT(GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glFragmentLightModelivEXT" );
}

static void REGAL_CALL loader_glFragmentLightModelivEXT(GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightModelivEXT, "glFragmentLightModelivEXT");
   if ( !driverTbl.glFragmentLightModelivEXT ) {
      driverTbl.glFragmentLightModelivEXT = missing_glFragmentLightModelivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightModelivEXT == loader_glFragmentLightModelivEXT) {
      rCtx->dsp.emuTbl.glFragmentLightModelivEXT = driverTbl.glFragmentLightModelivEXT;
   }
   driverTbl.glFragmentLightModelivEXT(pname, params);
}

static void REGAL_CALL missing_glFragmentLightfEXT(GLenum light, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glFragmentLightfEXT" );
}

static void REGAL_CALL loader_glFragmentLightfEXT(GLenum light, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightfEXT, "glFragmentLightfEXT");
   if ( !driverTbl.glFragmentLightfEXT ) {
      driverTbl.glFragmentLightfEXT = missing_glFragmentLightfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightfEXT == loader_glFragmentLightfEXT) {
      rCtx->dsp.emuTbl.glFragmentLightfEXT = driverTbl.glFragmentLightfEXT;
   }
   driverTbl.glFragmentLightfEXT(light, pname, param);
}

static void REGAL_CALL missing_glFragmentLightfvEXT(GLenum light, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glFragmentLightfvEXT" );
}

static void REGAL_CALL loader_glFragmentLightfvEXT(GLenum light, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightfvEXT, "glFragmentLightfvEXT");
   if ( !driverTbl.glFragmentLightfvEXT ) {
      driverTbl.glFragmentLightfvEXT = missing_glFragmentLightfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightfvEXT == loader_glFragmentLightfvEXT) {
      rCtx->dsp.emuTbl.glFragmentLightfvEXT = driverTbl.glFragmentLightfvEXT;
   }
   driverTbl.glFragmentLightfvEXT(light, pname, params);
}

static void REGAL_CALL missing_glFragmentLightiEXT(GLenum light, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glFragmentLightiEXT" );
}

static void REGAL_CALL loader_glFragmentLightiEXT(GLenum light, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightiEXT, "glFragmentLightiEXT");
   if ( !driverTbl.glFragmentLightiEXT ) {
      driverTbl.glFragmentLightiEXT = missing_glFragmentLightiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightiEXT == loader_glFragmentLightiEXT) {
      rCtx->dsp.emuTbl.glFragmentLightiEXT = driverTbl.glFragmentLightiEXT;
   }
   driverTbl.glFragmentLightiEXT(light, pname, param);
}

static void REGAL_CALL missing_glFragmentLightivEXT(GLenum light, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glFragmentLightivEXT" );
}

static void REGAL_CALL loader_glFragmentLightivEXT(GLenum light, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentLightivEXT, "glFragmentLightivEXT");
   if ( !driverTbl.glFragmentLightivEXT ) {
      driverTbl.glFragmentLightivEXT = missing_glFragmentLightivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentLightivEXT == loader_glFragmentLightivEXT) {
      rCtx->dsp.emuTbl.glFragmentLightivEXT = driverTbl.glFragmentLightivEXT;
   }
   driverTbl.glFragmentLightivEXT(light, pname, params);
}

static void REGAL_CALL missing_glFragmentMaterialfEXT(GLenum face, GLenum pname, const GLfloat param)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glFragmentMaterialfEXT" );
}

static void REGAL_CALL loader_glFragmentMaterialfEXT(GLenum face, GLenum pname, const GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentMaterialfEXT, "glFragmentMaterialfEXT");
   if ( !driverTbl.glFragmentMaterialfEXT ) {
      driverTbl.glFragmentMaterialfEXT = missing_glFragmentMaterialfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentMaterialfEXT == loader_glFragmentMaterialfEXT) {
      rCtx->dsp.emuTbl.glFragmentMaterialfEXT = driverTbl.glFragmentMaterialfEXT;
   }
   driverTbl.glFragmentMaterialfEXT(face, pname, param);
}

static void REGAL_CALL missing_glFragmentMaterialfvEXT(GLenum face, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glFragmentMaterialfvEXT" );
}

static void REGAL_CALL loader_glFragmentMaterialfvEXT(GLenum face, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentMaterialfvEXT, "glFragmentMaterialfvEXT");
   if ( !driverTbl.glFragmentMaterialfvEXT ) {
      driverTbl.glFragmentMaterialfvEXT = missing_glFragmentMaterialfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentMaterialfvEXT == loader_glFragmentMaterialfvEXT) {
      rCtx->dsp.emuTbl.glFragmentMaterialfvEXT = driverTbl.glFragmentMaterialfvEXT;
   }
   driverTbl.glFragmentMaterialfvEXT(face, pname, params);
}

static void REGAL_CALL missing_glFragmentMaterialiEXT(GLenum face, GLenum pname, const GLint param)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glFragmentMaterialiEXT" );
}

static void REGAL_CALL loader_glFragmentMaterialiEXT(GLenum face, GLenum pname, const GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentMaterialiEXT, "glFragmentMaterialiEXT");
   if ( !driverTbl.glFragmentMaterialiEXT ) {
      driverTbl.glFragmentMaterialiEXT = missing_glFragmentMaterialiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentMaterialiEXT == loader_glFragmentMaterialiEXT) {
      rCtx->dsp.emuTbl.glFragmentMaterialiEXT = driverTbl.glFragmentMaterialiEXT;
   }
   driverTbl.glFragmentMaterialiEXT(face, pname, param);
}

static void REGAL_CALL missing_glFragmentMaterialivEXT(GLenum face, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glFragmentMaterialivEXT" );
}

static void REGAL_CALL loader_glFragmentMaterialivEXT(GLenum face, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFragmentMaterialivEXT, "glFragmentMaterialivEXT");
   if ( !driverTbl.glFragmentMaterialivEXT ) {
      driverTbl.glFragmentMaterialivEXT = missing_glFragmentMaterialivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFragmentMaterialivEXT == loader_glFragmentMaterialivEXT) {
      rCtx->dsp.emuTbl.glFragmentMaterialivEXT = driverTbl.glFragmentMaterialivEXT;
   }
   driverTbl.glFragmentMaterialivEXT(face, pname, params);
}

static void REGAL_CALL missing_glGetFragmentLightfvEXT(GLenum light, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFragmentLightfvEXT" );
}

static void REGAL_CALL loader_glGetFragmentLightfvEXT(GLenum light, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFragmentLightfvEXT, "glGetFragmentLightfvEXT");
   if ( !driverTbl.glGetFragmentLightfvEXT ) {
      driverTbl.glGetFragmentLightfvEXT = missing_glGetFragmentLightfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFragmentLightfvEXT == loader_glGetFragmentLightfvEXT) {
      rCtx->dsp.emuTbl.glGetFragmentLightfvEXT = driverTbl.glGetFragmentLightfvEXT;
   }
   driverTbl.glGetFragmentLightfvEXT(light, pname, params);
}

static void REGAL_CALL missing_glGetFragmentLightivEXT(GLenum light, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFragmentLightivEXT" );
}

static void REGAL_CALL loader_glGetFragmentLightivEXT(GLenum light, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFragmentLightivEXT, "glGetFragmentLightivEXT");
   if ( !driverTbl.glGetFragmentLightivEXT ) {
      driverTbl.glGetFragmentLightivEXT = missing_glGetFragmentLightivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFragmentLightivEXT == loader_glGetFragmentLightivEXT) {
      rCtx->dsp.emuTbl.glGetFragmentLightivEXT = driverTbl.glGetFragmentLightivEXT;
   }
   driverTbl.glGetFragmentLightivEXT(light, pname, params);
}

static void REGAL_CALL missing_glGetFragmentMaterialfvEXT(GLenum face, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFragmentMaterialfvEXT" );
}

static void REGAL_CALL loader_glGetFragmentMaterialfvEXT(GLenum face, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFragmentMaterialfvEXT, "glGetFragmentMaterialfvEXT");
   if ( !driverTbl.glGetFragmentMaterialfvEXT ) {
      driverTbl.glGetFragmentMaterialfvEXT = missing_glGetFragmentMaterialfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFragmentMaterialfvEXT == loader_glGetFragmentMaterialfvEXT) {
      rCtx->dsp.emuTbl.glGetFragmentMaterialfvEXT = driverTbl.glGetFragmentMaterialfvEXT;
   }
   driverTbl.glGetFragmentMaterialfvEXT(face, pname, params);
}

static void REGAL_CALL missing_glGetFragmentMaterialivEXT(GLenum face, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "Called missing function glGetFragmentMaterialivEXT" );
}

static void REGAL_CALL loader_glGetFragmentMaterialivEXT(GLenum face, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glGetFragmentMaterialivEXT, "glGetFragmentMaterialivEXT");
   if ( !driverTbl.glGetFragmentMaterialivEXT ) {
      driverTbl.glGetFragmentMaterialivEXT = missing_glGetFragmentMaterialivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glGetFragmentMaterialivEXT == loader_glGetFragmentMaterialivEXT) {
      rCtx->dsp.emuTbl.glGetFragmentMaterialivEXT = driverTbl.glGetFragmentMaterialivEXT;
   }
   driverTbl.glGetFragmentMaterialivEXT(face, pname, params);
}

static void REGAL_CALL missing_glLightEnviEXT(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "Called missing function glLightEnviEXT" );
}

static void REGAL_CALL loader_glLightEnviEXT(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glLightEnviEXT, "glLightEnviEXT");
   if ( !driverTbl.glLightEnviEXT ) {
      driverTbl.glLightEnviEXT = missing_glLightEnviEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glLightEnviEXT == loader_glLightEnviEXT) {
      rCtx->dsp.emuTbl.glLightEnviEXT = driverTbl.glLightEnviEXT;
   }
   driverTbl.glLightEnviEXT(pname, param);
}

// GL_EXT_debug_marker

static void REGAL_CALL missing_glInsertEventMarkerEXT(GLsizei length, const GLchar *marker)
{
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(marker);
   Warning( "Called missing function glInsertEventMarkerEXT" );
}

static void REGAL_CALL loader_glInsertEventMarkerEXT(GLsizei length, const GLchar *marker)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glInsertEventMarkerEXT, "glInsertEventMarkerEXT");
   if ( !driverTbl.glInsertEventMarkerEXT ) {
      driverTbl.glInsertEventMarkerEXT = missing_glInsertEventMarkerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glInsertEventMarkerEXT == loader_glInsertEventMarkerEXT) {
      rCtx->dsp.emuTbl.glInsertEventMarkerEXT = driverTbl.glInsertEventMarkerEXT;
   }
   driverTbl.glInsertEventMarkerEXT(length, marker);
}

static void REGAL_CALL missing_glPushGroupMarkerEXT(GLsizei length, const GLchar *marker)
{
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(marker);
   Warning( "Called missing function glPushGroupMarkerEXT" );
}

static void REGAL_CALL loader_glPushGroupMarkerEXT(GLsizei length, const GLchar *marker)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPushGroupMarkerEXT, "glPushGroupMarkerEXT");
   if ( !driverTbl.glPushGroupMarkerEXT ) {
      driverTbl.glPushGroupMarkerEXT = missing_glPushGroupMarkerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPushGroupMarkerEXT == loader_glPushGroupMarkerEXT) {
      rCtx->dsp.emuTbl.glPushGroupMarkerEXT = driverTbl.glPushGroupMarkerEXT;
   }
   driverTbl.glPushGroupMarkerEXT(length, marker);
}

static void REGAL_CALL missing_glPopGroupMarkerEXT(void)
{
   Warning( "Called missing function glPopGroupMarkerEXT" );
}

static void REGAL_CALL loader_glPopGroupMarkerEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glPopGroupMarkerEXT, "glPopGroupMarkerEXT");
   if ( !driverTbl.glPopGroupMarkerEXT ) {
      driverTbl.glPopGroupMarkerEXT = missing_glPopGroupMarkerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glPopGroupMarkerEXT == loader_glPopGroupMarkerEXT) {
      rCtx->dsp.emuTbl.glPopGroupMarkerEXT = driverTbl.glPopGroupMarkerEXT;
   }
   driverTbl.glPopGroupMarkerEXT();
}

// GL_KTX_buffer_region

static GLuint REGAL_CALL missing_glBufferRegionEnabledEXT(void)
{
   Warning( "Called missing function glBufferRegionEnabledEXT" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glBufferRegionEnabledEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glBufferRegionEnabledEXT, "glBufferRegionEnabledEXT");
   if ( !driverTbl.glBufferRegionEnabledEXT ) {
      driverTbl.glBufferRegionEnabledEXT = missing_glBufferRegionEnabledEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glBufferRegionEnabledEXT == loader_glBufferRegionEnabledEXT) {
      rCtx->dsp.emuTbl.glBufferRegionEnabledEXT = driverTbl.glBufferRegionEnabledEXT;
   }
   return driverTbl.glBufferRegionEnabledEXT();
}

static GLuint REGAL_CALL missing_glNewBufferRegionEXT(GLenum region)
{
   UNUSED_PARAMETER(region);
   Warning( "Called missing function glNewBufferRegionEXT" );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glNewBufferRegionEXT(GLenum region)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glNewBufferRegionEXT, "glNewBufferRegionEXT");
   if ( !driverTbl.glNewBufferRegionEXT ) {
      driverTbl.glNewBufferRegionEXT = missing_glNewBufferRegionEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glNewBufferRegionEXT == loader_glNewBufferRegionEXT) {
      rCtx->dsp.emuTbl.glNewBufferRegionEXT = driverTbl.glNewBufferRegionEXT;
   }
   return driverTbl.glNewBufferRegionEXT(region);
}

static void REGAL_CALL missing_glDeleteBufferRegionEXT(GLenum region)
{
   UNUSED_PARAMETER(region);
   Warning( "Called missing function glDeleteBufferRegionEXT" );
}

static void REGAL_CALL loader_glDeleteBufferRegionEXT(GLenum region)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDeleteBufferRegionEXT, "glDeleteBufferRegionEXT");
   if ( !driverTbl.glDeleteBufferRegionEXT ) {
      driverTbl.glDeleteBufferRegionEXT = missing_glDeleteBufferRegionEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDeleteBufferRegionEXT == loader_glDeleteBufferRegionEXT) {
      rCtx->dsp.emuTbl.glDeleteBufferRegionEXT = driverTbl.glDeleteBufferRegionEXT;
   }
   driverTbl.glDeleteBufferRegionEXT(region);
}

static void REGAL_CALL missing_glReadBufferRegionEXT(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(region);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glReadBufferRegionEXT" );
}

static void REGAL_CALL loader_glReadBufferRegionEXT(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glReadBufferRegionEXT, "glReadBufferRegionEXT");
   if ( !driverTbl.glReadBufferRegionEXT ) {
      driverTbl.glReadBufferRegionEXT = missing_glReadBufferRegionEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glReadBufferRegionEXT == loader_glReadBufferRegionEXT) {
      rCtx->dsp.emuTbl.glReadBufferRegionEXT = driverTbl.glReadBufferRegionEXT;
   }
   driverTbl.glReadBufferRegionEXT(region, x, y, width, height);
}

static void REGAL_CALL missing_glDrawBufferRegionEXT(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest)
{
   UNUSED_PARAMETER(region);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(xDest);
   UNUSED_PARAMETER(yDest);
   Warning( "Called missing function glDrawBufferRegionEXT" );
}

static void REGAL_CALL loader_glDrawBufferRegionEXT(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glDrawBufferRegionEXT, "glDrawBufferRegionEXT");
   if ( !driverTbl.glDrawBufferRegionEXT ) {
      driverTbl.glDrawBufferRegionEXT = missing_glDrawBufferRegionEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glDrawBufferRegionEXT == loader_glDrawBufferRegionEXT) {
      rCtx->dsp.emuTbl.glDrawBufferRegionEXT = driverTbl.glDrawBufferRegionEXT;
   }
   driverTbl.glDrawBufferRegionEXT(region, x, y, width, height, xDest, yDest);
}

// GL_SGIX_fog_texture

static void REGAL_CALL missing_glTextureFogSGIX(GLenum pname)
{
   UNUSED_PARAMETER(pname);
   Warning( "Called missing function glTextureFogSGIX" );
}

static void REGAL_CALL loader_glTextureFogSGIX(GLenum pname)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glTextureFogSGIX, "glTextureFogSGIX");
   if ( !driverTbl.glTextureFogSGIX ) {
      driverTbl.glTextureFogSGIX = missing_glTextureFogSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glTextureFogSGIX == loader_glTextureFogSGIX) {
      rCtx->dsp.emuTbl.glTextureFogSGIX = driverTbl.glTextureFogSGIX;
   }
   driverTbl.glTextureFogSGIX(pname);
}

// GL_APPLE_flush_render

static void REGAL_CALL missing_glFlushRenderAPPLE(void)
{
   Warning( "Called missing function glFlushRenderAPPLE" );
}

static void REGAL_CALL loader_glFlushRenderAPPLE(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFlushRenderAPPLE, "glFlushRenderAPPLE");
   if ( !driverTbl.glFlushRenderAPPLE ) {
      driverTbl.glFlushRenderAPPLE = missing_glFlushRenderAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFlushRenderAPPLE == loader_glFlushRenderAPPLE) {
      rCtx->dsp.emuTbl.glFlushRenderAPPLE = driverTbl.glFlushRenderAPPLE;
   }
   driverTbl.glFlushRenderAPPLE();
}

static void REGAL_CALL missing_glFinishRenderAPPLE(void)
{
   Warning( "Called missing function glFinishRenderAPPLE" );
}

static void REGAL_CALL loader_glFinishRenderAPPLE(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glFinishRenderAPPLE, "glFinishRenderAPPLE");
   if ( !driverTbl.glFinishRenderAPPLE ) {
      driverTbl.glFinishRenderAPPLE = missing_glFinishRenderAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glFinishRenderAPPLE == loader_glFinishRenderAPPLE) {
      rCtx->dsp.emuTbl.glFinishRenderAPPLE = driverTbl.glFinishRenderAPPLE;
   }
   driverTbl.glFinishRenderAPPLE();
}

static void REGAL_CALL missing_glSwapAPPLE(void)
{
   Warning( "Called missing function glSwapAPPLE" );
}

static void REGAL_CALL loader_glSwapAPPLE(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glSwapAPPLE, "glSwapAPPLE");
   if ( !driverTbl.glSwapAPPLE ) {
      driverTbl.glSwapAPPLE = missing_glSwapAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glSwapAPPLE == loader_glSwapAPPLE) {
      rCtx->dsp.emuTbl.glSwapAPPLE = driverTbl.glSwapAPPLE;
   }
   driverTbl.glSwapAPPLE();
}

// GL_WIN_swap_hint

static void REGAL_CALL missing_glAddSwapHintRectWIN(GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "Called missing function glAddSwapHintRectWIN" );
}

static void REGAL_CALL loader_glAddSwapHintRectWIN(GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   DispatchTable & driverTbl = rCtx->dsp.driverTbl;
   RegalGetProcAddress( driverTbl.glAddSwapHintRectWIN, "glAddSwapHintRectWIN");
   if ( !driverTbl.glAddSwapHintRectWIN ) {
      driverTbl.glAddSwapHintRectWIN = missing_glAddSwapHintRectWIN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp.emuTbl.glAddSwapHintRectWIN == loader_glAddSwapHintRectWIN) {
      rCtx->dsp.emuTbl.glAddSwapHintRectWIN = driverTbl.glAddSwapHintRectWIN;
   }
   driverTbl.glAddSwapHintRectWIN(x, y, width, height);
}

void RegalPrivateInitLoaderDispatchTable( DispatchTable & tbl )
{

// GL_VERSION_1_0

   tbl.glNewList = loader_glNewList;
   tbl.glEndList = loader_glEndList;
   tbl.glCallList = loader_glCallList;
   tbl.glCallLists = loader_glCallLists;
   tbl.glDeleteLists = loader_glDeleteLists;
   tbl.glGenLists = loader_glGenLists;
   tbl.glListBase = loader_glListBase;
   tbl.glBegin = loader_glBegin;
   tbl.glBitmap = loader_glBitmap;
   tbl.glColor3b = loader_glColor3b;
   tbl.glColor3bv = loader_glColor3bv;
   tbl.glColor3d = loader_glColor3d;
   tbl.glColor3dv = loader_glColor3dv;
   tbl.glColor3f = loader_glColor3f;
   tbl.glColor3fv = loader_glColor3fv;
   tbl.glColor3i = loader_glColor3i;
   tbl.glColor3iv = loader_glColor3iv;
   tbl.glColor3s = loader_glColor3s;
   tbl.glColor3sv = loader_glColor3sv;
   tbl.glColor3ub = loader_glColor3ub;
   tbl.glColor3ubv = loader_glColor3ubv;
   tbl.glColor3ui = loader_glColor3ui;
   tbl.glColor3uiv = loader_glColor3uiv;
   tbl.glColor3us = loader_glColor3us;
   tbl.glColor3usv = loader_glColor3usv;
   tbl.glColor4b = loader_glColor4b;
   tbl.glColor4bv = loader_glColor4bv;
   tbl.glColor4d = loader_glColor4d;
   tbl.glColor4dv = loader_glColor4dv;
   tbl.glColor4f = loader_glColor4f;
   tbl.glColor4fv = loader_glColor4fv;
   tbl.glColor4i = loader_glColor4i;
   tbl.glColor4iv = loader_glColor4iv;
   tbl.glColor4s = loader_glColor4s;
   tbl.glColor4sv = loader_glColor4sv;
   tbl.glColor4ub = loader_glColor4ub;
   tbl.glColor4ubv = loader_glColor4ubv;
   tbl.glColor4ui = loader_glColor4ui;
   tbl.glColor4uiv = loader_glColor4uiv;
   tbl.glColor4us = loader_glColor4us;
   tbl.glColor4usv = loader_glColor4usv;
   tbl.glEdgeFlag = loader_glEdgeFlag;
   tbl.glEdgeFlagv = loader_glEdgeFlagv;
   tbl.glEnd = loader_glEnd;
   tbl.glIndexd = loader_glIndexd;
   tbl.glIndexdv = loader_glIndexdv;
   tbl.glIndexf = loader_glIndexf;
   tbl.glIndexfv = loader_glIndexfv;
   tbl.glIndexi = loader_glIndexi;
   tbl.glIndexiv = loader_glIndexiv;
   tbl.glIndexs = loader_glIndexs;
   tbl.glIndexsv = loader_glIndexsv;
   tbl.glNormal3b = loader_glNormal3b;
   tbl.glNormal3bv = loader_glNormal3bv;
   tbl.glNormal3d = loader_glNormal3d;
   tbl.glNormal3dv = loader_glNormal3dv;
   tbl.glNormal3f = loader_glNormal3f;
   tbl.glNormal3fv = loader_glNormal3fv;
   tbl.glNormal3i = loader_glNormal3i;
   tbl.glNormal3iv = loader_glNormal3iv;
   tbl.glNormal3s = loader_glNormal3s;
   tbl.glNormal3sv = loader_glNormal3sv;
   tbl.glRasterPos2d = loader_glRasterPos2d;
   tbl.glRasterPos2dv = loader_glRasterPos2dv;
   tbl.glRasterPos2f = loader_glRasterPos2f;
   tbl.glRasterPos2fv = loader_glRasterPos2fv;
   tbl.glRasterPos2i = loader_glRasterPos2i;
   tbl.glRasterPos2iv = loader_glRasterPos2iv;
   tbl.glRasterPos2s = loader_glRasterPos2s;
   tbl.glRasterPos2sv = loader_glRasterPos2sv;
   tbl.glRasterPos3d = loader_glRasterPos3d;
   tbl.glRasterPos3dv = loader_glRasterPos3dv;
   tbl.glRasterPos3f = loader_glRasterPos3f;
   tbl.glRasterPos3fv = loader_glRasterPos3fv;
   tbl.glRasterPos3i = loader_glRasterPos3i;
   tbl.glRasterPos3iv = loader_glRasterPos3iv;
   tbl.glRasterPos3s = loader_glRasterPos3s;
   tbl.glRasterPos3sv = loader_glRasterPos3sv;
   tbl.glRasterPos4d = loader_glRasterPos4d;
   tbl.glRasterPos4dv = loader_glRasterPos4dv;
   tbl.glRasterPos4f = loader_glRasterPos4f;
   tbl.glRasterPos4fv = loader_glRasterPos4fv;
   tbl.glRasterPos4i = loader_glRasterPos4i;
   tbl.glRasterPos4iv = loader_glRasterPos4iv;
   tbl.glRasterPos4s = loader_glRasterPos4s;
   tbl.glRasterPos4sv = loader_glRasterPos4sv;
   tbl.glRectd = loader_glRectd;
   tbl.glRectdv = loader_glRectdv;
   tbl.glRectf = loader_glRectf;
   tbl.glRectfv = loader_glRectfv;
   tbl.glRecti = loader_glRecti;
   tbl.glRectiv = loader_glRectiv;
   tbl.glRects = loader_glRects;
   tbl.glRectsv = loader_glRectsv;
   tbl.glTexCoord1d = loader_glTexCoord1d;
   tbl.glTexCoord1dv = loader_glTexCoord1dv;
   tbl.glTexCoord1f = loader_glTexCoord1f;
   tbl.glTexCoord1fv = loader_glTexCoord1fv;
   tbl.glTexCoord1i = loader_glTexCoord1i;
   tbl.glTexCoord1iv = loader_glTexCoord1iv;
   tbl.glTexCoord1s = loader_glTexCoord1s;
   tbl.glTexCoord1sv = loader_glTexCoord1sv;
   tbl.glTexCoord2d = loader_glTexCoord2d;
   tbl.glTexCoord2dv = loader_glTexCoord2dv;
   tbl.glTexCoord2f = loader_glTexCoord2f;
   tbl.glTexCoord2fv = loader_glTexCoord2fv;
   tbl.glTexCoord2i = loader_glTexCoord2i;
   tbl.glTexCoord2iv = loader_glTexCoord2iv;
   tbl.glTexCoord2s = loader_glTexCoord2s;
   tbl.glTexCoord2sv = loader_glTexCoord2sv;
   tbl.glTexCoord3d = loader_glTexCoord3d;
   tbl.glTexCoord3dv = loader_glTexCoord3dv;
   tbl.glTexCoord3f = loader_glTexCoord3f;
   tbl.glTexCoord3fv = loader_glTexCoord3fv;
   tbl.glTexCoord3i = loader_glTexCoord3i;
   tbl.glTexCoord3iv = loader_glTexCoord3iv;
   tbl.glTexCoord3s = loader_glTexCoord3s;
   tbl.glTexCoord3sv = loader_glTexCoord3sv;
   tbl.glTexCoord4d = loader_glTexCoord4d;
   tbl.glTexCoord4dv = loader_glTexCoord4dv;
   tbl.glTexCoord4f = loader_glTexCoord4f;
   tbl.glTexCoord4fv = loader_glTexCoord4fv;
   tbl.glTexCoord4i = loader_glTexCoord4i;
   tbl.glTexCoord4iv = loader_glTexCoord4iv;
   tbl.glTexCoord4s = loader_glTexCoord4s;
   tbl.glTexCoord4sv = loader_glTexCoord4sv;
   tbl.glVertex2d = loader_glVertex2d;
   tbl.glVertex2dv = loader_glVertex2dv;
   tbl.glVertex2f = loader_glVertex2f;
   tbl.glVertex2fv = loader_glVertex2fv;
   tbl.glVertex2i = loader_glVertex2i;
   tbl.glVertex2iv = loader_glVertex2iv;
   tbl.glVertex2s = loader_glVertex2s;
   tbl.glVertex2sv = loader_glVertex2sv;
   tbl.glVertex3d = loader_glVertex3d;
   tbl.glVertex3dv = loader_glVertex3dv;
   tbl.glVertex3f = loader_glVertex3f;
   tbl.glVertex3fv = loader_glVertex3fv;
   tbl.glVertex3i = loader_glVertex3i;
   tbl.glVertex3iv = loader_glVertex3iv;
   tbl.glVertex3s = loader_glVertex3s;
   tbl.glVertex3sv = loader_glVertex3sv;
   tbl.glVertex4d = loader_glVertex4d;
   tbl.glVertex4dv = loader_glVertex4dv;
   tbl.glVertex4f = loader_glVertex4f;
   tbl.glVertex4fv = loader_glVertex4fv;
   tbl.glVertex4i = loader_glVertex4i;
   tbl.glVertex4iv = loader_glVertex4iv;
   tbl.glVertex4s = loader_glVertex4s;
   tbl.glVertex4sv = loader_glVertex4sv;
   tbl.glClipPlane = loader_glClipPlane;
   tbl.glColorMaterial = loader_glColorMaterial;
   tbl.glCullFace = loader_glCullFace;
   tbl.glFogf = loader_glFogf;
   tbl.glFogfv = loader_glFogfv;
   tbl.glFogi = loader_glFogi;
   tbl.glFogiv = loader_glFogiv;
   tbl.glFrontFace = loader_glFrontFace;
   tbl.glHint = loader_glHint;
   tbl.glLightf = loader_glLightf;
   tbl.glLightfv = loader_glLightfv;
   tbl.glLighti = loader_glLighti;
   tbl.glLightiv = loader_glLightiv;
   tbl.glLightModelf = loader_glLightModelf;
   tbl.glLightModelfv = loader_glLightModelfv;
   tbl.glLightModeli = loader_glLightModeli;
   tbl.glLightModeliv = loader_glLightModeliv;
   tbl.glLineStipple = loader_glLineStipple;
   tbl.glLineWidth = loader_glLineWidth;
   tbl.glMaterialf = loader_glMaterialf;
   tbl.glMaterialfv = loader_glMaterialfv;
   tbl.glMateriali = loader_glMateriali;
   tbl.glMaterialiv = loader_glMaterialiv;
   tbl.glPointSize = loader_glPointSize;
   tbl.glPolygonMode = loader_glPolygonMode;
   tbl.glPolygonStipple = loader_glPolygonStipple;
   tbl.glScissor = loader_glScissor;
   tbl.glShadeModel = loader_glShadeModel;
   tbl.glTexParameterf = loader_glTexParameterf;
   tbl.glTexParameterfv = loader_glTexParameterfv;
   tbl.glTexParameteri = loader_glTexParameteri;
   tbl.glTexParameteriv = loader_glTexParameteriv;
   tbl.glTexImage1D = loader_glTexImage1D;
   tbl.glTexImage2D = loader_glTexImage2D;
   tbl.glTexEnvf = loader_glTexEnvf;
   tbl.glTexEnvfv = loader_glTexEnvfv;
   tbl.glTexEnvi = loader_glTexEnvi;
   tbl.glTexEnviv = loader_glTexEnviv;
   tbl.glTexGend = loader_glTexGend;
   tbl.glTexGendv = loader_glTexGendv;
   tbl.glTexGenf = loader_glTexGenf;
   tbl.glTexGenfv = loader_glTexGenfv;
   tbl.glTexGeni = loader_glTexGeni;
   tbl.glTexGeniv = loader_glTexGeniv;
   tbl.glFeedbackBuffer = loader_glFeedbackBuffer;
   tbl.glSelectBuffer = loader_glSelectBuffer;
   tbl.glRenderMode = loader_glRenderMode;
   tbl.glInitNames = loader_glInitNames;
   tbl.glLoadName = loader_glLoadName;
   tbl.glPassThrough = loader_glPassThrough;
   tbl.glPopName = loader_glPopName;
   tbl.glPushName = loader_glPushName;
   tbl.glDrawBuffer = loader_glDrawBuffer;
   tbl.glClear = loader_glClear;
   tbl.glClearAccum = loader_glClearAccum;
   tbl.glClearColor = loader_glClearColor;
   tbl.glClearDepth = loader_glClearDepth;
   tbl.glClearIndex = loader_glClearIndex;
   tbl.glClearStencil = loader_glClearStencil;
   tbl.glColorMask = loader_glColorMask;
   tbl.glDepthMask = loader_glDepthMask;
   tbl.glIndexMask = loader_glIndexMask;
   tbl.glStencilMask = loader_glStencilMask;
   tbl.glAccum = loader_glAccum;
   tbl.glDisable = loader_glDisable;
   tbl.glEnable = loader_glEnable;
   tbl.glFinish = loader_glFinish;
   tbl.glFlush = loader_glFlush;
   tbl.glPopAttrib = loader_glPopAttrib;
   tbl.glPushAttrib = loader_glPushAttrib;
   tbl.glMap1d = loader_glMap1d;
   tbl.glMap1f = loader_glMap1f;
   tbl.glMap2d = loader_glMap2d;
   tbl.glMap2f = loader_glMap2f;
   tbl.glMapGrid1d = loader_glMapGrid1d;
   tbl.glMapGrid1f = loader_glMapGrid1f;
   tbl.glMapGrid2d = loader_glMapGrid2d;
   tbl.glMapGrid2f = loader_glMapGrid2f;
   tbl.glEvalCoord1d = loader_glEvalCoord1d;
   tbl.glEvalCoord1dv = loader_glEvalCoord1dv;
   tbl.glEvalCoord1f = loader_glEvalCoord1f;
   tbl.glEvalCoord1fv = loader_glEvalCoord1fv;
   tbl.glEvalCoord2d = loader_glEvalCoord2d;
   tbl.glEvalCoord2dv = loader_glEvalCoord2dv;
   tbl.glEvalCoord2f = loader_glEvalCoord2f;
   tbl.glEvalCoord2fv = loader_glEvalCoord2fv;
   tbl.glEvalMesh1 = loader_glEvalMesh1;
   tbl.glEvalMesh2 = loader_glEvalMesh2;
   tbl.glEvalPoint1 = loader_glEvalPoint1;
   tbl.glEvalPoint2 = loader_glEvalPoint2;
   tbl.glAlphaFunc = loader_glAlphaFunc;
   tbl.glBlendFunc = loader_glBlendFunc;
   tbl.glDepthFunc = loader_glDepthFunc;
   tbl.glStencilFunc = loader_glStencilFunc;
   tbl.glLogicOp = loader_glLogicOp;
   tbl.glStencilOp = loader_glStencilOp;
   tbl.glPixelZoom = loader_glPixelZoom;
   tbl.glPixelTransferf = loader_glPixelTransferf;
   tbl.glPixelTransferi = loader_glPixelTransferi;
   tbl.glPixelStoref = loader_glPixelStoref;
   tbl.glPixelStorei = loader_glPixelStorei;
   tbl.glPixelMapfv = loader_glPixelMapfv;
   tbl.glPixelMapuiv = loader_glPixelMapuiv;
   tbl.glPixelMapusv = loader_glPixelMapusv;
   tbl.glReadBuffer = loader_glReadBuffer;
   tbl.glCopyPixels = loader_glCopyPixels;
   tbl.glReadPixels = loader_glReadPixels;
   tbl.glDrawPixels = loader_glDrawPixels;
   tbl.glGetBooleanv = loader_glGetBooleanv;
   tbl.glGetDoublev = loader_glGetDoublev;
   tbl.glGetFloatv = loader_glGetFloatv;
   tbl.glGetIntegerv = loader_glGetIntegerv;
   tbl.glGetClipPlane = loader_glGetClipPlane;
   tbl.glGetError = loader_glGetError;
   tbl.glGetLightfv = loader_glGetLightfv;
   tbl.glGetLightiv = loader_glGetLightiv;
   tbl.glGetMapdv = loader_glGetMapdv;
   tbl.glGetMapfv = loader_glGetMapfv;
   tbl.glGetMapiv = loader_glGetMapiv;
   tbl.glGetMaterialfv = loader_glGetMaterialfv;
   tbl.glGetMaterialiv = loader_glGetMaterialiv;
   tbl.glGetPixelMapfv = loader_glGetPixelMapfv;
   tbl.glGetPixelMapuiv = loader_glGetPixelMapuiv;
   tbl.glGetPixelMapusv = loader_glGetPixelMapusv;
   tbl.glGetPolygonStipple = loader_glGetPolygonStipple;
   tbl.glGetString = loader_glGetString;
   tbl.glGetTexEnvfv = loader_glGetTexEnvfv;
   tbl.glGetTexEnviv = loader_glGetTexEnviv;
   tbl.glGetTexGendv = loader_glGetTexGendv;
   tbl.glGetTexGenfv = loader_glGetTexGenfv;
   tbl.glGetTexGeniv = loader_glGetTexGeniv;
   tbl.glGetTexImage = loader_glGetTexImage;
   tbl.glGetTexParameterfv = loader_glGetTexParameterfv;
   tbl.glGetTexParameteriv = loader_glGetTexParameteriv;
   tbl.glGetTexLevelParameterfv = loader_glGetTexLevelParameterfv;
   tbl.glGetTexLevelParameteriv = loader_glGetTexLevelParameteriv;
   tbl.glIsEnabled = loader_glIsEnabled;
   tbl.glIsList = loader_glIsList;
   tbl.glDepthRange = loader_glDepthRange;
   tbl.glFrustum = loader_glFrustum;
   tbl.glLoadIdentity = loader_glLoadIdentity;
   tbl.glLoadMatrixd = loader_glLoadMatrixd;
   tbl.glLoadMatrixf = loader_glLoadMatrixf;
   tbl.glMatrixMode = loader_glMatrixMode;
   tbl.glMultMatrixd = loader_glMultMatrixd;
   tbl.glMultMatrixf = loader_glMultMatrixf;
   tbl.glOrtho = loader_glOrtho;
   tbl.glPopMatrix = loader_glPopMatrix;
   tbl.glPushMatrix = loader_glPushMatrix;
   tbl.glRotated = loader_glRotated;
   tbl.glRotatef = loader_glRotatef;
   tbl.glScaled = loader_glScaled;
   tbl.glScalef = loader_glScalef;
   tbl.glTranslated = loader_glTranslated;
   tbl.glTranslatef = loader_glTranslatef;
   tbl.glViewport = loader_glViewport;

// GL_VERSION_1_1

   tbl.glArrayElement = loader_glArrayElement;
   tbl.glDrawArrays = loader_glDrawArrays;
   tbl.glDrawElements = loader_glDrawElements;
   tbl.glInterleavedArrays = loader_glInterleavedArrays;
   tbl.glDisableClientState = loader_glDisableClientState;
   tbl.glEnableClientState = loader_glEnableClientState;
   tbl.glGetPointerv = loader_glGetPointerv;
   tbl.glColorPointer = loader_glColorPointer;
   tbl.glEdgeFlagPointer = loader_glEdgeFlagPointer;
   tbl.glIndexPointer = loader_glIndexPointer;
   tbl.glNormalPointer = loader_glNormalPointer;
   tbl.glTexCoordPointer = loader_glTexCoordPointer;
   tbl.glVertexPointer = loader_glVertexPointer;
   tbl.glPolygonOffset = loader_glPolygonOffset;
   tbl.glCopyTexImage1D = loader_glCopyTexImage1D;
   tbl.glCopyTexImage2D = loader_glCopyTexImage2D;
   tbl.glCopyTexSubImage1D = loader_glCopyTexSubImage1D;
   tbl.glCopyTexSubImage2D = loader_glCopyTexSubImage2D;
   tbl.glTexSubImage1D = loader_glTexSubImage1D;
   tbl.glTexSubImage2D = loader_glTexSubImage2D;
   tbl.glAreTexturesResident = loader_glAreTexturesResident;
   tbl.glBindTexture = loader_glBindTexture;
   tbl.glDeleteTextures = loader_glDeleteTextures;
   tbl.glGenTextures = loader_glGenTextures;
   tbl.glIsTexture = loader_glIsTexture;
   tbl.glPrioritizeTextures = loader_glPrioritizeTextures;
   tbl.glIndexub = loader_glIndexub;
   tbl.glIndexubv = loader_glIndexubv;
   tbl.glPopClientAttrib = loader_glPopClientAttrib;
   tbl.glPushClientAttrib = loader_glPushClientAttrib;

// GL_VERSION_1_2

   tbl.glBlendColor = loader_glBlendColor;
   tbl.glBlendEquation = loader_glBlendEquation;
   tbl.glDrawRangeElements = loader_glDrawRangeElements;
   tbl.glTexImage3D = loader_glTexImage3D;
   tbl.glTexSubImage3D = loader_glTexSubImage3D;
   tbl.glCopyTexSubImage3D = loader_glCopyTexSubImage3D;

// GL_ARB_imaging

   tbl.glColorTable = loader_glColorTable;
   tbl.glColorTableParameterfv = loader_glColorTableParameterfv;
   tbl.glColorTableParameteriv = loader_glColorTableParameteriv;
   tbl.glCopyColorTable = loader_glCopyColorTable;
   tbl.glGetColorTable = loader_glGetColorTable;
   tbl.glGetColorTableParameterfv = loader_glGetColorTableParameterfv;
   tbl.glGetColorTableParameteriv = loader_glGetColorTableParameteriv;
   tbl.glColorSubTable = loader_glColorSubTable;
   tbl.glCopyColorSubTable = loader_glCopyColorSubTable;
   tbl.glConvolutionFilter1D = loader_glConvolutionFilter1D;
   tbl.glConvolutionFilter2D = loader_glConvolutionFilter2D;
   tbl.glConvolutionParameterf = loader_glConvolutionParameterf;
   tbl.glConvolutionParameterfv = loader_glConvolutionParameterfv;
   tbl.glConvolutionParameteri = loader_glConvolutionParameteri;
   tbl.glConvolutionParameteriv = loader_glConvolutionParameteriv;
   tbl.glCopyConvolutionFilter1D = loader_glCopyConvolutionFilter1D;
   tbl.glCopyConvolutionFilter2D = loader_glCopyConvolutionFilter2D;
   tbl.glGetConvolutionFilter = loader_glGetConvolutionFilter;
   tbl.glGetConvolutionParameterfv = loader_glGetConvolutionParameterfv;
   tbl.glGetConvolutionParameteriv = loader_glGetConvolutionParameteriv;
   tbl.glGetSeparableFilter = loader_glGetSeparableFilter;
   tbl.glSeparableFilter2D = loader_glSeparableFilter2D;
   tbl.glGetHistogram = loader_glGetHistogram;
   tbl.glGetHistogramParameterfv = loader_glGetHistogramParameterfv;
   tbl.glGetHistogramParameteriv = loader_glGetHistogramParameteriv;
   tbl.glGetMinmax = loader_glGetMinmax;
   tbl.glGetMinmaxParameterfv = loader_glGetMinmaxParameterfv;
   tbl.glGetMinmaxParameteriv = loader_glGetMinmaxParameteriv;
   tbl.glHistogram = loader_glHistogram;
   tbl.glMinmax = loader_glMinmax;
   tbl.glResetHistogram = loader_glResetHistogram;
   tbl.glResetMinmax = loader_glResetMinmax;

// GL_VERSION_1_3

   tbl.glActiveTexture = loader_glActiveTexture;
   tbl.glSampleCoverage = loader_glSampleCoverage;
   tbl.glCompressedTexImage3D = loader_glCompressedTexImage3D;
   tbl.glCompressedTexImage2D = loader_glCompressedTexImage2D;
   tbl.glCompressedTexImage1D = loader_glCompressedTexImage1D;
   tbl.glCompressedTexSubImage3D = loader_glCompressedTexSubImage3D;
   tbl.glCompressedTexSubImage2D = loader_glCompressedTexSubImage2D;
   tbl.glCompressedTexSubImage1D = loader_glCompressedTexSubImage1D;
   tbl.glGetCompressedTexImage = loader_glGetCompressedTexImage;
   tbl.glClientActiveTexture = loader_glClientActiveTexture;
   tbl.glMultiTexCoord1d = loader_glMultiTexCoord1d;
   tbl.glMultiTexCoord1dv = loader_glMultiTexCoord1dv;
   tbl.glMultiTexCoord1f = loader_glMultiTexCoord1f;
   tbl.glMultiTexCoord1fv = loader_glMultiTexCoord1fv;
   tbl.glMultiTexCoord1i = loader_glMultiTexCoord1i;
   tbl.glMultiTexCoord1iv = loader_glMultiTexCoord1iv;
   tbl.glMultiTexCoord1s = loader_glMultiTexCoord1s;
   tbl.glMultiTexCoord1sv = loader_glMultiTexCoord1sv;
   tbl.glMultiTexCoord2d = loader_glMultiTexCoord2d;
   tbl.glMultiTexCoord2dv = loader_glMultiTexCoord2dv;
   tbl.glMultiTexCoord2f = loader_glMultiTexCoord2f;
   tbl.glMultiTexCoord2fv = loader_glMultiTexCoord2fv;
   tbl.glMultiTexCoord2i = loader_glMultiTexCoord2i;
   tbl.glMultiTexCoord2iv = loader_glMultiTexCoord2iv;
   tbl.glMultiTexCoord2s = loader_glMultiTexCoord2s;
   tbl.glMultiTexCoord2sv = loader_glMultiTexCoord2sv;
   tbl.glMultiTexCoord3d = loader_glMultiTexCoord3d;
   tbl.glMultiTexCoord3dv = loader_glMultiTexCoord3dv;
   tbl.glMultiTexCoord3f = loader_glMultiTexCoord3f;
   tbl.glMultiTexCoord3fv = loader_glMultiTexCoord3fv;
   tbl.glMultiTexCoord3i = loader_glMultiTexCoord3i;
   tbl.glMultiTexCoord3iv = loader_glMultiTexCoord3iv;
   tbl.glMultiTexCoord3s = loader_glMultiTexCoord3s;
   tbl.glMultiTexCoord3sv = loader_glMultiTexCoord3sv;
   tbl.glMultiTexCoord4d = loader_glMultiTexCoord4d;
   tbl.glMultiTexCoord4dv = loader_glMultiTexCoord4dv;
   tbl.glMultiTexCoord4f = loader_glMultiTexCoord4f;
   tbl.glMultiTexCoord4fv = loader_glMultiTexCoord4fv;
   tbl.glMultiTexCoord4i = loader_glMultiTexCoord4i;
   tbl.glMultiTexCoord4iv = loader_glMultiTexCoord4iv;
   tbl.glMultiTexCoord4s = loader_glMultiTexCoord4s;
   tbl.glMultiTexCoord4sv = loader_glMultiTexCoord4sv;
   tbl.glLoadTransposeMatrixf = loader_glLoadTransposeMatrixf;
   tbl.glLoadTransposeMatrixd = loader_glLoadTransposeMatrixd;
   tbl.glMultTransposeMatrixf = loader_glMultTransposeMatrixf;
   tbl.glMultTransposeMatrixd = loader_glMultTransposeMatrixd;

// GL_VERSION_1_4

   tbl.glBlendFuncSeparate = loader_glBlendFuncSeparate;
   tbl.glMultiDrawArrays = loader_glMultiDrawArrays;
   tbl.glMultiDrawElements = loader_glMultiDrawElements;
   tbl.glPointParameterf = loader_glPointParameterf;
   tbl.glPointParameterfv = loader_glPointParameterfv;
   tbl.glPointParameteri = loader_glPointParameteri;
   tbl.glPointParameteriv = loader_glPointParameteriv;
   tbl.glFogCoordf = loader_glFogCoordf;
   tbl.glFogCoordfv = loader_glFogCoordfv;
   tbl.glFogCoordd = loader_glFogCoordd;
   tbl.glFogCoorddv = loader_glFogCoorddv;
   tbl.glFogCoordPointer = loader_glFogCoordPointer;
   tbl.glSecondaryColor3b = loader_glSecondaryColor3b;
   tbl.glSecondaryColor3bv = loader_glSecondaryColor3bv;
   tbl.glSecondaryColor3d = loader_glSecondaryColor3d;
   tbl.glSecondaryColor3dv = loader_glSecondaryColor3dv;
   tbl.glSecondaryColor3f = loader_glSecondaryColor3f;
   tbl.glSecondaryColor3fv = loader_glSecondaryColor3fv;
   tbl.glSecondaryColor3i = loader_glSecondaryColor3i;
   tbl.glSecondaryColor3iv = loader_glSecondaryColor3iv;
   tbl.glSecondaryColor3s = loader_glSecondaryColor3s;
   tbl.glSecondaryColor3sv = loader_glSecondaryColor3sv;
   tbl.glSecondaryColor3ub = loader_glSecondaryColor3ub;
   tbl.glSecondaryColor3ubv = loader_glSecondaryColor3ubv;
   tbl.glSecondaryColor3ui = loader_glSecondaryColor3ui;
   tbl.glSecondaryColor3uiv = loader_glSecondaryColor3uiv;
   tbl.glSecondaryColor3us = loader_glSecondaryColor3us;
   tbl.glSecondaryColor3usv = loader_glSecondaryColor3usv;
   tbl.glSecondaryColorPointer = loader_glSecondaryColorPointer;
   tbl.glWindowPos2d = loader_glWindowPos2d;
   tbl.glWindowPos2dv = loader_glWindowPos2dv;
   tbl.glWindowPos2f = loader_glWindowPos2f;
   tbl.glWindowPos2fv = loader_glWindowPos2fv;
   tbl.glWindowPos2i = loader_glWindowPos2i;
   tbl.glWindowPos2iv = loader_glWindowPos2iv;
   tbl.glWindowPos2s = loader_glWindowPos2s;
   tbl.glWindowPos2sv = loader_glWindowPos2sv;
   tbl.glWindowPos3d = loader_glWindowPos3d;
   tbl.glWindowPos3dv = loader_glWindowPos3dv;
   tbl.glWindowPos3f = loader_glWindowPos3f;
   tbl.glWindowPos3fv = loader_glWindowPos3fv;
   tbl.glWindowPos3i = loader_glWindowPos3i;
   tbl.glWindowPos3iv = loader_glWindowPos3iv;
   tbl.glWindowPos3s = loader_glWindowPos3s;
   tbl.glWindowPos3sv = loader_glWindowPos3sv;

// GL_VERSION_1_5

   tbl.glGenQueries = loader_glGenQueries;
   tbl.glDeleteQueries = loader_glDeleteQueries;
   tbl.glIsQuery = loader_glIsQuery;
   tbl.glBeginQuery = loader_glBeginQuery;
   tbl.glEndQuery = loader_glEndQuery;
   tbl.glGetQueryiv = loader_glGetQueryiv;
   tbl.glGetQueryObjectiv = loader_glGetQueryObjectiv;
   tbl.glGetQueryObjectuiv = loader_glGetQueryObjectuiv;
   tbl.glBindBuffer = loader_glBindBuffer;
   tbl.glDeleteBuffers = loader_glDeleteBuffers;
   tbl.glGenBuffers = loader_glGenBuffers;
   tbl.glIsBuffer = loader_glIsBuffer;
   tbl.glBufferData = loader_glBufferData;
   tbl.glBufferSubData = loader_glBufferSubData;
   tbl.glGetBufferSubData = loader_glGetBufferSubData;
   tbl.glMapBuffer = loader_glMapBuffer;
   tbl.glUnmapBuffer = loader_glUnmapBuffer;
   tbl.glGetBufferParameteriv = loader_glGetBufferParameteriv;
   tbl.glGetBufferPointerv = loader_glGetBufferPointerv;

// GL_VERSION_2_0

   tbl.glBlendEquationSeparate = loader_glBlendEquationSeparate;
   tbl.glDrawBuffers = loader_glDrawBuffers;
   tbl.glStencilOpSeparate = loader_glStencilOpSeparate;
   tbl.glStencilFuncSeparate = loader_glStencilFuncSeparate;
   tbl.glStencilMaskSeparate = loader_glStencilMaskSeparate;
   tbl.glAttachShader = loader_glAttachShader;
   tbl.glBindAttribLocation = loader_glBindAttribLocation;
   tbl.glCompileShader = loader_glCompileShader;
   tbl.glCreateProgram = loader_glCreateProgram;
   tbl.glCreateShader = loader_glCreateShader;
   tbl.glDeleteProgram = loader_glDeleteProgram;
   tbl.glDeleteShader = loader_glDeleteShader;
   tbl.glDetachShader = loader_glDetachShader;
   tbl.glDisableVertexAttribArray = loader_glDisableVertexAttribArray;
   tbl.glEnableVertexAttribArray = loader_glEnableVertexAttribArray;
   tbl.glGetActiveAttrib = loader_glGetActiveAttrib;
   tbl.glGetActiveUniform = loader_glGetActiveUniform;
   tbl.glGetAttachedShaders = loader_glGetAttachedShaders;
   tbl.glGetAttribLocation = loader_glGetAttribLocation;
   tbl.glGetProgramiv = loader_glGetProgramiv;
   tbl.glGetProgramInfoLog = loader_glGetProgramInfoLog;
   tbl.glGetShaderiv = loader_glGetShaderiv;
   tbl.glGetShaderInfoLog = loader_glGetShaderInfoLog;
   tbl.glGetShaderSource = loader_glGetShaderSource;
   tbl.glGetUniformLocation = loader_glGetUniformLocation;
   tbl.glGetUniformfv = loader_glGetUniformfv;
   tbl.glGetUniformiv = loader_glGetUniformiv;
   tbl.glGetVertexAttribdv = loader_glGetVertexAttribdv;
   tbl.glGetVertexAttribfv = loader_glGetVertexAttribfv;
   tbl.glGetVertexAttribiv = loader_glGetVertexAttribiv;
   tbl.glGetVertexAttribPointerv = loader_glGetVertexAttribPointerv;
   tbl.glIsProgram = loader_glIsProgram;
   tbl.glIsShader = loader_glIsShader;
   tbl.glLinkProgram = loader_glLinkProgram;
   tbl.glShaderSource = loader_glShaderSource;
   tbl.glUseProgram = loader_glUseProgram;
   tbl.glUniform1f = loader_glUniform1f;
   tbl.glUniform2f = loader_glUniform2f;
   tbl.glUniform3f = loader_glUniform3f;
   tbl.glUniform4f = loader_glUniform4f;
   tbl.glUniform1i = loader_glUniform1i;
   tbl.glUniform2i = loader_glUniform2i;
   tbl.glUniform3i = loader_glUniform3i;
   tbl.glUniform4i = loader_glUniform4i;
   tbl.glUniform1fv = loader_glUniform1fv;
   tbl.glUniform2fv = loader_glUniform2fv;
   tbl.glUniform3fv = loader_glUniform3fv;
   tbl.glUniform4fv = loader_glUniform4fv;
   tbl.glUniform1iv = loader_glUniform1iv;
   tbl.glUniform2iv = loader_glUniform2iv;
   tbl.glUniform3iv = loader_glUniform3iv;
   tbl.glUniform4iv = loader_glUniform4iv;
   tbl.glUniformMatrix2fv = loader_glUniformMatrix2fv;
   tbl.glUniformMatrix3fv = loader_glUniformMatrix3fv;
   tbl.glUniformMatrix4fv = loader_glUniformMatrix4fv;
   tbl.glValidateProgram = loader_glValidateProgram;
   tbl.glVertexAttrib1d = loader_glVertexAttrib1d;
   tbl.glVertexAttrib1dv = loader_glVertexAttrib1dv;
   tbl.glVertexAttrib1f = loader_glVertexAttrib1f;
   tbl.glVertexAttrib1fv = loader_glVertexAttrib1fv;
   tbl.glVertexAttrib1s = loader_glVertexAttrib1s;
   tbl.glVertexAttrib1sv = loader_glVertexAttrib1sv;
   tbl.glVertexAttrib2d = loader_glVertexAttrib2d;
   tbl.glVertexAttrib2dv = loader_glVertexAttrib2dv;
   tbl.glVertexAttrib2f = loader_glVertexAttrib2f;
   tbl.glVertexAttrib2fv = loader_glVertexAttrib2fv;
   tbl.glVertexAttrib2s = loader_glVertexAttrib2s;
   tbl.glVertexAttrib2sv = loader_glVertexAttrib2sv;
   tbl.glVertexAttrib3d = loader_glVertexAttrib3d;
   tbl.glVertexAttrib3dv = loader_glVertexAttrib3dv;
   tbl.glVertexAttrib3f = loader_glVertexAttrib3f;
   tbl.glVertexAttrib3fv = loader_glVertexAttrib3fv;
   tbl.glVertexAttrib3s = loader_glVertexAttrib3s;
   tbl.glVertexAttrib3sv = loader_glVertexAttrib3sv;
   tbl.glVertexAttrib4Nbv = loader_glVertexAttrib4Nbv;
   tbl.glVertexAttrib4Niv = loader_glVertexAttrib4Niv;
   tbl.glVertexAttrib4Nsv = loader_glVertexAttrib4Nsv;
   tbl.glVertexAttrib4Nub = loader_glVertexAttrib4Nub;
   tbl.glVertexAttrib4Nubv = loader_glVertexAttrib4Nubv;
   tbl.glVertexAttrib4Nuiv = loader_glVertexAttrib4Nuiv;
   tbl.glVertexAttrib4Nusv = loader_glVertexAttrib4Nusv;
   tbl.glVertexAttrib4bv = loader_glVertexAttrib4bv;
   tbl.glVertexAttrib4d = loader_glVertexAttrib4d;
   tbl.glVertexAttrib4dv = loader_glVertexAttrib4dv;
   tbl.glVertexAttrib4f = loader_glVertexAttrib4f;
   tbl.glVertexAttrib4fv = loader_glVertexAttrib4fv;
   tbl.glVertexAttrib4iv = loader_glVertexAttrib4iv;
   tbl.glVertexAttrib4s = loader_glVertexAttrib4s;
   tbl.glVertexAttrib4sv = loader_glVertexAttrib4sv;
   tbl.glVertexAttrib4ubv = loader_glVertexAttrib4ubv;
   tbl.glVertexAttrib4uiv = loader_glVertexAttrib4uiv;
   tbl.glVertexAttrib4usv = loader_glVertexAttrib4usv;
   tbl.glVertexAttribPointer = loader_glVertexAttribPointer;

// GL_VERSION_2_1

   tbl.glUniformMatrix2x3fv = loader_glUniformMatrix2x3fv;
   tbl.glUniformMatrix3x2fv = loader_glUniformMatrix3x2fv;
   tbl.glUniformMatrix2x4fv = loader_glUniformMatrix2x4fv;
   tbl.glUniformMatrix4x2fv = loader_glUniformMatrix4x2fv;
   tbl.glUniformMatrix3x4fv = loader_glUniformMatrix3x4fv;
   tbl.glUniformMatrix4x3fv = loader_glUniformMatrix4x3fv;

// GL_VERSION_3_0

   tbl.glColorMaski = loader_glColorMaski;
   tbl.glGetBooleani_v = loader_glGetBooleani_v;

// GL_ARB_uniform_buffer_object

   tbl.glGetIntegeri_v = loader_glGetIntegeri_v;

// GL_VERSION_3_0

   tbl.glEnablei = loader_glEnablei;
   tbl.glDisablei = loader_glDisablei;
   tbl.glIsEnabledi = loader_glIsEnabledi;
   tbl.glBeginTransformFeedback = loader_glBeginTransformFeedback;
   tbl.glEndTransformFeedback = loader_glEndTransformFeedback;

// GL_ARB_uniform_buffer_object

   tbl.glBindBufferRange = loader_glBindBufferRange;
   tbl.glBindBufferBase = loader_glBindBufferBase;

// GL_VERSION_3_0

   tbl.glTransformFeedbackVaryings = loader_glTransformFeedbackVaryings;
   tbl.glGetTransformFeedbackVarying = loader_glGetTransformFeedbackVarying;
   tbl.glClampColor = loader_glClampColor;
   tbl.glBeginConditionalRender = loader_glBeginConditionalRender;
   tbl.glEndConditionalRender = loader_glEndConditionalRender;
   tbl.glVertexAttribIPointer = loader_glVertexAttribIPointer;
   tbl.glGetVertexAttribIiv = loader_glGetVertexAttribIiv;
   tbl.glGetVertexAttribIuiv = loader_glGetVertexAttribIuiv;
   tbl.glVertexAttribI1i = loader_glVertexAttribI1i;
   tbl.glVertexAttribI2i = loader_glVertexAttribI2i;
   tbl.glVertexAttribI3i = loader_glVertexAttribI3i;
   tbl.glVertexAttribI4i = loader_glVertexAttribI4i;
   tbl.glVertexAttribI1ui = loader_glVertexAttribI1ui;
   tbl.glVertexAttribI2ui = loader_glVertexAttribI2ui;
   tbl.glVertexAttribI3ui = loader_glVertexAttribI3ui;
   tbl.glVertexAttribI4ui = loader_glVertexAttribI4ui;
   tbl.glVertexAttribI1iv = loader_glVertexAttribI1iv;
   tbl.glVertexAttribI2iv = loader_glVertexAttribI2iv;
   tbl.glVertexAttribI3iv = loader_glVertexAttribI3iv;
   tbl.glVertexAttribI4iv = loader_glVertexAttribI4iv;
   tbl.glVertexAttribI1uiv = loader_glVertexAttribI1uiv;
   tbl.glVertexAttribI2uiv = loader_glVertexAttribI2uiv;
   tbl.glVertexAttribI3uiv = loader_glVertexAttribI3uiv;
   tbl.glVertexAttribI4uiv = loader_glVertexAttribI4uiv;
   tbl.glVertexAttribI4bv = loader_glVertexAttribI4bv;
   tbl.glVertexAttribI4sv = loader_glVertexAttribI4sv;
   tbl.glVertexAttribI4ubv = loader_glVertexAttribI4ubv;
   tbl.glVertexAttribI4usv = loader_glVertexAttribI4usv;
   tbl.glGetUniformuiv = loader_glGetUniformuiv;
   tbl.glBindFragDataLocation = loader_glBindFragDataLocation;
   tbl.glGetFragDataLocation = loader_glGetFragDataLocation;
   tbl.glUniform1ui = loader_glUniform1ui;
   tbl.glUniform2ui = loader_glUniform2ui;
   tbl.glUniform3ui = loader_glUniform3ui;
   tbl.glUniform4ui = loader_glUniform4ui;
   tbl.glUniform1uiv = loader_glUniform1uiv;
   tbl.glUniform2uiv = loader_glUniform2uiv;
   tbl.glUniform3uiv = loader_glUniform3uiv;
   tbl.glUniform4uiv = loader_glUniform4uiv;
   tbl.glTexParameterIiv = loader_glTexParameterIiv;
   tbl.glTexParameterIuiv = loader_glTexParameterIuiv;
   tbl.glGetTexParameterIiv = loader_glGetTexParameterIiv;
   tbl.glGetTexParameterIuiv = loader_glGetTexParameterIuiv;
   tbl.glClearBufferiv = loader_glClearBufferiv;
   tbl.glClearBufferuiv = loader_glClearBufferuiv;
   tbl.glClearBufferfv = loader_glClearBufferfv;
   tbl.glClearBufferfi = loader_glClearBufferfi;
   tbl.glGetStringi = loader_glGetStringi;

// GL_VERSION_3_1

   tbl.glDrawArraysInstanced = loader_glDrawArraysInstanced;
   tbl.glDrawElementsInstanced = loader_glDrawElementsInstanced;
   tbl.glTexBuffer = loader_glTexBuffer;
   tbl.glPrimitiveRestartIndex = loader_glPrimitiveRestartIndex;

// GL_VERSION_3_2

   tbl.glGetInteger64i_v = loader_glGetInteger64i_v;
   tbl.glGetBufferParameteri64v = loader_glGetBufferParameteri64v;
   tbl.glFramebufferTexture = loader_glFramebufferTexture;
   tbl.glFramebufferTextureFace = loader_glFramebufferTextureFace;

// GL_ARB_sampler_objects

   tbl.glGenSamplers = loader_glGenSamplers;
   tbl.glDeleteSamplers = loader_glDeleteSamplers;
   tbl.glIsSampler = loader_glIsSampler;
   tbl.glBindSampler = loader_glBindSampler;
   tbl.glSamplerParameteri = loader_glSamplerParameteri;
   tbl.glSamplerParameterf = loader_glSamplerParameterf;
   tbl.glSamplerParameteriv = loader_glSamplerParameteriv;
   tbl.glSamplerParameterfv = loader_glSamplerParameterfv;
   tbl.glSamplerParameterIiv = loader_glSamplerParameterIiv;
   tbl.glSamplerParameterIuiv = loader_glSamplerParameterIuiv;
   tbl.glGetSamplerParameteriv = loader_glGetSamplerParameteriv;
   tbl.glGetSamplerParameterfv = loader_glGetSamplerParameterfv;
   tbl.glGetSamplerParameterIiv = loader_glGetSamplerParameterIiv;
   tbl.glGetSamplerParameterIuiv = loader_glGetSamplerParameterIuiv;

// GL_ARB_blend_func_extended

   tbl.glBindFragDataLocationIndexed = loader_glBindFragDataLocationIndexed;
   tbl.glGetFragDataIndex = loader_glGetFragDataIndex;

// GL_ARB_timer_query

   tbl.glGetQueryObjecti64v = loader_glGetQueryObjecti64v;
   tbl.glGetQueryObjectui64v = loader_glGetQueryObjectui64v;
   tbl.glQueryCounter = loader_glQueryCounter;

// GL_VERSION_3_3

   tbl.glVertexAttribDivisor = loader_glVertexAttribDivisor;

// GL_ARB_vertex_type_2_10_10_10_rev

   tbl.glVertexP2ui = loader_glVertexP2ui;
   tbl.glVertexP2uiv = loader_glVertexP2uiv;
   tbl.glVertexP3ui = loader_glVertexP3ui;
   tbl.glVertexP3uiv = loader_glVertexP3uiv;
   tbl.glVertexP4ui = loader_glVertexP4ui;
   tbl.glVertexP4uiv = loader_glVertexP4uiv;
   tbl.glTexCoordP1ui = loader_glTexCoordP1ui;
   tbl.glTexCoordP1uiv = loader_glTexCoordP1uiv;
   tbl.glTexCoordP2ui = loader_glTexCoordP2ui;
   tbl.glTexCoordP2uiv = loader_glTexCoordP2uiv;
   tbl.glTexCoordP3ui = loader_glTexCoordP3ui;
   tbl.glTexCoordP3uiv = loader_glTexCoordP3uiv;
   tbl.glTexCoordP4ui = loader_glTexCoordP4ui;
   tbl.glTexCoordP4uiv = loader_glTexCoordP4uiv;
   tbl.glMultiTexCoordP1ui = loader_glMultiTexCoordP1ui;
   tbl.glMultiTexCoordP1uiv = loader_glMultiTexCoordP1uiv;
   tbl.glMultiTexCoordP2ui = loader_glMultiTexCoordP2ui;
   tbl.glMultiTexCoordP2uiv = loader_glMultiTexCoordP2uiv;
   tbl.glMultiTexCoordP3ui = loader_glMultiTexCoordP3ui;
   tbl.glMultiTexCoordP3uiv = loader_glMultiTexCoordP3uiv;
   tbl.glMultiTexCoordP4ui = loader_glMultiTexCoordP4ui;
   tbl.glMultiTexCoordP4uiv = loader_glMultiTexCoordP4uiv;
   tbl.glNormalP3ui = loader_glNormalP3ui;
   tbl.glNormalP3uiv = loader_glNormalP3uiv;
   tbl.glColorP3ui = loader_glColorP3ui;
   tbl.glColorP3uiv = loader_glColorP3uiv;
   tbl.glColorP4ui = loader_glColorP4ui;
   tbl.glColorP4uiv = loader_glColorP4uiv;
   tbl.glSecondaryColorP3ui = loader_glSecondaryColorP3ui;
   tbl.glSecondaryColorP3uiv = loader_glSecondaryColorP3uiv;
   tbl.glVertexAttribP1ui = loader_glVertexAttribP1ui;
   tbl.glVertexAttribP1uiv = loader_glVertexAttribP1uiv;
   tbl.glVertexAttribP2ui = loader_glVertexAttribP2ui;
   tbl.glVertexAttribP2uiv = loader_glVertexAttribP2uiv;
   tbl.glVertexAttribP3ui = loader_glVertexAttribP3ui;
   tbl.glVertexAttribP3uiv = loader_glVertexAttribP3uiv;
   tbl.glVertexAttribP4ui = loader_glVertexAttribP4ui;
   tbl.glVertexAttribP4uiv = loader_glVertexAttribP4uiv;

// GL_VERSION_4_0

   tbl.glBlendEquationi = loader_glBlendEquationi;
   tbl.glBlendEquationSeparatei = loader_glBlendEquationSeparatei;
   tbl.glBlendFunci = loader_glBlendFunci;
   tbl.glBlendFuncSeparatei = loader_glBlendFuncSeparatei;

// GL_ARB_draw_indirect

   tbl.glDrawArraysIndirect = loader_glDrawArraysIndirect;
   tbl.glDrawElementsIndirect = loader_glDrawElementsIndirect;

// GL_ARB_gpu_shader_fp64

   tbl.glUniform1d = loader_glUniform1d;
   tbl.glUniform2d = loader_glUniform2d;
   tbl.glUniform3d = loader_glUniform3d;
   tbl.glUniform4d = loader_glUniform4d;
   tbl.glUniform1dv = loader_glUniform1dv;
   tbl.glUniform2dv = loader_glUniform2dv;
   tbl.glUniform3dv = loader_glUniform3dv;
   tbl.glUniform4dv = loader_glUniform4dv;
   tbl.glUniformMatrix2dv = loader_glUniformMatrix2dv;
   tbl.glUniformMatrix3dv = loader_glUniformMatrix3dv;
   tbl.glUniformMatrix4dv = loader_glUniformMatrix4dv;
   tbl.glUniformMatrix2x3dv = loader_glUniformMatrix2x3dv;
   tbl.glUniformMatrix2x4dv = loader_glUniformMatrix2x4dv;
   tbl.glUniformMatrix3x2dv = loader_glUniformMatrix3x2dv;
   tbl.glUniformMatrix3x4dv = loader_glUniformMatrix3x4dv;
   tbl.glUniformMatrix4x2dv = loader_glUniformMatrix4x2dv;
   tbl.glUniformMatrix4x3dv = loader_glUniformMatrix4x3dv;
   tbl.glGetUniformdv = loader_glGetUniformdv;

// GL_ARB_sample_shading

   tbl.glMinSampleShading = loader_glMinSampleShading;

// GL_ARB_tessellation_shader

   tbl.glPatchParameteri = loader_glPatchParameteri;
   tbl.glPatchParameterfv = loader_glPatchParameterfv;

// GL_ARB_transform_feedback2

   tbl.glGenTransformFeedbacks = loader_glGenTransformFeedbacks;
   tbl.glDeleteTransformFeedbacks = loader_glDeleteTransformFeedbacks;
   tbl.glBindTransformFeedback = loader_glBindTransformFeedback;
   tbl.glIsTransformFeedback = loader_glIsTransformFeedback;
   tbl.glPauseTransformFeedback = loader_glPauseTransformFeedback;
   tbl.glResumeTransformFeedback = loader_glResumeTransformFeedback;
   tbl.glDrawTransformFeedback = loader_glDrawTransformFeedback;

// GL_ARB_transform_feedback3

   tbl.glDrawTransformFeedbackStream = loader_glDrawTransformFeedbackStream;
   tbl.glBeginQueryIndexed = loader_glBeginQueryIndexed;
   tbl.glEndQueryIndexed = loader_glEndQueryIndexed;
   tbl.glGetQueryIndexediv = loader_glGetQueryIndexediv;

// GL_ARB_shader_subroutine

   tbl.glGetSubroutineUniformLocation = loader_glGetSubroutineUniformLocation;
   tbl.glGetSubroutineIndex = loader_glGetSubroutineIndex;
   tbl.glGetActiveSubroutineUniformiv = loader_glGetActiveSubroutineUniformiv;
   tbl.glGetActiveSubroutineUniformName = loader_glGetActiveSubroutineUniformName;
   tbl.glGetActiveSubroutineName = loader_glGetActiveSubroutineName;
   tbl.glUniformSubroutinesuiv = loader_glUniformSubroutinesuiv;
   tbl.glGetUniformSubroutineuiv = loader_glGetUniformSubroutineuiv;
   tbl.glGetProgramStageiv = loader_glGetProgramStageiv;

// GL_ARB_vertex_attrib_64bit

   tbl.glVertexAttribL1d = loader_glVertexAttribL1d;
   tbl.glVertexAttribL2d = loader_glVertexAttribL2d;
   tbl.glVertexAttribL3d = loader_glVertexAttribL3d;
   tbl.glVertexAttribL4d = loader_glVertexAttribL4d;
   tbl.glVertexAttribL1dv = loader_glVertexAttribL1dv;
   tbl.glVertexAttribL2dv = loader_glVertexAttribL2dv;
   tbl.glVertexAttribL3dv = loader_glVertexAttribL3dv;
   tbl.glVertexAttribL4dv = loader_glVertexAttribL4dv;
   tbl.glVertexAttribLPointer = loader_glVertexAttribLPointer;
   tbl.glGetVertexAttribLdv = loader_glGetVertexAttribLdv;

// GL_ARB_ES2_compatibility

   tbl.glReleaseShaderCompiler = loader_glReleaseShaderCompiler;
   tbl.glShaderBinary = loader_glShaderBinary;
   tbl.glGetShaderPrecisionFormat = loader_glGetShaderPrecisionFormat;
   tbl.glDepthRangef = loader_glDepthRangef;
   tbl.glClearDepthf = loader_glClearDepthf;

// GL_ARB_get_program_binary

   tbl.glGetProgramBinary = loader_glGetProgramBinary;
   tbl.glProgramBinary = loader_glProgramBinary;
   tbl.glProgramParameteri = loader_glProgramParameteri;

// GL_ARB_viewport_array

   tbl.glViewportArrayv = loader_glViewportArrayv;
   tbl.glViewportIndexedf = loader_glViewportIndexedf;
   tbl.glViewportIndexedfv = loader_glViewportIndexedfv;
   tbl.glScissorArrayv = loader_glScissorArrayv;
   tbl.glScissorIndexed = loader_glScissorIndexed;
   tbl.glScissorIndexedv = loader_glScissorIndexedv;
   tbl.glDepthRangeArrayv = loader_glDepthRangeArrayv;
   tbl.glDepthRangeIndexed = loader_glDepthRangeIndexed;
   tbl.glGetFloati_v = loader_glGetFloati_v;
   tbl.glGetDoublei_v = loader_glGetDoublei_v;

// GL_ARB_separate_shader_objects

   tbl.glActiveShaderProgram = loader_glActiveShaderProgram;
   tbl.glUseProgramStages = loader_glUseProgramStages;
   tbl.glCreateShaderProgramv = loader_glCreateShaderProgramv;
   tbl.glBindProgramPipeline = loader_glBindProgramPipeline;
   tbl.glDeleteProgramPipelines = loader_glDeleteProgramPipelines;
   tbl.glGenProgramPipelines = loader_glGenProgramPipelines;
   tbl.glIsProgramPipeline = loader_glIsProgramPipeline;
   tbl.glGetProgramPipelineiv = loader_glGetProgramPipelineiv;
   tbl.glValidateProgramPipeline = loader_glValidateProgramPipeline;
   tbl.glGetProgramPipelineInfoLog = loader_glGetProgramPipelineInfoLog;
   tbl.glProgramUniform1f = loader_glProgramUniform1f;
   tbl.glProgramUniform2f = loader_glProgramUniform2f;
   tbl.glProgramUniform3f = loader_glProgramUniform3f;
   tbl.glProgramUniform4f = loader_glProgramUniform4f;
   tbl.glProgramUniform1i = loader_glProgramUniform1i;
   tbl.glProgramUniform2i = loader_glProgramUniform2i;
   tbl.glProgramUniform3i = loader_glProgramUniform3i;
   tbl.glProgramUniform4i = loader_glProgramUniform4i;
   tbl.glProgramUniform1fv = loader_glProgramUniform1fv;
   tbl.glProgramUniform2fv = loader_glProgramUniform2fv;
   tbl.glProgramUniform3fv = loader_glProgramUniform3fv;
   tbl.glProgramUniform4fv = loader_glProgramUniform4fv;
   tbl.glProgramUniform1iv = loader_glProgramUniform1iv;
   tbl.glProgramUniform2iv = loader_glProgramUniform2iv;
   tbl.glProgramUniform3iv = loader_glProgramUniform3iv;
   tbl.glProgramUniform4iv = loader_glProgramUniform4iv;
   tbl.glProgramUniformMatrix2fv = loader_glProgramUniformMatrix2fv;
   tbl.glProgramUniformMatrix3fv = loader_glProgramUniformMatrix3fv;
   tbl.glProgramUniformMatrix4fv = loader_glProgramUniformMatrix4fv;
   tbl.glProgramUniformMatrix2x3fv = loader_glProgramUniformMatrix2x3fv;
   tbl.glProgramUniformMatrix3x2fv = loader_glProgramUniformMatrix3x2fv;
   tbl.glProgramUniformMatrix2x4fv = loader_glProgramUniformMatrix2x4fv;
   tbl.glProgramUniformMatrix4x2fv = loader_glProgramUniformMatrix4x2fv;
   tbl.glProgramUniformMatrix3x4fv = loader_glProgramUniformMatrix3x4fv;
   tbl.glProgramUniformMatrix4x3fv = loader_glProgramUniformMatrix4x3fv;
   tbl.glProgramUniform1ui = loader_glProgramUniform1ui;
   tbl.glProgramUniform2ui = loader_glProgramUniform2ui;
   tbl.glProgramUniform3ui = loader_glProgramUniform3ui;
   tbl.glProgramUniform4ui = loader_glProgramUniform4ui;
   tbl.glProgramUniform1uiv = loader_glProgramUniform1uiv;
   tbl.glProgramUniform2uiv = loader_glProgramUniform2uiv;
   tbl.glProgramUniform3uiv = loader_glProgramUniform3uiv;
   tbl.glProgramUniform4uiv = loader_glProgramUniform4uiv;
   tbl.glProgramUniform1d = loader_glProgramUniform1d;
   tbl.glProgramUniform2d = loader_glProgramUniform2d;
   tbl.glProgramUniform3d = loader_glProgramUniform3d;
   tbl.glProgramUniform4d = loader_glProgramUniform4d;
   tbl.glProgramUniform1dv = loader_glProgramUniform1dv;
   tbl.glProgramUniform2dv = loader_glProgramUniform2dv;
   tbl.glProgramUniform3dv = loader_glProgramUniform3dv;
   tbl.glProgramUniform4dv = loader_glProgramUniform4dv;
   tbl.glProgramUniformMatrix2dv = loader_glProgramUniformMatrix2dv;
   tbl.glProgramUniformMatrix3dv = loader_glProgramUniformMatrix3dv;
   tbl.glProgramUniformMatrix4dv = loader_glProgramUniformMatrix4dv;
   tbl.glProgramUniformMatrix2x3dv = loader_glProgramUniformMatrix2x3dv;
   tbl.glProgramUniformMatrix2x4dv = loader_glProgramUniformMatrix2x4dv;
   tbl.glProgramUniformMatrix3x2dv = loader_glProgramUniformMatrix3x2dv;
   tbl.glProgramUniformMatrix3x4dv = loader_glProgramUniformMatrix3x4dv;
   tbl.glProgramUniformMatrix4x2dv = loader_glProgramUniformMatrix4x2dv;
   tbl.glProgramUniformMatrix4x3dv = loader_glProgramUniformMatrix4x3dv;

// GL_ARB_multitexture

   tbl.glActiveTextureARB = loader_glActiveTextureARB;
   tbl.glClientActiveTextureARB = loader_glClientActiveTextureARB;
   tbl.glMultiTexCoord1dARB = loader_glMultiTexCoord1dARB;
   tbl.glMultiTexCoord1dvARB = loader_glMultiTexCoord1dvARB;
   tbl.glMultiTexCoord1fARB = loader_glMultiTexCoord1fARB;
   tbl.glMultiTexCoord1fvARB = loader_glMultiTexCoord1fvARB;
   tbl.glMultiTexCoord1iARB = loader_glMultiTexCoord1iARB;
   tbl.glMultiTexCoord1ivARB = loader_glMultiTexCoord1ivARB;
   tbl.glMultiTexCoord1sARB = loader_glMultiTexCoord1sARB;
   tbl.glMultiTexCoord1svARB = loader_glMultiTexCoord1svARB;
   tbl.glMultiTexCoord2dARB = loader_glMultiTexCoord2dARB;
   tbl.glMultiTexCoord2dvARB = loader_glMultiTexCoord2dvARB;
   tbl.glMultiTexCoord2fARB = loader_glMultiTexCoord2fARB;
   tbl.glMultiTexCoord2fvARB = loader_glMultiTexCoord2fvARB;
   tbl.glMultiTexCoord2iARB = loader_glMultiTexCoord2iARB;
   tbl.glMultiTexCoord2ivARB = loader_glMultiTexCoord2ivARB;
   tbl.glMultiTexCoord2sARB = loader_glMultiTexCoord2sARB;
   tbl.glMultiTexCoord2svARB = loader_glMultiTexCoord2svARB;
   tbl.glMultiTexCoord3dARB = loader_glMultiTexCoord3dARB;
   tbl.glMultiTexCoord3dvARB = loader_glMultiTexCoord3dvARB;
   tbl.glMultiTexCoord3fARB = loader_glMultiTexCoord3fARB;
   tbl.glMultiTexCoord3fvARB = loader_glMultiTexCoord3fvARB;
   tbl.glMultiTexCoord3iARB = loader_glMultiTexCoord3iARB;
   tbl.glMultiTexCoord3ivARB = loader_glMultiTexCoord3ivARB;
   tbl.glMultiTexCoord3sARB = loader_glMultiTexCoord3sARB;
   tbl.glMultiTexCoord3svARB = loader_glMultiTexCoord3svARB;
   tbl.glMultiTexCoord4dARB = loader_glMultiTexCoord4dARB;
   tbl.glMultiTexCoord4dvARB = loader_glMultiTexCoord4dvARB;
   tbl.glMultiTexCoord4fARB = loader_glMultiTexCoord4fARB;
   tbl.glMultiTexCoord4fvARB = loader_glMultiTexCoord4fvARB;
   tbl.glMultiTexCoord4iARB = loader_glMultiTexCoord4iARB;
   tbl.glMultiTexCoord4ivARB = loader_glMultiTexCoord4ivARB;
   tbl.glMultiTexCoord4sARB = loader_glMultiTexCoord4sARB;
   tbl.glMultiTexCoord4svARB = loader_glMultiTexCoord4svARB;

// GL_ARB_transpose_matrix

   tbl.glLoadTransposeMatrixfARB = loader_glLoadTransposeMatrixfARB;
   tbl.glLoadTransposeMatrixdARB = loader_glLoadTransposeMatrixdARB;
   tbl.glMultTransposeMatrixfARB = loader_glMultTransposeMatrixfARB;
   tbl.glMultTransposeMatrixdARB = loader_glMultTransposeMatrixdARB;

// GL_ARB_multisample

   tbl.glSampleCoverageARB = loader_glSampleCoverageARB;

// GL_ARB_texture_compression

   tbl.glCompressedTexImage3DARB = loader_glCompressedTexImage3DARB;
   tbl.glCompressedTexImage2DARB = loader_glCompressedTexImage2DARB;
   tbl.glCompressedTexImage1DARB = loader_glCompressedTexImage1DARB;
   tbl.glCompressedTexSubImage3DARB = loader_glCompressedTexSubImage3DARB;
   tbl.glCompressedTexSubImage2DARB = loader_glCompressedTexSubImage2DARB;
   tbl.glCompressedTexSubImage1DARB = loader_glCompressedTexSubImage1DARB;
   tbl.glGetCompressedTexImageARB = loader_glGetCompressedTexImageARB;

// GL_ARB_point_parameters

   tbl.glPointParameterfARB = loader_glPointParameterfARB;
   tbl.glPointParameterfvARB = loader_glPointParameterfvARB;

// GL_ARB_vertex_blend

   tbl.glWeightbvARB = loader_glWeightbvARB;
   tbl.glWeightsvARB = loader_glWeightsvARB;
   tbl.glWeightivARB = loader_glWeightivARB;
   tbl.glWeightfvARB = loader_glWeightfvARB;
   tbl.glWeightdvARB = loader_glWeightdvARB;
   tbl.glWeightubvARB = loader_glWeightubvARB;
   tbl.glWeightusvARB = loader_glWeightusvARB;
   tbl.glWeightuivARB = loader_glWeightuivARB;
   tbl.glWeightPointerARB = loader_glWeightPointerARB;
   tbl.glVertexBlendARB = loader_glVertexBlendARB;

// GL_ARB_matrix_palette

   tbl.glCurrentPaletteMatrixARB = loader_glCurrentPaletteMatrixARB;
   tbl.glMatrixIndexubvARB = loader_glMatrixIndexubvARB;
   tbl.glMatrixIndexusvARB = loader_glMatrixIndexusvARB;
   tbl.glMatrixIndexuivARB = loader_glMatrixIndexuivARB;
   tbl.glMatrixIndexPointerARB = loader_glMatrixIndexPointerARB;

// GL_ARB_window_pos

   tbl.glWindowPos2dARB = loader_glWindowPos2dARB;
   tbl.glWindowPos2dvARB = loader_glWindowPos2dvARB;
   tbl.glWindowPos2fARB = loader_glWindowPos2fARB;
   tbl.glWindowPos2fvARB = loader_glWindowPos2fvARB;
   tbl.glWindowPos2iARB = loader_glWindowPos2iARB;
   tbl.glWindowPos2ivARB = loader_glWindowPos2ivARB;
   tbl.glWindowPos2sARB = loader_glWindowPos2sARB;
   tbl.glWindowPos2svARB = loader_glWindowPos2svARB;
   tbl.glWindowPos3dARB = loader_glWindowPos3dARB;
   tbl.glWindowPos3dvARB = loader_glWindowPos3dvARB;
   tbl.glWindowPos3fARB = loader_glWindowPos3fARB;
   tbl.glWindowPos3fvARB = loader_glWindowPos3fvARB;
   tbl.glWindowPos3iARB = loader_glWindowPos3iARB;
   tbl.glWindowPos3ivARB = loader_glWindowPos3ivARB;
   tbl.glWindowPos3sARB = loader_glWindowPos3sARB;
   tbl.glWindowPos3svARB = loader_glWindowPos3svARB;

// GL_ARB_vertex_program

   tbl.glVertexAttrib1dARB = loader_glVertexAttrib1dARB;
   tbl.glVertexAttrib1dvARB = loader_glVertexAttrib1dvARB;
   tbl.glVertexAttrib1fARB = loader_glVertexAttrib1fARB;
   tbl.glVertexAttrib1fvARB = loader_glVertexAttrib1fvARB;
   tbl.glVertexAttrib1sARB = loader_glVertexAttrib1sARB;
   tbl.glVertexAttrib1svARB = loader_glVertexAttrib1svARB;
   tbl.glVertexAttrib2dARB = loader_glVertexAttrib2dARB;
   tbl.glVertexAttrib2dvARB = loader_glVertexAttrib2dvARB;
   tbl.glVertexAttrib2fARB = loader_glVertexAttrib2fARB;
   tbl.glVertexAttrib2fvARB = loader_glVertexAttrib2fvARB;
   tbl.glVertexAttrib2sARB = loader_glVertexAttrib2sARB;
   tbl.glVertexAttrib2svARB = loader_glVertexAttrib2svARB;
   tbl.glVertexAttrib3dARB = loader_glVertexAttrib3dARB;
   tbl.glVertexAttrib3dvARB = loader_glVertexAttrib3dvARB;
   tbl.glVertexAttrib3fARB = loader_glVertexAttrib3fARB;
   tbl.glVertexAttrib3fvARB = loader_glVertexAttrib3fvARB;
   tbl.glVertexAttrib3sARB = loader_glVertexAttrib3sARB;
   tbl.glVertexAttrib3svARB = loader_glVertexAttrib3svARB;
   tbl.glVertexAttrib4NbvARB = loader_glVertexAttrib4NbvARB;
   tbl.glVertexAttrib4NivARB = loader_glVertexAttrib4NivARB;
   tbl.glVertexAttrib4NsvARB = loader_glVertexAttrib4NsvARB;
   tbl.glVertexAttrib4NubARB = loader_glVertexAttrib4NubARB;
   tbl.glVertexAttrib4NubvARB = loader_glVertexAttrib4NubvARB;
   tbl.glVertexAttrib4NuivARB = loader_glVertexAttrib4NuivARB;
   tbl.glVertexAttrib4NusvARB = loader_glVertexAttrib4NusvARB;
   tbl.glVertexAttrib4bvARB = loader_glVertexAttrib4bvARB;
   tbl.glVertexAttrib4dARB = loader_glVertexAttrib4dARB;
   tbl.glVertexAttrib4dvARB = loader_glVertexAttrib4dvARB;
   tbl.glVertexAttrib4fARB = loader_glVertexAttrib4fARB;
   tbl.glVertexAttrib4fvARB = loader_glVertexAttrib4fvARB;
   tbl.glVertexAttrib4ivARB = loader_glVertexAttrib4ivARB;
   tbl.glVertexAttrib4sARB = loader_glVertexAttrib4sARB;
   tbl.glVertexAttrib4svARB = loader_glVertexAttrib4svARB;
   tbl.glVertexAttrib4ubvARB = loader_glVertexAttrib4ubvARB;
   tbl.glVertexAttrib4uivARB = loader_glVertexAttrib4uivARB;
   tbl.glVertexAttrib4usvARB = loader_glVertexAttrib4usvARB;
   tbl.glVertexAttribPointerARB = loader_glVertexAttribPointerARB;
   tbl.glEnableVertexAttribArrayARB = loader_glEnableVertexAttribArrayARB;
   tbl.glDisableVertexAttribArrayARB = loader_glDisableVertexAttribArrayARB;
   tbl.glProgramStringARB = loader_glProgramStringARB;
   tbl.glBindProgramARB = loader_glBindProgramARB;
   tbl.glDeleteProgramsARB = loader_glDeleteProgramsARB;
   tbl.glGenProgramsARB = loader_glGenProgramsARB;
   tbl.glProgramEnvParameter4dARB = loader_glProgramEnvParameter4dARB;
   tbl.glProgramEnvParameter4dvARB = loader_glProgramEnvParameter4dvARB;
   tbl.glProgramEnvParameter4fARB = loader_glProgramEnvParameter4fARB;
   tbl.glProgramEnvParameter4fvARB = loader_glProgramEnvParameter4fvARB;
   tbl.glProgramLocalParameter4dARB = loader_glProgramLocalParameter4dARB;
   tbl.glProgramLocalParameter4dvARB = loader_glProgramLocalParameter4dvARB;
   tbl.glProgramLocalParameter4fARB = loader_glProgramLocalParameter4fARB;
   tbl.glProgramLocalParameter4fvARB = loader_glProgramLocalParameter4fvARB;
   tbl.glGetProgramEnvParameterdvARB = loader_glGetProgramEnvParameterdvARB;
   tbl.glGetProgramEnvParameterfvARB = loader_glGetProgramEnvParameterfvARB;
   tbl.glGetProgramLocalParameterdvARB = loader_glGetProgramLocalParameterdvARB;
   tbl.glGetProgramLocalParameterfvARB = loader_glGetProgramLocalParameterfvARB;
   tbl.glGetProgramivARB = loader_glGetProgramivARB;
   tbl.glGetProgramStringARB = loader_glGetProgramStringARB;
   tbl.glGetVertexAttribdvARB = loader_glGetVertexAttribdvARB;
   tbl.glGetVertexAttribfvARB = loader_glGetVertexAttribfvARB;
   tbl.glGetVertexAttribivARB = loader_glGetVertexAttribivARB;
   tbl.glGetVertexAttribPointervARB = loader_glGetVertexAttribPointervARB;
   tbl.glIsProgramARB = loader_glIsProgramARB;

// GL_ARB_vertex_buffer_object

   tbl.glBindBufferARB = loader_glBindBufferARB;
   tbl.glDeleteBuffersARB = loader_glDeleteBuffersARB;
   tbl.glGenBuffersARB = loader_glGenBuffersARB;
   tbl.glIsBufferARB = loader_glIsBufferARB;
   tbl.glBufferDataARB = loader_glBufferDataARB;
   tbl.glBufferSubDataARB = loader_glBufferSubDataARB;
   tbl.glGetBufferSubDataARB = loader_glGetBufferSubDataARB;
   tbl.glMapBufferARB = loader_glMapBufferARB;
   tbl.glUnmapBufferARB = loader_glUnmapBufferARB;
   tbl.glGetBufferParameterivARB = loader_glGetBufferParameterivARB;
   tbl.glGetBufferPointervARB = loader_glGetBufferPointervARB;

// GL_ARB_occlusion_query

   tbl.glGenQueriesARB = loader_glGenQueriesARB;
   tbl.glDeleteQueriesARB = loader_glDeleteQueriesARB;
   tbl.glIsQueryARB = loader_glIsQueryARB;
   tbl.glBeginQueryARB = loader_glBeginQueryARB;
   tbl.glEndQueryARB = loader_glEndQueryARB;
   tbl.glGetQueryivARB = loader_glGetQueryivARB;
   tbl.glGetQueryObjectivARB = loader_glGetQueryObjectivARB;
   tbl.glGetQueryObjectuivARB = loader_glGetQueryObjectuivARB;

// GL_ARB_shader_objects

   tbl.glDeleteObjectARB = loader_glDeleteObjectARB;
   tbl.glGetHandleARB = loader_glGetHandleARB;
   tbl.glDetachObjectARB = loader_glDetachObjectARB;
   tbl.glCreateShaderObjectARB = loader_glCreateShaderObjectARB;
   tbl.glShaderSourceARB = loader_glShaderSourceARB;
   tbl.glCompileShaderARB = loader_glCompileShaderARB;
   tbl.glCreateProgramObjectARB = loader_glCreateProgramObjectARB;
   tbl.glAttachObjectARB = loader_glAttachObjectARB;
   tbl.glLinkProgramARB = loader_glLinkProgramARB;
   tbl.glUseProgramObjectARB = loader_glUseProgramObjectARB;
   tbl.glValidateProgramARB = loader_glValidateProgramARB;
   tbl.glUniform1fARB = loader_glUniform1fARB;
   tbl.glUniform2fARB = loader_glUniform2fARB;
   tbl.glUniform3fARB = loader_glUniform3fARB;
   tbl.glUniform4fARB = loader_glUniform4fARB;
   tbl.glUniform1iARB = loader_glUniform1iARB;
   tbl.glUniform2iARB = loader_glUniform2iARB;
   tbl.glUniform3iARB = loader_glUniform3iARB;
   tbl.glUniform4iARB = loader_glUniform4iARB;
   tbl.glUniform1fvARB = loader_glUniform1fvARB;
   tbl.glUniform2fvARB = loader_glUniform2fvARB;
   tbl.glUniform3fvARB = loader_glUniform3fvARB;
   tbl.glUniform4fvARB = loader_glUniform4fvARB;
   tbl.glUniform1ivARB = loader_glUniform1ivARB;
   tbl.glUniform2ivARB = loader_glUniform2ivARB;
   tbl.glUniform3ivARB = loader_glUniform3ivARB;
   tbl.glUniform4ivARB = loader_glUniform4ivARB;
   tbl.glUniformMatrix2fvARB = loader_glUniformMatrix2fvARB;
   tbl.glUniformMatrix3fvARB = loader_glUniformMatrix3fvARB;
   tbl.glUniformMatrix4fvARB = loader_glUniformMatrix4fvARB;
   tbl.glGetObjectParameterfvARB = loader_glGetObjectParameterfvARB;
   tbl.glGetObjectParameterivARB = loader_glGetObjectParameterivARB;
   tbl.glGetInfoLogARB = loader_glGetInfoLogARB;
   tbl.glGetAttachedObjectsARB = loader_glGetAttachedObjectsARB;
   tbl.glGetUniformLocationARB = loader_glGetUniformLocationARB;
   tbl.glGetActiveUniformARB = loader_glGetActiveUniformARB;
   tbl.glGetUniformfvARB = loader_glGetUniformfvARB;
   tbl.glGetUniformivARB = loader_glGetUniformivARB;
   tbl.glGetShaderSourceARB = loader_glGetShaderSourceARB;

// GL_ARB_vertex_shader

   tbl.glBindAttribLocationARB = loader_glBindAttribLocationARB;
   tbl.glGetActiveAttribARB = loader_glGetActiveAttribARB;
   tbl.glGetAttribLocationARB = loader_glGetAttribLocationARB;

// GL_ARB_draw_buffers

   tbl.glDrawBuffersARB = loader_glDrawBuffersARB;

// GL_ARB_color_buffer_float

   tbl.glClampColorARB = loader_glClampColorARB;

// GL_ARB_draw_instanced

   tbl.glDrawArraysInstancedARB = loader_glDrawArraysInstancedARB;
   tbl.glDrawElementsInstancedARB = loader_glDrawElementsInstancedARB;

// GL_ARB_framebuffer_object

   tbl.glIsRenderbuffer = loader_glIsRenderbuffer;
   tbl.glBindRenderbuffer = loader_glBindRenderbuffer;
   tbl.glDeleteRenderbuffers = loader_glDeleteRenderbuffers;
   tbl.glGenRenderbuffers = loader_glGenRenderbuffers;
   tbl.glRenderbufferStorage = loader_glRenderbufferStorage;
   tbl.glGetRenderbufferParameteriv = loader_glGetRenderbufferParameteriv;
   tbl.glIsFramebuffer = loader_glIsFramebuffer;
   tbl.glBindFramebuffer = loader_glBindFramebuffer;
   tbl.glDeleteFramebuffers = loader_glDeleteFramebuffers;
   tbl.glGenFramebuffers = loader_glGenFramebuffers;
   tbl.glCheckFramebufferStatus = loader_glCheckFramebufferStatus;
   tbl.glFramebufferTexture1D = loader_glFramebufferTexture1D;
   tbl.glFramebufferTexture2D = loader_glFramebufferTexture2D;
   tbl.glFramebufferTexture3D = loader_glFramebufferTexture3D;
   tbl.glFramebufferRenderbuffer = loader_glFramebufferRenderbuffer;
   tbl.glGetFramebufferAttachmentParameteriv = loader_glGetFramebufferAttachmentParameteriv;
   tbl.glGenerateMipmap = loader_glGenerateMipmap;
   tbl.glBlitFramebuffer = loader_glBlitFramebuffer;
   tbl.glRenderbufferStorageMultisample = loader_glRenderbufferStorageMultisample;
   tbl.glFramebufferTextureLayer = loader_glFramebufferTextureLayer;

// GL_ARB_geometry_shader4

   tbl.glProgramParameteriARB = loader_glProgramParameteriARB;
   tbl.glFramebufferTextureARB = loader_glFramebufferTextureARB;
   tbl.glFramebufferTextureLayerARB = loader_glFramebufferTextureLayerARB;
   tbl.glFramebufferTextureFaceARB = loader_glFramebufferTextureFaceARB;

// GL_ARB_instanced_arrays

   tbl.glVertexAttribDivisorARB = loader_glVertexAttribDivisorARB;

// GL_ARB_map_buffer_range

   tbl.glMapBufferRange = loader_glMapBufferRange;
   tbl.glFlushMappedBufferRange = loader_glFlushMappedBufferRange;

// GL_ARB_texture_buffer_object

   tbl.glTexBufferARB = loader_glTexBufferARB;

// GL_ARB_vertex_array_object

   tbl.glBindVertexArray = loader_glBindVertexArray;
   tbl.glDeleteVertexArrays = loader_glDeleteVertexArrays;
   tbl.glGenVertexArrays = loader_glGenVertexArrays;
   tbl.glIsVertexArray = loader_glIsVertexArray;

// GL_ARB_uniform_buffer_object

   tbl.glGetUniformIndices = loader_glGetUniformIndices;
   tbl.glGetActiveUniformsiv = loader_glGetActiveUniformsiv;
   tbl.glGetActiveUniformName = loader_glGetActiveUniformName;
   tbl.glGetUniformBlockIndex = loader_glGetUniformBlockIndex;
   tbl.glGetActiveUniformBlockiv = loader_glGetActiveUniformBlockiv;
   tbl.glGetActiveUniformBlockName = loader_glGetActiveUniformBlockName;
   tbl.glUniformBlockBinding = loader_glUniformBlockBinding;

// GL_ARB_copy_buffer

   tbl.glCopyBufferSubData = loader_glCopyBufferSubData;

// GL_ARB_draw_elements_base_vertex

   tbl.glDrawElementsBaseVertex = loader_glDrawElementsBaseVertex;
   tbl.glDrawRangeElementsBaseVertex = loader_glDrawRangeElementsBaseVertex;
   tbl.glDrawElementsInstancedBaseVertex = loader_glDrawElementsInstancedBaseVertex;
   tbl.glMultiDrawElementsBaseVertex = loader_glMultiDrawElementsBaseVertex;

// GL_ARB_provoking_vertex

   tbl.glProvokingVertex = loader_glProvokingVertex;

// GL_ARB_sync

   tbl.glFenceSync = loader_glFenceSync;
   tbl.glIsSync = loader_glIsSync;
   tbl.glDeleteSync = loader_glDeleteSync;
   tbl.glClientWaitSync = loader_glClientWaitSync;
   tbl.glWaitSync = loader_glWaitSync;
   tbl.glGetInteger64v = loader_glGetInteger64v;
   tbl.glGetSynciv = loader_glGetSynciv;

// GL_ARB_texture_multisample

   tbl.glTexImage2DMultisample = loader_glTexImage2DMultisample;
   tbl.glTexImage3DMultisample = loader_glTexImage3DMultisample;
   tbl.glGetMultisamplefv = loader_glGetMultisamplefv;
   tbl.glSampleMaski = loader_glSampleMaski;

// GL_ARB_draw_buffers_blend

   tbl.glBlendEquationiARB = loader_glBlendEquationiARB;
   tbl.glBlendEquationSeparateiARB = loader_glBlendEquationSeparateiARB;
   tbl.glBlendFunciARB = loader_glBlendFunciARB;
   tbl.glBlendFuncSeparateiARB = loader_glBlendFuncSeparateiARB;

// GL_ARB_sample_shading

   tbl.glMinSampleShadingARB = loader_glMinSampleShadingARB;

// GL_ARB_shading_language_include

   tbl.glNamedStringARB = loader_glNamedStringARB;
   tbl.glDeleteNamedStringARB = loader_glDeleteNamedStringARB;
   tbl.glCompileShaderIncludeARB = loader_glCompileShaderIncludeARB;
   tbl.glIsNamedStringARB = loader_glIsNamedStringARB;
   tbl.glGetNamedStringARB = loader_glGetNamedStringARB;
   tbl.glGetNamedStringivARB = loader_glGetNamedStringivARB;

// GL_ARB_debug_output

   tbl.glDebugMessageControlARB = loader_glDebugMessageControlARB;
   tbl.glDebugMessageInsertARB = loader_glDebugMessageInsertARB;
   tbl.glDebugMessageCallbackARB = loader_glDebugMessageCallbackARB;
   tbl.glGetDebugMessageLogARB = loader_glGetDebugMessageLogARB;

// GL_ARB_robustness

   tbl.glGetGraphicsResetStatusARB = loader_glGetGraphicsResetStatusARB;
   tbl.glGetnMapdvARB = loader_glGetnMapdvARB;
   tbl.glGetnMapfvARB = loader_glGetnMapfvARB;
   tbl.glGetnMapivARB = loader_glGetnMapivARB;
   tbl.glGetnPixelMapfvARB = loader_glGetnPixelMapfvARB;
   tbl.glGetnPixelMapuivARB = loader_glGetnPixelMapuivARB;
   tbl.glGetnPixelMapusvARB = loader_glGetnPixelMapusvARB;
   tbl.glGetnPolygonStippleARB = loader_glGetnPolygonStippleARB;
   tbl.glGetnTexImageARB = loader_glGetnTexImageARB;
   tbl.glReadnPixelsARB = loader_glReadnPixelsARB;
   tbl.glGetnColorTableARB = loader_glGetnColorTableARB;
   tbl.glGetnConvolutionFilterARB = loader_glGetnConvolutionFilterARB;
   tbl.glGetnSeparableFilterARB = loader_glGetnSeparableFilterARB;
   tbl.glGetnHistogramARB = loader_glGetnHistogramARB;
   tbl.glGetnMinmaxARB = loader_glGetnMinmaxARB;
   tbl.glGetnCompressedTexImageARB = loader_glGetnCompressedTexImageARB;
   tbl.glGetnUniformfvARB = loader_glGetnUniformfvARB;
   tbl.glGetnUniformivARB = loader_glGetnUniformivARB;
   tbl.glGetnUniformuivARB = loader_glGetnUniformuivARB;
   tbl.glGetnUniformdvARB = loader_glGetnUniformdvARB;

// GL_EXT_blend_color

   tbl.glBlendColorEXT = loader_glBlendColorEXT;

// GL_EXT_polygon_offset

   tbl.glPolygonOffsetEXT = loader_glPolygonOffsetEXT;

// GL_EXT_texture3D

   tbl.glTexImage3DEXT = loader_glTexImage3DEXT;

// GL_SGIS_texture_filter4

   tbl.glGetTexFilterFuncSGIS = loader_glGetTexFilterFuncSGIS;
   tbl.glTexFilterFuncSGIS = loader_glTexFilterFuncSGIS;

// GL_EXT_subtexture

   tbl.glTexSubImage1DEXT = loader_glTexSubImage1DEXT;
   tbl.glTexSubImage2DEXT = loader_glTexSubImage2DEXT;
   tbl.glTexSubImage3DEXT = loader_glTexSubImage3DEXT;

// GL_EXT_copy_texture

   tbl.glCopyTexImage1DEXT = loader_glCopyTexImage1DEXT;
   tbl.glCopyTexImage2DEXT = loader_glCopyTexImage2DEXT;
   tbl.glCopyTexSubImage1DEXT = loader_glCopyTexSubImage1DEXT;
   tbl.glCopyTexSubImage2DEXT = loader_glCopyTexSubImage2DEXT;
   tbl.glCopyTexSubImage3DEXT = loader_glCopyTexSubImage3DEXT;

// GL_EXT_histogram

   tbl.glGetHistogramEXT = loader_glGetHistogramEXT;
   tbl.glGetHistogramParameterfvEXT = loader_glGetHistogramParameterfvEXT;
   tbl.glGetHistogramParameterivEXT = loader_glGetHistogramParameterivEXT;
   tbl.glGetMinmaxEXT = loader_glGetMinmaxEXT;
   tbl.glGetMinmaxParameterfvEXT = loader_glGetMinmaxParameterfvEXT;
   tbl.glGetMinmaxParameterivEXT = loader_glGetMinmaxParameterivEXT;
   tbl.glHistogramEXT = loader_glHistogramEXT;
   tbl.glMinmaxEXT = loader_glMinmaxEXT;
   tbl.glResetHistogramEXT = loader_glResetHistogramEXT;
   tbl.glResetMinmaxEXT = loader_glResetMinmaxEXT;

// GL_EXT_convolution

   tbl.glConvolutionFilter1DEXT = loader_glConvolutionFilter1DEXT;
   tbl.glConvolutionFilter2DEXT = loader_glConvolutionFilter2DEXT;
   tbl.glConvolutionParameterfEXT = loader_glConvolutionParameterfEXT;
   tbl.glConvolutionParameterfvEXT = loader_glConvolutionParameterfvEXT;
   tbl.glConvolutionParameteriEXT = loader_glConvolutionParameteriEXT;
   tbl.glConvolutionParameterivEXT = loader_glConvolutionParameterivEXT;
   tbl.glCopyConvolutionFilter1DEXT = loader_glCopyConvolutionFilter1DEXT;
   tbl.glCopyConvolutionFilter2DEXT = loader_glCopyConvolutionFilter2DEXT;
   tbl.glGetConvolutionFilterEXT = loader_glGetConvolutionFilterEXT;
   tbl.glGetConvolutionParameterfvEXT = loader_glGetConvolutionParameterfvEXT;
   tbl.glGetConvolutionParameterivEXT = loader_glGetConvolutionParameterivEXT;
   tbl.glGetSeparableFilterEXT = loader_glGetSeparableFilterEXT;
   tbl.glSeparableFilter2DEXT = loader_glSeparableFilter2DEXT;

// GL_SGI_color_table

   tbl.glColorTableSGI = loader_glColorTableSGI;
   tbl.glColorTableParameterfvSGI = loader_glColorTableParameterfvSGI;
   tbl.glColorTableParameterivSGI = loader_glColorTableParameterivSGI;
   tbl.glCopyColorTableSGI = loader_glCopyColorTableSGI;
   tbl.glGetColorTableSGI = loader_glGetColorTableSGI;
   tbl.glGetColorTableParameterfvSGI = loader_glGetColorTableParameterfvSGI;
   tbl.glGetColorTableParameterivSGI = loader_glGetColorTableParameterivSGI;

// GL_SGIX_pixel_texture

   tbl.glPixelTexGenSGIX = loader_glPixelTexGenSGIX;

// GL_SGIS_pixel_texture

   tbl.glPixelTexGenParameteriSGIS = loader_glPixelTexGenParameteriSGIS;
   tbl.glPixelTexGenParameterivSGIS = loader_glPixelTexGenParameterivSGIS;
   tbl.glPixelTexGenParameterfSGIS = loader_glPixelTexGenParameterfSGIS;
   tbl.glPixelTexGenParameterfvSGIS = loader_glPixelTexGenParameterfvSGIS;
   tbl.glGetPixelTexGenParameterivSGIS = loader_glGetPixelTexGenParameterivSGIS;
   tbl.glGetPixelTexGenParameterfvSGIS = loader_glGetPixelTexGenParameterfvSGIS;

// GL_SGIS_texture4D

   tbl.glTexImage4DSGIS = loader_glTexImage4DSGIS;
   tbl.glTexSubImage4DSGIS = loader_glTexSubImage4DSGIS;

// GL_EXT_texture_object

   tbl.glAreTexturesResidentEXT = loader_glAreTexturesResidentEXT;
   tbl.glBindTextureEXT = loader_glBindTextureEXT;
   tbl.glDeleteTexturesEXT = loader_glDeleteTexturesEXT;
   tbl.glGenTexturesEXT = loader_glGenTexturesEXT;
   tbl.glIsTextureEXT = loader_glIsTextureEXT;
   tbl.glPrioritizeTexturesEXT = loader_glPrioritizeTexturesEXT;

// GL_SGIS_detail_texture

   tbl.glDetailTexFuncSGIS = loader_glDetailTexFuncSGIS;
   tbl.glGetDetailTexFuncSGIS = loader_glGetDetailTexFuncSGIS;

// GL_SGIS_sharpen_texture

   tbl.glSharpenTexFuncSGIS = loader_glSharpenTexFuncSGIS;
   tbl.glGetSharpenTexFuncSGIS = loader_glGetSharpenTexFuncSGIS;

// GL_SGIS_multisample

   tbl.glSampleMaskSGIS = loader_glSampleMaskSGIS;
   tbl.glSamplePatternSGIS = loader_glSamplePatternSGIS;

// GL_EXT_vertex_array

   tbl.glArrayElementEXT = loader_glArrayElementEXT;
   tbl.glColorPointerEXT = loader_glColorPointerEXT;
   tbl.glDrawArraysEXT = loader_glDrawArraysEXT;
   tbl.glEdgeFlagPointerEXT = loader_glEdgeFlagPointerEXT;
   tbl.glGetPointervEXT = loader_glGetPointervEXT;
   tbl.glIndexPointerEXT = loader_glIndexPointerEXT;
   tbl.glNormalPointerEXT = loader_glNormalPointerEXT;
   tbl.glTexCoordPointerEXT = loader_glTexCoordPointerEXT;
   tbl.glVertexPointerEXT = loader_glVertexPointerEXT;

// GL_EXT_blend_minmax

   tbl.glBlendEquationEXT = loader_glBlendEquationEXT;

// GL_SGIX_sprite

   tbl.glSpriteParameterfSGIX = loader_glSpriteParameterfSGIX;
   tbl.glSpriteParameterfvSGIX = loader_glSpriteParameterfvSGIX;
   tbl.glSpriteParameteriSGIX = loader_glSpriteParameteriSGIX;
   tbl.glSpriteParameterivSGIX = loader_glSpriteParameterivSGIX;

// GL_EXT_point_parameters

   tbl.glPointParameterfEXT = loader_glPointParameterfEXT;
   tbl.glPointParameterfvEXT = loader_glPointParameterfvEXT;

// GL_SGIS_point_parameters

   tbl.glPointParameterfSGIS = loader_glPointParameterfSGIS;
   tbl.glPointParameterfvSGIS = loader_glPointParameterfvSGIS;

// GL_SGIX_instruments

   tbl.glGetInstrumentsSGIX = loader_glGetInstrumentsSGIX;
   tbl.glInstrumentsBufferSGIX = loader_glInstrumentsBufferSGIX;
   tbl.glPollInstrumentsSGIX = loader_glPollInstrumentsSGIX;
   tbl.glReadInstrumentsSGIX = loader_glReadInstrumentsSGIX;
   tbl.glStartInstrumentsSGIX = loader_glStartInstrumentsSGIX;
   tbl.glStopInstrumentsSGIX = loader_glStopInstrumentsSGIX;

// GL_SGIX_framezoom

   tbl.glFrameZoomSGIX = loader_glFrameZoomSGIX;

// GL_SGIX_tag_sample_buffer

   tbl.glTagSampleBufferSGIX = loader_glTagSampleBufferSGIX;

// GL_SGIX_polynomial_ffd

   tbl.glDeformationMap3dSGIX = loader_glDeformationMap3dSGIX;
   tbl.glDeformationMap3fSGIX = loader_glDeformationMap3fSGIX;
   tbl.glDeformSGIX = loader_glDeformSGIX;
   tbl.glLoadIdentityDeformationMapSGIX = loader_glLoadIdentityDeformationMapSGIX;

// GL_SGIX_reference_plane

   tbl.glReferencePlaneSGIX = loader_glReferencePlaneSGIX;

// GL_SGIX_flush_raster

   tbl.glFlushRasterSGIX = loader_glFlushRasterSGIX;

// GL_SGIS_fog_function

   tbl.glFogFuncSGIS = loader_glFogFuncSGIS;
   tbl.glGetFogFuncSGIS = loader_glGetFogFuncSGIS;

// GL_HP_image_transform

   tbl.glImageTransformParameteriHP = loader_glImageTransformParameteriHP;
   tbl.glImageTransformParameterfHP = loader_glImageTransformParameterfHP;
   tbl.glImageTransformParameterivHP = loader_glImageTransformParameterivHP;
   tbl.glImageTransformParameterfvHP = loader_glImageTransformParameterfvHP;
   tbl.glGetImageTransformParameterivHP = loader_glGetImageTransformParameterivHP;
   tbl.glGetImageTransformParameterfvHP = loader_glGetImageTransformParameterfvHP;

// GL_EXT_color_subtable

   tbl.glColorSubTableEXT = loader_glColorSubTableEXT;
   tbl.glCopyColorSubTableEXT = loader_glCopyColorSubTableEXT;

// GL_PGI_misc_hints

   tbl.glHintPGI = loader_glHintPGI;

// GL_EXT_paletted_texture

   tbl.glColorTableEXT = loader_glColorTableEXT;
   tbl.glGetColorTableEXT = loader_glGetColorTableEXT;
   tbl.glGetColorTableParameterivEXT = loader_glGetColorTableParameterivEXT;
   tbl.glGetColorTableParameterfvEXT = loader_glGetColorTableParameterfvEXT;

// GL_SGIX_list_priority

   tbl.glGetListParameterfvSGIX = loader_glGetListParameterfvSGIX;
   tbl.glGetListParameterivSGIX = loader_glGetListParameterivSGIX;
   tbl.glListParameterfSGIX = loader_glListParameterfSGIX;
   tbl.glListParameterfvSGIX = loader_glListParameterfvSGIX;
   tbl.glListParameteriSGIX = loader_glListParameteriSGIX;
   tbl.glListParameterivSGIX = loader_glListParameterivSGIX;

// GL_EXT_index_material

   tbl.glIndexMaterialEXT = loader_glIndexMaterialEXT;

// GL_EXT_index_func

   tbl.glIndexFuncEXT = loader_glIndexFuncEXT;

// GL_EXT_compiled_vertex_array

   tbl.glLockArraysEXT = loader_glLockArraysEXT;
   tbl.glUnlockArraysEXT = loader_glUnlockArraysEXT;

// GL_EXT_cull_vertex

   tbl.glCullParameterdvEXT = loader_glCullParameterdvEXT;
   tbl.glCullParameterfvEXT = loader_glCullParameterfvEXT;

// GL_SGIX_fragment_lighting

   tbl.glFragmentColorMaterialSGIX = loader_glFragmentColorMaterialSGIX;
   tbl.glFragmentLightfSGIX = loader_glFragmentLightfSGIX;
   tbl.glFragmentLightfvSGIX = loader_glFragmentLightfvSGIX;
   tbl.glFragmentLightiSGIX = loader_glFragmentLightiSGIX;
   tbl.glFragmentLightivSGIX = loader_glFragmentLightivSGIX;
   tbl.glFragmentLightModelfSGIX = loader_glFragmentLightModelfSGIX;
   tbl.glFragmentLightModelfvSGIX = loader_glFragmentLightModelfvSGIX;
   tbl.glFragmentLightModeliSGIX = loader_glFragmentLightModeliSGIX;
   tbl.glFragmentLightModelivSGIX = loader_glFragmentLightModelivSGIX;
   tbl.glFragmentMaterialfSGIX = loader_glFragmentMaterialfSGIX;
   tbl.glFragmentMaterialfvSGIX = loader_glFragmentMaterialfvSGIX;
   tbl.glFragmentMaterialiSGIX = loader_glFragmentMaterialiSGIX;
   tbl.glFragmentMaterialivSGIX = loader_glFragmentMaterialivSGIX;
   tbl.glGetFragmentLightfvSGIX = loader_glGetFragmentLightfvSGIX;
   tbl.glGetFragmentLightivSGIX = loader_glGetFragmentLightivSGIX;
   tbl.glGetFragmentMaterialfvSGIX = loader_glGetFragmentMaterialfvSGIX;
   tbl.glGetFragmentMaterialivSGIX = loader_glGetFragmentMaterialivSGIX;
   tbl.glLightEnviSGIX = loader_glLightEnviSGIX;

// GL_EXT_draw_range_elements

   tbl.glDrawRangeElementsEXT = loader_glDrawRangeElementsEXT;

// GL_EXT_light_texture

   tbl.glApplyTextureEXT = loader_glApplyTextureEXT;
   tbl.glTextureLightEXT = loader_glTextureLightEXT;
   tbl.glTextureMaterialEXT = loader_glTextureMaterialEXT;

// GL_EXT_scene_marker

   tbl.glBeginSceneEXT = loader_glBeginSceneEXT;
   tbl.glEndSceneEXT = loader_glEndSceneEXT;

// GL_SGIX_async

   tbl.glAsyncMarkerSGIX = loader_glAsyncMarkerSGIX;
   tbl.glFinishAsyncSGIX = loader_glFinishAsyncSGIX;
   tbl.glPollAsyncSGIX = loader_glPollAsyncSGIX;
   tbl.glGenAsyncMarkersSGIX = loader_glGenAsyncMarkersSGIX;
   tbl.glDeleteAsyncMarkersSGIX = loader_glDeleteAsyncMarkersSGIX;
   tbl.glIsAsyncMarkerSGIX = loader_glIsAsyncMarkerSGIX;

// GL_INTEL_parallel_arrays

   tbl.glVertexPointervINTEL = loader_glVertexPointervINTEL;
   tbl.glNormalPointervINTEL = loader_glNormalPointervINTEL;
   tbl.glColorPointervINTEL = loader_glColorPointervINTEL;
   tbl.glTexCoordPointervINTEL = loader_glTexCoordPointervINTEL;

// GL_EXT_pixel_transform

   tbl.glPixelTransformParameteriEXT = loader_glPixelTransformParameteriEXT;
   tbl.glPixelTransformParameterfEXT = loader_glPixelTransformParameterfEXT;
   tbl.glPixelTransformParameterivEXT = loader_glPixelTransformParameterivEXT;
   tbl.glPixelTransformParameterfvEXT = loader_glPixelTransformParameterfvEXT;

// GL_EXT_secondary_color

   tbl.glSecondaryColor3bEXT = loader_glSecondaryColor3bEXT;
   tbl.glSecondaryColor3bvEXT = loader_glSecondaryColor3bvEXT;
   tbl.glSecondaryColor3dEXT = loader_glSecondaryColor3dEXT;
   tbl.glSecondaryColor3dvEXT = loader_glSecondaryColor3dvEXT;
   tbl.glSecondaryColor3fEXT = loader_glSecondaryColor3fEXT;
   tbl.glSecondaryColor3fvEXT = loader_glSecondaryColor3fvEXT;
   tbl.glSecondaryColor3iEXT = loader_glSecondaryColor3iEXT;
   tbl.glSecondaryColor3ivEXT = loader_glSecondaryColor3ivEXT;
   tbl.glSecondaryColor3sEXT = loader_glSecondaryColor3sEXT;
   tbl.glSecondaryColor3svEXT = loader_glSecondaryColor3svEXT;
   tbl.glSecondaryColor3ubEXT = loader_glSecondaryColor3ubEXT;
   tbl.glSecondaryColor3ubvEXT = loader_glSecondaryColor3ubvEXT;
   tbl.glSecondaryColor3uiEXT = loader_glSecondaryColor3uiEXT;
   tbl.glSecondaryColor3uivEXT = loader_glSecondaryColor3uivEXT;
   tbl.glSecondaryColor3usEXT = loader_glSecondaryColor3usEXT;
   tbl.glSecondaryColor3usvEXT = loader_glSecondaryColor3usvEXT;
   tbl.glSecondaryColorPointerEXT = loader_glSecondaryColorPointerEXT;

// GL_EXT_texture_perturb_normal

   tbl.glTextureNormalEXT = loader_glTextureNormalEXT;

// GL_EXT_multi_draw_arrays

   tbl.glMultiDrawArraysEXT = loader_glMultiDrawArraysEXT;
   tbl.glMultiDrawElementsEXT = loader_glMultiDrawElementsEXT;

// GL_EXT_fog_coord

   tbl.glFogCoordfEXT = loader_glFogCoordfEXT;
   tbl.glFogCoordfvEXT = loader_glFogCoordfvEXT;
   tbl.glFogCoorddEXT = loader_glFogCoorddEXT;
   tbl.glFogCoorddvEXT = loader_glFogCoorddvEXT;
   tbl.glFogCoordPointerEXT = loader_glFogCoordPointerEXT;

// GL_EXT_coordinate_frame

   tbl.glTangent3bEXT = loader_glTangent3bEXT;
   tbl.glTangent3bvEXT = loader_glTangent3bvEXT;
   tbl.glTangent3dEXT = loader_glTangent3dEXT;
   tbl.glTangent3dvEXT = loader_glTangent3dvEXT;
   tbl.glTangent3fEXT = loader_glTangent3fEXT;
   tbl.glTangent3fvEXT = loader_glTangent3fvEXT;
   tbl.glTangent3iEXT = loader_glTangent3iEXT;
   tbl.glTangent3ivEXT = loader_glTangent3ivEXT;
   tbl.glTangent3sEXT = loader_glTangent3sEXT;
   tbl.glTangent3svEXT = loader_glTangent3svEXT;
   tbl.glBinormal3bEXT = loader_glBinormal3bEXT;
   tbl.glBinormal3bvEXT = loader_glBinormal3bvEXT;
   tbl.glBinormal3dEXT = loader_glBinormal3dEXT;
   tbl.glBinormal3dvEXT = loader_glBinormal3dvEXT;
   tbl.glBinormal3fEXT = loader_glBinormal3fEXT;
   tbl.glBinormal3fvEXT = loader_glBinormal3fvEXT;
   tbl.glBinormal3iEXT = loader_glBinormal3iEXT;
   tbl.glBinormal3ivEXT = loader_glBinormal3ivEXT;
   tbl.glBinormal3sEXT = loader_glBinormal3sEXT;
   tbl.glBinormal3svEXT = loader_glBinormal3svEXT;
   tbl.glTangentPointerEXT = loader_glTangentPointerEXT;
   tbl.glBinormalPointerEXT = loader_glBinormalPointerEXT;

// GL_SUNX_constant_data

   tbl.glFinishTextureSUNX = loader_glFinishTextureSUNX;

// GL_SUN_global_alpha

   tbl.glGlobalAlphaFactorbSUN = loader_glGlobalAlphaFactorbSUN;
   tbl.glGlobalAlphaFactorsSUN = loader_glGlobalAlphaFactorsSUN;
   tbl.glGlobalAlphaFactoriSUN = loader_glGlobalAlphaFactoriSUN;
   tbl.glGlobalAlphaFactorfSUN = loader_glGlobalAlphaFactorfSUN;
   tbl.glGlobalAlphaFactordSUN = loader_glGlobalAlphaFactordSUN;
   tbl.glGlobalAlphaFactorubSUN = loader_glGlobalAlphaFactorubSUN;
   tbl.glGlobalAlphaFactorusSUN = loader_glGlobalAlphaFactorusSUN;
   tbl.glGlobalAlphaFactoruiSUN = loader_glGlobalAlphaFactoruiSUN;

// GL_SUN_triangle_list

   tbl.glReplacementCodeuiSUN = loader_glReplacementCodeuiSUN;
   tbl.glReplacementCodeusSUN = loader_glReplacementCodeusSUN;
   tbl.glReplacementCodeubSUN = loader_glReplacementCodeubSUN;
   tbl.glReplacementCodeuivSUN = loader_glReplacementCodeuivSUN;
   tbl.glReplacementCodeusvSUN = loader_glReplacementCodeusvSUN;
   tbl.glReplacementCodeubvSUN = loader_glReplacementCodeubvSUN;
   tbl.glReplacementCodePointerSUN = loader_glReplacementCodePointerSUN;

// GL_SUN_vertex

   tbl.glColor4ubVertex2fSUN = loader_glColor4ubVertex2fSUN;
   tbl.glColor4ubVertex2fvSUN = loader_glColor4ubVertex2fvSUN;
   tbl.glColor4ubVertex3fSUN = loader_glColor4ubVertex3fSUN;
   tbl.glColor4ubVertex3fvSUN = loader_glColor4ubVertex3fvSUN;
   tbl.glColor3fVertex3fSUN = loader_glColor3fVertex3fSUN;
   tbl.glColor3fVertex3fvSUN = loader_glColor3fVertex3fvSUN;
   tbl.glNormal3fVertex3fSUN = loader_glNormal3fVertex3fSUN;
   tbl.glNormal3fVertex3fvSUN = loader_glNormal3fVertex3fvSUN;
   tbl.glColor4fNormal3fVertex3fSUN = loader_glColor4fNormal3fVertex3fSUN;
   tbl.glColor4fNormal3fVertex3fvSUN = loader_glColor4fNormal3fVertex3fvSUN;
   tbl.glTexCoord2fVertex3fSUN = loader_glTexCoord2fVertex3fSUN;
   tbl.glTexCoord2fVertex3fvSUN = loader_glTexCoord2fVertex3fvSUN;
   tbl.glTexCoord4fVertex4fSUN = loader_glTexCoord4fVertex4fSUN;
   tbl.glTexCoord4fVertex4fvSUN = loader_glTexCoord4fVertex4fvSUN;
   tbl.glTexCoord2fColor4ubVertex3fSUN = loader_glTexCoord2fColor4ubVertex3fSUN;
   tbl.glTexCoord2fColor4ubVertex3fvSUN = loader_glTexCoord2fColor4ubVertex3fvSUN;
   tbl.glTexCoord2fColor3fVertex3fSUN = loader_glTexCoord2fColor3fVertex3fSUN;
   tbl.glTexCoord2fColor3fVertex3fvSUN = loader_glTexCoord2fColor3fVertex3fvSUN;
   tbl.glTexCoord2fNormal3fVertex3fSUN = loader_glTexCoord2fNormal3fVertex3fSUN;
   tbl.glTexCoord2fNormal3fVertex3fvSUN = loader_glTexCoord2fNormal3fVertex3fvSUN;
   tbl.glTexCoord2fColor4fNormal3fVertex3fSUN = loader_glTexCoord2fColor4fNormal3fVertex3fSUN;
   tbl.glTexCoord2fColor4fNormal3fVertex3fvSUN = loader_glTexCoord2fColor4fNormal3fVertex3fvSUN;
   tbl.glTexCoord4fColor4fNormal3fVertex4fSUN = loader_glTexCoord4fColor4fNormal3fVertex4fSUN;
   tbl.glTexCoord4fColor4fNormal3fVertex4fvSUN = loader_glTexCoord4fColor4fNormal3fVertex4fvSUN;
   tbl.glReplacementCodeuiVertex3fSUN = loader_glReplacementCodeuiVertex3fSUN;
   tbl.glReplacementCodeuiVertex3fvSUN = loader_glReplacementCodeuiVertex3fvSUN;
   tbl.glReplacementCodeuiColor4ubVertex3fSUN = loader_glReplacementCodeuiColor4ubVertex3fSUN;
   tbl.glReplacementCodeuiColor4ubVertex3fvSUN = loader_glReplacementCodeuiColor4ubVertex3fvSUN;
   tbl.glReplacementCodeuiColor3fVertex3fSUN = loader_glReplacementCodeuiColor3fVertex3fSUN;
   tbl.glReplacementCodeuiColor3fVertex3fvSUN = loader_glReplacementCodeuiColor3fVertex3fvSUN;
   tbl.glReplacementCodeuiNormal3fVertex3fSUN = loader_glReplacementCodeuiNormal3fVertex3fSUN;
   tbl.glReplacementCodeuiNormal3fVertex3fvSUN = loader_glReplacementCodeuiNormal3fVertex3fvSUN;
   tbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN = loader_glReplacementCodeuiColor4fNormal3fVertex3fSUN;
   tbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN = loader_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
   tbl.glReplacementCodeuiTexCoord2fVertex3fSUN = loader_glReplacementCodeuiTexCoord2fVertex3fSUN;
   tbl.glReplacementCodeuiTexCoord2fVertex3fvSUN = loader_glReplacementCodeuiTexCoord2fVertex3fvSUN;
   tbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
   tbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
   tbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
   tbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;

// GL_EXT_blend_func_separate

   tbl.glBlendFuncSeparateEXT = loader_glBlendFuncSeparateEXT;

// GL_INGR_blend_func_separate

   tbl.glBlendFuncSeparateINGR = loader_glBlendFuncSeparateINGR;

// GL_EXT_vertex_weighting

   tbl.glVertexWeightfEXT = loader_glVertexWeightfEXT;
   tbl.glVertexWeightfvEXT = loader_glVertexWeightfvEXT;
   tbl.glVertexWeightPointerEXT = loader_glVertexWeightPointerEXT;

// GL_NV_vertex_array_range

   tbl.glFlushVertexArrayRangeNV = loader_glFlushVertexArrayRangeNV;
   tbl.glVertexArrayRangeNV = loader_glVertexArrayRangeNV;

// GL_NV_register_combiners

   tbl.glCombinerParameterfvNV = loader_glCombinerParameterfvNV;
   tbl.glCombinerParameterfNV = loader_glCombinerParameterfNV;
   tbl.glCombinerParameterivNV = loader_glCombinerParameterivNV;
   tbl.glCombinerParameteriNV = loader_glCombinerParameteriNV;
   tbl.glCombinerInputNV = loader_glCombinerInputNV;
   tbl.glCombinerOutputNV = loader_glCombinerOutputNV;
   tbl.glFinalCombinerInputNV = loader_glFinalCombinerInputNV;
   tbl.glGetCombinerInputParameterfvNV = loader_glGetCombinerInputParameterfvNV;
   tbl.glGetCombinerInputParameterivNV = loader_glGetCombinerInputParameterivNV;
   tbl.glGetCombinerOutputParameterfvNV = loader_glGetCombinerOutputParameterfvNV;
   tbl.glGetCombinerOutputParameterivNV = loader_glGetCombinerOutputParameterivNV;
   tbl.glGetFinalCombinerInputParameterfvNV = loader_glGetFinalCombinerInputParameterfvNV;
   tbl.glGetFinalCombinerInputParameterivNV = loader_glGetFinalCombinerInputParameterivNV;

// GL_MESA_resize_buffers

   tbl.glResizeBuffersMESA = loader_glResizeBuffersMESA;

// GL_MESA_window_pos

   tbl.glWindowPos2dMESA = loader_glWindowPos2dMESA;
   tbl.glWindowPos2dvMESA = loader_glWindowPos2dvMESA;
   tbl.glWindowPos2fMESA = loader_glWindowPos2fMESA;
   tbl.glWindowPos2fvMESA = loader_glWindowPos2fvMESA;
   tbl.glWindowPos2iMESA = loader_glWindowPos2iMESA;
   tbl.glWindowPos2ivMESA = loader_glWindowPos2ivMESA;
   tbl.glWindowPos2sMESA = loader_glWindowPos2sMESA;
   tbl.glWindowPos2svMESA = loader_glWindowPos2svMESA;
   tbl.glWindowPos3dMESA = loader_glWindowPos3dMESA;
   tbl.glWindowPos3dvMESA = loader_glWindowPos3dvMESA;
   tbl.glWindowPos3fMESA = loader_glWindowPos3fMESA;
   tbl.glWindowPos3fvMESA = loader_glWindowPos3fvMESA;
   tbl.glWindowPos3iMESA = loader_glWindowPos3iMESA;
   tbl.glWindowPos3ivMESA = loader_glWindowPos3ivMESA;
   tbl.glWindowPos3sMESA = loader_glWindowPos3sMESA;
   tbl.glWindowPos3svMESA = loader_glWindowPos3svMESA;
   tbl.glWindowPos4dMESA = loader_glWindowPos4dMESA;
   tbl.glWindowPos4dvMESA = loader_glWindowPos4dvMESA;
   tbl.glWindowPos4fMESA = loader_glWindowPos4fMESA;
   tbl.glWindowPos4fvMESA = loader_glWindowPos4fvMESA;
   tbl.glWindowPos4iMESA = loader_glWindowPos4iMESA;
   tbl.glWindowPos4ivMESA = loader_glWindowPos4ivMESA;
   tbl.glWindowPos4sMESA = loader_glWindowPos4sMESA;
   tbl.glWindowPos4svMESA = loader_glWindowPos4svMESA;

// GL_IBM_multimode_draw_arrays

   tbl.glMultiModeDrawArraysIBM = loader_glMultiModeDrawArraysIBM;
   tbl.glMultiModeDrawElementsIBM = loader_glMultiModeDrawElementsIBM;

// GL_IBM_vertex_array_lists

   tbl.glColorPointerListIBM = loader_glColorPointerListIBM;
   tbl.glSecondaryColorPointerListIBM = loader_glSecondaryColorPointerListIBM;
   tbl.glEdgeFlagPointerListIBM = loader_glEdgeFlagPointerListIBM;
   tbl.glFogCoordPointerListIBM = loader_glFogCoordPointerListIBM;
   tbl.glIndexPointerListIBM = loader_glIndexPointerListIBM;
   tbl.glNormalPointerListIBM = loader_glNormalPointerListIBM;
   tbl.glTexCoordPointerListIBM = loader_glTexCoordPointerListIBM;
   tbl.glVertexPointerListIBM = loader_glVertexPointerListIBM;

// GL_3DFX_tbuffer

   tbl.glTbufferMask3DFX = loader_glTbufferMask3DFX;

// GL_EXT_multisample

   tbl.glSampleMaskEXT = loader_glSampleMaskEXT;
   tbl.glSamplePatternEXT = loader_glSamplePatternEXT;

// GL_SGIS_texture_color_mask

   tbl.glTextureColorMaskSGIS = loader_glTextureColorMaskSGIS;

// GL_SGIX_igloo_interface

   tbl.glIglooInterfaceSGIX = loader_glIglooInterfaceSGIX;

// GL_NV_fence

   tbl.glDeleteFencesNV = loader_glDeleteFencesNV;
   tbl.glGenFencesNV = loader_glGenFencesNV;
   tbl.glIsFenceNV = loader_glIsFenceNV;
   tbl.glTestFenceNV = loader_glTestFenceNV;
   tbl.glGetFenceivNV = loader_glGetFenceivNV;
   tbl.glFinishFenceNV = loader_glFinishFenceNV;
   tbl.glSetFenceNV = loader_glSetFenceNV;

// GL_NV_evaluators

   tbl.glMapControlPointsNV = loader_glMapControlPointsNV;
   tbl.glMapParameterivNV = loader_glMapParameterivNV;
   tbl.glMapParameterfvNV = loader_glMapParameterfvNV;
   tbl.glGetMapControlPointsNV = loader_glGetMapControlPointsNV;
   tbl.glGetMapParameterivNV = loader_glGetMapParameterivNV;
   tbl.glGetMapParameterfvNV = loader_glGetMapParameterfvNV;
   tbl.glGetMapAttribParameterivNV = loader_glGetMapAttribParameterivNV;
   tbl.glGetMapAttribParameterfvNV = loader_glGetMapAttribParameterfvNV;
   tbl.glEvalMapsNV = loader_glEvalMapsNV;

// GL_NV_register_combiners2

   tbl.glCombinerStageParameterfvNV = loader_glCombinerStageParameterfvNV;
   tbl.glGetCombinerStageParameterfvNV = loader_glGetCombinerStageParameterfvNV;

// GL_NV_vertex_program

   tbl.glAreProgramsResidentNV = loader_glAreProgramsResidentNV;
   tbl.glBindProgramNV = loader_glBindProgramNV;
   tbl.glDeleteProgramsNV = loader_glDeleteProgramsNV;
   tbl.glExecuteProgramNV = loader_glExecuteProgramNV;
   tbl.glGenProgramsNV = loader_glGenProgramsNV;
   tbl.glGetProgramParameterdvNV = loader_glGetProgramParameterdvNV;
   tbl.glGetProgramParameterfvNV = loader_glGetProgramParameterfvNV;
   tbl.glGetProgramivNV = loader_glGetProgramivNV;
   tbl.glGetProgramStringNV = loader_glGetProgramStringNV;
   tbl.glGetTrackMatrixivNV = loader_glGetTrackMatrixivNV;
   tbl.glGetVertexAttribdvNV = loader_glGetVertexAttribdvNV;
   tbl.glGetVertexAttribfvNV = loader_glGetVertexAttribfvNV;
   tbl.glGetVertexAttribivNV = loader_glGetVertexAttribivNV;
   tbl.glGetVertexAttribPointervNV = loader_glGetVertexAttribPointervNV;
   tbl.glIsProgramNV = loader_glIsProgramNV;
   tbl.glLoadProgramNV = loader_glLoadProgramNV;
   tbl.glProgramParameter4dNV = loader_glProgramParameter4dNV;
   tbl.glProgramParameter4dvNV = loader_glProgramParameter4dvNV;
   tbl.glProgramParameter4fNV = loader_glProgramParameter4fNV;
   tbl.glProgramParameter4fvNV = loader_glProgramParameter4fvNV;
   tbl.glProgramParameters4dvNV = loader_glProgramParameters4dvNV;
   tbl.glProgramParameters4fvNV = loader_glProgramParameters4fvNV;
   tbl.glRequestResidentProgramsNV = loader_glRequestResidentProgramsNV;
   tbl.glTrackMatrixNV = loader_glTrackMatrixNV;
   tbl.glVertexAttribPointerNV = loader_glVertexAttribPointerNV;
   tbl.glVertexAttrib1dNV = loader_glVertexAttrib1dNV;
   tbl.glVertexAttrib1dvNV = loader_glVertexAttrib1dvNV;
   tbl.glVertexAttrib1fNV = loader_glVertexAttrib1fNV;
   tbl.glVertexAttrib1fvNV = loader_glVertexAttrib1fvNV;
   tbl.glVertexAttrib1sNV = loader_glVertexAttrib1sNV;
   tbl.glVertexAttrib1svNV = loader_glVertexAttrib1svNV;
   tbl.glVertexAttrib2dNV = loader_glVertexAttrib2dNV;
   tbl.glVertexAttrib2dvNV = loader_glVertexAttrib2dvNV;
   tbl.glVertexAttrib2fNV = loader_glVertexAttrib2fNV;
   tbl.glVertexAttrib2fvNV = loader_glVertexAttrib2fvNV;
   tbl.glVertexAttrib2sNV = loader_glVertexAttrib2sNV;
   tbl.glVertexAttrib2svNV = loader_glVertexAttrib2svNV;
   tbl.glVertexAttrib3dNV = loader_glVertexAttrib3dNV;
   tbl.glVertexAttrib3dvNV = loader_glVertexAttrib3dvNV;
   tbl.glVertexAttrib3fNV = loader_glVertexAttrib3fNV;
   tbl.glVertexAttrib3fvNV = loader_glVertexAttrib3fvNV;
   tbl.glVertexAttrib3sNV = loader_glVertexAttrib3sNV;
   tbl.glVertexAttrib3svNV = loader_glVertexAttrib3svNV;
   tbl.glVertexAttrib4dNV = loader_glVertexAttrib4dNV;
   tbl.glVertexAttrib4dvNV = loader_glVertexAttrib4dvNV;
   tbl.glVertexAttrib4fNV = loader_glVertexAttrib4fNV;
   tbl.glVertexAttrib4fvNV = loader_glVertexAttrib4fvNV;
   tbl.glVertexAttrib4sNV = loader_glVertexAttrib4sNV;
   tbl.glVertexAttrib4svNV = loader_glVertexAttrib4svNV;
   tbl.glVertexAttrib4ubNV = loader_glVertexAttrib4ubNV;
   tbl.glVertexAttrib4ubvNV = loader_glVertexAttrib4ubvNV;
   tbl.glVertexAttribs1dvNV = loader_glVertexAttribs1dvNV;
   tbl.glVertexAttribs1fvNV = loader_glVertexAttribs1fvNV;
   tbl.glVertexAttribs1svNV = loader_glVertexAttribs1svNV;
   tbl.glVertexAttribs2dvNV = loader_glVertexAttribs2dvNV;
   tbl.glVertexAttribs2fvNV = loader_glVertexAttribs2fvNV;
   tbl.glVertexAttribs2svNV = loader_glVertexAttribs2svNV;
   tbl.glVertexAttribs3dvNV = loader_glVertexAttribs3dvNV;
   tbl.glVertexAttribs3fvNV = loader_glVertexAttribs3fvNV;
   tbl.glVertexAttribs3svNV = loader_glVertexAttribs3svNV;
   tbl.glVertexAttribs4dvNV = loader_glVertexAttribs4dvNV;
   tbl.glVertexAttribs4fvNV = loader_glVertexAttribs4fvNV;
   tbl.glVertexAttribs4svNV = loader_glVertexAttribs4svNV;
   tbl.glVertexAttribs4ubvNV = loader_glVertexAttribs4ubvNV;

// GL_ATI_envmap_bumpmap

   tbl.glTexBumpParameterivATI = loader_glTexBumpParameterivATI;
   tbl.glTexBumpParameterfvATI = loader_glTexBumpParameterfvATI;
   tbl.glGetTexBumpParameterivATI = loader_glGetTexBumpParameterivATI;
   tbl.glGetTexBumpParameterfvATI = loader_glGetTexBumpParameterfvATI;

// GL_ATI_fragment_shader

   tbl.glGenFragmentShadersATI = loader_glGenFragmentShadersATI;
   tbl.glBindFragmentShaderATI = loader_glBindFragmentShaderATI;
   tbl.glDeleteFragmentShaderATI = loader_glDeleteFragmentShaderATI;
   tbl.glBeginFragmentShaderATI = loader_glBeginFragmentShaderATI;
   tbl.glEndFragmentShaderATI = loader_glEndFragmentShaderATI;
   tbl.glPassTexCoordATI = loader_glPassTexCoordATI;
   tbl.glSampleMapATI = loader_glSampleMapATI;
   tbl.glColorFragmentOp1ATI = loader_glColorFragmentOp1ATI;
   tbl.glColorFragmentOp2ATI = loader_glColorFragmentOp2ATI;
   tbl.glColorFragmentOp3ATI = loader_glColorFragmentOp3ATI;
   tbl.glAlphaFragmentOp1ATI = loader_glAlphaFragmentOp1ATI;
   tbl.glAlphaFragmentOp2ATI = loader_glAlphaFragmentOp2ATI;
   tbl.glAlphaFragmentOp3ATI = loader_glAlphaFragmentOp3ATI;
   tbl.glSetFragmentShaderConstantATI = loader_glSetFragmentShaderConstantATI;

// GL_ATI_pn_triangles

   tbl.glPNTrianglesiATI = loader_glPNTrianglesiATI;
   tbl.glPNTrianglesfATI = loader_glPNTrianglesfATI;

// GL_ATI_vertex_array_object

   tbl.glNewObjectBufferATI = loader_glNewObjectBufferATI;
   tbl.glIsObjectBufferATI = loader_glIsObjectBufferATI;
   tbl.glUpdateObjectBufferATI = loader_glUpdateObjectBufferATI;
   tbl.glGetObjectBufferfvATI = loader_glGetObjectBufferfvATI;
   tbl.glGetObjectBufferivATI = loader_glGetObjectBufferivATI;
   tbl.glFreeObjectBufferATI = loader_glFreeObjectBufferATI;
   tbl.glArrayObjectATI = loader_glArrayObjectATI;
   tbl.glGetArrayObjectfvATI = loader_glGetArrayObjectfvATI;
   tbl.glGetArrayObjectivATI = loader_glGetArrayObjectivATI;
   tbl.glVariantArrayObjectATI = loader_glVariantArrayObjectATI;
   tbl.glGetVariantArrayObjectfvATI = loader_glGetVariantArrayObjectfvATI;
   tbl.glGetVariantArrayObjectivATI = loader_glGetVariantArrayObjectivATI;

// GL_EXT_vertex_shader

   tbl.glBeginVertexShaderEXT = loader_glBeginVertexShaderEXT;
   tbl.glEndVertexShaderEXT = loader_glEndVertexShaderEXT;
   tbl.glBindVertexShaderEXT = loader_glBindVertexShaderEXT;
   tbl.glGenVertexShadersEXT = loader_glGenVertexShadersEXT;
   tbl.glDeleteVertexShaderEXT = loader_glDeleteVertexShaderEXT;
   tbl.glShaderOp1EXT = loader_glShaderOp1EXT;
   tbl.glShaderOp2EXT = loader_glShaderOp2EXT;
   tbl.glShaderOp3EXT = loader_glShaderOp3EXT;
   tbl.glSwizzleEXT = loader_glSwizzleEXT;
   tbl.glWriteMaskEXT = loader_glWriteMaskEXT;
   tbl.glInsertComponentEXT = loader_glInsertComponentEXT;
   tbl.glExtractComponentEXT = loader_glExtractComponentEXT;
   tbl.glGenSymbolsEXT = loader_glGenSymbolsEXT;
   tbl.glSetInvariantEXT = loader_glSetInvariantEXT;
   tbl.glSetLocalConstantEXT = loader_glSetLocalConstantEXT;
   tbl.glVariantbvEXT = loader_glVariantbvEXT;
   tbl.glVariantsvEXT = loader_glVariantsvEXT;
   tbl.glVariantivEXT = loader_glVariantivEXT;
   tbl.glVariantfvEXT = loader_glVariantfvEXT;
   tbl.glVariantdvEXT = loader_glVariantdvEXT;
   tbl.glVariantubvEXT = loader_glVariantubvEXT;
   tbl.glVariantusvEXT = loader_glVariantusvEXT;
   tbl.glVariantuivEXT = loader_glVariantuivEXT;
   tbl.glVariantPointerEXT = loader_glVariantPointerEXT;
   tbl.glEnableVariantClientStateEXT = loader_glEnableVariantClientStateEXT;
   tbl.glDisableVariantClientStateEXT = loader_glDisableVariantClientStateEXT;
   tbl.glBindLightParameterEXT = loader_glBindLightParameterEXT;
   tbl.glBindMaterialParameterEXT = loader_glBindMaterialParameterEXT;
   tbl.glBindTexGenParameterEXT = loader_glBindTexGenParameterEXT;
   tbl.glBindTextureUnitParameterEXT = loader_glBindTextureUnitParameterEXT;
   tbl.glBindParameterEXT = loader_glBindParameterEXT;
   tbl.glIsVariantEnabledEXT = loader_glIsVariantEnabledEXT;
   tbl.glGetVariantBooleanvEXT = loader_glGetVariantBooleanvEXT;
   tbl.glGetVariantIntegervEXT = loader_glGetVariantIntegervEXT;
   tbl.glGetVariantFloatvEXT = loader_glGetVariantFloatvEXT;
   tbl.glGetVariantPointervEXT = loader_glGetVariantPointervEXT;
   tbl.glGetInvariantBooleanvEXT = loader_glGetInvariantBooleanvEXT;
   tbl.glGetInvariantIntegervEXT = loader_glGetInvariantIntegervEXT;
   tbl.glGetInvariantFloatvEXT = loader_glGetInvariantFloatvEXT;
   tbl.glGetLocalConstantBooleanvEXT = loader_glGetLocalConstantBooleanvEXT;
   tbl.glGetLocalConstantIntegervEXT = loader_glGetLocalConstantIntegervEXT;
   tbl.glGetLocalConstantFloatvEXT = loader_glGetLocalConstantFloatvEXT;

// GL_ATI_vertex_streams

   tbl.glVertexStream1sATI = loader_glVertexStream1sATI;
   tbl.glVertexStream1svATI = loader_glVertexStream1svATI;
   tbl.glVertexStream1iATI = loader_glVertexStream1iATI;
   tbl.glVertexStream1ivATI = loader_glVertexStream1ivATI;
   tbl.glVertexStream1fATI = loader_glVertexStream1fATI;
   tbl.glVertexStream1fvATI = loader_glVertexStream1fvATI;
   tbl.glVertexStream1dATI = loader_glVertexStream1dATI;
   tbl.glVertexStream1dvATI = loader_glVertexStream1dvATI;
   tbl.glVertexStream2sATI = loader_glVertexStream2sATI;
   tbl.glVertexStream2svATI = loader_glVertexStream2svATI;
   tbl.glVertexStream2iATI = loader_glVertexStream2iATI;
   tbl.glVertexStream2ivATI = loader_glVertexStream2ivATI;
   tbl.glVertexStream2fATI = loader_glVertexStream2fATI;
   tbl.glVertexStream2fvATI = loader_glVertexStream2fvATI;
   tbl.glVertexStream2dATI = loader_glVertexStream2dATI;
   tbl.glVertexStream2dvATI = loader_glVertexStream2dvATI;
   tbl.glVertexStream3sATI = loader_glVertexStream3sATI;
   tbl.glVertexStream3svATI = loader_glVertexStream3svATI;
   tbl.glVertexStream3iATI = loader_glVertexStream3iATI;
   tbl.glVertexStream3ivATI = loader_glVertexStream3ivATI;
   tbl.glVertexStream3fATI = loader_glVertexStream3fATI;
   tbl.glVertexStream3fvATI = loader_glVertexStream3fvATI;
   tbl.glVertexStream3dATI = loader_glVertexStream3dATI;
   tbl.glVertexStream3dvATI = loader_glVertexStream3dvATI;
   tbl.glVertexStream4sATI = loader_glVertexStream4sATI;
   tbl.glVertexStream4svATI = loader_glVertexStream4svATI;
   tbl.glVertexStream4iATI = loader_glVertexStream4iATI;
   tbl.glVertexStream4ivATI = loader_glVertexStream4ivATI;
   tbl.glVertexStream4fATI = loader_glVertexStream4fATI;
   tbl.glVertexStream4fvATI = loader_glVertexStream4fvATI;
   tbl.glVertexStream4dATI = loader_glVertexStream4dATI;
   tbl.glVertexStream4dvATI = loader_glVertexStream4dvATI;
   tbl.glNormalStream3bATI = loader_glNormalStream3bATI;
   tbl.glNormalStream3bvATI = loader_glNormalStream3bvATI;
   tbl.glNormalStream3sATI = loader_glNormalStream3sATI;
   tbl.glNormalStream3svATI = loader_glNormalStream3svATI;
   tbl.glNormalStream3iATI = loader_glNormalStream3iATI;
   tbl.glNormalStream3ivATI = loader_glNormalStream3ivATI;
   tbl.glNormalStream3fATI = loader_glNormalStream3fATI;
   tbl.glNormalStream3fvATI = loader_glNormalStream3fvATI;
   tbl.glNormalStream3dATI = loader_glNormalStream3dATI;
   tbl.glNormalStream3dvATI = loader_glNormalStream3dvATI;
   tbl.glClientActiveVertexStreamATI = loader_glClientActiveVertexStreamATI;
   tbl.glVertexBlendEnviATI = loader_glVertexBlendEnviATI;
   tbl.glVertexBlendEnvfATI = loader_glVertexBlendEnvfATI;

// GL_ATI_element_array

   tbl.glElementPointerATI = loader_glElementPointerATI;
   tbl.glDrawElementArrayATI = loader_glDrawElementArrayATI;
   tbl.glDrawRangeElementArrayATI = loader_glDrawRangeElementArrayATI;

// GL_SUN_mesh_array

   tbl.glDrawMeshArraysSUN = loader_glDrawMeshArraysSUN;

// GL_NV_occlusion_query

   tbl.glGenOcclusionQueriesNV = loader_glGenOcclusionQueriesNV;
   tbl.glDeleteOcclusionQueriesNV = loader_glDeleteOcclusionQueriesNV;
   tbl.glIsOcclusionQueryNV = loader_glIsOcclusionQueryNV;
   tbl.glBeginOcclusionQueryNV = loader_glBeginOcclusionQueryNV;
   tbl.glEndOcclusionQueryNV = loader_glEndOcclusionQueryNV;
   tbl.glGetOcclusionQueryivNV = loader_glGetOcclusionQueryivNV;
   tbl.glGetOcclusionQueryuivNV = loader_glGetOcclusionQueryuivNV;

// GL_NV_point_sprite

   tbl.glPointParameteriNV = loader_glPointParameteriNV;
   tbl.glPointParameterivNV = loader_glPointParameterivNV;

// GL_EXT_stencil_two_side

   tbl.glActiveStencilFaceEXT = loader_glActiveStencilFaceEXT;

// GL_APPLE_element_array

   tbl.glElementPointerAPPLE = loader_glElementPointerAPPLE;
   tbl.glDrawElementArrayAPPLE = loader_glDrawElementArrayAPPLE;
   tbl.glDrawRangeElementArrayAPPLE = loader_glDrawRangeElementArrayAPPLE;
   tbl.glMultiDrawElementArrayAPPLE = loader_glMultiDrawElementArrayAPPLE;
   tbl.glMultiDrawRangeElementArrayAPPLE = loader_glMultiDrawRangeElementArrayAPPLE;

// GL_APPLE_fence

   tbl.glGenFencesAPPLE = loader_glGenFencesAPPLE;
   tbl.glDeleteFencesAPPLE = loader_glDeleteFencesAPPLE;
   tbl.glSetFenceAPPLE = loader_glSetFenceAPPLE;
   tbl.glIsFenceAPPLE = loader_glIsFenceAPPLE;
   tbl.glTestFenceAPPLE = loader_glTestFenceAPPLE;
   tbl.glFinishFenceAPPLE = loader_glFinishFenceAPPLE;
   tbl.glTestObjectAPPLE = loader_glTestObjectAPPLE;
   tbl.glFinishObjectAPPLE = loader_glFinishObjectAPPLE;

// GL_APPLE_vertex_array_object

   tbl.glBindVertexArrayAPPLE = loader_glBindVertexArrayAPPLE;
   tbl.glDeleteVertexArraysAPPLE = loader_glDeleteVertexArraysAPPLE;
   tbl.glGenVertexArraysAPPLE = loader_glGenVertexArraysAPPLE;
   tbl.glIsVertexArrayAPPLE = loader_glIsVertexArrayAPPLE;

// GL_APPLE_vertex_array_range

   tbl.glVertexArrayRangeAPPLE = loader_glVertexArrayRangeAPPLE;
   tbl.glFlushVertexArrayRangeAPPLE = loader_glFlushVertexArrayRangeAPPLE;
   tbl.glVertexArrayParameteriAPPLE = loader_glVertexArrayParameteriAPPLE;

// GL_ATI_draw_buffers

   tbl.glDrawBuffersATI = loader_glDrawBuffersATI;

// GL_NV_fragment_program

   tbl.glProgramNamedParameter4fNV = loader_glProgramNamedParameter4fNV;
   tbl.glProgramNamedParameter4dNV = loader_glProgramNamedParameter4dNV;
   tbl.glProgramNamedParameter4fvNV = loader_glProgramNamedParameter4fvNV;
   tbl.glProgramNamedParameter4dvNV = loader_glProgramNamedParameter4dvNV;
   tbl.glGetProgramNamedParameterfvNV = loader_glGetProgramNamedParameterfvNV;
   tbl.glGetProgramNamedParameterdvNV = loader_glGetProgramNamedParameterdvNV;

// GL_NV_half_float

   tbl.glVertex2hNV = loader_glVertex2hNV;
   tbl.glVertex2hvNV = loader_glVertex2hvNV;
   tbl.glVertex3hNV = loader_glVertex3hNV;
   tbl.glVertex3hvNV = loader_glVertex3hvNV;
   tbl.glVertex4hNV = loader_glVertex4hNV;
   tbl.glVertex4hvNV = loader_glVertex4hvNV;
   tbl.glNormal3hNV = loader_glNormal3hNV;
   tbl.glNormal3hvNV = loader_glNormal3hvNV;
   tbl.glColor3hNV = loader_glColor3hNV;
   tbl.glColor3hvNV = loader_glColor3hvNV;
   tbl.glColor4hNV = loader_glColor4hNV;
   tbl.glColor4hvNV = loader_glColor4hvNV;
   tbl.glTexCoord1hNV = loader_glTexCoord1hNV;
   tbl.glTexCoord1hvNV = loader_glTexCoord1hvNV;
   tbl.glTexCoord2hNV = loader_glTexCoord2hNV;
   tbl.glTexCoord2hvNV = loader_glTexCoord2hvNV;
   tbl.glTexCoord3hNV = loader_glTexCoord3hNV;
   tbl.glTexCoord3hvNV = loader_glTexCoord3hvNV;
   tbl.glTexCoord4hNV = loader_glTexCoord4hNV;
   tbl.glTexCoord4hvNV = loader_glTexCoord4hvNV;
   tbl.glMultiTexCoord1hNV = loader_glMultiTexCoord1hNV;
   tbl.glMultiTexCoord1hvNV = loader_glMultiTexCoord1hvNV;
   tbl.glMultiTexCoord2hNV = loader_glMultiTexCoord2hNV;
   tbl.glMultiTexCoord2hvNV = loader_glMultiTexCoord2hvNV;
   tbl.glMultiTexCoord3hNV = loader_glMultiTexCoord3hNV;
   tbl.glMultiTexCoord3hvNV = loader_glMultiTexCoord3hvNV;
   tbl.glMultiTexCoord4hNV = loader_glMultiTexCoord4hNV;
   tbl.glMultiTexCoord4hvNV = loader_glMultiTexCoord4hvNV;
   tbl.glFogCoordhNV = loader_glFogCoordhNV;
   tbl.glFogCoordhvNV = loader_glFogCoordhvNV;
   tbl.glSecondaryColor3hNV = loader_glSecondaryColor3hNV;
   tbl.glSecondaryColor3hvNV = loader_glSecondaryColor3hvNV;
   tbl.glVertexWeighthNV = loader_glVertexWeighthNV;
   tbl.glVertexWeighthvNV = loader_glVertexWeighthvNV;
   tbl.glVertexAttrib1hNV = loader_glVertexAttrib1hNV;
   tbl.glVertexAttrib1hvNV = loader_glVertexAttrib1hvNV;
   tbl.glVertexAttrib2hNV = loader_glVertexAttrib2hNV;
   tbl.glVertexAttrib2hvNV = loader_glVertexAttrib2hvNV;
   tbl.glVertexAttrib3hNV = loader_glVertexAttrib3hNV;
   tbl.glVertexAttrib3hvNV = loader_glVertexAttrib3hvNV;
   tbl.glVertexAttrib4hNV = loader_glVertexAttrib4hNV;
   tbl.glVertexAttrib4hvNV = loader_glVertexAttrib4hvNV;
   tbl.glVertexAttribs1hvNV = loader_glVertexAttribs1hvNV;
   tbl.glVertexAttribs2hvNV = loader_glVertexAttribs2hvNV;
   tbl.glVertexAttribs3hvNV = loader_glVertexAttribs3hvNV;
   tbl.glVertexAttribs4hvNV = loader_glVertexAttribs4hvNV;

// GL_NV_pixel_data_range

   tbl.glPixelDataRangeNV = loader_glPixelDataRangeNV;
   tbl.glFlushPixelDataRangeNV = loader_glFlushPixelDataRangeNV;

// GL_NV_primitive_restart

   tbl.glPrimitiveRestartNV = loader_glPrimitiveRestartNV;
   tbl.glPrimitiveRestartIndexNV = loader_glPrimitiveRestartIndexNV;

// GL_ATI_map_object_buffer

   tbl.glMapObjectBufferATI = loader_glMapObjectBufferATI;
   tbl.glUnmapObjectBufferATI = loader_glUnmapObjectBufferATI;

// GL_ATI_separate_stencil

   tbl.glStencilOpSeparateATI = loader_glStencilOpSeparateATI;
   tbl.glStencilFuncSeparateATI = loader_glStencilFuncSeparateATI;

// GL_ATI_vertex_attrib_array_object

   tbl.glVertexAttribArrayObjectATI = loader_glVertexAttribArrayObjectATI;
   tbl.glGetVertexAttribArrayObjectfvATI = loader_glGetVertexAttribArrayObjectfvATI;
   tbl.glGetVertexAttribArrayObjectivATI = loader_glGetVertexAttribArrayObjectivATI;

// GL_EXT_depth_bounds_test

   tbl.glDepthBoundsEXT = loader_glDepthBoundsEXT;

// GL_EXT_blend_equation_separate

   tbl.glBlendEquationSeparateEXT = loader_glBlendEquationSeparateEXT;

// GL_EXT_framebuffer_object

   tbl.glIsRenderbufferEXT = loader_glIsRenderbufferEXT;
   tbl.glBindRenderbufferEXT = loader_glBindRenderbufferEXT;
   tbl.glDeleteRenderbuffersEXT = loader_glDeleteRenderbuffersEXT;
   tbl.glGenRenderbuffersEXT = loader_glGenRenderbuffersEXT;
   tbl.glRenderbufferStorageEXT = loader_glRenderbufferStorageEXT;
   tbl.glGetRenderbufferParameterivEXT = loader_glGetRenderbufferParameterivEXT;
   tbl.glIsFramebufferEXT = loader_glIsFramebufferEXT;
   tbl.glBindFramebufferEXT = loader_glBindFramebufferEXT;
   tbl.glDeleteFramebuffersEXT = loader_glDeleteFramebuffersEXT;
   tbl.glGenFramebuffersEXT = loader_glGenFramebuffersEXT;
   tbl.glCheckFramebufferStatusEXT = loader_glCheckFramebufferStatusEXT;
   tbl.glFramebufferTexture1DEXT = loader_glFramebufferTexture1DEXT;
   tbl.glFramebufferTexture2DEXT = loader_glFramebufferTexture2DEXT;
   tbl.glFramebufferTexture3DEXT = loader_glFramebufferTexture3DEXT;
   tbl.glFramebufferRenderbufferEXT = loader_glFramebufferRenderbufferEXT;
   tbl.glGetFramebufferAttachmentParameterivEXT = loader_glGetFramebufferAttachmentParameterivEXT;
   tbl.glGenerateMipmapEXT = loader_glGenerateMipmapEXT;

// GL_GREMEDY_string_marker

   tbl.glStringMarkerGREMEDY = loader_glStringMarkerGREMEDY;

// GL_EXT_stencil_clear_tag

   tbl.glStencilClearTagEXT = loader_glStencilClearTagEXT;

// GL_EXT_framebuffer_blit

   tbl.glBlitFramebufferEXT = loader_glBlitFramebufferEXT;

// GL_EXT_framebuffer_multisample

   tbl.glRenderbufferStorageMultisampleEXT = loader_glRenderbufferStorageMultisampleEXT;

// GL_EXT_timer_query

   tbl.glGetQueryObjecti64vEXT = loader_glGetQueryObjecti64vEXT;
   tbl.glGetQueryObjectui64vEXT = loader_glGetQueryObjectui64vEXT;

// GL_EXT_gpu_program_parameters

   tbl.glProgramEnvParameters4fvEXT = loader_glProgramEnvParameters4fvEXT;
   tbl.glProgramLocalParameters4fvEXT = loader_glProgramLocalParameters4fvEXT;

// GL_APPLE_flush_buffer_range

   tbl.glBufferParameteriAPPLE = loader_glBufferParameteriAPPLE;
   tbl.glFlushMappedBufferRangeAPPLE = loader_glFlushMappedBufferRangeAPPLE;

// GL_NV_gpu_program4

   tbl.glProgramLocalParameterI4iNV = loader_glProgramLocalParameterI4iNV;
   tbl.glProgramLocalParameterI4ivNV = loader_glProgramLocalParameterI4ivNV;
   tbl.glProgramLocalParametersI4ivNV = loader_glProgramLocalParametersI4ivNV;
   tbl.glProgramLocalParameterI4uiNV = loader_glProgramLocalParameterI4uiNV;
   tbl.glProgramLocalParameterI4uivNV = loader_glProgramLocalParameterI4uivNV;
   tbl.glProgramLocalParametersI4uivNV = loader_glProgramLocalParametersI4uivNV;
   tbl.glProgramEnvParameterI4iNV = loader_glProgramEnvParameterI4iNV;
   tbl.glProgramEnvParameterI4ivNV = loader_glProgramEnvParameterI4ivNV;
   tbl.glProgramEnvParametersI4ivNV = loader_glProgramEnvParametersI4ivNV;
   tbl.glProgramEnvParameterI4uiNV = loader_glProgramEnvParameterI4uiNV;
   tbl.glProgramEnvParameterI4uivNV = loader_glProgramEnvParameterI4uivNV;
   tbl.glProgramEnvParametersI4uivNV = loader_glProgramEnvParametersI4uivNV;
   tbl.glGetProgramLocalParameterIivNV = loader_glGetProgramLocalParameterIivNV;
   tbl.glGetProgramLocalParameterIuivNV = loader_glGetProgramLocalParameterIuivNV;
   tbl.glGetProgramEnvParameterIivNV = loader_glGetProgramEnvParameterIivNV;
   tbl.glGetProgramEnvParameterIuivNV = loader_glGetProgramEnvParameterIuivNV;

// GL_NV_geometry_program4

   tbl.glProgramVertexLimitNV = loader_glProgramVertexLimitNV;
   tbl.glFramebufferTextureEXT = loader_glFramebufferTextureEXT;
   tbl.glFramebufferTextureFaceEXT = loader_glFramebufferTextureFaceEXT;

// GL_EXT_geometry_shader4

   tbl.glProgramParameteriEXT = loader_glProgramParameteriEXT;

// GL_NV_vertex_program4

   tbl.glVertexAttribI1iEXT = loader_glVertexAttribI1iEXT;
   tbl.glVertexAttribI2iEXT = loader_glVertexAttribI2iEXT;
   tbl.glVertexAttribI3iEXT = loader_glVertexAttribI3iEXT;
   tbl.glVertexAttribI4iEXT = loader_glVertexAttribI4iEXT;
   tbl.glVertexAttribI1uiEXT = loader_glVertexAttribI1uiEXT;
   tbl.glVertexAttribI2uiEXT = loader_glVertexAttribI2uiEXT;
   tbl.glVertexAttribI3uiEXT = loader_glVertexAttribI3uiEXT;
   tbl.glVertexAttribI4uiEXT = loader_glVertexAttribI4uiEXT;
   tbl.glVertexAttribI1ivEXT = loader_glVertexAttribI1ivEXT;
   tbl.glVertexAttribI2ivEXT = loader_glVertexAttribI2ivEXT;
   tbl.glVertexAttribI3ivEXT = loader_glVertexAttribI3ivEXT;
   tbl.glVertexAttribI4ivEXT = loader_glVertexAttribI4ivEXT;
   tbl.glVertexAttribI1uivEXT = loader_glVertexAttribI1uivEXT;
   tbl.glVertexAttribI2uivEXT = loader_glVertexAttribI2uivEXT;
   tbl.glVertexAttribI3uivEXT = loader_glVertexAttribI3uivEXT;
   tbl.glVertexAttribI4uivEXT = loader_glVertexAttribI4uivEXT;
   tbl.glVertexAttribI4bvEXT = loader_glVertexAttribI4bvEXT;
   tbl.glVertexAttribI4svEXT = loader_glVertexAttribI4svEXT;
   tbl.glVertexAttribI4ubvEXT = loader_glVertexAttribI4ubvEXT;
   tbl.glVertexAttribI4usvEXT = loader_glVertexAttribI4usvEXT;
   tbl.glVertexAttribIPointerEXT = loader_glVertexAttribIPointerEXT;
   tbl.glGetVertexAttribIivEXT = loader_glGetVertexAttribIivEXT;
   tbl.glGetVertexAttribIuivEXT = loader_glGetVertexAttribIuivEXT;

// GL_EXT_gpu_shader4

   tbl.glGetUniformuivEXT = loader_glGetUniformuivEXT;
   tbl.glBindFragDataLocationEXT = loader_glBindFragDataLocationEXT;
   tbl.glGetFragDataLocationEXT = loader_glGetFragDataLocationEXT;
   tbl.glUniform1uiEXT = loader_glUniform1uiEXT;
   tbl.glUniform2uiEXT = loader_glUniform2uiEXT;
   tbl.glUniform3uiEXT = loader_glUniform3uiEXT;
   tbl.glUniform4uiEXT = loader_glUniform4uiEXT;
   tbl.glUniform1uivEXT = loader_glUniform1uivEXT;
   tbl.glUniform2uivEXT = loader_glUniform2uivEXT;
   tbl.glUniform3uivEXT = loader_glUniform3uivEXT;
   tbl.glUniform4uivEXT = loader_glUniform4uivEXT;

// GL_EXT_draw_instanced

   tbl.glDrawArraysInstancedEXT = loader_glDrawArraysInstancedEXT;
   tbl.glDrawElementsInstancedEXT = loader_glDrawElementsInstancedEXT;

// GL_EXT_texture_array

   tbl.glFramebufferTextureLayerEXT = loader_glFramebufferTextureLayerEXT;

// GL_EXT_texture_buffer_object

   tbl.glTexBufferEXT = loader_glTexBufferEXT;

// GL_NV_depth_buffer_float

   tbl.glDepthRangedNV = loader_glDepthRangedNV;
   tbl.glClearDepthdNV = loader_glClearDepthdNV;
   tbl.glDepthBoundsdNV = loader_glDepthBoundsdNV;

// GL_NV_framebuffer_multisample_coverage

   tbl.glRenderbufferStorageMultisampleCoverageNV = loader_glRenderbufferStorageMultisampleCoverageNV;

// GL_NV_parameter_buffer_object

   tbl.glProgramBufferParametersfvNV = loader_glProgramBufferParametersfvNV;
   tbl.glProgramBufferParametersIivNV = loader_glProgramBufferParametersIivNV;
   tbl.glProgramBufferParametersIuivNV = loader_glProgramBufferParametersIuivNV;

// GL_EXT_draw_buffers2

   tbl.glColorMaskIndexedEXT = loader_glColorMaskIndexedEXT;
   tbl.glGetBooleanIndexedvEXT = loader_glGetBooleanIndexedvEXT;
   tbl.glGetIntegerIndexedvEXT = loader_glGetIntegerIndexedvEXT;
   tbl.glEnableIndexedEXT = loader_glEnableIndexedEXT;
   tbl.glDisableIndexedEXT = loader_glDisableIndexedEXT;
   tbl.glIsEnabledIndexedEXT = loader_glIsEnabledIndexedEXT;

// GL_NV_transform_feedback

   tbl.glBeginTransformFeedbackNV = loader_glBeginTransformFeedbackNV;
   tbl.glEndTransformFeedbackNV = loader_glEndTransformFeedbackNV;
   tbl.glTransformFeedbackAttribsNV = loader_glTransformFeedbackAttribsNV;
   tbl.glBindBufferRangeNV = loader_glBindBufferRangeNV;
   tbl.glBindBufferOffsetNV = loader_glBindBufferOffsetNV;
   tbl.glBindBufferBaseNV = loader_glBindBufferBaseNV;
   tbl.glTransformFeedbackVaryingsNV = loader_glTransformFeedbackVaryingsNV;
   tbl.glActiveVaryingNV = loader_glActiveVaryingNV;
   tbl.glGetVaryingLocationNV = loader_glGetVaryingLocationNV;
   tbl.glGetActiveVaryingNV = loader_glGetActiveVaryingNV;
   tbl.glGetTransformFeedbackVaryingNV = loader_glGetTransformFeedbackVaryingNV;

// GL_EXT_bindable_uniform

   tbl.glUniformBufferEXT = loader_glUniformBufferEXT;
   tbl.glGetUniformBufferSizeEXT = loader_glGetUniformBufferSizeEXT;
   tbl.glGetUniformOffsetEXT = loader_glGetUniformOffsetEXT;

// GL_EXT_texture_integer

   tbl.glTexParameterIivEXT = loader_glTexParameterIivEXT;
   tbl.glTexParameterIuivEXT = loader_glTexParameterIuivEXT;
   tbl.glGetTexParameterIivEXT = loader_glGetTexParameterIivEXT;
   tbl.glGetTexParameterIuivEXT = loader_glGetTexParameterIuivEXT;
   tbl.glClearColorIiEXT = loader_glClearColorIiEXT;
   tbl.glClearColorIuiEXT = loader_glClearColorIuiEXT;

// GL_GREMEDY_frame_terminator

   tbl.glFrameTerminatorGREMEDY = loader_glFrameTerminatorGREMEDY;

// GL_NV_conditional_render

   tbl.glBeginConditionalRenderNV = loader_glBeginConditionalRenderNV;
   tbl.glEndConditionalRenderNV = loader_glEndConditionalRenderNV;

// GL_NV_present_video

   tbl.glPresentFrameKeyedNV = loader_glPresentFrameKeyedNV;
   tbl.glPresentFrameDualFillNV = loader_glPresentFrameDualFillNV;
   tbl.glGetVideoivNV = loader_glGetVideoivNV;
   tbl.glGetVideouivNV = loader_glGetVideouivNV;
   tbl.glGetVideoi64vNV = loader_glGetVideoi64vNV;
   tbl.glGetVideoui64vNV = loader_glGetVideoui64vNV;

// GL_EXT_transform_feedback

   tbl.glBeginTransformFeedbackEXT = loader_glBeginTransformFeedbackEXT;
   tbl.glEndTransformFeedbackEXT = loader_glEndTransformFeedbackEXT;
   tbl.glBindBufferRangeEXT = loader_glBindBufferRangeEXT;
   tbl.glBindBufferOffsetEXT = loader_glBindBufferOffsetEXT;
   tbl.glBindBufferBaseEXT = loader_glBindBufferBaseEXT;
   tbl.glTransformFeedbackVaryingsEXT = loader_glTransformFeedbackVaryingsEXT;
   tbl.glGetTransformFeedbackVaryingEXT = loader_glGetTransformFeedbackVaryingEXT;

// GL_EXT_direct_state_access

   tbl.glClientAttribDefaultEXT = loader_glClientAttribDefaultEXT;
   tbl.glPushClientAttribDefaultEXT = loader_glPushClientAttribDefaultEXT;
   tbl.glMatrixLoadfEXT = loader_glMatrixLoadfEXT;
   tbl.glMatrixLoaddEXT = loader_glMatrixLoaddEXT;
   tbl.glMatrixMultfEXT = loader_glMatrixMultfEXT;
   tbl.glMatrixMultdEXT = loader_glMatrixMultdEXT;
   tbl.glMatrixLoadIdentityEXT = loader_glMatrixLoadIdentityEXT;
   tbl.glMatrixRotatefEXT = loader_glMatrixRotatefEXT;
   tbl.glMatrixRotatedEXT = loader_glMatrixRotatedEXT;
   tbl.glMatrixScalefEXT = loader_glMatrixScalefEXT;
   tbl.glMatrixScaledEXT = loader_glMatrixScaledEXT;
   tbl.glMatrixTranslatefEXT = loader_glMatrixTranslatefEXT;
   tbl.glMatrixTranslatedEXT = loader_glMatrixTranslatedEXT;
   tbl.glMatrixFrustumEXT = loader_glMatrixFrustumEXT;
   tbl.glMatrixOrthoEXT = loader_glMatrixOrthoEXT;
   tbl.glMatrixPopEXT = loader_glMatrixPopEXT;
   tbl.glMatrixPushEXT = loader_glMatrixPushEXT;
   tbl.glMatrixLoadTransposefEXT = loader_glMatrixLoadTransposefEXT;
   tbl.glMatrixLoadTransposedEXT = loader_glMatrixLoadTransposedEXT;
   tbl.glMatrixMultTransposefEXT = loader_glMatrixMultTransposefEXT;
   tbl.glMatrixMultTransposedEXT = loader_glMatrixMultTransposedEXT;
   tbl.glTextureParameterfEXT = loader_glTextureParameterfEXT;
   tbl.glTextureParameterfvEXT = loader_glTextureParameterfvEXT;
   tbl.glTextureParameteriEXT = loader_glTextureParameteriEXT;
   tbl.glTextureParameterivEXT = loader_glTextureParameterivEXT;
   tbl.glTextureImage1DEXT = loader_glTextureImage1DEXT;
   tbl.glTextureImage2DEXT = loader_glTextureImage2DEXT;
   tbl.glTextureSubImage1DEXT = loader_glTextureSubImage1DEXT;
   tbl.glTextureSubImage2DEXT = loader_glTextureSubImage2DEXT;
   tbl.glCopyTextureImage1DEXT = loader_glCopyTextureImage1DEXT;
   tbl.glCopyTextureImage2DEXT = loader_glCopyTextureImage2DEXT;
   tbl.glCopyTextureSubImage1DEXT = loader_glCopyTextureSubImage1DEXT;
   tbl.glCopyTextureSubImage2DEXT = loader_glCopyTextureSubImage2DEXT;
   tbl.glGetTextureImageEXT = loader_glGetTextureImageEXT;
   tbl.glGetTextureParameterfvEXT = loader_glGetTextureParameterfvEXT;
   tbl.glGetTextureParameterivEXT = loader_glGetTextureParameterivEXT;
   tbl.glGetTextureLevelParameterfvEXT = loader_glGetTextureLevelParameterfvEXT;
   tbl.glGetTextureLevelParameterivEXT = loader_glGetTextureLevelParameterivEXT;
   tbl.glTextureImage3DEXT = loader_glTextureImage3DEXT;
   tbl.glTextureSubImage3DEXT = loader_glTextureSubImage3DEXT;
   tbl.glCopyTextureSubImage3DEXT = loader_glCopyTextureSubImage3DEXT;
   tbl.glMultiTexParameterfEXT = loader_glMultiTexParameterfEXT;
   tbl.glMultiTexParameterfvEXT = loader_glMultiTexParameterfvEXT;
   tbl.glMultiTexParameteriEXT = loader_glMultiTexParameteriEXT;
   tbl.glMultiTexParameterivEXT = loader_glMultiTexParameterivEXT;
   tbl.glMultiTexImage1DEXT = loader_glMultiTexImage1DEXT;
   tbl.glMultiTexImage2DEXT = loader_glMultiTexImage2DEXT;
   tbl.glMultiTexSubImage1DEXT = loader_glMultiTexSubImage1DEXT;
   tbl.glMultiTexSubImage2DEXT = loader_glMultiTexSubImage2DEXT;
   tbl.glCopyMultiTexImage1DEXT = loader_glCopyMultiTexImage1DEXT;
   tbl.glCopyMultiTexImage2DEXT = loader_glCopyMultiTexImage2DEXT;
   tbl.glCopyMultiTexSubImage1DEXT = loader_glCopyMultiTexSubImage1DEXT;
   tbl.glCopyMultiTexSubImage2DEXT = loader_glCopyMultiTexSubImage2DEXT;
   tbl.glGetMultiTexImageEXT = loader_glGetMultiTexImageEXT;
   tbl.glGetMultiTexParameterfvEXT = loader_glGetMultiTexParameterfvEXT;
   tbl.glGetMultiTexParameterivEXT = loader_glGetMultiTexParameterivEXT;
   tbl.glGetMultiTexLevelParameterfvEXT = loader_glGetMultiTexLevelParameterfvEXT;
   tbl.glGetMultiTexLevelParameterivEXT = loader_glGetMultiTexLevelParameterivEXT;
   tbl.glMultiTexImage3DEXT = loader_glMultiTexImage3DEXT;
   tbl.glMultiTexSubImage3DEXT = loader_glMultiTexSubImage3DEXT;
   tbl.glCopyMultiTexSubImage3DEXT = loader_glCopyMultiTexSubImage3DEXT;
   tbl.glBindMultiTextureEXT = loader_glBindMultiTextureEXT;
   tbl.glEnableClientStateIndexedEXT = loader_glEnableClientStateIndexedEXT;
   tbl.glDisableClientStateIndexedEXT = loader_glDisableClientStateIndexedEXT;
   tbl.glMultiTexCoordPointerEXT = loader_glMultiTexCoordPointerEXT;
   tbl.glMultiTexEnvfEXT = loader_glMultiTexEnvfEXT;
   tbl.glMultiTexEnvfvEXT = loader_glMultiTexEnvfvEXT;
   tbl.glMultiTexEnviEXT = loader_glMultiTexEnviEXT;
   tbl.glMultiTexEnvivEXT = loader_glMultiTexEnvivEXT;
   tbl.glMultiTexGendEXT = loader_glMultiTexGendEXT;
   tbl.glMultiTexGendvEXT = loader_glMultiTexGendvEXT;
   tbl.glMultiTexGenfEXT = loader_glMultiTexGenfEXT;
   tbl.glMultiTexGenfvEXT = loader_glMultiTexGenfvEXT;
   tbl.glMultiTexGeniEXT = loader_glMultiTexGeniEXT;
   tbl.glMultiTexGenivEXT = loader_glMultiTexGenivEXT;
   tbl.glGetMultiTexEnvfvEXT = loader_glGetMultiTexEnvfvEXT;
   tbl.glGetMultiTexEnvivEXT = loader_glGetMultiTexEnvivEXT;
   tbl.glGetMultiTexGendvEXT = loader_glGetMultiTexGendvEXT;
   tbl.glGetMultiTexGenfvEXT = loader_glGetMultiTexGenfvEXT;
   tbl.glGetMultiTexGenivEXT = loader_glGetMultiTexGenivEXT;
   tbl.glGetFloatIndexedvEXT = loader_glGetFloatIndexedvEXT;
   tbl.glGetDoubleIndexedvEXT = loader_glGetDoubleIndexedvEXT;
   tbl.glGetPointerIndexedvEXT = loader_glGetPointerIndexedvEXT;
   tbl.glCompressedTextureImage3DEXT = loader_glCompressedTextureImage3DEXT;
   tbl.glCompressedTextureImage2DEXT = loader_glCompressedTextureImage2DEXT;
   tbl.glCompressedTextureImage1DEXT = loader_glCompressedTextureImage1DEXT;
   tbl.glCompressedTextureSubImage3DEXT = loader_glCompressedTextureSubImage3DEXT;
   tbl.glCompressedTextureSubImage2DEXT = loader_glCompressedTextureSubImage2DEXT;
   tbl.glCompressedTextureSubImage1DEXT = loader_glCompressedTextureSubImage1DEXT;
   tbl.glGetCompressedTextureImageEXT = loader_glGetCompressedTextureImageEXT;
   tbl.glCompressedMultiTexImage3DEXT = loader_glCompressedMultiTexImage3DEXT;
   tbl.glCompressedMultiTexImage2DEXT = loader_glCompressedMultiTexImage2DEXT;
   tbl.glCompressedMultiTexImage1DEXT = loader_glCompressedMultiTexImage1DEXT;
   tbl.glCompressedMultiTexSubImage3DEXT = loader_glCompressedMultiTexSubImage3DEXT;
   tbl.glCompressedMultiTexSubImage2DEXT = loader_glCompressedMultiTexSubImage2DEXT;
   tbl.glCompressedMultiTexSubImage1DEXT = loader_glCompressedMultiTexSubImage1DEXT;
   tbl.glGetCompressedMultiTexImageEXT = loader_glGetCompressedMultiTexImageEXT;
   tbl.glNamedProgramStringEXT = loader_glNamedProgramStringEXT;
   tbl.glNamedProgramLocalParameter4dEXT = loader_glNamedProgramLocalParameter4dEXT;
   tbl.glNamedProgramLocalParameter4dvEXT = loader_glNamedProgramLocalParameter4dvEXT;
   tbl.glNamedProgramLocalParameter4fEXT = loader_glNamedProgramLocalParameter4fEXT;
   tbl.glNamedProgramLocalParameter4fvEXT = loader_glNamedProgramLocalParameter4fvEXT;
   tbl.glGetNamedProgramLocalParameterdvEXT = loader_glGetNamedProgramLocalParameterdvEXT;
   tbl.glGetNamedProgramLocalParameterfvEXT = loader_glGetNamedProgramLocalParameterfvEXT;
   tbl.glGetNamedProgramivEXT = loader_glGetNamedProgramivEXT;
   tbl.glGetNamedProgramStringEXT = loader_glGetNamedProgramStringEXT;
   tbl.glNamedProgramLocalParameters4fvEXT = loader_glNamedProgramLocalParameters4fvEXT;
   tbl.glNamedProgramLocalParameterI4iEXT = loader_glNamedProgramLocalParameterI4iEXT;
   tbl.glNamedProgramLocalParameterI4ivEXT = loader_glNamedProgramLocalParameterI4ivEXT;
   tbl.glNamedProgramLocalParametersI4ivEXT = loader_glNamedProgramLocalParametersI4ivEXT;
   tbl.glNamedProgramLocalParameterI4uiEXT = loader_glNamedProgramLocalParameterI4uiEXT;
   tbl.glNamedProgramLocalParameterI4uivEXT = loader_glNamedProgramLocalParameterI4uivEXT;
   tbl.glNamedProgramLocalParametersI4uivEXT = loader_glNamedProgramLocalParametersI4uivEXT;
   tbl.glGetNamedProgramLocalParameterIivEXT = loader_glGetNamedProgramLocalParameterIivEXT;
   tbl.glGetNamedProgramLocalParameterIuivEXT = loader_glGetNamedProgramLocalParameterIuivEXT;
   tbl.glTextureParameterIivEXT = loader_glTextureParameterIivEXT;
   tbl.glTextureParameterIuivEXT = loader_glTextureParameterIuivEXT;
   tbl.glGetTextureParameterIivEXT = loader_glGetTextureParameterIivEXT;
   tbl.glGetTextureParameterIuivEXT = loader_glGetTextureParameterIuivEXT;
   tbl.glMultiTexParameterIivEXT = loader_glMultiTexParameterIivEXT;
   tbl.glMultiTexParameterIuivEXT = loader_glMultiTexParameterIuivEXT;
   tbl.glGetMultiTexParameterIivEXT = loader_glGetMultiTexParameterIivEXT;
   tbl.glGetMultiTexParameterIuivEXT = loader_glGetMultiTexParameterIuivEXT;
   tbl.glProgramUniform1fEXT = loader_glProgramUniform1fEXT;
   tbl.glProgramUniform2fEXT = loader_glProgramUniform2fEXT;
   tbl.glProgramUniform3fEXT = loader_glProgramUniform3fEXT;
   tbl.glProgramUniform4fEXT = loader_glProgramUniform4fEXT;
   tbl.glProgramUniform1iEXT = loader_glProgramUniform1iEXT;
   tbl.glProgramUniform2iEXT = loader_glProgramUniform2iEXT;
   tbl.glProgramUniform3iEXT = loader_glProgramUniform3iEXT;
   tbl.glProgramUniform4iEXT = loader_glProgramUniform4iEXT;
   tbl.glProgramUniform1fvEXT = loader_glProgramUniform1fvEXT;
   tbl.glProgramUniform2fvEXT = loader_glProgramUniform2fvEXT;
   tbl.glProgramUniform3fvEXT = loader_glProgramUniform3fvEXT;
   tbl.glProgramUniform4fvEXT = loader_glProgramUniform4fvEXT;
   tbl.glProgramUniform1ivEXT = loader_glProgramUniform1ivEXT;
   tbl.glProgramUniform2ivEXT = loader_glProgramUniform2ivEXT;
   tbl.glProgramUniform3ivEXT = loader_glProgramUniform3ivEXT;
   tbl.glProgramUniform4ivEXT = loader_glProgramUniform4ivEXT;
   tbl.glProgramUniformMatrix2fvEXT = loader_glProgramUniformMatrix2fvEXT;
   tbl.glProgramUniformMatrix3fvEXT = loader_glProgramUniformMatrix3fvEXT;
   tbl.glProgramUniformMatrix4fvEXT = loader_glProgramUniformMatrix4fvEXT;
   tbl.glProgramUniformMatrix2x3fvEXT = loader_glProgramUniformMatrix2x3fvEXT;
   tbl.glProgramUniformMatrix3x2fvEXT = loader_glProgramUniformMatrix3x2fvEXT;
   tbl.glProgramUniformMatrix2x4fvEXT = loader_glProgramUniformMatrix2x4fvEXT;
   tbl.glProgramUniformMatrix4x2fvEXT = loader_glProgramUniformMatrix4x2fvEXT;
   tbl.glProgramUniformMatrix3x4fvEXT = loader_glProgramUniformMatrix3x4fvEXT;
   tbl.glProgramUniformMatrix4x3fvEXT = loader_glProgramUniformMatrix4x3fvEXT;
   tbl.glProgramUniform1uiEXT = loader_glProgramUniform1uiEXT;
   tbl.glProgramUniform2uiEXT = loader_glProgramUniform2uiEXT;
   tbl.glProgramUniform3uiEXT = loader_glProgramUniform3uiEXT;
   tbl.glProgramUniform4uiEXT = loader_glProgramUniform4uiEXT;
   tbl.glProgramUniform1uivEXT = loader_glProgramUniform1uivEXT;
   tbl.glProgramUniform2uivEXT = loader_glProgramUniform2uivEXT;
   tbl.glProgramUniform3uivEXT = loader_glProgramUniform3uivEXT;
   tbl.glProgramUniform4uivEXT = loader_glProgramUniform4uivEXT;
   tbl.glNamedBufferDataEXT = loader_glNamedBufferDataEXT;
   tbl.glNamedBufferSubDataEXT = loader_glNamedBufferSubDataEXT;
   tbl.glMapNamedBufferEXT = loader_glMapNamedBufferEXT;
   tbl.glUnmapNamedBufferEXT = loader_glUnmapNamedBufferEXT;
   tbl.glGetNamedBufferParameterivEXT = loader_glGetNamedBufferParameterivEXT;
   tbl.glGetNamedBufferPointervEXT = loader_glGetNamedBufferPointervEXT;
   tbl.glGetNamedBufferSubDataEXT = loader_glGetNamedBufferSubDataEXT;
   tbl.glTextureBufferEXT = loader_glTextureBufferEXT;
   tbl.glMultiTexBufferEXT = loader_glMultiTexBufferEXT;
   tbl.glNamedRenderbufferStorageEXT = loader_glNamedRenderbufferStorageEXT;
   tbl.glGetNamedRenderbufferParameterivEXT = loader_glGetNamedRenderbufferParameterivEXT;
   tbl.glCheckNamedFramebufferStatusEXT = loader_glCheckNamedFramebufferStatusEXT;
   tbl.glNamedFramebufferTexture1DEXT = loader_glNamedFramebufferTexture1DEXT;
   tbl.glNamedFramebufferTexture2DEXT = loader_glNamedFramebufferTexture2DEXT;
   tbl.glNamedFramebufferTexture3DEXT = loader_glNamedFramebufferTexture3DEXT;
   tbl.glNamedFramebufferRenderbufferEXT = loader_glNamedFramebufferRenderbufferEXT;
   tbl.glGetNamedFramebufferAttachmentParameterivEXT = loader_glGetNamedFramebufferAttachmentParameterivEXT;
   tbl.glGenerateTextureMipmapEXT = loader_glGenerateTextureMipmapEXT;
   tbl.glGenerateMultiTexMipmapEXT = loader_glGenerateMultiTexMipmapEXT;
   tbl.glFramebufferDrawBufferEXT = loader_glFramebufferDrawBufferEXT;
   tbl.glFramebufferDrawBuffersEXT = loader_glFramebufferDrawBuffersEXT;
   tbl.glFramebufferReadBufferEXT = loader_glFramebufferReadBufferEXT;
   tbl.glGetFramebufferParameterivEXT = loader_glGetFramebufferParameterivEXT;
   tbl.glNamedRenderbufferStorageMultisampleEXT = loader_glNamedRenderbufferStorageMultisampleEXT;
   tbl.glNamedRenderbufferStorageMultisampleCoverageEXT = loader_glNamedRenderbufferStorageMultisampleCoverageEXT;
   tbl.glNamedFramebufferTextureEXT = loader_glNamedFramebufferTextureEXT;
   tbl.glNamedFramebufferTextureLayerEXT = loader_glNamedFramebufferTextureLayerEXT;
   tbl.glNamedFramebufferTextureFaceEXT = loader_glNamedFramebufferTextureFaceEXT;
   tbl.glTextureRenderbufferEXT = loader_glTextureRenderbufferEXT;
   tbl.glMultiTexRenderbufferEXT = loader_glMultiTexRenderbufferEXT;
   tbl.glMapNamedBufferRangeEXT = loader_glMapNamedBufferRangeEXT;
   tbl.glFlushMappedNamedBufferRangeEXT = loader_glFlushMappedNamedBufferRangeEXT;
   tbl.glNamedCopyBufferSubDataEXT = loader_glNamedCopyBufferSubDataEXT;
   tbl.glProgramUniform1dEXT = loader_glProgramUniform1dEXT;
   tbl.glProgramUniform2dEXT = loader_glProgramUniform2dEXT;
   tbl.glProgramUniform3dEXT = loader_glProgramUniform3dEXT;
   tbl.glProgramUniform4dEXT = loader_glProgramUniform4dEXT;
   tbl.glProgramUniform1dvEXT = loader_glProgramUniform1dvEXT;
   tbl.glProgramUniform2dvEXT = loader_glProgramUniform2dvEXT;
   tbl.glProgramUniform3dvEXT = loader_glProgramUniform3dvEXT;
   tbl.glProgramUniform4dvEXT = loader_glProgramUniform4dvEXT;
   tbl.glProgramUniformMatrix2dvEXT = loader_glProgramUniformMatrix2dvEXT;
   tbl.glProgramUniformMatrix3dvEXT = loader_glProgramUniformMatrix3dvEXT;
   tbl.glProgramUniformMatrix4dvEXT = loader_glProgramUniformMatrix4dvEXT;
   tbl.glProgramUniformMatrix2x3dvEXT = loader_glProgramUniformMatrix2x3dvEXT;
   tbl.glProgramUniformMatrix2x4dvEXT = loader_glProgramUniformMatrix2x4dvEXT;
   tbl.glProgramUniformMatrix3x2dvEXT = loader_glProgramUniformMatrix3x2dvEXT;
   tbl.glProgramUniformMatrix3x4dvEXT = loader_glProgramUniformMatrix3x4dvEXT;
   tbl.glProgramUniformMatrix4x2dvEXT = loader_glProgramUniformMatrix4x2dvEXT;
   tbl.glProgramUniformMatrix4x3dvEXT = loader_glProgramUniformMatrix4x3dvEXT;

// GL_NV_explicit_multisample

   tbl.glGetMultisamplefvNV = loader_glGetMultisamplefvNV;
   tbl.glSampleMaskIndexedNV = loader_glSampleMaskIndexedNV;
   tbl.glTexRenderbufferNV = loader_glTexRenderbufferNV;

// GL_NV_transform_feedback2

   tbl.glBindTransformFeedbackNV = loader_glBindTransformFeedbackNV;
   tbl.glDeleteTransformFeedbacksNV = loader_glDeleteTransformFeedbacksNV;
   tbl.glGenTransformFeedbacksNV = loader_glGenTransformFeedbacksNV;
   tbl.glIsTransformFeedbackNV = loader_glIsTransformFeedbackNV;
   tbl.glPauseTransformFeedbackNV = loader_glPauseTransformFeedbackNV;
   tbl.glResumeTransformFeedbackNV = loader_glResumeTransformFeedbackNV;
   tbl.glDrawTransformFeedbackNV = loader_glDrawTransformFeedbackNV;

// GL_AMD_performance_monitor

   tbl.glGetPerfMonitorGroupsAMD = loader_glGetPerfMonitorGroupsAMD;
   tbl.glGetPerfMonitorCountersAMD = loader_glGetPerfMonitorCountersAMD;
   tbl.glGetPerfMonitorGroupStringAMD = loader_glGetPerfMonitorGroupStringAMD;
   tbl.glGetPerfMonitorCounterStringAMD = loader_glGetPerfMonitorCounterStringAMD;
   tbl.glGetPerfMonitorCounterInfoAMD = loader_glGetPerfMonitorCounterInfoAMD;
   tbl.glGenPerfMonitorsAMD = loader_glGenPerfMonitorsAMD;
   tbl.glDeletePerfMonitorsAMD = loader_glDeletePerfMonitorsAMD;
   tbl.glSelectPerfMonitorCountersAMD = loader_glSelectPerfMonitorCountersAMD;
   tbl.glBeginPerfMonitorAMD = loader_glBeginPerfMonitorAMD;
   tbl.glEndPerfMonitorAMD = loader_glEndPerfMonitorAMD;
   tbl.glGetPerfMonitorCounterDataAMD = loader_glGetPerfMonitorCounterDataAMD;

// GL_AMD_vertex_shader_tessellator

   tbl.glTessellationFactorAMD = loader_glTessellationFactorAMD;
   tbl.glTessellationModeAMD = loader_glTessellationModeAMD;

// GL_EXT_provoking_vertex

   tbl.glProvokingVertexEXT = loader_glProvokingVertexEXT;

// GL_AMD_draw_buffers_blend

   tbl.glBlendFuncIndexedAMD = loader_glBlendFuncIndexedAMD;
   tbl.glBlendFuncSeparateIndexedAMD = loader_glBlendFuncSeparateIndexedAMD;
   tbl.glBlendEquationIndexedAMD = loader_glBlendEquationIndexedAMD;
   tbl.glBlendEquationSeparateIndexedAMD = loader_glBlendEquationSeparateIndexedAMD;

// GL_APPLE_texture_range

   tbl.glTextureRangeAPPLE = loader_glTextureRangeAPPLE;
   tbl.glGetTexParameterPointervAPPLE = loader_glGetTexParameterPointervAPPLE;

// GL_APPLE_vertex_program_evaluators

   tbl.glEnableVertexAttribAPPLE = loader_glEnableVertexAttribAPPLE;
   tbl.glDisableVertexAttribAPPLE = loader_glDisableVertexAttribAPPLE;
   tbl.glIsVertexAttribEnabledAPPLE = loader_glIsVertexAttribEnabledAPPLE;
   tbl.glMapVertexAttrib1dAPPLE = loader_glMapVertexAttrib1dAPPLE;
   tbl.glMapVertexAttrib1fAPPLE = loader_glMapVertexAttrib1fAPPLE;
   tbl.glMapVertexAttrib2dAPPLE = loader_glMapVertexAttrib2dAPPLE;
   tbl.glMapVertexAttrib2fAPPLE = loader_glMapVertexAttrib2fAPPLE;

// GL_APPLE_object_purgeable

   tbl.glObjectPurgeableAPPLE = loader_glObjectPurgeableAPPLE;
   tbl.glObjectUnpurgeableAPPLE = loader_glObjectUnpurgeableAPPLE;
   tbl.glGetObjectParameterivAPPLE = loader_glGetObjectParameterivAPPLE;

// GL_NV_video_capture

   tbl.glBeginVideoCaptureNV = loader_glBeginVideoCaptureNV;
   tbl.glBindVideoCaptureStreamBufferNV = loader_glBindVideoCaptureStreamBufferNV;
   tbl.glBindVideoCaptureStreamTextureNV = loader_glBindVideoCaptureStreamTextureNV;
   tbl.glEndVideoCaptureNV = loader_glEndVideoCaptureNV;
   tbl.glGetVideoCaptureivNV = loader_glGetVideoCaptureivNV;
   tbl.glGetVideoCaptureStreamivNV = loader_glGetVideoCaptureStreamivNV;
   tbl.glGetVideoCaptureStreamfvNV = loader_glGetVideoCaptureStreamfvNV;
   tbl.glGetVideoCaptureStreamdvNV = loader_glGetVideoCaptureStreamdvNV;
   tbl.glVideoCaptureNV = loader_glVideoCaptureNV;
   tbl.glVideoCaptureStreamParameterivNV = loader_glVideoCaptureStreamParameterivNV;
   tbl.glVideoCaptureStreamParameterfvNV = loader_glVideoCaptureStreamParameterfvNV;
   tbl.glVideoCaptureStreamParameterdvNV = loader_glVideoCaptureStreamParameterdvNV;

// GL_NV_copy_image

   tbl.glCopyImageSubDataNV = loader_glCopyImageSubDataNV;

// GL_EXT_separate_shader_objects

   tbl.glUseShaderProgramEXT = loader_glUseShaderProgramEXT;
   tbl.glActiveProgramEXT = loader_glActiveProgramEXT;
   tbl.glCreateShaderProgramEXT = loader_glCreateShaderProgramEXT;

// GL_NV_shader_buffer_load

   tbl.glMakeBufferResidentNV = loader_glMakeBufferResidentNV;
   tbl.glMakeBufferNonResidentNV = loader_glMakeBufferNonResidentNV;
   tbl.glIsBufferResidentNV = loader_glIsBufferResidentNV;
   tbl.glMakeNamedBufferResidentNV = loader_glMakeNamedBufferResidentNV;
   tbl.glMakeNamedBufferNonResidentNV = loader_glMakeNamedBufferNonResidentNV;
   tbl.glIsNamedBufferResidentNV = loader_glIsNamedBufferResidentNV;
   tbl.glGetBufferParameterui64vNV = loader_glGetBufferParameterui64vNV;
   tbl.glGetNamedBufferParameterui64vNV = loader_glGetNamedBufferParameterui64vNV;
   tbl.glGetIntegerui64vNV = loader_glGetIntegerui64vNV;
   tbl.glUniformui64NV = loader_glUniformui64NV;
   tbl.glUniformui64vNV = loader_glUniformui64vNV;
   tbl.glGetUniformui64vNV = loader_glGetUniformui64vNV;
   tbl.glProgramUniformui64NV = loader_glProgramUniformui64NV;
   tbl.glProgramUniformui64vNV = loader_glProgramUniformui64vNV;

// GL_NV_vertex_buffer_unified_memory

   tbl.glBufferAddressRangeNV = loader_glBufferAddressRangeNV;
   tbl.glVertexFormatNV = loader_glVertexFormatNV;
   tbl.glNormalFormatNV = loader_glNormalFormatNV;
   tbl.glColorFormatNV = loader_glColorFormatNV;
   tbl.glIndexFormatNV = loader_glIndexFormatNV;
   tbl.glTexCoordFormatNV = loader_glTexCoordFormatNV;
   tbl.glEdgeFlagFormatNV = loader_glEdgeFlagFormatNV;
   tbl.glSecondaryColorFormatNV = loader_glSecondaryColorFormatNV;
   tbl.glFogCoordFormatNV = loader_glFogCoordFormatNV;
   tbl.glVertexAttribFormatNV = loader_glVertexAttribFormatNV;
   tbl.glVertexAttribIFormatNV = loader_glVertexAttribIFormatNV;
   tbl.glGetIntegerui64i_vNV = loader_glGetIntegerui64i_vNV;

// GL_NV_texture_barrier

   tbl.glTextureBarrierNV = loader_glTextureBarrierNV;

// GL_EXT_shader_image_load_store

   tbl.glBindImageTextureEXT = loader_glBindImageTextureEXT;
   tbl.glMemoryBarrierEXT = loader_glMemoryBarrierEXT;

// GL_EXT_vertex_attrib_64bit

   tbl.glVertexAttribL1dEXT = loader_glVertexAttribL1dEXT;
   tbl.glVertexAttribL2dEXT = loader_glVertexAttribL2dEXT;
   tbl.glVertexAttribL3dEXT = loader_glVertexAttribL3dEXT;
   tbl.glVertexAttribL4dEXT = loader_glVertexAttribL4dEXT;
   tbl.glVertexAttribL1dvEXT = loader_glVertexAttribL1dvEXT;
   tbl.glVertexAttribL2dvEXT = loader_glVertexAttribL2dvEXT;
   tbl.glVertexAttribL3dvEXT = loader_glVertexAttribL3dvEXT;
   tbl.glVertexAttribL4dvEXT = loader_glVertexAttribL4dvEXT;
   tbl.glVertexAttribLPointerEXT = loader_glVertexAttribLPointerEXT;
   tbl.glVertexArrayVertexAttribLOffsetEXT = loader_glVertexArrayVertexAttribLOffsetEXT;
   tbl.glGetVertexAttribLdvEXT = loader_glGetVertexAttribLdvEXT;

// GL_NV_gpu_shader5

   tbl.glUniform1i64NV = loader_glUniform1i64NV;
   tbl.glUniform2i64NV = loader_glUniform2i64NV;
   tbl.glUniform3i64NV = loader_glUniform3i64NV;
   tbl.glUniform4i64NV = loader_glUniform4i64NV;
   tbl.glUniform1i64vNV = loader_glUniform1i64vNV;
   tbl.glUniform2i64vNV = loader_glUniform2i64vNV;
   tbl.glUniform3i64vNV = loader_glUniform3i64vNV;
   tbl.glUniform4i64vNV = loader_glUniform4i64vNV;
   tbl.glUniform1ui64NV = loader_glUniform1ui64NV;
   tbl.glUniform2ui64NV = loader_glUniform2ui64NV;
   tbl.glUniform3ui64NV = loader_glUniform3ui64NV;
   tbl.glUniform4ui64NV = loader_glUniform4ui64NV;
   tbl.glUniform1ui64vNV = loader_glUniform1ui64vNV;
   tbl.glUniform2ui64vNV = loader_glUniform2ui64vNV;
   tbl.glUniform3ui64vNV = loader_glUniform3ui64vNV;
   tbl.glUniform4ui64vNV = loader_glUniform4ui64vNV;
   tbl.glProgramUniform1i64NV = loader_glProgramUniform1i64NV;
   tbl.glProgramUniform2i64NV = loader_glProgramUniform2i64NV;
   tbl.glProgramUniform3i64NV = loader_glProgramUniform3i64NV;
   tbl.glProgramUniform4i64NV = loader_glProgramUniform4i64NV;
   tbl.glProgramUniform1i64vNV = loader_glProgramUniform1i64vNV;
   tbl.glProgramUniform2i64vNV = loader_glProgramUniform2i64vNV;
   tbl.glProgramUniform3i64vNV = loader_glProgramUniform3i64vNV;
   tbl.glProgramUniform4i64vNV = loader_glProgramUniform4i64vNV;
   tbl.glProgramUniform1ui64NV = loader_glProgramUniform1ui64NV;
   tbl.glProgramUniform2ui64NV = loader_glProgramUniform2ui64NV;
   tbl.glProgramUniform3ui64NV = loader_glProgramUniform3ui64NV;
   tbl.glProgramUniform4ui64NV = loader_glProgramUniform4ui64NV;
   tbl.glProgramUniform1ui64vNV = loader_glProgramUniform1ui64vNV;
   tbl.glProgramUniform2ui64vNV = loader_glProgramUniform2ui64vNV;
   tbl.glProgramUniform3ui64vNV = loader_glProgramUniform3ui64vNV;
   tbl.glProgramUniform4ui64vNV = loader_glProgramUniform4ui64vNV;
   tbl.glGetUniformi64vNV = loader_glGetUniformi64vNV;

// GL_NV_vertex_attrib_integer_64bit

   tbl.glVertexAttribL1i64NV = loader_glVertexAttribL1i64NV;
   tbl.glVertexAttribL2i64NV = loader_glVertexAttribL2i64NV;
   tbl.glVertexAttribL3i64NV = loader_glVertexAttribL3i64NV;
   tbl.glVertexAttribL4i64NV = loader_glVertexAttribL4i64NV;
   tbl.glVertexAttribL1ui64NV = loader_glVertexAttribL1ui64NV;
   tbl.glVertexAttribL2ui64NV = loader_glVertexAttribL2ui64NV;
   tbl.glVertexAttribL3ui64NV = loader_glVertexAttribL3ui64NV;
   tbl.glVertexAttribL4ui64NV = loader_glVertexAttribL4ui64NV;
   tbl.glVertexAttribL1i64vNV = loader_glVertexAttribL1i64vNV;
   tbl.glVertexAttribL2i64vNV = loader_glVertexAttribL2i64vNV;
   tbl.glVertexAttribL3i64vNV = loader_glVertexAttribL3i64vNV;
   tbl.glVertexAttribL4i64vNV = loader_glVertexAttribL4i64vNV;
   tbl.glVertexAttribL1ui64vNV = loader_glVertexAttribL1ui64vNV;
   tbl.glVertexAttribL2ui64vNV = loader_glVertexAttribL2ui64vNV;
   tbl.glVertexAttribL3ui64vNV = loader_glVertexAttribL3ui64vNV;
   tbl.glVertexAttribL4ui64vNV = loader_glVertexAttribL4ui64vNV;
   tbl.glVertexAttribLFormatNV = loader_glVertexAttribLFormatNV;
   tbl.glGetVertexAttribLi64vNV = loader_glGetVertexAttribLi64vNV;
   tbl.glGetVertexAttribLui64vNV = loader_glGetVertexAttribLui64vNV;

// GL_NV_vdpau_interop

   tbl.glVDPAUInitNV = loader_glVDPAUInitNV;
   tbl.glVDPAUFiniNV = loader_glVDPAUFiniNV;
   tbl.glVDPAURegisterVideoSurfaceNV = loader_glVDPAURegisterVideoSurfaceNV;
   tbl.glVDPAURegisterOutputSurfaceNV = loader_glVDPAURegisterOutputSurfaceNV;
   tbl.glVDPAUIsSurfaceNV = loader_glVDPAUIsSurfaceNV;
   tbl.glVDPAUUnregisterSurfaceNV = loader_glVDPAUUnregisterSurfaceNV;
   tbl.glVDPAUGetSurfaceivNV = loader_glVDPAUGetSurfaceivNV;
   tbl.glVDPAUSurfaceAccessNV = loader_glVDPAUSurfaceAccessNV;
   tbl.glVDPAUMapSurfacesNV = loader_glVDPAUMapSurfacesNV;
   tbl.glVDPAUUnmapSurfacesNV = loader_glVDPAUUnmapSurfacesNV;

// GL_NV_path_rendering

   tbl.glCopyPathNV = loader_glCopyPathNV;
   tbl.glCoverFillPathInstancedNV = loader_glCoverFillPathInstancedNV;
   tbl.glCoverFillPathNV = loader_glCoverFillPathNV;
   tbl.glCoverStrokePathInstancedNV = loader_glCoverStrokePathInstancedNV;
   tbl.glCoverStrokePathNV = loader_glCoverStrokePathNV;
   tbl.glDeletePathsNV = loader_glDeletePathsNV;
   tbl.glGenPathsNV = loader_glGenPathsNV;
   tbl.glGetPathColorGenfvNV = loader_glGetPathColorGenfvNV;
   tbl.glGetPathColorGenivNV = loader_glGetPathColorGenivNV;
   tbl.glGetPathCommandsNV = loader_glGetPathCommandsNV;
   tbl.glGetPathCoordsNV = loader_glGetPathCoordsNV;
   tbl.glGetPathDashArrayNV = loader_glGetPathDashArrayNV;
   tbl.glGetPathLengthNV = loader_glGetPathLengthNV;
   tbl.glGetPathMetricRangeNV = loader_glGetPathMetricRangeNV;
   tbl.glGetPathMetricsNV = loader_glGetPathMetricsNV;
   tbl.glGetPathParameterfvNV = loader_glGetPathParameterfvNV;
   tbl.glGetPathParameterivNV = loader_glGetPathParameterivNV;
   tbl.glGetPathSpacingNV = loader_glGetPathSpacingNV;
   tbl.glGetPathTexGenfvNV = loader_glGetPathTexGenfvNV;
   tbl.glGetPathTexGenivNV = loader_glGetPathTexGenivNV;
   tbl.glInterpolatePathsNV = loader_glInterpolatePathsNV;
   tbl.glIsPathNV = loader_glIsPathNV;
   tbl.glIsPointInFillPathNV = loader_glIsPointInFillPathNV;
   tbl.glIsPointInStrokePathNV = loader_glIsPointInStrokePathNV;
   tbl.glPathColorGenNV = loader_glPathColorGenNV;
   tbl.glPathCommandsNV = loader_glPathCommandsNV;
   tbl.glPathCoordsNV = loader_glPathCoordsNV;
   tbl.glPathCoverDepthFuncNV = loader_glPathCoverDepthFuncNV;
   tbl.glPathDashArrayNV = loader_glPathDashArrayNV;
   tbl.glPathFogGenNV = loader_glPathFogGenNV;
   tbl.glPathGlyphRangeNV = loader_glPathGlyphRangeNV;
   tbl.glPathGlyphsNV = loader_glPathGlyphsNV;
   tbl.glPathParameterfNV = loader_glPathParameterfNV;
   tbl.glPathParameterfvNV = loader_glPathParameterfvNV;
   tbl.glPathParameteriNV = loader_glPathParameteriNV;
   tbl.glPathParameterivNV = loader_glPathParameterivNV;
   tbl.glPathStencilDepthOffsetNV = loader_glPathStencilDepthOffsetNV;
   tbl.glPathStencilFuncNV = loader_glPathStencilFuncNV;
   tbl.glPathStringNV = loader_glPathStringNV;
   tbl.glPathSubCommandsNV = loader_glPathSubCommandsNV;
   tbl.glPathSubCoordsNV = loader_glPathSubCoordsNV;
   tbl.glPathTexGenNV = loader_glPathTexGenNV;
   tbl.glPointAlongPathNV = loader_glPointAlongPathNV;
   tbl.glStencilFillPathInstancedNV = loader_glStencilFillPathInstancedNV;
   tbl.glStencilFillPathNV = loader_glStencilFillPathNV;
   tbl.glStencilStrokePathInstancedNV = loader_glStencilStrokePathInstancedNV;
   tbl.glStencilStrokePathNV = loader_glStencilStrokePathNV;
   tbl.glTransformPathNV = loader_glTransformPathNV;
   tbl.glWeightPathsNV = loader_glWeightPathsNV;

// GL_REGAL_extension_query

   tbl.glGetExtensionREGAL = loader_glGetExtensionREGAL;
   tbl.glIsSupportedREGAL = loader_glIsSupportedREGAL;

// GL_AMD_debug_output

   tbl.glGetDebugMessageLogAMD = loader_glGetDebugMessageLogAMD;
   tbl.glDebugMessageCallbackAMD = loader_glDebugMessageCallbackAMD;
   tbl.glDebugMessageEnableAMD = loader_glDebugMessageEnableAMD;
   tbl.glDebugMessageInsertAMD = loader_glDebugMessageInsertAMD;

// GL_AMD_multi_draw_indirect

   tbl.glMultiDrawArraysIndirectAMD = loader_glMultiDrawArraysIndirectAMD;
   tbl.glMultiDrawElementsIndirectAMD = loader_glMultiDrawElementsIndirectAMD;

// GL_AMD_name_gen_delete

   tbl.glIsNameAMD = loader_glIsNameAMD;
   tbl.glDeleteNamesAMD = loader_glDeleteNamesAMD;
   tbl.glGenNamesAMD = loader_glGenNamesAMD;

// GL_AMD_sample_positions

   tbl.glSetMultisamplefvAMD = loader_glSetMultisamplefvAMD;

// GL_AMD_stencil_operation_extended

   tbl.glStencilOpValueAMD = loader_glStencilOpValueAMD;

// GL_ARB_base_instance

   tbl.glDrawArraysInstancedBaseInstance = loader_glDrawArraysInstancedBaseInstance;
   tbl.glDrawElementsInstancedBaseInstance = loader_glDrawElementsInstancedBaseInstance;
   tbl.glDrawElementsInstancedBaseVertexBaseInstance = loader_glDrawElementsInstancedBaseVertexBaseInstance;

// GL_ARB_cl_event

   tbl.glCreateSyncFromCLeventARB = loader_glCreateSyncFromCLeventARB;

// GL_ARB_internalformat_query

   tbl.glGetInternalformativ = loader_glGetInternalformativ;

// GL_ARB_texture_storage

   tbl.glTexStorage1D = loader_glTexStorage1D;
   tbl.glTexStorage2D = loader_glTexStorage2D;
   tbl.glTexStorage3D = loader_glTexStorage3D;
   tbl.glTextureStorage1DEXT = loader_glTextureStorage1DEXT;
   tbl.glTextureStorage2DEXT = loader_glTextureStorage2DEXT;
   tbl.glTextureStorage3DEXT = loader_glTextureStorage3DEXT;

// GL_ARB_transform_feedback_instanced

   tbl.glDrawTransformFeedbackInstanced = loader_glDrawTransformFeedbackInstanced;
   tbl.glDrawTransformFeedbackStreamInstanced = loader_glDrawTransformFeedbackStreamInstanced;

// GL_EXT_x11_sync_object

   tbl.glImportSyncEXT = loader_glImportSyncEXT;

// GL_INTEL_texture_scissor

   tbl.glTexScissorFuncINTEL = loader_glTexScissorFuncINTEL;
   tbl.glTexScissorINTEL = loader_glTexScissorINTEL;

// GL_NV_bindless_texture

   tbl.glIsImageHandleResidentNV = loader_glIsImageHandleResidentNV;
   tbl.glIsTextureHandleResidentNV = loader_glIsTextureHandleResidentNV;
   tbl.glGetImageHandleNV = loader_glGetImageHandleNV;
   tbl.glGetTextureHandleNV = loader_glGetTextureHandleNV;
   tbl.glGetTextureSamplerHandleNV = loader_glGetTextureSamplerHandleNV;
   tbl.glMakeImageHandleNonResidentNV = loader_glMakeImageHandleNonResidentNV;
   tbl.glMakeImageHandleResidentNV = loader_glMakeImageHandleResidentNV;
   tbl.glMakeTextureHandleNonResidentNV = loader_glMakeTextureHandleNonResidentNV;
   tbl.glMakeTextureHandleResidentNV = loader_glMakeTextureHandleResidentNV;
   tbl.glProgramUniformHandleui64NV = loader_glProgramUniformHandleui64NV;
   tbl.glProgramUniformHandleui64vNV = loader_glProgramUniformHandleui64vNV;
   tbl.glUniformHandleui64NV = loader_glUniformHandleui64NV;
   tbl.glUniformHandleui64vNV = loader_glUniformHandleui64vNV;

// GL_NV_texture_multisample

   tbl.glTexImage2DMultisampleCoverageNV = loader_glTexImage2DMultisampleCoverageNV;
   tbl.glTexImage3DMultisampleCoverageNV = loader_glTexImage3DMultisampleCoverageNV;
   tbl.glTextureImage2DMultisampleCoverageNV = loader_glTextureImage2DMultisampleCoverageNV;
   tbl.glTextureImage2DMultisampleNV = loader_glTextureImage2DMultisampleNV;
   tbl.glTextureImage3DMultisampleCoverageNV = loader_glTextureImage3DMultisampleCoverageNV;
   tbl.glTextureImage3DMultisampleNV = loader_glTextureImage3DMultisampleNV;

// GL_SUN_read_video_pixels

   tbl.glReadVideoPixelsSUN = loader_glReadVideoPixelsSUN;

// GL_EXT_fragment_lighting

   tbl.glFragmentColorMaterialEXT = loader_glFragmentColorMaterialEXT;
   tbl.glFragmentLightModelfEXT = loader_glFragmentLightModelfEXT;
   tbl.glFragmentLightModelfvEXT = loader_glFragmentLightModelfvEXT;
   tbl.glFragmentLightModeliEXT = loader_glFragmentLightModeliEXT;
   tbl.glFragmentLightModelivEXT = loader_glFragmentLightModelivEXT;
   tbl.glFragmentLightfEXT = loader_glFragmentLightfEXT;
   tbl.glFragmentLightfvEXT = loader_glFragmentLightfvEXT;
   tbl.glFragmentLightiEXT = loader_glFragmentLightiEXT;
   tbl.glFragmentLightivEXT = loader_glFragmentLightivEXT;
   tbl.glFragmentMaterialfEXT = loader_glFragmentMaterialfEXT;
   tbl.glFragmentMaterialfvEXT = loader_glFragmentMaterialfvEXT;
   tbl.glFragmentMaterialiEXT = loader_glFragmentMaterialiEXT;
   tbl.glFragmentMaterialivEXT = loader_glFragmentMaterialivEXT;
   tbl.glGetFragmentLightfvEXT = loader_glGetFragmentLightfvEXT;
   tbl.glGetFragmentLightivEXT = loader_glGetFragmentLightivEXT;
   tbl.glGetFragmentMaterialfvEXT = loader_glGetFragmentMaterialfvEXT;
   tbl.glGetFragmentMaterialivEXT = loader_glGetFragmentMaterialivEXT;
   tbl.glLightEnviEXT = loader_glLightEnviEXT;

// GL_EXT_debug_marker

   tbl.glInsertEventMarkerEXT = loader_glInsertEventMarkerEXT;
   tbl.glPushGroupMarkerEXT = loader_glPushGroupMarkerEXT;
   tbl.glPopGroupMarkerEXT = loader_glPopGroupMarkerEXT;

// GL_KTX_buffer_region

   tbl.glBufferRegionEnabledEXT = loader_glBufferRegionEnabledEXT;
   tbl.glNewBufferRegionEXT = loader_glNewBufferRegionEXT;
   tbl.glDeleteBufferRegionEXT = loader_glDeleteBufferRegionEXT;
   tbl.glReadBufferRegionEXT = loader_glReadBufferRegionEXT;
   tbl.glDrawBufferRegionEXT = loader_glDrawBufferRegionEXT;

// GL_SGIX_fog_texture

   tbl.glTextureFogSGIX = loader_glTextureFogSGIX;

// GL_APPLE_flush_render

   tbl.glFlushRenderAPPLE = loader_glFlushRenderAPPLE;
   tbl.glFinishRenderAPPLE = loader_glFinishRenderAPPLE;
   tbl.glSwapAPPLE = loader_glSwapAPPLE;

// GL_WIN_swap_hint

   tbl.glAddSwapHintRectWIN = loader_glAddSwapHintRectWIN;

}

REGAL_NAMESPACE_END
