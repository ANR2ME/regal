/* NOTE: Do not edit this file, it is generated by a script:
   Export.py --api gl 4.2 --api wgl 4.0 --api glx 4.0 --api cgl 1.4 --api egl 1.0 --outdir src/regal
*/

/*
  Copyright (c) 2011 NVIDIA Corporation
  Copyright (c) 2011-2012 Cass Everitt
  Copyright (c) 2012 Scott Nations
  Copyright (c) 2012 Mathias Schott
  Copyright (c) 2012 Nigel Stewart
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "pch.h" /* For MS precompiled header support */

#include "RegalUtil.h"

REGAL_GLOBAL_BEGIN

#include <string>
using namespace std;

#include "RegalLog.h"
#include "RegalToken.h"
#include "RegalHelper.h"
#include "RegalPrivate.h"
#include "RegalContext.h"
#include "RegalDispatchState.h"

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

using namespace ::REGAL_NAMESPACE_INTERNAL::Logging;
using namespace ::REGAL_NAMESPACE_INTERNAL::Token;

// GL_VERSION_1_0

static void REGAL_CALL missing_glAccum(GLenum op, GLfloat value)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(value);
   Warning( "glAccum not available." );
}

static void REGAL_CALL loader_glAccum(GLenum op, GLfloat value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glAccum, "glAccum");
   if ( !driverTbl.glAccum ) {
      driverTbl.glAccum = missing_glAccum;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glAccum == loader_glAccum) {
      rCtx->dsp->emuTbl.glAccum = driverTbl.glAccum;
   }
   driverTbl.glAccum(op, value);
}

static void REGAL_CALL missing_glAlphaFunc(GLenum func, GLclampf ref)
{
   UNUSED_PARAMETER(func);
   UNUSED_PARAMETER(ref);
   Warning( "glAlphaFunc not available." );
}

static void REGAL_CALL loader_glAlphaFunc(GLenum func, GLclampf ref)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glAlphaFunc, "glAlphaFunc");
   if ( !driverTbl.glAlphaFunc ) {
      driverTbl.glAlphaFunc = missing_glAlphaFunc;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glAlphaFunc == loader_glAlphaFunc) {
      rCtx->dsp->emuTbl.glAlphaFunc = driverTbl.glAlphaFunc;
   }
   driverTbl.glAlphaFunc(func, ref);
}

static void REGAL_CALL missing_glBegin(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glBegin not available." );
}

static void REGAL_CALL loader_glBegin(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBegin, "glBegin");
   if ( !driverTbl.glBegin ) {
      driverTbl.glBegin = missing_glBegin;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBegin == loader_glBegin) {
      rCtx->dsp->emuTbl.glBegin = driverTbl.glBegin;
   }
   driverTbl.glBegin(mode);
}

static void REGAL_CALL missing_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(xorig);
   UNUSED_PARAMETER(yorig);
   UNUSED_PARAMETER(xmove);
   UNUSED_PARAMETER(ymove);
   UNUSED_PARAMETER(bitmap);
   Warning( "glBitmap not available." );
}

static void REGAL_CALL loader_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBitmap, "glBitmap");
   if ( !driverTbl.glBitmap ) {
      driverTbl.glBitmap = missing_glBitmap;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBitmap == loader_glBitmap) {
      rCtx->dsp->emuTbl.glBitmap = driverTbl.glBitmap;
   }
   driverTbl.glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
}

static void REGAL_CALL missing_glBlendFunc(GLenum sfactor, GLenum dfactor)
{
   UNUSED_PARAMETER(sfactor);
   UNUSED_PARAMETER(dfactor);
   Warning( "glBlendFunc not available." );
}

static void REGAL_CALL loader_glBlendFunc(GLenum sfactor, GLenum dfactor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendFunc, "glBlendFunc");
   if ( !driverTbl.glBlendFunc ) {
      driverTbl.glBlendFunc = missing_glBlendFunc;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendFunc == loader_glBlendFunc) {
      rCtx->dsp->emuTbl.glBlendFunc = driverTbl.glBlendFunc;
   }
   driverTbl.glBlendFunc(sfactor, dfactor);
}

static void REGAL_CALL missing_glCallList(GLuint list)
{
   UNUSED_PARAMETER(list);
   Warning( "glCallList not available." );
}

static void REGAL_CALL loader_glCallList(GLuint list)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCallList, "glCallList");
   if ( !driverTbl.glCallList ) {
      driverTbl.glCallList = missing_glCallList;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCallList == loader_glCallList) {
      rCtx->dsp->emuTbl.glCallList = driverTbl.glCallList;
   }
   driverTbl.glCallList(list);
}

static void REGAL_CALL missing_glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(lists);
   Warning( "glCallLists not available." );
}

static void REGAL_CALL loader_glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCallLists, "glCallLists");
   if ( !driverTbl.glCallLists ) {
      driverTbl.glCallLists = missing_glCallLists;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCallLists == loader_glCallLists) {
      rCtx->dsp->emuTbl.glCallLists = driverTbl.glCallLists;
   }
   driverTbl.glCallLists(n, type, lists);
}

static void REGAL_CALL missing_glClear(GLbitfield mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "glClear not available." );
}

static void REGAL_CALL loader_glClear(GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClear, "glClear");
   if ( !driverTbl.glClear ) {
      driverTbl.glClear = missing_glClear;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClear == loader_glClear) {
      rCtx->dsp->emuTbl.glClear = driverTbl.glClear;
   }
   driverTbl.glClear(mask);
}

static void REGAL_CALL missing_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glClearAccum not available." );
}

static void REGAL_CALL loader_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearAccum, "glClearAccum");
   if ( !driverTbl.glClearAccum ) {
      driverTbl.glClearAccum = missing_glClearAccum;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearAccum == loader_glClearAccum) {
      rCtx->dsp->emuTbl.glClearAccum = driverTbl.glClearAccum;
   }
   driverTbl.glClearAccum(red, green, blue, alpha);
}

static void REGAL_CALL missing_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glClearColor not available." );
}

static void REGAL_CALL loader_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearColor, "glClearColor");
   if ( !driverTbl.glClearColor ) {
      driverTbl.glClearColor = missing_glClearColor;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearColor == loader_glClearColor) {
      rCtx->dsp->emuTbl.glClearColor = driverTbl.glClearColor;
   }
   driverTbl.glClearColor(red, green, blue, alpha);
}

static void REGAL_CALL missing_glClearDepth(GLclampd depth)
{
   UNUSED_PARAMETER(depth);
   Warning( "glClearDepth not available." );
}

static void REGAL_CALL loader_glClearDepth(GLclampd depth)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearDepth, "glClearDepth");
   if ( !driverTbl.glClearDepth ) {
      driverTbl.glClearDepth = missing_glClearDepth;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearDepth == loader_glClearDepth) {
      rCtx->dsp->emuTbl.glClearDepth = driverTbl.glClearDepth;
   }
   driverTbl.glClearDepth(depth);
}

static void REGAL_CALL missing_glClearIndex(GLfloat c)
{
   UNUSED_PARAMETER(c);
   Warning( "glClearIndex not available." );
}

static void REGAL_CALL loader_glClearIndex(GLfloat c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearIndex, "glClearIndex");
   if ( !driverTbl.glClearIndex ) {
      driverTbl.glClearIndex = missing_glClearIndex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearIndex == loader_glClearIndex) {
      rCtx->dsp->emuTbl.glClearIndex = driverTbl.glClearIndex;
   }
   driverTbl.glClearIndex(c);
}

static void REGAL_CALL missing_glClearStencil(GLint s)
{
   UNUSED_PARAMETER(s);
   Warning( "glClearStencil not available." );
}

static void REGAL_CALL loader_glClearStencil(GLint s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearStencil, "glClearStencil");
   if ( !driverTbl.glClearStencil ) {
      driverTbl.glClearStencil = missing_glClearStencil;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearStencil == loader_glClearStencil) {
      rCtx->dsp->emuTbl.glClearStencil = driverTbl.glClearStencil;
   }
   driverTbl.glClearStencil(s);
}

static void REGAL_CALL missing_glClipPlane(GLenum plane, const GLdouble *equation)
{
   UNUSED_PARAMETER(plane);
   UNUSED_PARAMETER(equation);
   Warning( "glClipPlane not available." );
}

static void REGAL_CALL loader_glClipPlane(GLenum plane, const GLdouble *equation)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClipPlane, "glClipPlane");
   if ( !driverTbl.glClipPlane ) {
      driverTbl.glClipPlane = missing_glClipPlane;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClipPlane == loader_glClipPlane) {
      rCtx->dsp->emuTbl.glClipPlane = driverTbl.glClipPlane;
   }
   driverTbl.glClipPlane(plane, equation);
}

static void REGAL_CALL missing_glColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glColor3b not available." );
}

static void REGAL_CALL loader_glColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3b, "glColor3b");
   if ( !driverTbl.glColor3b ) {
      driverTbl.glColor3b = missing_glColor3b;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3b == loader_glColor3b) {
      rCtx->dsp->emuTbl.glColor3b = driverTbl.glColor3b;
   }
   driverTbl.glColor3b(red, green, blue);
}

static void REGAL_CALL missing_glColor3bv(const GLbyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor3bv not available." );
}

static void REGAL_CALL loader_glColor3bv(const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3bv, "glColor3bv");
   if ( !driverTbl.glColor3bv ) {
      driverTbl.glColor3bv = missing_glColor3bv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3bv == loader_glColor3bv) {
      rCtx->dsp->emuTbl.glColor3bv = driverTbl.glColor3bv;
   }
   driverTbl.glColor3bv(v);
}

static void REGAL_CALL missing_glColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glColor3d not available." );
}

static void REGAL_CALL loader_glColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3d, "glColor3d");
   if ( !driverTbl.glColor3d ) {
      driverTbl.glColor3d = missing_glColor3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3d == loader_glColor3d) {
      rCtx->dsp->emuTbl.glColor3d = driverTbl.glColor3d;
   }
   driverTbl.glColor3d(red, green, blue);
}

static void REGAL_CALL missing_glColor3dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor3dv not available." );
}

static void REGAL_CALL loader_glColor3dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3dv, "glColor3dv");
   if ( !driverTbl.glColor3dv ) {
      driverTbl.glColor3dv = missing_glColor3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3dv == loader_glColor3dv) {
      rCtx->dsp->emuTbl.glColor3dv = driverTbl.glColor3dv;
   }
   driverTbl.glColor3dv(v);
}

static void REGAL_CALL missing_glColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glColor3f not available." );
}

static void REGAL_CALL loader_glColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3f, "glColor3f");
   if ( !driverTbl.glColor3f ) {
      driverTbl.glColor3f = missing_glColor3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3f == loader_glColor3f) {
      rCtx->dsp->emuTbl.glColor3f = driverTbl.glColor3f;
   }
   driverTbl.glColor3f(red, green, blue);
}

static void REGAL_CALL missing_glColor3fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor3fv not available." );
}

static void REGAL_CALL loader_glColor3fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3fv, "glColor3fv");
   if ( !driverTbl.glColor3fv ) {
      driverTbl.glColor3fv = missing_glColor3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3fv == loader_glColor3fv) {
      rCtx->dsp->emuTbl.glColor3fv = driverTbl.glColor3fv;
   }
   driverTbl.glColor3fv(v);
}

static void REGAL_CALL missing_glColor3i(GLint red, GLint green, GLint blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glColor3i not available." );
}

static void REGAL_CALL loader_glColor3i(GLint red, GLint green, GLint blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3i, "glColor3i");
   if ( !driverTbl.glColor3i ) {
      driverTbl.glColor3i = missing_glColor3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3i == loader_glColor3i) {
      rCtx->dsp->emuTbl.glColor3i = driverTbl.glColor3i;
   }
   driverTbl.glColor3i(red, green, blue);
}

static void REGAL_CALL missing_glColor3iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor3iv not available." );
}

static void REGAL_CALL loader_glColor3iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3iv, "glColor3iv");
   if ( !driverTbl.glColor3iv ) {
      driverTbl.glColor3iv = missing_glColor3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3iv == loader_glColor3iv) {
      rCtx->dsp->emuTbl.glColor3iv = driverTbl.glColor3iv;
   }
   driverTbl.glColor3iv(v);
}

static void REGAL_CALL missing_glColor3s(GLshort red, GLshort green, GLshort blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glColor3s not available." );
}

static void REGAL_CALL loader_glColor3s(GLshort red, GLshort green, GLshort blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3s, "glColor3s");
   if ( !driverTbl.glColor3s ) {
      driverTbl.glColor3s = missing_glColor3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3s == loader_glColor3s) {
      rCtx->dsp->emuTbl.glColor3s = driverTbl.glColor3s;
   }
   driverTbl.glColor3s(red, green, blue);
}

static void REGAL_CALL missing_glColor3sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor3sv not available." );
}

static void REGAL_CALL loader_glColor3sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3sv, "glColor3sv");
   if ( !driverTbl.glColor3sv ) {
      driverTbl.glColor3sv = missing_glColor3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3sv == loader_glColor3sv) {
      rCtx->dsp->emuTbl.glColor3sv = driverTbl.glColor3sv;
   }
   driverTbl.glColor3sv(v);
}

static void REGAL_CALL missing_glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glColor3ub not available." );
}

static void REGAL_CALL loader_glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3ub, "glColor3ub");
   if ( !driverTbl.glColor3ub ) {
      driverTbl.glColor3ub = missing_glColor3ub;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3ub == loader_glColor3ub) {
      rCtx->dsp->emuTbl.glColor3ub = driverTbl.glColor3ub;
   }
   driverTbl.glColor3ub(red, green, blue);
}

static void REGAL_CALL missing_glColor3ubv(const GLubyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor3ubv not available." );
}

static void REGAL_CALL loader_glColor3ubv(const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3ubv, "glColor3ubv");
   if ( !driverTbl.glColor3ubv ) {
      driverTbl.glColor3ubv = missing_glColor3ubv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3ubv == loader_glColor3ubv) {
      rCtx->dsp->emuTbl.glColor3ubv = driverTbl.glColor3ubv;
   }
   driverTbl.glColor3ubv(v);
}

static void REGAL_CALL missing_glColor3ui(GLuint red, GLuint green, GLuint blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glColor3ui not available." );
}

static void REGAL_CALL loader_glColor3ui(GLuint red, GLuint green, GLuint blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3ui, "glColor3ui");
   if ( !driverTbl.glColor3ui ) {
      driverTbl.glColor3ui = missing_glColor3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3ui == loader_glColor3ui) {
      rCtx->dsp->emuTbl.glColor3ui = driverTbl.glColor3ui;
   }
   driverTbl.glColor3ui(red, green, blue);
}

static void REGAL_CALL missing_glColor3uiv(const GLuint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor3uiv not available." );
}

static void REGAL_CALL loader_glColor3uiv(const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3uiv, "glColor3uiv");
   if ( !driverTbl.glColor3uiv ) {
      driverTbl.glColor3uiv = missing_glColor3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3uiv == loader_glColor3uiv) {
      rCtx->dsp->emuTbl.glColor3uiv = driverTbl.glColor3uiv;
   }
   driverTbl.glColor3uiv(v);
}

static void REGAL_CALL missing_glColor3us(GLushort red, GLushort green, GLushort blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glColor3us not available." );
}

static void REGAL_CALL loader_glColor3us(GLushort red, GLushort green, GLushort blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3us, "glColor3us");
   if ( !driverTbl.glColor3us ) {
      driverTbl.glColor3us = missing_glColor3us;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3us == loader_glColor3us) {
      rCtx->dsp->emuTbl.glColor3us = driverTbl.glColor3us;
   }
   driverTbl.glColor3us(red, green, blue);
}

static void REGAL_CALL missing_glColor3usv(const GLushort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor3usv not available." );
}

static void REGAL_CALL loader_glColor3usv(const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3usv, "glColor3usv");
   if ( !driverTbl.glColor3usv ) {
      driverTbl.glColor3usv = missing_glColor3usv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3usv == loader_glColor3usv) {
      rCtx->dsp->emuTbl.glColor3usv = driverTbl.glColor3usv;
   }
   driverTbl.glColor3usv(v);
}

static void REGAL_CALL missing_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glColor4b not available." );
}

static void REGAL_CALL loader_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4b, "glColor4b");
   if ( !driverTbl.glColor4b ) {
      driverTbl.glColor4b = missing_glColor4b;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4b == loader_glColor4b) {
      rCtx->dsp->emuTbl.glColor4b = driverTbl.glColor4b;
   }
   driverTbl.glColor4b(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4bv(const GLbyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor4bv not available." );
}

static void REGAL_CALL loader_glColor4bv(const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4bv, "glColor4bv");
   if ( !driverTbl.glColor4bv ) {
      driverTbl.glColor4bv = missing_glColor4bv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4bv == loader_glColor4bv) {
      rCtx->dsp->emuTbl.glColor4bv = driverTbl.glColor4bv;
   }
   driverTbl.glColor4bv(v);
}

static void REGAL_CALL missing_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glColor4d not available." );
}

static void REGAL_CALL loader_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4d, "glColor4d");
   if ( !driverTbl.glColor4d ) {
      driverTbl.glColor4d = missing_glColor4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4d == loader_glColor4d) {
      rCtx->dsp->emuTbl.glColor4d = driverTbl.glColor4d;
   }
   driverTbl.glColor4d(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor4dv not available." );
}

static void REGAL_CALL loader_glColor4dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4dv, "glColor4dv");
   if ( !driverTbl.glColor4dv ) {
      driverTbl.glColor4dv = missing_glColor4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4dv == loader_glColor4dv) {
      rCtx->dsp->emuTbl.glColor4dv = driverTbl.glColor4dv;
   }
   driverTbl.glColor4dv(v);
}

static void REGAL_CALL missing_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glColor4f not available." );
}

static void REGAL_CALL loader_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4f, "glColor4f");
   if ( !driverTbl.glColor4f ) {
      driverTbl.glColor4f = missing_glColor4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4f == loader_glColor4f) {
      rCtx->dsp->emuTbl.glColor4f = driverTbl.glColor4f;
   }
   driverTbl.glColor4f(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor4fv not available." );
}

static void REGAL_CALL loader_glColor4fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4fv, "glColor4fv");
   if ( !driverTbl.glColor4fv ) {
      driverTbl.glColor4fv = missing_glColor4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4fv == loader_glColor4fv) {
      rCtx->dsp->emuTbl.glColor4fv = driverTbl.glColor4fv;
   }
   driverTbl.glColor4fv(v);
}

static void REGAL_CALL missing_glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glColor4i not available." );
}

static void REGAL_CALL loader_glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4i, "glColor4i");
   if ( !driverTbl.glColor4i ) {
      driverTbl.glColor4i = missing_glColor4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4i == loader_glColor4i) {
      rCtx->dsp->emuTbl.glColor4i = driverTbl.glColor4i;
   }
   driverTbl.glColor4i(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor4iv not available." );
}

static void REGAL_CALL loader_glColor4iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4iv, "glColor4iv");
   if ( !driverTbl.glColor4iv ) {
      driverTbl.glColor4iv = missing_glColor4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4iv == loader_glColor4iv) {
      rCtx->dsp->emuTbl.glColor4iv = driverTbl.glColor4iv;
   }
   driverTbl.glColor4iv(v);
}

static void REGAL_CALL missing_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glColor4s not available." );
}

static void REGAL_CALL loader_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4s, "glColor4s");
   if ( !driverTbl.glColor4s ) {
      driverTbl.glColor4s = missing_glColor4s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4s == loader_glColor4s) {
      rCtx->dsp->emuTbl.glColor4s = driverTbl.glColor4s;
   }
   driverTbl.glColor4s(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor4sv not available." );
}

static void REGAL_CALL loader_glColor4sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4sv, "glColor4sv");
   if ( !driverTbl.glColor4sv ) {
      driverTbl.glColor4sv = missing_glColor4sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4sv == loader_glColor4sv) {
      rCtx->dsp->emuTbl.glColor4sv = driverTbl.glColor4sv;
   }
   driverTbl.glColor4sv(v);
}

static void REGAL_CALL missing_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glColor4ub not available." );
}

static void REGAL_CALL loader_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4ub, "glColor4ub");
   if ( !driverTbl.glColor4ub ) {
      driverTbl.glColor4ub = missing_glColor4ub;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4ub == loader_glColor4ub) {
      rCtx->dsp->emuTbl.glColor4ub = driverTbl.glColor4ub;
   }
   driverTbl.glColor4ub(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4ubv(const GLubyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor4ubv not available." );
}

static void REGAL_CALL loader_glColor4ubv(const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4ubv, "glColor4ubv");
   if ( !driverTbl.glColor4ubv ) {
      driverTbl.glColor4ubv = missing_glColor4ubv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4ubv == loader_glColor4ubv) {
      rCtx->dsp->emuTbl.glColor4ubv = driverTbl.glColor4ubv;
   }
   driverTbl.glColor4ubv(v);
}

static void REGAL_CALL missing_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glColor4ui not available." );
}

static void REGAL_CALL loader_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4ui, "glColor4ui");
   if ( !driverTbl.glColor4ui ) {
      driverTbl.glColor4ui = missing_glColor4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4ui == loader_glColor4ui) {
      rCtx->dsp->emuTbl.glColor4ui = driverTbl.glColor4ui;
   }
   driverTbl.glColor4ui(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4uiv(const GLuint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor4uiv not available." );
}

static void REGAL_CALL loader_glColor4uiv(const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4uiv, "glColor4uiv");
   if ( !driverTbl.glColor4uiv ) {
      driverTbl.glColor4uiv = missing_glColor4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4uiv == loader_glColor4uiv) {
      rCtx->dsp->emuTbl.glColor4uiv = driverTbl.glColor4uiv;
   }
   driverTbl.glColor4uiv(v);
}

static void REGAL_CALL missing_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glColor4us not available." );
}

static void REGAL_CALL loader_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4us, "glColor4us");
   if ( !driverTbl.glColor4us ) {
      driverTbl.glColor4us = missing_glColor4us;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4us == loader_glColor4us) {
      rCtx->dsp->emuTbl.glColor4us = driverTbl.glColor4us;
   }
   driverTbl.glColor4us(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4usv(const GLushort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor4usv not available." );
}

static void REGAL_CALL loader_glColor4usv(const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4usv, "glColor4usv");
   if ( !driverTbl.glColor4usv ) {
      driverTbl.glColor4usv = missing_glColor4usv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4usv == loader_glColor4usv) {
      rCtx->dsp->emuTbl.glColor4usv = driverTbl.glColor4usv;
   }
   driverTbl.glColor4usv(v);
}

static void REGAL_CALL missing_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glColorMask not available." );
}

static void REGAL_CALL loader_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorMask, "glColorMask");
   if ( !driverTbl.glColorMask ) {
      driverTbl.glColorMask = missing_glColorMask;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorMask == loader_glColorMask) {
      rCtx->dsp->emuTbl.glColorMask = driverTbl.glColorMask;
   }
   driverTbl.glColorMask(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColorMaterial(GLenum face, GLenum mode)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(mode);
   Warning( "glColorMaterial not available." );
}

static void REGAL_CALL loader_glColorMaterial(GLenum face, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorMaterial, "glColorMaterial");
   if ( !driverTbl.glColorMaterial ) {
      driverTbl.glColorMaterial = missing_glColorMaterial;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorMaterial == loader_glColorMaterial) {
      rCtx->dsp->emuTbl.glColorMaterial = driverTbl.glColorMaterial;
   }
   driverTbl.glColorMaterial(face, mode);
}

static void REGAL_CALL missing_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(type);
   Warning( "glCopyPixels not available." );
}

static void REGAL_CALL loader_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyPixels, "glCopyPixels");
   if ( !driverTbl.glCopyPixels ) {
      driverTbl.glCopyPixels = missing_glCopyPixels;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyPixels == loader_glCopyPixels) {
      rCtx->dsp->emuTbl.glCopyPixels = driverTbl.glCopyPixels;
   }
   driverTbl.glCopyPixels(x, y, width, height, type);
}

static void REGAL_CALL missing_glCullFace(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glCullFace not available." );
}

static void REGAL_CALL loader_glCullFace(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCullFace, "glCullFace");
   if ( !driverTbl.glCullFace ) {
      driverTbl.glCullFace = missing_glCullFace;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCullFace == loader_glCullFace) {
      rCtx->dsp->emuTbl.glCullFace = driverTbl.glCullFace;
   }
   driverTbl.glCullFace(mode);
}

static void REGAL_CALL missing_glDeleteLists(GLuint list, GLsizei range)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(range);
   Warning( "glDeleteLists not available." );
}

static void REGAL_CALL loader_glDeleteLists(GLuint list, GLsizei range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteLists, "glDeleteLists");
   if ( !driverTbl.glDeleteLists ) {
      driverTbl.glDeleteLists = missing_glDeleteLists;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteLists == loader_glDeleteLists) {
      rCtx->dsp->emuTbl.glDeleteLists = driverTbl.glDeleteLists;
   }
   driverTbl.glDeleteLists(list, range);
}

static void REGAL_CALL missing_glDepthFunc(GLenum func)
{
   UNUSED_PARAMETER(func);
   Warning( "glDepthFunc not available." );
}

static void REGAL_CALL loader_glDepthFunc(GLenum func)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDepthFunc, "glDepthFunc");
   if ( !driverTbl.glDepthFunc ) {
      driverTbl.glDepthFunc = missing_glDepthFunc;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDepthFunc == loader_glDepthFunc) {
      rCtx->dsp->emuTbl.glDepthFunc = driverTbl.glDepthFunc;
   }
   driverTbl.glDepthFunc(func);
}

static void REGAL_CALL missing_glDepthMask(GLboolean flag)
{
   UNUSED_PARAMETER(flag);
   Warning( "glDepthMask not available." );
}

static void REGAL_CALL loader_glDepthMask(GLboolean flag)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDepthMask, "glDepthMask");
   if ( !driverTbl.glDepthMask ) {
      driverTbl.glDepthMask = missing_glDepthMask;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDepthMask == loader_glDepthMask) {
      rCtx->dsp->emuTbl.glDepthMask = driverTbl.glDepthMask;
   }
   driverTbl.glDepthMask(flag);
}

static void REGAL_CALL missing_glDepthRange(GLclampd zNear, GLclampd zFar)
{
   UNUSED_PARAMETER(zNear);
   UNUSED_PARAMETER(zFar);
   Warning( "glDepthRange not available." );
}

static void REGAL_CALL loader_glDepthRange(GLclampd zNear, GLclampd zFar)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDepthRange, "glDepthRange");
   if ( !driverTbl.glDepthRange ) {
      driverTbl.glDepthRange = missing_glDepthRange;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDepthRange == loader_glDepthRange) {
      rCtx->dsp->emuTbl.glDepthRange = driverTbl.glDepthRange;
   }
   driverTbl.glDepthRange(zNear, zFar);
}

static void REGAL_CALL missing_glDisable(GLenum cap)
{
   UNUSED_PARAMETER(cap);
   Warning( "glDisable not available." );
}

static void REGAL_CALL loader_glDisable(GLenum cap)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDisable, "glDisable");
   if ( !driverTbl.glDisable ) {
      driverTbl.glDisable = missing_glDisable;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDisable == loader_glDisable) {
      rCtx->dsp->emuTbl.glDisable = driverTbl.glDisable;
   }
   driverTbl.glDisable(cap);
}

static void REGAL_CALL missing_glDrawBuffer(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glDrawBuffer not available." );
}

static void REGAL_CALL loader_glDrawBuffer(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawBuffer, "glDrawBuffer");
   if ( !driverTbl.glDrawBuffer ) {
      driverTbl.glDrawBuffer = missing_glDrawBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawBuffer == loader_glDrawBuffer) {
      rCtx->dsp->emuTbl.glDrawBuffer = driverTbl.glDrawBuffer;
   }
   driverTbl.glDrawBuffer(mode);
}

static void REGAL_CALL missing_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glDrawPixels not available." );
}

static void REGAL_CALL loader_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawPixels, "glDrawPixels");
   if ( !driverTbl.glDrawPixels ) {
      driverTbl.glDrawPixels = missing_glDrawPixels;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawPixels == loader_glDrawPixels) {
      rCtx->dsp->emuTbl.glDrawPixels = driverTbl.glDrawPixels;
   }
   driverTbl.glDrawPixels(width, height, format, type, pixels);
}

static void REGAL_CALL missing_glEdgeFlag(GLboolean flag)
{
   UNUSED_PARAMETER(flag);
   Warning( "glEdgeFlag not available." );
}

static void REGAL_CALL loader_glEdgeFlag(GLboolean flag)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEdgeFlag, "glEdgeFlag");
   if ( !driverTbl.glEdgeFlag ) {
      driverTbl.glEdgeFlag = missing_glEdgeFlag;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEdgeFlag == loader_glEdgeFlag) {
      rCtx->dsp->emuTbl.glEdgeFlag = driverTbl.glEdgeFlag;
   }
   driverTbl.glEdgeFlag(flag);
}

static void REGAL_CALL missing_glEdgeFlagv(const GLboolean *flag)
{
   UNUSED_PARAMETER(flag);
   Warning( "glEdgeFlagv not available." );
}

static void REGAL_CALL loader_glEdgeFlagv(const GLboolean *flag)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEdgeFlagv, "glEdgeFlagv");
   if ( !driverTbl.glEdgeFlagv ) {
      driverTbl.glEdgeFlagv = missing_glEdgeFlagv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEdgeFlagv == loader_glEdgeFlagv) {
      rCtx->dsp->emuTbl.glEdgeFlagv = driverTbl.glEdgeFlagv;
   }
   driverTbl.glEdgeFlagv(flag);
}

static void REGAL_CALL missing_glEnable(GLenum cap)
{
   UNUSED_PARAMETER(cap);
   Warning( "glEnable not available." );
}

static void REGAL_CALL loader_glEnable(GLenum cap)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEnable, "glEnable");
   if ( !driverTbl.glEnable ) {
      driverTbl.glEnable = missing_glEnable;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEnable == loader_glEnable) {
      rCtx->dsp->emuTbl.glEnable = driverTbl.glEnable;
   }
   driverTbl.glEnable(cap);
}

static void REGAL_CALL missing_glEnd(void)
{
   Warning( "glEnd not available." );
}

static void REGAL_CALL loader_glEnd(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEnd, "glEnd");
   if ( !driverTbl.glEnd ) {
      driverTbl.glEnd = missing_glEnd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEnd == loader_glEnd) {
      rCtx->dsp->emuTbl.glEnd = driverTbl.glEnd;
   }
   driverTbl.glEnd();
}

static void REGAL_CALL missing_glEndList(void)
{
   Warning( "glEndList not available." );
}

static void REGAL_CALL loader_glEndList(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndList, "glEndList");
   if ( !driverTbl.glEndList ) {
      driverTbl.glEndList = missing_glEndList;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndList == loader_glEndList) {
      rCtx->dsp->emuTbl.glEndList = driverTbl.glEndList;
   }
   driverTbl.glEndList();
}

static void REGAL_CALL missing_glEvalCoord1d(GLdouble u)
{
   UNUSED_PARAMETER(u);
   Warning( "glEvalCoord1d not available." );
}

static void REGAL_CALL loader_glEvalCoord1d(GLdouble u)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEvalCoord1d, "glEvalCoord1d");
   if ( !driverTbl.glEvalCoord1d ) {
      driverTbl.glEvalCoord1d = missing_glEvalCoord1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEvalCoord1d == loader_glEvalCoord1d) {
      rCtx->dsp->emuTbl.glEvalCoord1d = driverTbl.glEvalCoord1d;
   }
   driverTbl.glEvalCoord1d(u);
}

static void REGAL_CALL missing_glEvalCoord1dv(const GLdouble *u)
{
   UNUSED_PARAMETER(u);
   Warning( "glEvalCoord1dv not available." );
}

static void REGAL_CALL loader_glEvalCoord1dv(const GLdouble *u)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEvalCoord1dv, "glEvalCoord1dv");
   if ( !driverTbl.glEvalCoord1dv ) {
      driverTbl.glEvalCoord1dv = missing_glEvalCoord1dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEvalCoord1dv == loader_glEvalCoord1dv) {
      rCtx->dsp->emuTbl.glEvalCoord1dv = driverTbl.glEvalCoord1dv;
   }
   driverTbl.glEvalCoord1dv(u);
}

static void REGAL_CALL missing_glEvalCoord1f(GLfloat u)
{
   UNUSED_PARAMETER(u);
   Warning( "glEvalCoord1f not available." );
}

static void REGAL_CALL loader_glEvalCoord1f(GLfloat u)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEvalCoord1f, "glEvalCoord1f");
   if ( !driverTbl.glEvalCoord1f ) {
      driverTbl.glEvalCoord1f = missing_glEvalCoord1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEvalCoord1f == loader_glEvalCoord1f) {
      rCtx->dsp->emuTbl.glEvalCoord1f = driverTbl.glEvalCoord1f;
   }
   driverTbl.glEvalCoord1f(u);
}

static void REGAL_CALL missing_glEvalCoord1fv(const GLfloat *u)
{
   UNUSED_PARAMETER(u);
   Warning( "glEvalCoord1fv not available." );
}

static void REGAL_CALL loader_glEvalCoord1fv(const GLfloat *u)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEvalCoord1fv, "glEvalCoord1fv");
   if ( !driverTbl.glEvalCoord1fv ) {
      driverTbl.glEvalCoord1fv = missing_glEvalCoord1fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEvalCoord1fv == loader_glEvalCoord1fv) {
      rCtx->dsp->emuTbl.glEvalCoord1fv = driverTbl.glEvalCoord1fv;
   }
   driverTbl.glEvalCoord1fv(u);
}

static void REGAL_CALL missing_glEvalCoord2d(GLdouble u, GLdouble v)
{
   UNUSED_PARAMETER(u);
   UNUSED_PARAMETER(v);
   Warning( "glEvalCoord2d not available." );
}

static void REGAL_CALL loader_glEvalCoord2d(GLdouble u, GLdouble v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEvalCoord2d, "glEvalCoord2d");
   if ( !driverTbl.glEvalCoord2d ) {
      driverTbl.glEvalCoord2d = missing_glEvalCoord2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEvalCoord2d == loader_glEvalCoord2d) {
      rCtx->dsp->emuTbl.glEvalCoord2d = driverTbl.glEvalCoord2d;
   }
   driverTbl.glEvalCoord2d(u, v);
}

static void REGAL_CALL missing_glEvalCoord2dv(const GLdouble *u)
{
   UNUSED_PARAMETER(u);
   Warning( "glEvalCoord2dv not available." );
}

static void REGAL_CALL loader_glEvalCoord2dv(const GLdouble *u)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEvalCoord2dv, "glEvalCoord2dv");
   if ( !driverTbl.glEvalCoord2dv ) {
      driverTbl.glEvalCoord2dv = missing_glEvalCoord2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEvalCoord2dv == loader_glEvalCoord2dv) {
      rCtx->dsp->emuTbl.glEvalCoord2dv = driverTbl.glEvalCoord2dv;
   }
   driverTbl.glEvalCoord2dv(u);
}

static void REGAL_CALL missing_glEvalCoord2f(GLfloat u, GLfloat v)
{
   UNUSED_PARAMETER(u);
   UNUSED_PARAMETER(v);
   Warning( "glEvalCoord2f not available." );
}

static void REGAL_CALL loader_glEvalCoord2f(GLfloat u, GLfloat v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEvalCoord2f, "glEvalCoord2f");
   if ( !driverTbl.glEvalCoord2f ) {
      driverTbl.glEvalCoord2f = missing_glEvalCoord2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEvalCoord2f == loader_glEvalCoord2f) {
      rCtx->dsp->emuTbl.glEvalCoord2f = driverTbl.glEvalCoord2f;
   }
   driverTbl.glEvalCoord2f(u, v);
}

static void REGAL_CALL missing_glEvalCoord2fv(const GLfloat *u)
{
   UNUSED_PARAMETER(u);
   Warning( "glEvalCoord2fv not available." );
}

static void REGAL_CALL loader_glEvalCoord2fv(const GLfloat *u)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEvalCoord2fv, "glEvalCoord2fv");
   if ( !driverTbl.glEvalCoord2fv ) {
      driverTbl.glEvalCoord2fv = missing_glEvalCoord2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEvalCoord2fv == loader_glEvalCoord2fv) {
      rCtx->dsp->emuTbl.glEvalCoord2fv = driverTbl.glEvalCoord2fv;
   }
   driverTbl.glEvalCoord2fv(u);
}

static void REGAL_CALL missing_glEvalMesh1(GLenum mode, GLint i1, GLint i2)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(i1);
   UNUSED_PARAMETER(i2);
   Warning( "glEvalMesh1 not available." );
}

static void REGAL_CALL loader_glEvalMesh1(GLenum mode, GLint i1, GLint i2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEvalMesh1, "glEvalMesh1");
   if ( !driverTbl.glEvalMesh1 ) {
      driverTbl.glEvalMesh1 = missing_glEvalMesh1;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEvalMesh1 == loader_glEvalMesh1) {
      rCtx->dsp->emuTbl.glEvalMesh1 = driverTbl.glEvalMesh1;
   }
   driverTbl.glEvalMesh1(mode, i1, i2);
}

static void REGAL_CALL missing_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(i1);
   UNUSED_PARAMETER(i2);
   UNUSED_PARAMETER(j1);
   UNUSED_PARAMETER(j2);
   Warning( "glEvalMesh2 not available." );
}

static void REGAL_CALL loader_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEvalMesh2, "glEvalMesh2");
   if ( !driverTbl.glEvalMesh2 ) {
      driverTbl.glEvalMesh2 = missing_glEvalMesh2;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEvalMesh2 == loader_glEvalMesh2) {
      rCtx->dsp->emuTbl.glEvalMesh2 = driverTbl.glEvalMesh2;
   }
   driverTbl.glEvalMesh2(mode, i1, i2, j1, j2);
}

static void REGAL_CALL missing_glEvalPoint1(GLint i)
{
   UNUSED_PARAMETER(i);
   Warning( "glEvalPoint1 not available." );
}

static void REGAL_CALL loader_glEvalPoint1(GLint i)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEvalPoint1, "glEvalPoint1");
   if ( !driverTbl.glEvalPoint1 ) {
      driverTbl.glEvalPoint1 = missing_glEvalPoint1;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEvalPoint1 == loader_glEvalPoint1) {
      rCtx->dsp->emuTbl.glEvalPoint1 = driverTbl.glEvalPoint1;
   }
   driverTbl.glEvalPoint1(i);
}

static void REGAL_CALL missing_glEvalPoint2(GLint i, GLint j)
{
   UNUSED_PARAMETER(i);
   UNUSED_PARAMETER(j);
   Warning( "glEvalPoint2 not available." );
}

static void REGAL_CALL loader_glEvalPoint2(GLint i, GLint j)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEvalPoint2, "glEvalPoint2");
   if ( !driverTbl.glEvalPoint2 ) {
      driverTbl.glEvalPoint2 = missing_glEvalPoint2;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEvalPoint2 == loader_glEvalPoint2) {
      rCtx->dsp->emuTbl.glEvalPoint2 = driverTbl.glEvalPoint2;
   }
   driverTbl.glEvalPoint2(i, j);
}

static void REGAL_CALL missing_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(buffer);
   Warning( "glFeedbackBuffer not available." );
}

static void REGAL_CALL loader_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFeedbackBuffer, "glFeedbackBuffer");
   if ( !driverTbl.glFeedbackBuffer ) {
      driverTbl.glFeedbackBuffer = missing_glFeedbackBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFeedbackBuffer == loader_glFeedbackBuffer) {
      rCtx->dsp->emuTbl.glFeedbackBuffer = driverTbl.glFeedbackBuffer;
   }
   driverTbl.glFeedbackBuffer(size, type, buffer);
}

static void REGAL_CALL missing_glFinish(void)
{
   Warning( "glFinish not available." );
}

static void REGAL_CALL loader_glFinish(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFinish, "glFinish");
   if ( !driverTbl.glFinish ) {
      driverTbl.glFinish = missing_glFinish;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFinish == loader_glFinish) {
      rCtx->dsp->emuTbl.glFinish = driverTbl.glFinish;
   }
   driverTbl.glFinish();
}

static void REGAL_CALL missing_glFlush(void)
{
   Warning( "glFlush not available." );
}

static void REGAL_CALL loader_glFlush(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFlush, "glFlush");
   if ( !driverTbl.glFlush ) {
      driverTbl.glFlush = missing_glFlush;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFlush == loader_glFlush) {
      rCtx->dsp->emuTbl.glFlush = driverTbl.glFlush;
   }
   driverTbl.glFlush();
}

static void REGAL_CALL missing_glFogf(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFogf not available." );
}

static void REGAL_CALL loader_glFogf(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogf, "glFogf");
   if ( !driverTbl.glFogf ) {
      driverTbl.glFogf = missing_glFogf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogf == loader_glFogf) {
      rCtx->dsp->emuTbl.glFogf = driverTbl.glFogf;
   }
   driverTbl.glFogf(pname, param);
}

static void REGAL_CALL missing_glFogfv(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glFogfv not available." );
}

static void REGAL_CALL loader_glFogfv(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogfv, "glFogfv");
   if ( !driverTbl.glFogfv ) {
      driverTbl.glFogfv = missing_glFogfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogfv == loader_glFogfv) {
      rCtx->dsp->emuTbl.glFogfv = driverTbl.glFogfv;
   }
   driverTbl.glFogfv(pname, params);
}

static void REGAL_CALL missing_glFogi(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFogi not available." );
}

static void REGAL_CALL loader_glFogi(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogi, "glFogi");
   if ( !driverTbl.glFogi ) {
      driverTbl.glFogi = missing_glFogi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogi == loader_glFogi) {
      rCtx->dsp->emuTbl.glFogi = driverTbl.glFogi;
   }
   driverTbl.glFogi(pname, param);
}

static void REGAL_CALL missing_glFogiv(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glFogiv not available." );
}

static void REGAL_CALL loader_glFogiv(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogiv, "glFogiv");
   if ( !driverTbl.glFogiv ) {
      driverTbl.glFogiv = missing_glFogiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogiv == loader_glFogiv) {
      rCtx->dsp->emuTbl.glFogiv = driverTbl.glFogiv;
   }
   driverTbl.glFogiv(pname, params);
}

static void REGAL_CALL missing_glFrontFace(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glFrontFace not available." );
}

static void REGAL_CALL loader_glFrontFace(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFrontFace, "glFrontFace");
   if ( !driverTbl.glFrontFace ) {
      driverTbl.glFrontFace = missing_glFrontFace;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFrontFace == loader_glFrontFace) {
      rCtx->dsp->emuTbl.glFrontFace = driverTbl.glFrontFace;
   }
   driverTbl.glFrontFace(mode);
}

static void REGAL_CALL missing_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   UNUSED_PARAMETER(left);
   UNUSED_PARAMETER(right);
   UNUSED_PARAMETER(bottom);
   UNUSED_PARAMETER(top);
   UNUSED_PARAMETER(zNear);
   UNUSED_PARAMETER(zFar);
   Warning( "glFrustum not available." );
}

static void REGAL_CALL loader_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFrustum, "glFrustum");
   if ( !driverTbl.glFrustum ) {
      driverTbl.glFrustum = missing_glFrustum;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFrustum == loader_glFrustum) {
      rCtx->dsp->emuTbl.glFrustum = driverTbl.glFrustum;
   }
   driverTbl.glFrustum(left, right, bottom, top, zNear, zFar);
}

static GLuint REGAL_CALL missing_glGenLists(GLsizei range)
{
   UNUSED_PARAMETER(range);
   Warning( "glGenLists not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGenLists(GLsizei range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenLists, "glGenLists");
   if ( !driverTbl.glGenLists ) {
      driverTbl.glGenLists = missing_glGenLists;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenLists == loader_glGenLists) {
      rCtx->dsp->emuTbl.glGenLists = driverTbl.glGenLists;
   }
   return driverTbl.glGenLists(range);
}

static void REGAL_CALL missing_glGetBooleanv(GLenum pname, GLboolean *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetBooleanv not available." );
}

static void REGAL_CALL loader_glGetBooleanv(GLenum pname, GLboolean *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetBooleanv, "glGetBooleanv");
   if ( !driverTbl.glGetBooleanv ) {
      driverTbl.glGetBooleanv = missing_glGetBooleanv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetBooleanv == loader_glGetBooleanv) {
      rCtx->dsp->emuTbl.glGetBooleanv = driverTbl.glGetBooleanv;
   }
   driverTbl.glGetBooleanv(pname, params);
}

static void REGAL_CALL missing_glGetClipPlane(GLenum plane, GLdouble *equation)
{
   UNUSED_PARAMETER(plane);
   UNUSED_PARAMETER(equation);
   Warning( "glGetClipPlane not available." );
}

static void REGAL_CALL loader_glGetClipPlane(GLenum plane, GLdouble *equation)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetClipPlane, "glGetClipPlane");
   if ( !driverTbl.glGetClipPlane ) {
      driverTbl.glGetClipPlane = missing_glGetClipPlane;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetClipPlane == loader_glGetClipPlane) {
      rCtx->dsp->emuTbl.glGetClipPlane = driverTbl.glGetClipPlane;
   }
   driverTbl.glGetClipPlane(plane, equation);
}

static void REGAL_CALL missing_glGetDoublev(GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetDoublev not available." );
}

static void REGAL_CALL loader_glGetDoublev(GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetDoublev, "glGetDoublev");
   if ( !driverTbl.glGetDoublev ) {
      driverTbl.glGetDoublev = missing_glGetDoublev;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetDoublev == loader_glGetDoublev) {
      rCtx->dsp->emuTbl.glGetDoublev = driverTbl.glGetDoublev;
   }
   driverTbl.glGetDoublev(pname, params);
}

static GLenum REGAL_CALL missing_glGetError(void)
{
   Warning( "glGetError not available." );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glGetError(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetError, "glGetError");
   if ( !driverTbl.glGetError ) {
      driverTbl.glGetError = missing_glGetError;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetError == loader_glGetError) {
      rCtx->dsp->emuTbl.glGetError = driverTbl.glGetError;
   }
   return driverTbl.glGetError();
}

static void REGAL_CALL missing_glGetFloatv(GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFloatv not available." );
}

static void REGAL_CALL loader_glGetFloatv(GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFloatv, "glGetFloatv");
   if ( !driverTbl.glGetFloatv ) {
      driverTbl.glGetFloatv = missing_glGetFloatv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFloatv == loader_glGetFloatv) {
      rCtx->dsp->emuTbl.glGetFloatv = driverTbl.glGetFloatv;
   }
   driverTbl.glGetFloatv(pname, params);
}

static void REGAL_CALL missing_glGetIntegerv(GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetIntegerv not available." );
}

static void REGAL_CALL loader_glGetIntegerv(GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetIntegerv, "glGetIntegerv");
   if ( !driverTbl.glGetIntegerv ) {
      driverTbl.glGetIntegerv = missing_glGetIntegerv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetIntegerv == loader_glGetIntegerv) {
      rCtx->dsp->emuTbl.glGetIntegerv = driverTbl.glGetIntegerv;
   }
   driverTbl.glGetIntegerv(pname, params);
}

static void REGAL_CALL missing_glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetLightfv not available." );
}

static void REGAL_CALL loader_glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetLightfv, "glGetLightfv");
   if ( !driverTbl.glGetLightfv ) {
      driverTbl.glGetLightfv = missing_glGetLightfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetLightfv == loader_glGetLightfv) {
      rCtx->dsp->emuTbl.glGetLightfv = driverTbl.glGetLightfv;
   }
   driverTbl.glGetLightfv(light, pname, params);
}

static void REGAL_CALL missing_glGetLightiv(GLenum light, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetLightiv not available." );
}

static void REGAL_CALL loader_glGetLightiv(GLenum light, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetLightiv, "glGetLightiv");
   if ( !driverTbl.glGetLightiv ) {
      driverTbl.glGetLightiv = missing_glGetLightiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetLightiv == loader_glGetLightiv) {
      rCtx->dsp->emuTbl.glGetLightiv = driverTbl.glGetLightiv;
   }
   driverTbl.glGetLightiv(light, pname, params);
}

static void REGAL_CALL missing_glGetMapdv(GLenum target, GLenum query, GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(query);
   UNUSED_PARAMETER(v);
   Warning( "glGetMapdv not available." );
}

static void REGAL_CALL loader_glGetMapdv(GLenum target, GLenum query, GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMapdv, "glGetMapdv");
   if ( !driverTbl.glGetMapdv ) {
      driverTbl.glGetMapdv = missing_glGetMapdv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMapdv == loader_glGetMapdv) {
      rCtx->dsp->emuTbl.glGetMapdv = driverTbl.glGetMapdv;
   }
   driverTbl.glGetMapdv(target, query, v);
}

static void REGAL_CALL missing_glGetMapfv(GLenum target, GLenum query, GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(query);
   UNUSED_PARAMETER(v);
   Warning( "glGetMapfv not available." );
}

static void REGAL_CALL loader_glGetMapfv(GLenum target, GLenum query, GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMapfv, "glGetMapfv");
   if ( !driverTbl.glGetMapfv ) {
      driverTbl.glGetMapfv = missing_glGetMapfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMapfv == loader_glGetMapfv) {
      rCtx->dsp->emuTbl.glGetMapfv = driverTbl.glGetMapfv;
   }
   driverTbl.glGetMapfv(target, query, v);
}

static void REGAL_CALL missing_glGetMapiv(GLenum target, GLenum query, GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(query);
   UNUSED_PARAMETER(v);
   Warning( "glGetMapiv not available." );
}

static void REGAL_CALL loader_glGetMapiv(GLenum target, GLenum query, GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMapiv, "glGetMapiv");
   if ( !driverTbl.glGetMapiv ) {
      driverTbl.glGetMapiv = missing_glGetMapiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMapiv == loader_glGetMapiv) {
      rCtx->dsp->emuTbl.glGetMapiv = driverTbl.glGetMapiv;
   }
   driverTbl.glGetMapiv(target, query, v);
}

static void REGAL_CALL missing_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMaterialfv not available." );
}

static void REGAL_CALL loader_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMaterialfv, "glGetMaterialfv");
   if ( !driverTbl.glGetMaterialfv ) {
      driverTbl.glGetMaterialfv = missing_glGetMaterialfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMaterialfv == loader_glGetMaterialfv) {
      rCtx->dsp->emuTbl.glGetMaterialfv = driverTbl.glGetMaterialfv;
   }
   driverTbl.glGetMaterialfv(face, pname, params);
}

static void REGAL_CALL missing_glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMaterialiv not available." );
}

static void REGAL_CALL loader_glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMaterialiv, "glGetMaterialiv");
   if ( !driverTbl.glGetMaterialiv ) {
      driverTbl.glGetMaterialiv = missing_glGetMaterialiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMaterialiv == loader_glGetMaterialiv) {
      rCtx->dsp->emuTbl.glGetMaterialiv = driverTbl.glGetMaterialiv;
   }
   driverTbl.glGetMaterialiv(face, pname, params);
}

static void REGAL_CALL missing_glGetPixelMapfv(GLenum map, GLfloat *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(values);
   Warning( "glGetPixelMapfv not available." );
}

static void REGAL_CALL loader_glGetPixelMapfv(GLenum map, GLfloat *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPixelMapfv, "glGetPixelMapfv");
   if ( !driverTbl.glGetPixelMapfv ) {
      driverTbl.glGetPixelMapfv = missing_glGetPixelMapfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPixelMapfv == loader_glGetPixelMapfv) {
      rCtx->dsp->emuTbl.glGetPixelMapfv = driverTbl.glGetPixelMapfv;
   }
   driverTbl.glGetPixelMapfv(map, values);
}

static void REGAL_CALL missing_glGetPixelMapuiv(GLenum map, GLuint *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(values);
   Warning( "glGetPixelMapuiv not available." );
}

static void REGAL_CALL loader_glGetPixelMapuiv(GLenum map, GLuint *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPixelMapuiv, "glGetPixelMapuiv");
   if ( !driverTbl.glGetPixelMapuiv ) {
      driverTbl.glGetPixelMapuiv = missing_glGetPixelMapuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPixelMapuiv == loader_glGetPixelMapuiv) {
      rCtx->dsp->emuTbl.glGetPixelMapuiv = driverTbl.glGetPixelMapuiv;
   }
   driverTbl.glGetPixelMapuiv(map, values);
}

static void REGAL_CALL missing_glGetPixelMapusv(GLenum map, GLushort *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(values);
   Warning( "glGetPixelMapusv not available." );
}

static void REGAL_CALL loader_glGetPixelMapusv(GLenum map, GLushort *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPixelMapusv, "glGetPixelMapusv");
   if ( !driverTbl.glGetPixelMapusv ) {
      driverTbl.glGetPixelMapusv = missing_glGetPixelMapusv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPixelMapusv == loader_glGetPixelMapusv) {
      rCtx->dsp->emuTbl.glGetPixelMapusv = driverTbl.glGetPixelMapusv;
   }
   driverTbl.glGetPixelMapusv(map, values);
}

static void REGAL_CALL missing_glGetPolygonStipple(GLubyte *mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "glGetPolygonStipple not available." );
}

static void REGAL_CALL loader_glGetPolygonStipple(GLubyte *mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPolygonStipple, "glGetPolygonStipple");
   if ( !driverTbl.glGetPolygonStipple ) {
      driverTbl.glGetPolygonStipple = missing_glGetPolygonStipple;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPolygonStipple == loader_glGetPolygonStipple) {
      rCtx->dsp->emuTbl.glGetPolygonStipple = driverTbl.glGetPolygonStipple;
   }
   driverTbl.glGetPolygonStipple(mask);
}

static const GLubyte *REGAL_CALL missing_glGetString(GLenum name)
{
   UNUSED_PARAMETER(name);
   Warning( "glGetString not available." );
  const GLubyte * ret = NULL;
  return ret;
}

static const GLubyte *REGAL_CALL loader_glGetString(GLenum name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetString, "glGetString");
   if ( !driverTbl.glGetString ) {
      driverTbl.glGetString = missing_glGetString;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetString == loader_glGetString) {
      rCtx->dsp->emuTbl.glGetString = driverTbl.glGetString;
   }
   return driverTbl.glGetString(name);
}

static void REGAL_CALL missing_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTexEnvfv not available." );
}

static void REGAL_CALL loader_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexEnvfv, "glGetTexEnvfv");
   if ( !driverTbl.glGetTexEnvfv ) {
      driverTbl.glGetTexEnvfv = missing_glGetTexEnvfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexEnvfv == loader_glGetTexEnvfv) {
      rCtx->dsp->emuTbl.glGetTexEnvfv = driverTbl.glGetTexEnvfv;
   }
   driverTbl.glGetTexEnvfv(target, pname, params);
}

static void REGAL_CALL missing_glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTexEnviv not available." );
}

static void REGAL_CALL loader_glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexEnviv, "glGetTexEnviv");
   if ( !driverTbl.glGetTexEnviv ) {
      driverTbl.glGetTexEnviv = missing_glGetTexEnviv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexEnviv == loader_glGetTexEnviv) {
      rCtx->dsp->emuTbl.glGetTexEnviv = driverTbl.glGetTexEnviv;
   }
   driverTbl.glGetTexEnviv(target, pname, params);
}

static void REGAL_CALL missing_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTexGendv not available." );
}

static void REGAL_CALL loader_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexGendv, "glGetTexGendv");
   if ( !driverTbl.glGetTexGendv ) {
      driverTbl.glGetTexGendv = missing_glGetTexGendv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexGendv == loader_glGetTexGendv) {
      rCtx->dsp->emuTbl.glGetTexGendv = driverTbl.glGetTexGendv;
   }
   driverTbl.glGetTexGendv(coord, pname, params);
}

static void REGAL_CALL missing_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTexGenfv not available." );
}

static void REGAL_CALL loader_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexGenfv, "glGetTexGenfv");
   if ( !driverTbl.glGetTexGenfv ) {
      driverTbl.glGetTexGenfv = missing_glGetTexGenfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexGenfv == loader_glGetTexGenfv) {
      rCtx->dsp->emuTbl.glGetTexGenfv = driverTbl.glGetTexGenfv;
   }
   driverTbl.glGetTexGenfv(coord, pname, params);
}

static void REGAL_CALL missing_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTexGeniv not available." );
}

static void REGAL_CALL loader_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexGeniv, "glGetTexGeniv");
   if ( !driverTbl.glGetTexGeniv ) {
      driverTbl.glGetTexGeniv = missing_glGetTexGeniv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexGeniv == loader_glGetTexGeniv) {
      rCtx->dsp->emuTbl.glGetTexGeniv = driverTbl.glGetTexGeniv;
   }
   driverTbl.glGetTexGeniv(coord, pname, params);
}

static void REGAL_CALL missing_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glGetTexImage not available." );
}

static void REGAL_CALL loader_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexImage, "glGetTexImage");
   if ( !driverTbl.glGetTexImage ) {
      driverTbl.glGetTexImage = missing_glGetTexImage;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexImage == loader_glGetTexImage) {
      rCtx->dsp->emuTbl.glGetTexImage = driverTbl.glGetTexImage;
   }
   driverTbl.glGetTexImage(target, level, format, type, pixels);
}

static void REGAL_CALL missing_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTexLevelParameterfv not available." );
}

static void REGAL_CALL loader_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexLevelParameterfv, "glGetTexLevelParameterfv");
   if ( !driverTbl.glGetTexLevelParameterfv ) {
      driverTbl.glGetTexLevelParameterfv = missing_glGetTexLevelParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexLevelParameterfv == loader_glGetTexLevelParameterfv) {
      rCtx->dsp->emuTbl.glGetTexLevelParameterfv = driverTbl.glGetTexLevelParameterfv;
   }
   driverTbl.glGetTexLevelParameterfv(target, level, pname, params);
}

static void REGAL_CALL missing_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTexLevelParameteriv not available." );
}

static void REGAL_CALL loader_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexLevelParameteriv, "glGetTexLevelParameteriv");
   if ( !driverTbl.glGetTexLevelParameteriv ) {
      driverTbl.glGetTexLevelParameteriv = missing_glGetTexLevelParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexLevelParameteriv == loader_glGetTexLevelParameteriv) {
      rCtx->dsp->emuTbl.glGetTexLevelParameteriv = driverTbl.glGetTexLevelParameteriv;
   }
   driverTbl.glGetTexLevelParameteriv(target, level, pname, params);
}

static void REGAL_CALL missing_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTexParameterfv not available." );
}

static void REGAL_CALL loader_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexParameterfv, "glGetTexParameterfv");
   if ( !driverTbl.glGetTexParameterfv ) {
      driverTbl.glGetTexParameterfv = missing_glGetTexParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexParameterfv == loader_glGetTexParameterfv) {
      rCtx->dsp->emuTbl.glGetTexParameterfv = driverTbl.glGetTexParameterfv;
   }
   driverTbl.glGetTexParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTexParameteriv not available." );
}

static void REGAL_CALL loader_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexParameteriv, "glGetTexParameteriv");
   if ( !driverTbl.glGetTexParameteriv ) {
      driverTbl.glGetTexParameteriv = missing_glGetTexParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexParameteriv == loader_glGetTexParameteriv) {
      rCtx->dsp->emuTbl.glGetTexParameteriv = driverTbl.glGetTexParameteriv;
   }
   driverTbl.glGetTexParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glHint(GLenum target, GLenum mode)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(mode);
   Warning( "glHint not available." );
}

static void REGAL_CALL loader_glHint(GLenum target, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glHint, "glHint");
   if ( !driverTbl.glHint ) {
      driverTbl.glHint = missing_glHint;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glHint == loader_glHint) {
      rCtx->dsp->emuTbl.glHint = driverTbl.glHint;
   }
   driverTbl.glHint(target, mode);
}

static void REGAL_CALL missing_glIndexMask(GLuint mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "glIndexMask not available." );
}

static void REGAL_CALL loader_glIndexMask(GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexMask, "glIndexMask");
   if ( !driverTbl.glIndexMask ) {
      driverTbl.glIndexMask = missing_glIndexMask;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexMask == loader_glIndexMask) {
      rCtx->dsp->emuTbl.glIndexMask = driverTbl.glIndexMask;
   }
   driverTbl.glIndexMask(mask);
}

static void REGAL_CALL missing_glIndexd(GLdouble c)
{
   UNUSED_PARAMETER(c);
   Warning( "glIndexd not available." );
}

static void REGAL_CALL loader_glIndexd(GLdouble c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexd, "glIndexd");
   if ( !driverTbl.glIndexd ) {
      driverTbl.glIndexd = missing_glIndexd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexd == loader_glIndexd) {
      rCtx->dsp->emuTbl.glIndexd = driverTbl.glIndexd;
   }
   driverTbl.glIndexd(c);
}

static void REGAL_CALL missing_glIndexdv(const GLdouble *c)
{
   UNUSED_PARAMETER(c);
   Warning( "glIndexdv not available." );
}

static void REGAL_CALL loader_glIndexdv(const GLdouble *c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexdv, "glIndexdv");
   if ( !driverTbl.glIndexdv ) {
      driverTbl.glIndexdv = missing_glIndexdv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexdv == loader_glIndexdv) {
      rCtx->dsp->emuTbl.glIndexdv = driverTbl.glIndexdv;
   }
   driverTbl.glIndexdv(c);
}

static void REGAL_CALL missing_glIndexf(GLfloat c)
{
   UNUSED_PARAMETER(c);
   Warning( "glIndexf not available." );
}

static void REGAL_CALL loader_glIndexf(GLfloat c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexf, "glIndexf");
   if ( !driverTbl.glIndexf ) {
      driverTbl.glIndexf = missing_glIndexf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexf == loader_glIndexf) {
      rCtx->dsp->emuTbl.glIndexf = driverTbl.glIndexf;
   }
   driverTbl.glIndexf(c);
}

static void REGAL_CALL missing_glIndexfv(const GLfloat *c)
{
   UNUSED_PARAMETER(c);
   Warning( "glIndexfv not available." );
}

static void REGAL_CALL loader_glIndexfv(const GLfloat *c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexfv, "glIndexfv");
   if ( !driverTbl.glIndexfv ) {
      driverTbl.glIndexfv = missing_glIndexfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexfv == loader_glIndexfv) {
      rCtx->dsp->emuTbl.glIndexfv = driverTbl.glIndexfv;
   }
   driverTbl.glIndexfv(c);
}

static void REGAL_CALL missing_glIndexi(GLint c)
{
   UNUSED_PARAMETER(c);
   Warning( "glIndexi not available." );
}

static void REGAL_CALL loader_glIndexi(GLint c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexi, "glIndexi");
   if ( !driverTbl.glIndexi ) {
      driverTbl.glIndexi = missing_glIndexi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexi == loader_glIndexi) {
      rCtx->dsp->emuTbl.glIndexi = driverTbl.glIndexi;
   }
   driverTbl.glIndexi(c);
}

static void REGAL_CALL missing_glIndexiv(const GLint *c)
{
   UNUSED_PARAMETER(c);
   Warning( "glIndexiv not available." );
}

static void REGAL_CALL loader_glIndexiv(const GLint *c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexiv, "glIndexiv");
   if ( !driverTbl.glIndexiv ) {
      driverTbl.glIndexiv = missing_glIndexiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexiv == loader_glIndexiv) {
      rCtx->dsp->emuTbl.glIndexiv = driverTbl.glIndexiv;
   }
   driverTbl.glIndexiv(c);
}

static void REGAL_CALL missing_glIndexs(GLshort c)
{
   UNUSED_PARAMETER(c);
   Warning( "glIndexs not available." );
}

static void REGAL_CALL loader_glIndexs(GLshort c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexs, "glIndexs");
   if ( !driverTbl.glIndexs ) {
      driverTbl.glIndexs = missing_glIndexs;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexs == loader_glIndexs) {
      rCtx->dsp->emuTbl.glIndexs = driverTbl.glIndexs;
   }
   driverTbl.glIndexs(c);
}

static void REGAL_CALL missing_glIndexsv(const GLshort *c)
{
   UNUSED_PARAMETER(c);
   Warning( "glIndexsv not available." );
}

static void REGAL_CALL loader_glIndexsv(const GLshort *c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexsv, "glIndexsv");
   if ( !driverTbl.glIndexsv ) {
      driverTbl.glIndexsv = missing_glIndexsv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexsv == loader_glIndexsv) {
      rCtx->dsp->emuTbl.glIndexsv = driverTbl.glIndexsv;
   }
   driverTbl.glIndexsv(c);
}

static void REGAL_CALL missing_glInitNames(void)
{
   Warning( "glInitNames not available." );
}

static void REGAL_CALL loader_glInitNames(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glInitNames, "glInitNames");
   if ( !driverTbl.glInitNames ) {
      driverTbl.glInitNames = missing_glInitNames;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glInitNames == loader_glInitNames) {
      rCtx->dsp->emuTbl.glInitNames = driverTbl.glInitNames;
   }
   driverTbl.glInitNames();
}

static GLboolean REGAL_CALL missing_glIsEnabled(GLenum cap)
{
   UNUSED_PARAMETER(cap);
   Warning( "glIsEnabled not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsEnabled(GLenum cap)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsEnabled, "glIsEnabled");
   if ( !driverTbl.glIsEnabled ) {
      driverTbl.glIsEnabled = missing_glIsEnabled;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsEnabled == loader_glIsEnabled) {
      rCtx->dsp->emuTbl.glIsEnabled = driverTbl.glIsEnabled;
   }
   return driverTbl.glIsEnabled(cap);
}

static GLboolean REGAL_CALL missing_glIsList(GLuint list)
{
   UNUSED_PARAMETER(list);
   Warning( "glIsList not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsList(GLuint list)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsList, "glIsList");
   if ( !driverTbl.glIsList ) {
      driverTbl.glIsList = missing_glIsList;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsList == loader_glIsList) {
      rCtx->dsp->emuTbl.glIsList = driverTbl.glIsList;
   }
   return driverTbl.glIsList(list);
}

static void REGAL_CALL missing_glLightModelf(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glLightModelf not available." );
}

static void REGAL_CALL loader_glLightModelf(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLightModelf, "glLightModelf");
   if ( !driverTbl.glLightModelf ) {
      driverTbl.glLightModelf = missing_glLightModelf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLightModelf == loader_glLightModelf) {
      rCtx->dsp->emuTbl.glLightModelf = driverTbl.glLightModelf;
   }
   driverTbl.glLightModelf(pname, param);
}

static void REGAL_CALL missing_glLightModelfv(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glLightModelfv not available." );
}

static void REGAL_CALL loader_glLightModelfv(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLightModelfv, "glLightModelfv");
   if ( !driverTbl.glLightModelfv ) {
      driverTbl.glLightModelfv = missing_glLightModelfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLightModelfv == loader_glLightModelfv) {
      rCtx->dsp->emuTbl.glLightModelfv = driverTbl.glLightModelfv;
   }
   driverTbl.glLightModelfv(pname, params);
}

static void REGAL_CALL missing_glLightModeli(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glLightModeli not available." );
}

static void REGAL_CALL loader_glLightModeli(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLightModeli, "glLightModeli");
   if ( !driverTbl.glLightModeli ) {
      driverTbl.glLightModeli = missing_glLightModeli;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLightModeli == loader_glLightModeli) {
      rCtx->dsp->emuTbl.glLightModeli = driverTbl.glLightModeli;
   }
   driverTbl.glLightModeli(pname, param);
}

static void REGAL_CALL missing_glLightModeliv(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glLightModeliv not available." );
}

static void REGAL_CALL loader_glLightModeliv(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLightModeliv, "glLightModeliv");
   if ( !driverTbl.glLightModeliv ) {
      driverTbl.glLightModeliv = missing_glLightModeliv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLightModeliv == loader_glLightModeliv) {
      rCtx->dsp->emuTbl.glLightModeliv = driverTbl.glLightModeliv;
   }
   driverTbl.glLightModeliv(pname, params);
}

static void REGAL_CALL missing_glLightf(GLenum light, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glLightf not available." );
}

static void REGAL_CALL loader_glLightf(GLenum light, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLightf, "glLightf");
   if ( !driverTbl.glLightf ) {
      driverTbl.glLightf = missing_glLightf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLightf == loader_glLightf) {
      rCtx->dsp->emuTbl.glLightf = driverTbl.glLightf;
   }
   driverTbl.glLightf(light, pname, param);
}

static void REGAL_CALL missing_glLightfv(GLenum light, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glLightfv not available." );
}

static void REGAL_CALL loader_glLightfv(GLenum light, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLightfv, "glLightfv");
   if ( !driverTbl.glLightfv ) {
      driverTbl.glLightfv = missing_glLightfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLightfv == loader_glLightfv) {
      rCtx->dsp->emuTbl.glLightfv = driverTbl.glLightfv;
   }
   driverTbl.glLightfv(light, pname, params);
}

static void REGAL_CALL missing_glLighti(GLenum light, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glLighti not available." );
}

static void REGAL_CALL loader_glLighti(GLenum light, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLighti, "glLighti");
   if ( !driverTbl.glLighti ) {
      driverTbl.glLighti = missing_glLighti;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLighti == loader_glLighti) {
      rCtx->dsp->emuTbl.glLighti = driverTbl.glLighti;
   }
   driverTbl.glLighti(light, pname, param);
}

static void REGAL_CALL missing_glLightiv(GLenum light, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glLightiv not available." );
}

static void REGAL_CALL loader_glLightiv(GLenum light, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLightiv, "glLightiv");
   if ( !driverTbl.glLightiv ) {
      driverTbl.glLightiv = missing_glLightiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLightiv == loader_glLightiv) {
      rCtx->dsp->emuTbl.glLightiv = driverTbl.glLightiv;
   }
   driverTbl.glLightiv(light, pname, params);
}

static void REGAL_CALL missing_glLineStipple(GLint factor, GLushort pattern)
{
   UNUSED_PARAMETER(factor);
   UNUSED_PARAMETER(pattern);
   Warning( "glLineStipple not available." );
}

static void REGAL_CALL loader_glLineStipple(GLint factor, GLushort pattern)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLineStipple, "glLineStipple");
   if ( !driverTbl.glLineStipple ) {
      driverTbl.glLineStipple = missing_glLineStipple;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLineStipple == loader_glLineStipple) {
      rCtx->dsp->emuTbl.glLineStipple = driverTbl.glLineStipple;
   }
   driverTbl.glLineStipple(factor, pattern);
}

static void REGAL_CALL missing_glLineWidth(GLfloat width)
{
   UNUSED_PARAMETER(width);
   Warning( "glLineWidth not available." );
}

static void REGAL_CALL loader_glLineWidth(GLfloat width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLineWidth, "glLineWidth");
   if ( !driverTbl.glLineWidth ) {
      driverTbl.glLineWidth = missing_glLineWidth;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLineWidth == loader_glLineWidth) {
      rCtx->dsp->emuTbl.glLineWidth = driverTbl.glLineWidth;
   }
   driverTbl.glLineWidth(width);
}

static void REGAL_CALL missing_glListBase(GLuint base)
{
   UNUSED_PARAMETER(base);
   Warning( "glListBase not available." );
}

static void REGAL_CALL loader_glListBase(GLuint base)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glListBase, "glListBase");
   if ( !driverTbl.glListBase ) {
      driverTbl.glListBase = missing_glListBase;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glListBase == loader_glListBase) {
      rCtx->dsp->emuTbl.glListBase = driverTbl.glListBase;
   }
   driverTbl.glListBase(base);
}

static void REGAL_CALL missing_glLoadIdentity(void)
{
   Warning( "glLoadIdentity not available." );
}

static void REGAL_CALL loader_glLoadIdentity(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLoadIdentity, "glLoadIdentity");
   if ( !driverTbl.glLoadIdentity ) {
      driverTbl.glLoadIdentity = missing_glLoadIdentity;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLoadIdentity == loader_glLoadIdentity) {
      rCtx->dsp->emuTbl.glLoadIdentity = driverTbl.glLoadIdentity;
   }
   driverTbl.glLoadIdentity();
}

static void REGAL_CALL missing_glLoadMatrixd(const GLdouble *m)
{
   UNUSED_PARAMETER(m);
   Warning( "glLoadMatrixd not available." );
}

static void REGAL_CALL loader_glLoadMatrixd(const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLoadMatrixd, "glLoadMatrixd");
   if ( !driverTbl.glLoadMatrixd ) {
      driverTbl.glLoadMatrixd = missing_glLoadMatrixd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLoadMatrixd == loader_glLoadMatrixd) {
      rCtx->dsp->emuTbl.glLoadMatrixd = driverTbl.glLoadMatrixd;
   }
   driverTbl.glLoadMatrixd(m);
}

static void REGAL_CALL missing_glLoadMatrixf(const GLfloat *m)
{
   UNUSED_PARAMETER(m);
   Warning( "glLoadMatrixf not available." );
}

static void REGAL_CALL loader_glLoadMatrixf(const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLoadMatrixf, "glLoadMatrixf");
   if ( !driverTbl.glLoadMatrixf ) {
      driverTbl.glLoadMatrixf = missing_glLoadMatrixf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLoadMatrixf == loader_glLoadMatrixf) {
      rCtx->dsp->emuTbl.glLoadMatrixf = driverTbl.glLoadMatrixf;
   }
   driverTbl.glLoadMatrixf(m);
}

static void REGAL_CALL missing_glLoadName(GLuint name)
{
   UNUSED_PARAMETER(name);
   Warning( "glLoadName not available." );
}

static void REGAL_CALL loader_glLoadName(GLuint name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLoadName, "glLoadName");
   if ( !driverTbl.glLoadName ) {
      driverTbl.glLoadName = missing_glLoadName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLoadName == loader_glLoadName) {
      rCtx->dsp->emuTbl.glLoadName = driverTbl.glLoadName;
   }
   driverTbl.glLoadName(name);
}

static void REGAL_CALL missing_glLogicOp(GLenum opcode)
{
   UNUSED_PARAMETER(opcode);
   Warning( "glLogicOp not available." );
}

static void REGAL_CALL loader_glLogicOp(GLenum opcode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLogicOp, "glLogicOp");
   if ( !driverTbl.glLogicOp ) {
      driverTbl.glLogicOp = missing_glLogicOp;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLogicOp == loader_glLogicOp) {
      rCtx->dsp->emuTbl.glLogicOp = driverTbl.glLogicOp;
   }
   driverTbl.glLogicOp(opcode);
}

static void REGAL_CALL missing_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(order);
   UNUSED_PARAMETER(points);
   Warning( "glMap1d not available." );
}

static void REGAL_CALL loader_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMap1d, "glMap1d");
   if ( !driverTbl.glMap1d ) {
      driverTbl.glMap1d = missing_glMap1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMap1d == loader_glMap1d) {
      rCtx->dsp->emuTbl.glMap1d = driverTbl.glMap1d;
   }
   driverTbl.glMap1d(target, u1, u2, stride, order, points);
}

static void REGAL_CALL missing_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(order);
   UNUSED_PARAMETER(points);
   Warning( "glMap1f not available." );
}

static void REGAL_CALL loader_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMap1f, "glMap1f");
   if ( !driverTbl.glMap1f ) {
      driverTbl.glMap1f = missing_glMap1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMap1f == loader_glMap1f) {
      rCtx->dsp->emuTbl.glMap1f = driverTbl.glMap1f;
   }
   driverTbl.glMap1f(target, u1, u2, stride, order, points);
}

static void REGAL_CALL missing_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(uorder);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(vorder);
   UNUSED_PARAMETER(points);
   Warning( "glMap2d not available." );
}

static void REGAL_CALL loader_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMap2d, "glMap2d");
   if ( !driverTbl.glMap2d ) {
      driverTbl.glMap2d = missing_glMap2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMap2d == loader_glMap2d) {
      rCtx->dsp->emuTbl.glMap2d = driverTbl.glMap2d;
   }
   driverTbl.glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

static void REGAL_CALL missing_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(uorder);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(vorder);
   UNUSED_PARAMETER(points);
   Warning( "glMap2f not available." );
}

static void REGAL_CALL loader_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMap2f, "glMap2f");
   if ( !driverTbl.glMap2f ) {
      driverTbl.glMap2f = missing_glMap2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMap2f == loader_glMap2f) {
      rCtx->dsp->emuTbl.glMap2f = driverTbl.glMap2f;
   }
   driverTbl.glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

static void REGAL_CALL missing_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
{
   UNUSED_PARAMETER(un);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   Warning( "glMapGrid1d not available." );
}

static void REGAL_CALL loader_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapGrid1d, "glMapGrid1d");
   if ( !driverTbl.glMapGrid1d ) {
      driverTbl.glMapGrid1d = missing_glMapGrid1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapGrid1d == loader_glMapGrid1d) {
      rCtx->dsp->emuTbl.glMapGrid1d = driverTbl.glMapGrid1d;
   }
   driverTbl.glMapGrid1d(un, u1, u2);
}

static void REGAL_CALL missing_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
{
   UNUSED_PARAMETER(un);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   Warning( "glMapGrid1f not available." );
}

static void REGAL_CALL loader_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapGrid1f, "glMapGrid1f");
   if ( !driverTbl.glMapGrid1f ) {
      driverTbl.glMapGrid1f = missing_glMapGrid1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapGrid1f == loader_glMapGrid1f) {
      rCtx->dsp->emuTbl.glMapGrid1f = driverTbl.glMapGrid1f;
   }
   driverTbl.glMapGrid1f(un, u1, u2);
}

static void REGAL_CALL missing_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{
   UNUSED_PARAMETER(un);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(vn);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glMapGrid2d not available." );
}

static void REGAL_CALL loader_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapGrid2d, "glMapGrid2d");
   if ( !driverTbl.glMapGrid2d ) {
      driverTbl.glMapGrid2d = missing_glMapGrid2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapGrid2d == loader_glMapGrid2d) {
      rCtx->dsp->emuTbl.glMapGrid2d = driverTbl.glMapGrid2d;
   }
   driverTbl.glMapGrid2d(un, u1, u2, vn, v1, v2);
}

static void REGAL_CALL missing_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{
   UNUSED_PARAMETER(un);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(vn);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glMapGrid2f not available." );
}

static void REGAL_CALL loader_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapGrid2f, "glMapGrid2f");
   if ( !driverTbl.glMapGrid2f ) {
      driverTbl.glMapGrid2f = missing_glMapGrid2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapGrid2f == loader_glMapGrid2f) {
      rCtx->dsp->emuTbl.glMapGrid2f = driverTbl.glMapGrid2f;
   }
   driverTbl.glMapGrid2f(un, u1, u2, vn, v1, v2);
}

static void REGAL_CALL missing_glMaterialf(GLenum face, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glMaterialf not available." );
}

static void REGAL_CALL loader_glMaterialf(GLenum face, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMaterialf, "glMaterialf");
   if ( !driverTbl.glMaterialf ) {
      driverTbl.glMaterialf = missing_glMaterialf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMaterialf == loader_glMaterialf) {
      rCtx->dsp->emuTbl.glMaterialf = driverTbl.glMaterialf;
   }
   driverTbl.glMaterialf(face, pname, param);
}

static void REGAL_CALL missing_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glMaterialfv not available." );
}

static void REGAL_CALL loader_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMaterialfv, "glMaterialfv");
   if ( !driverTbl.glMaterialfv ) {
      driverTbl.glMaterialfv = missing_glMaterialfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMaterialfv == loader_glMaterialfv) {
      rCtx->dsp->emuTbl.glMaterialfv = driverTbl.glMaterialfv;
   }
   driverTbl.glMaterialfv(face, pname, params);
}

static void REGAL_CALL missing_glMateriali(GLenum face, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glMateriali not available." );
}

static void REGAL_CALL loader_glMateriali(GLenum face, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMateriali, "glMateriali");
   if ( !driverTbl.glMateriali ) {
      driverTbl.glMateriali = missing_glMateriali;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMateriali == loader_glMateriali) {
      rCtx->dsp->emuTbl.glMateriali = driverTbl.glMateriali;
   }
   driverTbl.glMateriali(face, pname, param);
}

static void REGAL_CALL missing_glMaterialiv(GLenum face, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glMaterialiv not available." );
}

static void REGAL_CALL loader_glMaterialiv(GLenum face, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMaterialiv, "glMaterialiv");
   if ( !driverTbl.glMaterialiv ) {
      driverTbl.glMaterialiv = missing_glMaterialiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMaterialiv == loader_glMaterialiv) {
      rCtx->dsp->emuTbl.glMaterialiv = driverTbl.glMaterialiv;
   }
   driverTbl.glMaterialiv(face, pname, params);
}

static void REGAL_CALL missing_glMatrixMode(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glMatrixMode not available." );
}

static void REGAL_CALL loader_glMatrixMode(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixMode, "glMatrixMode");
   if ( !driverTbl.glMatrixMode ) {
      driverTbl.glMatrixMode = missing_glMatrixMode;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixMode == loader_glMatrixMode) {
      rCtx->dsp->emuTbl.glMatrixMode = driverTbl.glMatrixMode;
   }
   driverTbl.glMatrixMode(mode);
}

static void REGAL_CALL missing_glMultMatrixd(const GLdouble *m)
{
   UNUSED_PARAMETER(m);
   Warning( "glMultMatrixd not available." );
}

static void REGAL_CALL loader_glMultMatrixd(const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultMatrixd, "glMultMatrixd");
   if ( !driverTbl.glMultMatrixd ) {
      driverTbl.glMultMatrixd = missing_glMultMatrixd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultMatrixd == loader_glMultMatrixd) {
      rCtx->dsp->emuTbl.glMultMatrixd = driverTbl.glMultMatrixd;
   }
   driverTbl.glMultMatrixd(m);
}

static void REGAL_CALL missing_glMultMatrixf(const GLfloat *m)
{
   UNUSED_PARAMETER(m);
   Warning( "glMultMatrixf not available." );
}

static void REGAL_CALL loader_glMultMatrixf(const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultMatrixf, "glMultMatrixf");
   if ( !driverTbl.glMultMatrixf ) {
      driverTbl.glMultMatrixf = missing_glMultMatrixf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultMatrixf == loader_glMultMatrixf) {
      rCtx->dsp->emuTbl.glMultMatrixf = driverTbl.glMultMatrixf;
   }
   driverTbl.glMultMatrixf(m);
}

static void REGAL_CALL missing_glNewList(GLuint list, GLenum mode)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(mode);
   Warning( "glNewList not available." );
}

static void REGAL_CALL loader_glNewList(GLuint list, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNewList, "glNewList");
   if ( !driverTbl.glNewList ) {
      driverTbl.glNewList = missing_glNewList;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNewList == loader_glNewList) {
      rCtx->dsp->emuTbl.glNewList = driverTbl.glNewList;
   }
   driverTbl.glNewList(list, mode);
}

static void REGAL_CALL missing_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
{
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   Warning( "glNormal3b not available." );
}

static void REGAL_CALL loader_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormal3b, "glNormal3b");
   if ( !driverTbl.glNormal3b ) {
      driverTbl.glNormal3b = missing_glNormal3b;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormal3b == loader_glNormal3b) {
      rCtx->dsp->emuTbl.glNormal3b = driverTbl.glNormal3b;
   }
   driverTbl.glNormal3b(nx, ny, nz);
}

static void REGAL_CALL missing_glNormal3bv(const GLbyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glNormal3bv not available." );
}

static void REGAL_CALL loader_glNormal3bv(const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormal3bv, "glNormal3bv");
   if ( !driverTbl.glNormal3bv ) {
      driverTbl.glNormal3bv = missing_glNormal3bv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormal3bv == loader_glNormal3bv) {
      rCtx->dsp->emuTbl.glNormal3bv = driverTbl.glNormal3bv;
   }
   driverTbl.glNormal3bv(v);
}

static void REGAL_CALL missing_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
{
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   Warning( "glNormal3d not available." );
}

static void REGAL_CALL loader_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormal3d, "glNormal3d");
   if ( !driverTbl.glNormal3d ) {
      driverTbl.glNormal3d = missing_glNormal3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormal3d == loader_glNormal3d) {
      rCtx->dsp->emuTbl.glNormal3d = driverTbl.glNormal3d;
   }
   driverTbl.glNormal3d(nx, ny, nz);
}

static void REGAL_CALL missing_glNormal3dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glNormal3dv not available." );
}

static void REGAL_CALL loader_glNormal3dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormal3dv, "glNormal3dv");
   if ( !driverTbl.glNormal3dv ) {
      driverTbl.glNormal3dv = missing_glNormal3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormal3dv == loader_glNormal3dv) {
      rCtx->dsp->emuTbl.glNormal3dv = driverTbl.glNormal3dv;
   }
   driverTbl.glNormal3dv(v);
}

static void REGAL_CALL missing_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
{
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   Warning( "glNormal3f not available." );
}

static void REGAL_CALL loader_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormal3f, "glNormal3f");
   if ( !driverTbl.glNormal3f ) {
      driverTbl.glNormal3f = missing_glNormal3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormal3f == loader_glNormal3f) {
      rCtx->dsp->emuTbl.glNormal3f = driverTbl.glNormal3f;
   }
   driverTbl.glNormal3f(nx, ny, nz);
}

static void REGAL_CALL missing_glNormal3fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glNormal3fv not available." );
}

static void REGAL_CALL loader_glNormal3fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormal3fv, "glNormal3fv");
   if ( !driverTbl.glNormal3fv ) {
      driverTbl.glNormal3fv = missing_glNormal3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormal3fv == loader_glNormal3fv) {
      rCtx->dsp->emuTbl.glNormal3fv = driverTbl.glNormal3fv;
   }
   driverTbl.glNormal3fv(v);
}

static void REGAL_CALL missing_glNormal3i(GLint nx, GLint ny, GLint nz)
{
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   Warning( "glNormal3i not available." );
}

static void REGAL_CALL loader_glNormal3i(GLint nx, GLint ny, GLint nz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormal3i, "glNormal3i");
   if ( !driverTbl.glNormal3i ) {
      driverTbl.glNormal3i = missing_glNormal3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormal3i == loader_glNormal3i) {
      rCtx->dsp->emuTbl.glNormal3i = driverTbl.glNormal3i;
   }
   driverTbl.glNormal3i(nx, ny, nz);
}

static void REGAL_CALL missing_glNormal3iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glNormal3iv not available." );
}

static void REGAL_CALL loader_glNormal3iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormal3iv, "glNormal3iv");
   if ( !driverTbl.glNormal3iv ) {
      driverTbl.glNormal3iv = missing_glNormal3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormal3iv == loader_glNormal3iv) {
      rCtx->dsp->emuTbl.glNormal3iv = driverTbl.glNormal3iv;
   }
   driverTbl.glNormal3iv(v);
}

static void REGAL_CALL missing_glNormal3s(GLshort nx, GLshort ny, GLshort nz)
{
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   Warning( "glNormal3s not available." );
}

static void REGAL_CALL loader_glNormal3s(GLshort nx, GLshort ny, GLshort nz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormal3s, "glNormal3s");
   if ( !driverTbl.glNormal3s ) {
      driverTbl.glNormal3s = missing_glNormal3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormal3s == loader_glNormal3s) {
      rCtx->dsp->emuTbl.glNormal3s = driverTbl.glNormal3s;
   }
   driverTbl.glNormal3s(nx, ny, nz);
}

static void REGAL_CALL missing_glNormal3sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glNormal3sv not available." );
}

static void REGAL_CALL loader_glNormal3sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormal3sv, "glNormal3sv");
   if ( !driverTbl.glNormal3sv ) {
      driverTbl.glNormal3sv = missing_glNormal3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormal3sv == loader_glNormal3sv) {
      rCtx->dsp->emuTbl.glNormal3sv = driverTbl.glNormal3sv;
   }
   driverTbl.glNormal3sv(v);
}

static void REGAL_CALL missing_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   UNUSED_PARAMETER(left);
   UNUSED_PARAMETER(right);
   UNUSED_PARAMETER(bottom);
   UNUSED_PARAMETER(top);
   UNUSED_PARAMETER(zNear);
   UNUSED_PARAMETER(zFar);
   Warning( "glOrtho not available." );
}

static void REGAL_CALL loader_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glOrtho, "glOrtho");
   if ( !driverTbl.glOrtho ) {
      driverTbl.glOrtho = missing_glOrtho;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glOrtho == loader_glOrtho) {
      rCtx->dsp->emuTbl.glOrtho = driverTbl.glOrtho;
   }
   driverTbl.glOrtho(left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL missing_glPassThrough(GLfloat token)
{
   UNUSED_PARAMETER(token);
   Warning( "glPassThrough not available." );
}

static void REGAL_CALL loader_glPassThrough(GLfloat token)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPassThrough, "glPassThrough");
   if ( !driverTbl.glPassThrough ) {
      driverTbl.glPassThrough = missing_glPassThrough;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPassThrough == loader_glPassThrough) {
      rCtx->dsp->emuTbl.glPassThrough = driverTbl.glPassThrough;
   }
   driverTbl.glPassThrough(token);
}

static void REGAL_CALL missing_glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(mapsize);
   UNUSED_PARAMETER(values);
   Warning( "glPixelMapfv not available." );
}

static void REGAL_CALL loader_glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelMapfv, "glPixelMapfv");
   if ( !driverTbl.glPixelMapfv ) {
      driverTbl.glPixelMapfv = missing_glPixelMapfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelMapfv == loader_glPixelMapfv) {
      rCtx->dsp->emuTbl.glPixelMapfv = driverTbl.glPixelMapfv;
   }
   driverTbl.glPixelMapfv(map, mapsize, values);
}

static void REGAL_CALL missing_glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(mapsize);
   UNUSED_PARAMETER(values);
   Warning( "glPixelMapuiv not available." );
}

static void REGAL_CALL loader_glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelMapuiv, "glPixelMapuiv");
   if ( !driverTbl.glPixelMapuiv ) {
      driverTbl.glPixelMapuiv = missing_glPixelMapuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelMapuiv == loader_glPixelMapuiv) {
      rCtx->dsp->emuTbl.glPixelMapuiv = driverTbl.glPixelMapuiv;
   }
   driverTbl.glPixelMapuiv(map, mapsize, values);
}

static void REGAL_CALL missing_glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(mapsize);
   UNUSED_PARAMETER(values);
   Warning( "glPixelMapusv not available." );
}

static void REGAL_CALL loader_glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelMapusv, "glPixelMapusv");
   if ( !driverTbl.glPixelMapusv ) {
      driverTbl.glPixelMapusv = missing_glPixelMapusv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelMapusv == loader_glPixelMapusv) {
      rCtx->dsp->emuTbl.glPixelMapusv = driverTbl.glPixelMapusv;
   }
   driverTbl.glPixelMapusv(map, mapsize, values);
}

static void REGAL_CALL missing_glPixelStoref(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPixelStoref not available." );
}

static void REGAL_CALL loader_glPixelStoref(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelStoref, "glPixelStoref");
   if ( !driverTbl.glPixelStoref ) {
      driverTbl.glPixelStoref = missing_glPixelStoref;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelStoref == loader_glPixelStoref) {
      rCtx->dsp->emuTbl.glPixelStoref = driverTbl.glPixelStoref;
   }
   driverTbl.glPixelStoref(pname, param);
}

static void REGAL_CALL missing_glPixelStorei(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPixelStorei not available." );
}

static void REGAL_CALL loader_glPixelStorei(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelStorei, "glPixelStorei");
   if ( !driverTbl.glPixelStorei ) {
      driverTbl.glPixelStorei = missing_glPixelStorei;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelStorei == loader_glPixelStorei) {
      rCtx->dsp->emuTbl.glPixelStorei = driverTbl.glPixelStorei;
   }
   driverTbl.glPixelStorei(pname, param);
}

static void REGAL_CALL missing_glPixelTransferf(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPixelTransferf not available." );
}

static void REGAL_CALL loader_glPixelTransferf(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelTransferf, "glPixelTransferf");
   if ( !driverTbl.glPixelTransferf ) {
      driverTbl.glPixelTransferf = missing_glPixelTransferf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelTransferf == loader_glPixelTransferf) {
      rCtx->dsp->emuTbl.glPixelTransferf = driverTbl.glPixelTransferf;
   }
   driverTbl.glPixelTransferf(pname, param);
}

static void REGAL_CALL missing_glPixelTransferi(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPixelTransferi not available." );
}

static void REGAL_CALL loader_glPixelTransferi(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelTransferi, "glPixelTransferi");
   if ( !driverTbl.glPixelTransferi ) {
      driverTbl.glPixelTransferi = missing_glPixelTransferi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelTransferi == loader_glPixelTransferi) {
      rCtx->dsp->emuTbl.glPixelTransferi = driverTbl.glPixelTransferi;
   }
   driverTbl.glPixelTransferi(pname, param);
}

static void REGAL_CALL missing_glPixelZoom(GLfloat xfactor, GLfloat yfactor)
{
   UNUSED_PARAMETER(xfactor);
   UNUSED_PARAMETER(yfactor);
   Warning( "glPixelZoom not available." );
}

static void REGAL_CALL loader_glPixelZoom(GLfloat xfactor, GLfloat yfactor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelZoom, "glPixelZoom");
   if ( !driverTbl.glPixelZoom ) {
      driverTbl.glPixelZoom = missing_glPixelZoom;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelZoom == loader_glPixelZoom) {
      rCtx->dsp->emuTbl.glPixelZoom = driverTbl.glPixelZoom;
   }
   driverTbl.glPixelZoom(xfactor, yfactor);
}

static void REGAL_CALL missing_glPointSize(GLfloat size)
{
   UNUSED_PARAMETER(size);
   Warning( "glPointSize not available." );
}

static void REGAL_CALL loader_glPointSize(GLfloat size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPointSize, "glPointSize");
   if ( !driverTbl.glPointSize ) {
      driverTbl.glPointSize = missing_glPointSize;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPointSize == loader_glPointSize) {
      rCtx->dsp->emuTbl.glPointSize = driverTbl.glPointSize;
   }
   driverTbl.glPointSize(size);
}

static void REGAL_CALL missing_glPolygonMode(GLenum face, GLenum mode)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(mode);
   Warning( "glPolygonMode not available." );
}

static void REGAL_CALL loader_glPolygonMode(GLenum face, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPolygonMode, "glPolygonMode");
   if ( !driverTbl.glPolygonMode ) {
      driverTbl.glPolygonMode = missing_glPolygonMode;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPolygonMode == loader_glPolygonMode) {
      rCtx->dsp->emuTbl.glPolygonMode = driverTbl.glPolygonMode;
   }
   driverTbl.glPolygonMode(face, mode);
}

static void REGAL_CALL missing_glPolygonStipple(const GLubyte *mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "glPolygonStipple not available." );
}

static void REGAL_CALL loader_glPolygonStipple(const GLubyte *mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPolygonStipple, "glPolygonStipple");
   if ( !driverTbl.glPolygonStipple ) {
      driverTbl.glPolygonStipple = missing_glPolygonStipple;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPolygonStipple == loader_glPolygonStipple) {
      rCtx->dsp->emuTbl.glPolygonStipple = driverTbl.glPolygonStipple;
   }
   driverTbl.glPolygonStipple(mask);
}

static void REGAL_CALL missing_glPopAttrib(void)
{
   Warning( "glPopAttrib not available." );
}

static void REGAL_CALL loader_glPopAttrib(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPopAttrib, "glPopAttrib");
   if ( !driverTbl.glPopAttrib ) {
      driverTbl.glPopAttrib = missing_glPopAttrib;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPopAttrib == loader_glPopAttrib) {
      rCtx->dsp->emuTbl.glPopAttrib = driverTbl.glPopAttrib;
   }
   driverTbl.glPopAttrib();
}

static void REGAL_CALL missing_glPopMatrix(void)
{
   Warning( "glPopMatrix not available." );
}

static void REGAL_CALL loader_glPopMatrix(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPopMatrix, "glPopMatrix");
   if ( !driverTbl.glPopMatrix ) {
      driverTbl.glPopMatrix = missing_glPopMatrix;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPopMatrix == loader_glPopMatrix) {
      rCtx->dsp->emuTbl.glPopMatrix = driverTbl.glPopMatrix;
   }
   driverTbl.glPopMatrix();
}

static void REGAL_CALL missing_glPopName(void)
{
   Warning( "glPopName not available." );
}

static void REGAL_CALL loader_glPopName(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPopName, "glPopName");
   if ( !driverTbl.glPopName ) {
      driverTbl.glPopName = missing_glPopName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPopName == loader_glPopName) {
      rCtx->dsp->emuTbl.glPopName = driverTbl.glPopName;
   }
   driverTbl.glPopName();
}

static void REGAL_CALL missing_glPushAttrib(GLbitfield mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "glPushAttrib not available." );
}

static void REGAL_CALL loader_glPushAttrib(GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPushAttrib, "glPushAttrib");
   if ( !driverTbl.glPushAttrib ) {
      driverTbl.glPushAttrib = missing_glPushAttrib;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPushAttrib == loader_glPushAttrib) {
      rCtx->dsp->emuTbl.glPushAttrib = driverTbl.glPushAttrib;
   }
   driverTbl.glPushAttrib(mask);
}

static void REGAL_CALL missing_glPushMatrix(void)
{
   Warning( "glPushMatrix not available." );
}

static void REGAL_CALL loader_glPushMatrix(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPushMatrix, "glPushMatrix");
   if ( !driverTbl.glPushMatrix ) {
      driverTbl.glPushMatrix = missing_glPushMatrix;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPushMatrix == loader_glPushMatrix) {
      rCtx->dsp->emuTbl.glPushMatrix = driverTbl.glPushMatrix;
   }
   driverTbl.glPushMatrix();
}

static void REGAL_CALL missing_glPushName(GLuint name)
{
   UNUSED_PARAMETER(name);
   Warning( "glPushName not available." );
}

static void REGAL_CALL loader_glPushName(GLuint name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPushName, "glPushName");
   if ( !driverTbl.glPushName ) {
      driverTbl.glPushName = missing_glPushName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPushName == loader_glPushName) {
      rCtx->dsp->emuTbl.glPushName = driverTbl.glPushName;
   }
   driverTbl.glPushName(name);
}

static void REGAL_CALL missing_glRasterPos2d(GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glRasterPos2d not available." );
}

static void REGAL_CALL loader_glRasterPos2d(GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos2d, "glRasterPos2d");
   if ( !driverTbl.glRasterPos2d ) {
      driverTbl.glRasterPos2d = missing_glRasterPos2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos2d == loader_glRasterPos2d) {
      rCtx->dsp->emuTbl.glRasterPos2d = driverTbl.glRasterPos2d;
   }
   driverTbl.glRasterPos2d(x, y);
}

static void REGAL_CALL missing_glRasterPos2dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glRasterPos2dv not available." );
}

static void REGAL_CALL loader_glRasterPos2dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos2dv, "glRasterPos2dv");
   if ( !driverTbl.glRasterPos2dv ) {
      driverTbl.glRasterPos2dv = missing_glRasterPos2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos2dv == loader_glRasterPos2dv) {
      rCtx->dsp->emuTbl.glRasterPos2dv = driverTbl.glRasterPos2dv;
   }
   driverTbl.glRasterPos2dv(v);
}

static void REGAL_CALL missing_glRasterPos2f(GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glRasterPos2f not available." );
}

static void REGAL_CALL loader_glRasterPos2f(GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos2f, "glRasterPos2f");
   if ( !driverTbl.glRasterPos2f ) {
      driverTbl.glRasterPos2f = missing_glRasterPos2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos2f == loader_glRasterPos2f) {
      rCtx->dsp->emuTbl.glRasterPos2f = driverTbl.glRasterPos2f;
   }
   driverTbl.glRasterPos2f(x, y);
}

static void REGAL_CALL missing_glRasterPos2fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glRasterPos2fv not available." );
}

static void REGAL_CALL loader_glRasterPos2fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos2fv, "glRasterPos2fv");
   if ( !driverTbl.glRasterPos2fv ) {
      driverTbl.glRasterPos2fv = missing_glRasterPos2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos2fv == loader_glRasterPos2fv) {
      rCtx->dsp->emuTbl.glRasterPos2fv = driverTbl.glRasterPos2fv;
   }
   driverTbl.glRasterPos2fv(v);
}

static void REGAL_CALL missing_glRasterPos2i(GLint x, GLint y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glRasterPos2i not available." );
}

static void REGAL_CALL loader_glRasterPos2i(GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos2i, "glRasterPos2i");
   if ( !driverTbl.glRasterPos2i ) {
      driverTbl.glRasterPos2i = missing_glRasterPos2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos2i == loader_glRasterPos2i) {
      rCtx->dsp->emuTbl.glRasterPos2i = driverTbl.glRasterPos2i;
   }
   driverTbl.glRasterPos2i(x, y);
}

static void REGAL_CALL missing_glRasterPos2iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glRasterPos2iv not available." );
}

static void REGAL_CALL loader_glRasterPos2iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos2iv, "glRasterPos2iv");
   if ( !driverTbl.glRasterPos2iv ) {
      driverTbl.glRasterPos2iv = missing_glRasterPos2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos2iv == loader_glRasterPos2iv) {
      rCtx->dsp->emuTbl.glRasterPos2iv = driverTbl.glRasterPos2iv;
   }
   driverTbl.glRasterPos2iv(v);
}

static void REGAL_CALL missing_glRasterPos2s(GLshort x, GLshort y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glRasterPos2s not available." );
}

static void REGAL_CALL loader_glRasterPos2s(GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos2s, "glRasterPos2s");
   if ( !driverTbl.glRasterPos2s ) {
      driverTbl.glRasterPos2s = missing_glRasterPos2s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos2s == loader_glRasterPos2s) {
      rCtx->dsp->emuTbl.glRasterPos2s = driverTbl.glRasterPos2s;
   }
   driverTbl.glRasterPos2s(x, y);
}

static void REGAL_CALL missing_glRasterPos2sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glRasterPos2sv not available." );
}

static void REGAL_CALL loader_glRasterPos2sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos2sv, "glRasterPos2sv");
   if ( !driverTbl.glRasterPos2sv ) {
      driverTbl.glRasterPos2sv = missing_glRasterPos2sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos2sv == loader_glRasterPos2sv) {
      rCtx->dsp->emuTbl.glRasterPos2sv = driverTbl.glRasterPos2sv;
   }
   driverTbl.glRasterPos2sv(v);
}

static void REGAL_CALL missing_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glRasterPos3d not available." );
}

static void REGAL_CALL loader_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos3d, "glRasterPos3d");
   if ( !driverTbl.glRasterPos3d ) {
      driverTbl.glRasterPos3d = missing_glRasterPos3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos3d == loader_glRasterPos3d) {
      rCtx->dsp->emuTbl.glRasterPos3d = driverTbl.glRasterPos3d;
   }
   driverTbl.glRasterPos3d(x, y, z);
}

static void REGAL_CALL missing_glRasterPos3dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glRasterPos3dv not available." );
}

static void REGAL_CALL loader_glRasterPos3dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos3dv, "glRasterPos3dv");
   if ( !driverTbl.glRasterPos3dv ) {
      driverTbl.glRasterPos3dv = missing_glRasterPos3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos3dv == loader_glRasterPos3dv) {
      rCtx->dsp->emuTbl.glRasterPos3dv = driverTbl.glRasterPos3dv;
   }
   driverTbl.glRasterPos3dv(v);
}

static void REGAL_CALL missing_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glRasterPos3f not available." );
}

static void REGAL_CALL loader_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos3f, "glRasterPos3f");
   if ( !driverTbl.glRasterPos3f ) {
      driverTbl.glRasterPos3f = missing_glRasterPos3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos3f == loader_glRasterPos3f) {
      rCtx->dsp->emuTbl.glRasterPos3f = driverTbl.glRasterPos3f;
   }
   driverTbl.glRasterPos3f(x, y, z);
}

static void REGAL_CALL missing_glRasterPos3fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glRasterPos3fv not available." );
}

static void REGAL_CALL loader_glRasterPos3fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos3fv, "glRasterPos3fv");
   if ( !driverTbl.glRasterPos3fv ) {
      driverTbl.glRasterPos3fv = missing_glRasterPos3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos3fv == loader_glRasterPos3fv) {
      rCtx->dsp->emuTbl.glRasterPos3fv = driverTbl.glRasterPos3fv;
   }
   driverTbl.glRasterPos3fv(v);
}

static void REGAL_CALL missing_glRasterPos3i(GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glRasterPos3i not available." );
}

static void REGAL_CALL loader_glRasterPos3i(GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos3i, "glRasterPos3i");
   if ( !driverTbl.glRasterPos3i ) {
      driverTbl.glRasterPos3i = missing_glRasterPos3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos3i == loader_glRasterPos3i) {
      rCtx->dsp->emuTbl.glRasterPos3i = driverTbl.glRasterPos3i;
   }
   driverTbl.glRasterPos3i(x, y, z);
}

static void REGAL_CALL missing_glRasterPos3iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glRasterPos3iv not available." );
}

static void REGAL_CALL loader_glRasterPos3iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos3iv, "glRasterPos3iv");
   if ( !driverTbl.glRasterPos3iv ) {
      driverTbl.glRasterPos3iv = missing_glRasterPos3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos3iv == loader_glRasterPos3iv) {
      rCtx->dsp->emuTbl.glRasterPos3iv = driverTbl.glRasterPos3iv;
   }
   driverTbl.glRasterPos3iv(v);
}

static void REGAL_CALL missing_glRasterPos3s(GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glRasterPos3s not available." );
}

static void REGAL_CALL loader_glRasterPos3s(GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos3s, "glRasterPos3s");
   if ( !driverTbl.glRasterPos3s ) {
      driverTbl.glRasterPos3s = missing_glRasterPos3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos3s == loader_glRasterPos3s) {
      rCtx->dsp->emuTbl.glRasterPos3s = driverTbl.glRasterPos3s;
   }
   driverTbl.glRasterPos3s(x, y, z);
}

static void REGAL_CALL missing_glRasterPos3sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glRasterPos3sv not available." );
}

static void REGAL_CALL loader_glRasterPos3sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos3sv, "glRasterPos3sv");
   if ( !driverTbl.glRasterPos3sv ) {
      driverTbl.glRasterPos3sv = missing_glRasterPos3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos3sv == loader_glRasterPos3sv) {
      rCtx->dsp->emuTbl.glRasterPos3sv = driverTbl.glRasterPos3sv;
   }
   driverTbl.glRasterPos3sv(v);
}

static void REGAL_CALL missing_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glRasterPos4d not available." );
}

static void REGAL_CALL loader_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos4d, "glRasterPos4d");
   if ( !driverTbl.glRasterPos4d ) {
      driverTbl.glRasterPos4d = missing_glRasterPos4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos4d == loader_glRasterPos4d) {
      rCtx->dsp->emuTbl.glRasterPos4d = driverTbl.glRasterPos4d;
   }
   driverTbl.glRasterPos4d(x, y, z, w);
}

static void REGAL_CALL missing_glRasterPos4dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glRasterPos4dv not available." );
}

static void REGAL_CALL loader_glRasterPos4dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos4dv, "glRasterPos4dv");
   if ( !driverTbl.glRasterPos4dv ) {
      driverTbl.glRasterPos4dv = missing_glRasterPos4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos4dv == loader_glRasterPos4dv) {
      rCtx->dsp->emuTbl.glRasterPos4dv = driverTbl.glRasterPos4dv;
   }
   driverTbl.glRasterPos4dv(v);
}

static void REGAL_CALL missing_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glRasterPos4f not available." );
}

static void REGAL_CALL loader_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos4f, "glRasterPos4f");
   if ( !driverTbl.glRasterPos4f ) {
      driverTbl.glRasterPos4f = missing_glRasterPos4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos4f == loader_glRasterPos4f) {
      rCtx->dsp->emuTbl.glRasterPos4f = driverTbl.glRasterPos4f;
   }
   driverTbl.glRasterPos4f(x, y, z, w);
}

static void REGAL_CALL missing_glRasterPos4fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glRasterPos4fv not available." );
}

static void REGAL_CALL loader_glRasterPos4fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos4fv, "glRasterPos4fv");
   if ( !driverTbl.glRasterPos4fv ) {
      driverTbl.glRasterPos4fv = missing_glRasterPos4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos4fv == loader_glRasterPos4fv) {
      rCtx->dsp->emuTbl.glRasterPos4fv = driverTbl.glRasterPos4fv;
   }
   driverTbl.glRasterPos4fv(v);
}

static void REGAL_CALL missing_glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glRasterPos4i not available." );
}

static void REGAL_CALL loader_glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos4i, "glRasterPos4i");
   if ( !driverTbl.glRasterPos4i ) {
      driverTbl.glRasterPos4i = missing_glRasterPos4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos4i == loader_glRasterPos4i) {
      rCtx->dsp->emuTbl.glRasterPos4i = driverTbl.glRasterPos4i;
   }
   driverTbl.glRasterPos4i(x, y, z, w);
}

static void REGAL_CALL missing_glRasterPos4iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glRasterPos4iv not available." );
}

static void REGAL_CALL loader_glRasterPos4iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos4iv, "glRasterPos4iv");
   if ( !driverTbl.glRasterPos4iv ) {
      driverTbl.glRasterPos4iv = missing_glRasterPos4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos4iv == loader_glRasterPos4iv) {
      rCtx->dsp->emuTbl.glRasterPos4iv = driverTbl.glRasterPos4iv;
   }
   driverTbl.glRasterPos4iv(v);
}

static void REGAL_CALL missing_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glRasterPos4s not available." );
}

static void REGAL_CALL loader_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos4s, "glRasterPos4s");
   if ( !driverTbl.glRasterPos4s ) {
      driverTbl.glRasterPos4s = missing_glRasterPos4s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos4s == loader_glRasterPos4s) {
      rCtx->dsp->emuTbl.glRasterPos4s = driverTbl.glRasterPos4s;
   }
   driverTbl.glRasterPos4s(x, y, z, w);
}

static void REGAL_CALL missing_glRasterPos4sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glRasterPos4sv not available." );
}

static void REGAL_CALL loader_glRasterPos4sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRasterPos4sv, "glRasterPos4sv");
   if ( !driverTbl.glRasterPos4sv ) {
      driverTbl.glRasterPos4sv = missing_glRasterPos4sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRasterPos4sv == loader_glRasterPos4sv) {
      rCtx->dsp->emuTbl.glRasterPos4sv = driverTbl.glRasterPos4sv;
   }
   driverTbl.glRasterPos4sv(v);
}

static void REGAL_CALL missing_glReadBuffer(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glReadBuffer not available." );
}

static void REGAL_CALL loader_glReadBuffer(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReadBuffer, "glReadBuffer");
   if ( !driverTbl.glReadBuffer ) {
      driverTbl.glReadBuffer = missing_glReadBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReadBuffer == loader_glReadBuffer) {
      rCtx->dsp->emuTbl.glReadBuffer = driverTbl.glReadBuffer;
   }
   driverTbl.glReadBuffer(mode);
}

static void REGAL_CALL missing_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glReadPixels not available." );
}

static void REGAL_CALL loader_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReadPixels, "glReadPixels");
   if ( !driverTbl.glReadPixels ) {
      driverTbl.glReadPixels = missing_glReadPixels;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReadPixels == loader_glReadPixels) {
      rCtx->dsp->emuTbl.glReadPixels = driverTbl.glReadPixels;
   }
   driverTbl.glReadPixels(x, y, width, height, format, type, pixels);
}

static void REGAL_CALL missing_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{
   UNUSED_PARAMETER(x1);
   UNUSED_PARAMETER(y1);
   UNUSED_PARAMETER(x2);
   UNUSED_PARAMETER(y2);
   Warning( "glRectd not available." );
}

static void REGAL_CALL loader_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRectd, "glRectd");
   if ( !driverTbl.glRectd ) {
      driverTbl.glRectd = missing_glRectd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRectd == loader_glRectd) {
      rCtx->dsp->emuTbl.glRectd = driverTbl.glRectd;
   }
   driverTbl.glRectd(x1, y1, x2, y2);
}

static void REGAL_CALL missing_glRectdv(const GLdouble *v1, const GLdouble *v2)
{
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glRectdv not available." );
}

static void REGAL_CALL loader_glRectdv(const GLdouble *v1, const GLdouble *v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRectdv, "glRectdv");
   if ( !driverTbl.glRectdv ) {
      driverTbl.glRectdv = missing_glRectdv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRectdv == loader_glRectdv) {
      rCtx->dsp->emuTbl.glRectdv = driverTbl.glRectdv;
   }
   driverTbl.glRectdv(v1, v2);
}

static void REGAL_CALL missing_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
   UNUSED_PARAMETER(x1);
   UNUSED_PARAMETER(y1);
   UNUSED_PARAMETER(x2);
   UNUSED_PARAMETER(y2);
   Warning( "glRectf not available." );
}

static void REGAL_CALL loader_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRectf, "glRectf");
   if ( !driverTbl.glRectf ) {
      driverTbl.glRectf = missing_glRectf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRectf == loader_glRectf) {
      rCtx->dsp->emuTbl.glRectf = driverTbl.glRectf;
   }
   driverTbl.glRectf(x1, y1, x2, y2);
}

static void REGAL_CALL missing_glRectfv(const GLfloat *v1, const GLfloat *v2)
{
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glRectfv not available." );
}

static void REGAL_CALL loader_glRectfv(const GLfloat *v1, const GLfloat *v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRectfv, "glRectfv");
   if ( !driverTbl.glRectfv ) {
      driverTbl.glRectfv = missing_glRectfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRectfv == loader_glRectfv) {
      rCtx->dsp->emuTbl.glRectfv = driverTbl.glRectfv;
   }
   driverTbl.glRectfv(v1, v2);
}

static void REGAL_CALL missing_glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
{
   UNUSED_PARAMETER(x1);
   UNUSED_PARAMETER(y1);
   UNUSED_PARAMETER(x2);
   UNUSED_PARAMETER(y2);
   Warning( "glRecti not available." );
}

static void REGAL_CALL loader_glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRecti, "glRecti");
   if ( !driverTbl.glRecti ) {
      driverTbl.glRecti = missing_glRecti;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRecti == loader_glRecti) {
      rCtx->dsp->emuTbl.glRecti = driverTbl.glRecti;
   }
   driverTbl.glRecti(x1, y1, x2, y2);
}

static void REGAL_CALL missing_glRectiv(const GLint *v1, const GLint *v2)
{
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glRectiv not available." );
}

static void REGAL_CALL loader_glRectiv(const GLint *v1, const GLint *v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRectiv, "glRectiv");
   if ( !driverTbl.glRectiv ) {
      driverTbl.glRectiv = missing_glRectiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRectiv == loader_glRectiv) {
      rCtx->dsp->emuTbl.glRectiv = driverTbl.glRectiv;
   }
   driverTbl.glRectiv(v1, v2);
}

static void REGAL_CALL missing_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
{
   UNUSED_PARAMETER(x1);
   UNUSED_PARAMETER(y1);
   UNUSED_PARAMETER(x2);
   UNUSED_PARAMETER(y2);
   Warning( "glRects not available." );
}

static void REGAL_CALL loader_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRects, "glRects");
   if ( !driverTbl.glRects ) {
      driverTbl.glRects = missing_glRects;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRects == loader_glRects) {
      rCtx->dsp->emuTbl.glRects = driverTbl.glRects;
   }
   driverTbl.glRects(x1, y1, x2, y2);
}

static void REGAL_CALL missing_glRectsv(const GLshort *v1, const GLshort *v2)
{
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glRectsv not available." );
}

static void REGAL_CALL loader_glRectsv(const GLshort *v1, const GLshort *v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRectsv, "glRectsv");
   if ( !driverTbl.glRectsv ) {
      driverTbl.glRectsv = missing_glRectsv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRectsv == loader_glRectsv) {
      rCtx->dsp->emuTbl.glRectsv = driverTbl.glRectsv;
   }
   driverTbl.glRectsv(v1, v2);
}

static GLint REGAL_CALL missing_glRenderMode(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glRenderMode not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glRenderMode(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRenderMode, "glRenderMode");
   if ( !driverTbl.glRenderMode ) {
      driverTbl.glRenderMode = missing_glRenderMode;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRenderMode == loader_glRenderMode) {
      rCtx->dsp->emuTbl.glRenderMode = driverTbl.glRenderMode;
   }
   return driverTbl.glRenderMode(mode);
}

static void REGAL_CALL missing_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(angle);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glRotated not available." );
}

static void REGAL_CALL loader_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRotated, "glRotated");
   if ( !driverTbl.glRotated ) {
      driverTbl.glRotated = missing_glRotated;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRotated == loader_glRotated) {
      rCtx->dsp->emuTbl.glRotated = driverTbl.glRotated;
   }
   driverTbl.glRotated(angle, x, y, z);
}

static void REGAL_CALL missing_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(angle);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glRotatef not available." );
}

static void REGAL_CALL loader_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRotatef, "glRotatef");
   if ( !driverTbl.glRotatef ) {
      driverTbl.glRotatef = missing_glRotatef;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRotatef == loader_glRotatef) {
      rCtx->dsp->emuTbl.glRotatef = driverTbl.glRotatef;
   }
   driverTbl.glRotatef(angle, x, y, z);
}

static void REGAL_CALL missing_glScaled(GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glScaled not available." );
}

static void REGAL_CALL loader_glScaled(GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glScaled, "glScaled");
   if ( !driverTbl.glScaled ) {
      driverTbl.glScaled = missing_glScaled;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glScaled == loader_glScaled) {
      rCtx->dsp->emuTbl.glScaled = driverTbl.glScaled;
   }
   driverTbl.glScaled(x, y, z);
}

static void REGAL_CALL missing_glScalef(GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glScalef not available." );
}

static void REGAL_CALL loader_glScalef(GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glScalef, "glScalef");
   if ( !driverTbl.glScalef ) {
      driverTbl.glScalef = missing_glScalef;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glScalef == loader_glScalef) {
      rCtx->dsp->emuTbl.glScalef = driverTbl.glScalef;
   }
   driverTbl.glScalef(x, y, z);
}

static void REGAL_CALL missing_glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glScissor not available." );
}

static void REGAL_CALL loader_glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glScissor, "glScissor");
   if ( !driverTbl.glScissor ) {
      driverTbl.glScissor = missing_glScissor;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glScissor == loader_glScissor) {
      rCtx->dsp->emuTbl.glScissor = driverTbl.glScissor;
   }
   driverTbl.glScissor(x, y, width, height);
}

static void REGAL_CALL missing_glSelectBuffer(GLsizei size, GLuint *buffer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(buffer);
   Warning( "glSelectBuffer not available." );
}

static void REGAL_CALL loader_glSelectBuffer(GLsizei size, GLuint *buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSelectBuffer, "glSelectBuffer");
   if ( !driverTbl.glSelectBuffer ) {
      driverTbl.glSelectBuffer = missing_glSelectBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSelectBuffer == loader_glSelectBuffer) {
      rCtx->dsp->emuTbl.glSelectBuffer = driverTbl.glSelectBuffer;
   }
   driverTbl.glSelectBuffer(size, buffer);
}

static void REGAL_CALL missing_glShadeModel(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glShadeModel not available." );
}

static void REGAL_CALL loader_glShadeModel(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glShadeModel, "glShadeModel");
   if ( !driverTbl.glShadeModel ) {
      driverTbl.glShadeModel = missing_glShadeModel;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glShadeModel == loader_glShadeModel) {
      rCtx->dsp->emuTbl.glShadeModel = driverTbl.glShadeModel;
   }
   driverTbl.glShadeModel(mode);
}

static void REGAL_CALL missing_glStencilFunc(GLenum func, GLint ref, GLuint mask)
{
   UNUSED_PARAMETER(func);
   UNUSED_PARAMETER(ref);
   UNUSED_PARAMETER(mask);
   Warning( "glStencilFunc not available." );
}

static void REGAL_CALL loader_glStencilFunc(GLenum func, GLint ref, GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStencilFunc, "glStencilFunc");
   if ( !driverTbl.glStencilFunc ) {
      driverTbl.glStencilFunc = missing_glStencilFunc;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStencilFunc == loader_glStencilFunc) {
      rCtx->dsp->emuTbl.glStencilFunc = driverTbl.glStencilFunc;
   }
   driverTbl.glStencilFunc(func, ref, mask);
}

static void REGAL_CALL missing_glStencilMask(GLuint mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "glStencilMask not available." );
}

static void REGAL_CALL loader_glStencilMask(GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStencilMask, "glStencilMask");
   if ( !driverTbl.glStencilMask ) {
      driverTbl.glStencilMask = missing_glStencilMask;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStencilMask == loader_glStencilMask) {
      rCtx->dsp->emuTbl.glStencilMask = driverTbl.glStencilMask;
   }
   driverTbl.glStencilMask(mask);
}

static void REGAL_CALL missing_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
   UNUSED_PARAMETER(fail);
   UNUSED_PARAMETER(zfail);
   UNUSED_PARAMETER(zpass);
   Warning( "glStencilOp not available." );
}

static void REGAL_CALL loader_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStencilOp, "glStencilOp");
   if ( !driverTbl.glStencilOp ) {
      driverTbl.glStencilOp = missing_glStencilOp;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStencilOp == loader_glStencilOp) {
      rCtx->dsp->emuTbl.glStencilOp = driverTbl.glStencilOp;
   }
   driverTbl.glStencilOp(fail, zfail, zpass);
}

static void REGAL_CALL missing_glTexCoord1d(GLdouble s)
{
   UNUSED_PARAMETER(s);
   Warning( "glTexCoord1d not available." );
}

static void REGAL_CALL loader_glTexCoord1d(GLdouble s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord1d, "glTexCoord1d");
   if ( !driverTbl.glTexCoord1d ) {
      driverTbl.glTexCoord1d = missing_glTexCoord1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord1d == loader_glTexCoord1d) {
      rCtx->dsp->emuTbl.glTexCoord1d = driverTbl.glTexCoord1d;
   }
   driverTbl.glTexCoord1d(s);
}

static void REGAL_CALL missing_glTexCoord1dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord1dv not available." );
}

static void REGAL_CALL loader_glTexCoord1dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord1dv, "glTexCoord1dv");
   if ( !driverTbl.glTexCoord1dv ) {
      driverTbl.glTexCoord1dv = missing_glTexCoord1dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord1dv == loader_glTexCoord1dv) {
      rCtx->dsp->emuTbl.glTexCoord1dv = driverTbl.glTexCoord1dv;
   }
   driverTbl.glTexCoord1dv(v);
}

static void REGAL_CALL missing_glTexCoord1f(GLfloat s)
{
   UNUSED_PARAMETER(s);
   Warning( "glTexCoord1f not available." );
}

static void REGAL_CALL loader_glTexCoord1f(GLfloat s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord1f, "glTexCoord1f");
   if ( !driverTbl.glTexCoord1f ) {
      driverTbl.glTexCoord1f = missing_glTexCoord1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord1f == loader_glTexCoord1f) {
      rCtx->dsp->emuTbl.glTexCoord1f = driverTbl.glTexCoord1f;
   }
   driverTbl.glTexCoord1f(s);
}

static void REGAL_CALL missing_glTexCoord1fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord1fv not available." );
}

static void REGAL_CALL loader_glTexCoord1fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord1fv, "glTexCoord1fv");
   if ( !driverTbl.glTexCoord1fv ) {
      driverTbl.glTexCoord1fv = missing_glTexCoord1fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord1fv == loader_glTexCoord1fv) {
      rCtx->dsp->emuTbl.glTexCoord1fv = driverTbl.glTexCoord1fv;
   }
   driverTbl.glTexCoord1fv(v);
}

static void REGAL_CALL missing_glTexCoord1i(GLint s)
{
   UNUSED_PARAMETER(s);
   Warning( "glTexCoord1i not available." );
}

static void REGAL_CALL loader_glTexCoord1i(GLint s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord1i, "glTexCoord1i");
   if ( !driverTbl.glTexCoord1i ) {
      driverTbl.glTexCoord1i = missing_glTexCoord1i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord1i == loader_glTexCoord1i) {
      rCtx->dsp->emuTbl.glTexCoord1i = driverTbl.glTexCoord1i;
   }
   driverTbl.glTexCoord1i(s);
}

static void REGAL_CALL missing_glTexCoord1iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord1iv not available." );
}

static void REGAL_CALL loader_glTexCoord1iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord1iv, "glTexCoord1iv");
   if ( !driverTbl.glTexCoord1iv ) {
      driverTbl.glTexCoord1iv = missing_glTexCoord1iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord1iv == loader_glTexCoord1iv) {
      rCtx->dsp->emuTbl.glTexCoord1iv = driverTbl.glTexCoord1iv;
   }
   driverTbl.glTexCoord1iv(v);
}

static void REGAL_CALL missing_glTexCoord1s(GLshort s)
{
   UNUSED_PARAMETER(s);
   Warning( "glTexCoord1s not available." );
}

static void REGAL_CALL loader_glTexCoord1s(GLshort s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord1s, "glTexCoord1s");
   if ( !driverTbl.glTexCoord1s ) {
      driverTbl.glTexCoord1s = missing_glTexCoord1s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord1s == loader_glTexCoord1s) {
      rCtx->dsp->emuTbl.glTexCoord1s = driverTbl.glTexCoord1s;
   }
   driverTbl.glTexCoord1s(s);
}

static void REGAL_CALL missing_glTexCoord1sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord1sv not available." );
}

static void REGAL_CALL loader_glTexCoord1sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord1sv, "glTexCoord1sv");
   if ( !driverTbl.glTexCoord1sv ) {
      driverTbl.glTexCoord1sv = missing_glTexCoord1sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord1sv == loader_glTexCoord1sv) {
      rCtx->dsp->emuTbl.glTexCoord1sv = driverTbl.glTexCoord1sv;
   }
   driverTbl.glTexCoord1sv(v);
}

static void REGAL_CALL missing_glTexCoord2d(GLdouble s, GLdouble t)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "glTexCoord2d not available." );
}

static void REGAL_CALL loader_glTexCoord2d(GLdouble s, GLdouble t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2d, "glTexCoord2d");
   if ( !driverTbl.glTexCoord2d ) {
      driverTbl.glTexCoord2d = missing_glTexCoord2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2d == loader_glTexCoord2d) {
      rCtx->dsp->emuTbl.glTexCoord2d = driverTbl.glTexCoord2d;
   }
   driverTbl.glTexCoord2d(s, t);
}

static void REGAL_CALL missing_glTexCoord2dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord2dv not available." );
}

static void REGAL_CALL loader_glTexCoord2dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2dv, "glTexCoord2dv");
   if ( !driverTbl.glTexCoord2dv ) {
      driverTbl.glTexCoord2dv = missing_glTexCoord2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2dv == loader_glTexCoord2dv) {
      rCtx->dsp->emuTbl.glTexCoord2dv = driverTbl.glTexCoord2dv;
   }
   driverTbl.glTexCoord2dv(v);
}

static void REGAL_CALL missing_glTexCoord2f(GLfloat s, GLfloat t)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "glTexCoord2f not available." );
}

static void REGAL_CALL loader_glTexCoord2f(GLfloat s, GLfloat t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2f, "glTexCoord2f");
   if ( !driverTbl.glTexCoord2f ) {
      driverTbl.glTexCoord2f = missing_glTexCoord2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2f == loader_glTexCoord2f) {
      rCtx->dsp->emuTbl.glTexCoord2f = driverTbl.glTexCoord2f;
   }
   driverTbl.glTexCoord2f(s, t);
}

static void REGAL_CALL missing_glTexCoord2fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord2fv not available." );
}

static void REGAL_CALL loader_glTexCoord2fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2fv, "glTexCoord2fv");
   if ( !driverTbl.glTexCoord2fv ) {
      driverTbl.glTexCoord2fv = missing_glTexCoord2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2fv == loader_glTexCoord2fv) {
      rCtx->dsp->emuTbl.glTexCoord2fv = driverTbl.glTexCoord2fv;
   }
   driverTbl.glTexCoord2fv(v);
}

static void REGAL_CALL missing_glTexCoord2i(GLint s, GLint t)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "glTexCoord2i not available." );
}

static void REGAL_CALL loader_glTexCoord2i(GLint s, GLint t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2i, "glTexCoord2i");
   if ( !driverTbl.glTexCoord2i ) {
      driverTbl.glTexCoord2i = missing_glTexCoord2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2i == loader_glTexCoord2i) {
      rCtx->dsp->emuTbl.glTexCoord2i = driverTbl.glTexCoord2i;
   }
   driverTbl.glTexCoord2i(s, t);
}

static void REGAL_CALL missing_glTexCoord2iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord2iv not available." );
}

static void REGAL_CALL loader_glTexCoord2iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2iv, "glTexCoord2iv");
   if ( !driverTbl.glTexCoord2iv ) {
      driverTbl.glTexCoord2iv = missing_glTexCoord2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2iv == loader_glTexCoord2iv) {
      rCtx->dsp->emuTbl.glTexCoord2iv = driverTbl.glTexCoord2iv;
   }
   driverTbl.glTexCoord2iv(v);
}

static void REGAL_CALL missing_glTexCoord2s(GLshort s, GLshort t)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "glTexCoord2s not available." );
}

static void REGAL_CALL loader_glTexCoord2s(GLshort s, GLshort t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2s, "glTexCoord2s");
   if ( !driverTbl.glTexCoord2s ) {
      driverTbl.glTexCoord2s = missing_glTexCoord2s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2s == loader_glTexCoord2s) {
      rCtx->dsp->emuTbl.glTexCoord2s = driverTbl.glTexCoord2s;
   }
   driverTbl.glTexCoord2s(s, t);
}

static void REGAL_CALL missing_glTexCoord2sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord2sv not available." );
}

static void REGAL_CALL loader_glTexCoord2sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2sv, "glTexCoord2sv");
   if ( !driverTbl.glTexCoord2sv ) {
      driverTbl.glTexCoord2sv = missing_glTexCoord2sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2sv == loader_glTexCoord2sv) {
      rCtx->dsp->emuTbl.glTexCoord2sv = driverTbl.glTexCoord2sv;
   }
   driverTbl.glTexCoord2sv(v);
}

static void REGAL_CALL missing_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "glTexCoord3d not available." );
}

static void REGAL_CALL loader_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord3d, "glTexCoord3d");
   if ( !driverTbl.glTexCoord3d ) {
      driverTbl.glTexCoord3d = missing_glTexCoord3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord3d == loader_glTexCoord3d) {
      rCtx->dsp->emuTbl.glTexCoord3d = driverTbl.glTexCoord3d;
   }
   driverTbl.glTexCoord3d(s, t, r);
}

static void REGAL_CALL missing_glTexCoord3dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord3dv not available." );
}

static void REGAL_CALL loader_glTexCoord3dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord3dv, "glTexCoord3dv");
   if ( !driverTbl.glTexCoord3dv ) {
      driverTbl.glTexCoord3dv = missing_glTexCoord3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord3dv == loader_glTexCoord3dv) {
      rCtx->dsp->emuTbl.glTexCoord3dv = driverTbl.glTexCoord3dv;
   }
   driverTbl.glTexCoord3dv(v);
}

static void REGAL_CALL missing_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "glTexCoord3f not available." );
}

static void REGAL_CALL loader_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord3f, "glTexCoord3f");
   if ( !driverTbl.glTexCoord3f ) {
      driverTbl.glTexCoord3f = missing_glTexCoord3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord3f == loader_glTexCoord3f) {
      rCtx->dsp->emuTbl.glTexCoord3f = driverTbl.glTexCoord3f;
   }
   driverTbl.glTexCoord3f(s, t, r);
}

static void REGAL_CALL missing_glTexCoord3fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord3fv not available." );
}

static void REGAL_CALL loader_glTexCoord3fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord3fv, "glTexCoord3fv");
   if ( !driverTbl.glTexCoord3fv ) {
      driverTbl.glTexCoord3fv = missing_glTexCoord3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord3fv == loader_glTexCoord3fv) {
      rCtx->dsp->emuTbl.glTexCoord3fv = driverTbl.glTexCoord3fv;
   }
   driverTbl.glTexCoord3fv(v);
}

static void REGAL_CALL missing_glTexCoord3i(GLint s, GLint t, GLint r)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "glTexCoord3i not available." );
}

static void REGAL_CALL loader_glTexCoord3i(GLint s, GLint t, GLint r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord3i, "glTexCoord3i");
   if ( !driverTbl.glTexCoord3i ) {
      driverTbl.glTexCoord3i = missing_glTexCoord3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord3i == loader_glTexCoord3i) {
      rCtx->dsp->emuTbl.glTexCoord3i = driverTbl.glTexCoord3i;
   }
   driverTbl.glTexCoord3i(s, t, r);
}

static void REGAL_CALL missing_glTexCoord3iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord3iv not available." );
}

static void REGAL_CALL loader_glTexCoord3iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord3iv, "glTexCoord3iv");
   if ( !driverTbl.glTexCoord3iv ) {
      driverTbl.glTexCoord3iv = missing_glTexCoord3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord3iv == loader_glTexCoord3iv) {
      rCtx->dsp->emuTbl.glTexCoord3iv = driverTbl.glTexCoord3iv;
   }
   driverTbl.glTexCoord3iv(v);
}

static void REGAL_CALL missing_glTexCoord3s(GLshort s, GLshort t, GLshort r)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "glTexCoord3s not available." );
}

static void REGAL_CALL loader_glTexCoord3s(GLshort s, GLshort t, GLshort r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord3s, "glTexCoord3s");
   if ( !driverTbl.glTexCoord3s ) {
      driverTbl.glTexCoord3s = missing_glTexCoord3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord3s == loader_glTexCoord3s) {
      rCtx->dsp->emuTbl.glTexCoord3s = driverTbl.glTexCoord3s;
   }
   driverTbl.glTexCoord3s(s, t, r);
}

static void REGAL_CALL missing_glTexCoord3sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord3sv not available." );
}

static void REGAL_CALL loader_glTexCoord3sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord3sv, "glTexCoord3sv");
   if ( !driverTbl.glTexCoord3sv ) {
      driverTbl.glTexCoord3sv = missing_glTexCoord3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord3sv == loader_glTexCoord3sv) {
      rCtx->dsp->emuTbl.glTexCoord3sv = driverTbl.glTexCoord3sv;
   }
   driverTbl.glTexCoord3sv(v);
}

static void REGAL_CALL missing_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "glTexCoord4d not available." );
}

static void REGAL_CALL loader_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord4d, "glTexCoord4d");
   if ( !driverTbl.glTexCoord4d ) {
      driverTbl.glTexCoord4d = missing_glTexCoord4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord4d == loader_glTexCoord4d) {
      rCtx->dsp->emuTbl.glTexCoord4d = driverTbl.glTexCoord4d;
   }
   driverTbl.glTexCoord4d(s, t, r, q);
}

static void REGAL_CALL missing_glTexCoord4dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord4dv not available." );
}

static void REGAL_CALL loader_glTexCoord4dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord4dv, "glTexCoord4dv");
   if ( !driverTbl.glTexCoord4dv ) {
      driverTbl.glTexCoord4dv = missing_glTexCoord4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord4dv == loader_glTexCoord4dv) {
      rCtx->dsp->emuTbl.glTexCoord4dv = driverTbl.glTexCoord4dv;
   }
   driverTbl.glTexCoord4dv(v);
}

static void REGAL_CALL missing_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "glTexCoord4f not available." );
}

static void REGAL_CALL loader_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord4f, "glTexCoord4f");
   if ( !driverTbl.glTexCoord4f ) {
      driverTbl.glTexCoord4f = missing_glTexCoord4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord4f == loader_glTexCoord4f) {
      rCtx->dsp->emuTbl.glTexCoord4f = driverTbl.glTexCoord4f;
   }
   driverTbl.glTexCoord4f(s, t, r, q);
}

static void REGAL_CALL missing_glTexCoord4fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord4fv not available." );
}

static void REGAL_CALL loader_glTexCoord4fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord4fv, "glTexCoord4fv");
   if ( !driverTbl.glTexCoord4fv ) {
      driverTbl.glTexCoord4fv = missing_glTexCoord4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord4fv == loader_glTexCoord4fv) {
      rCtx->dsp->emuTbl.glTexCoord4fv = driverTbl.glTexCoord4fv;
   }
   driverTbl.glTexCoord4fv(v);
}

static void REGAL_CALL missing_glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "glTexCoord4i not available." );
}

static void REGAL_CALL loader_glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord4i, "glTexCoord4i");
   if ( !driverTbl.glTexCoord4i ) {
      driverTbl.glTexCoord4i = missing_glTexCoord4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord4i == loader_glTexCoord4i) {
      rCtx->dsp->emuTbl.glTexCoord4i = driverTbl.glTexCoord4i;
   }
   driverTbl.glTexCoord4i(s, t, r, q);
}

static void REGAL_CALL missing_glTexCoord4iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord4iv not available." );
}

static void REGAL_CALL loader_glTexCoord4iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord4iv, "glTexCoord4iv");
   if ( !driverTbl.glTexCoord4iv ) {
      driverTbl.glTexCoord4iv = missing_glTexCoord4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord4iv == loader_glTexCoord4iv) {
      rCtx->dsp->emuTbl.glTexCoord4iv = driverTbl.glTexCoord4iv;
   }
   driverTbl.glTexCoord4iv(v);
}

static void REGAL_CALL missing_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "glTexCoord4s not available." );
}

static void REGAL_CALL loader_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord4s, "glTexCoord4s");
   if ( !driverTbl.glTexCoord4s ) {
      driverTbl.glTexCoord4s = missing_glTexCoord4s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord4s == loader_glTexCoord4s) {
      rCtx->dsp->emuTbl.glTexCoord4s = driverTbl.glTexCoord4s;
   }
   driverTbl.glTexCoord4s(s, t, r, q);
}

static void REGAL_CALL missing_glTexCoord4sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord4sv not available." );
}

static void REGAL_CALL loader_glTexCoord4sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord4sv, "glTexCoord4sv");
   if ( !driverTbl.glTexCoord4sv ) {
      driverTbl.glTexCoord4sv = missing_glTexCoord4sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord4sv == loader_glTexCoord4sv) {
      rCtx->dsp->emuTbl.glTexCoord4sv = driverTbl.glTexCoord4sv;
   }
   driverTbl.glTexCoord4sv(v);
}

static void REGAL_CALL missing_glTexEnvf(GLenum target, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glTexEnvf not available." );
}

static void REGAL_CALL loader_glTexEnvf(GLenum target, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexEnvf, "glTexEnvf");
   if ( !driverTbl.glTexEnvf ) {
      driverTbl.glTexEnvf = missing_glTexEnvf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexEnvf == loader_glTexEnvf) {
      rCtx->dsp->emuTbl.glTexEnvf = driverTbl.glTexEnvf;
   }
   driverTbl.glTexEnvf(target, pname, param);
}

static void REGAL_CALL missing_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glTexEnvfv not available." );
}

static void REGAL_CALL loader_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexEnvfv, "glTexEnvfv");
   if ( !driverTbl.glTexEnvfv ) {
      driverTbl.glTexEnvfv = missing_glTexEnvfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexEnvfv == loader_glTexEnvfv) {
      rCtx->dsp->emuTbl.glTexEnvfv = driverTbl.glTexEnvfv;
   }
   driverTbl.glTexEnvfv(target, pname, params);
}

static void REGAL_CALL missing_glTexEnvi(GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glTexEnvi not available." );
}

static void REGAL_CALL loader_glTexEnvi(GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexEnvi, "glTexEnvi");
   if ( !driverTbl.glTexEnvi ) {
      driverTbl.glTexEnvi = missing_glTexEnvi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexEnvi == loader_glTexEnvi) {
      rCtx->dsp->emuTbl.glTexEnvi = driverTbl.glTexEnvi;
   }
   driverTbl.glTexEnvi(target, pname, param);
}

static void REGAL_CALL missing_glTexEnviv(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glTexEnviv not available." );
}

static void REGAL_CALL loader_glTexEnviv(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexEnviv, "glTexEnviv");
   if ( !driverTbl.glTexEnviv ) {
      driverTbl.glTexEnviv = missing_glTexEnviv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexEnviv == loader_glTexEnviv) {
      rCtx->dsp->emuTbl.glTexEnviv = driverTbl.glTexEnviv;
   }
   driverTbl.glTexEnviv(target, pname, params);
}

static void REGAL_CALL missing_glTexGend(GLenum coord, GLenum pname, GLdouble param)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glTexGend not available." );
}

static void REGAL_CALL loader_glTexGend(GLenum coord, GLenum pname, GLdouble param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexGend, "glTexGend");
   if ( !driverTbl.glTexGend ) {
      driverTbl.glTexGend = missing_glTexGend;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexGend == loader_glTexGend) {
      rCtx->dsp->emuTbl.glTexGend = driverTbl.glTexGend;
   }
   driverTbl.glTexGend(coord, pname, param);
}

static void REGAL_CALL missing_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glTexGendv not available." );
}

static void REGAL_CALL loader_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexGendv, "glTexGendv");
   if ( !driverTbl.glTexGendv ) {
      driverTbl.glTexGendv = missing_glTexGendv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexGendv == loader_glTexGendv) {
      rCtx->dsp->emuTbl.glTexGendv = driverTbl.glTexGendv;
   }
   driverTbl.glTexGendv(coord, pname, params);
}

static void REGAL_CALL missing_glTexGenf(GLenum coord, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glTexGenf not available." );
}

static void REGAL_CALL loader_glTexGenf(GLenum coord, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexGenf, "glTexGenf");
   if ( !driverTbl.glTexGenf ) {
      driverTbl.glTexGenf = missing_glTexGenf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexGenf == loader_glTexGenf) {
      rCtx->dsp->emuTbl.glTexGenf = driverTbl.glTexGenf;
   }
   driverTbl.glTexGenf(coord, pname, param);
}

static void REGAL_CALL missing_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glTexGenfv not available." );
}

static void REGAL_CALL loader_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexGenfv, "glTexGenfv");
   if ( !driverTbl.glTexGenfv ) {
      driverTbl.glTexGenfv = missing_glTexGenfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexGenfv == loader_glTexGenfv) {
      rCtx->dsp->emuTbl.glTexGenfv = driverTbl.glTexGenfv;
   }
   driverTbl.glTexGenfv(coord, pname, params);
}

static void REGAL_CALL missing_glTexGeni(GLenum coord, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glTexGeni not available." );
}

static void REGAL_CALL loader_glTexGeni(GLenum coord, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexGeni, "glTexGeni");
   if ( !driverTbl.glTexGeni ) {
      driverTbl.glTexGeni = missing_glTexGeni;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexGeni == loader_glTexGeni) {
      rCtx->dsp->emuTbl.glTexGeni = driverTbl.glTexGeni;
   }
   driverTbl.glTexGeni(coord, pname, param);
}

static void REGAL_CALL missing_glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glTexGeniv not available." );
}

static void REGAL_CALL loader_glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexGeniv, "glTexGeniv");
   if ( !driverTbl.glTexGeniv ) {
      driverTbl.glTexGeniv = missing_glTexGeniv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexGeniv == loader_glTexGeniv) {
      rCtx->dsp->emuTbl.glTexGeniv = driverTbl.glTexGeniv;
   }
   driverTbl.glTexGeniv(coord, pname, params);
}

static void REGAL_CALL missing_glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTexImage1D not available." );
}

static void REGAL_CALL loader_glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexImage1D, "glTexImage1D");
   if ( !driverTbl.glTexImage1D ) {
      driverTbl.glTexImage1D = missing_glTexImage1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexImage1D == loader_glTexImage1D) {
      rCtx->dsp->emuTbl.glTexImage1D = driverTbl.glTexImage1D;
   }
   driverTbl.glTexImage1D(target, level, internalformat, width, border, format, type, pixels);
}

static void REGAL_CALL missing_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTexImage2D not available." );
}

static void REGAL_CALL loader_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexImage2D, "glTexImage2D");
   if ( !driverTbl.glTexImage2D ) {
      driverTbl.glTexImage2D = missing_glTexImage2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexImage2D == loader_glTexImage2D) {
      rCtx->dsp->emuTbl.glTexImage2D = driverTbl.glTexImage2D;
   }
   driverTbl.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
}

static void REGAL_CALL missing_glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glTexParameterf not available." );
}

static void REGAL_CALL loader_glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexParameterf, "glTexParameterf");
   if ( !driverTbl.glTexParameterf ) {
      driverTbl.glTexParameterf = missing_glTexParameterf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexParameterf == loader_glTexParameterf) {
      rCtx->dsp->emuTbl.glTexParameterf = driverTbl.glTexParameterf;
   }
   driverTbl.glTexParameterf(target, pname, param);
}

static void REGAL_CALL missing_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glTexParameterfv not available." );
}

static void REGAL_CALL loader_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexParameterfv, "glTexParameterfv");
   if ( !driverTbl.glTexParameterfv ) {
      driverTbl.glTexParameterfv = missing_glTexParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexParameterfv == loader_glTexParameterfv) {
      rCtx->dsp->emuTbl.glTexParameterfv = driverTbl.glTexParameterfv;
   }
   driverTbl.glTexParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glTexParameteri(GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glTexParameteri not available." );
}

static void REGAL_CALL loader_glTexParameteri(GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexParameteri, "glTexParameteri");
   if ( !driverTbl.glTexParameteri ) {
      driverTbl.glTexParameteri = missing_glTexParameteri;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexParameteri == loader_glTexParameteri) {
      rCtx->dsp->emuTbl.glTexParameteri = driverTbl.glTexParameteri;
   }
   driverTbl.glTexParameteri(target, pname, param);
}

static void REGAL_CALL missing_glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glTexParameteriv not available." );
}

static void REGAL_CALL loader_glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexParameteriv, "glTexParameteriv");
   if ( !driverTbl.glTexParameteriv ) {
      driverTbl.glTexParameteriv = missing_glTexParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexParameteriv == loader_glTexParameteriv) {
      rCtx->dsp->emuTbl.glTexParameteriv = driverTbl.glTexParameteriv;
   }
   driverTbl.glTexParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glTranslated(GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glTranslated not available." );
}

static void REGAL_CALL loader_glTranslated(GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTranslated, "glTranslated");
   if ( !driverTbl.glTranslated ) {
      driverTbl.glTranslated = missing_glTranslated;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTranslated == loader_glTranslated) {
      rCtx->dsp->emuTbl.glTranslated = driverTbl.glTranslated;
   }
   driverTbl.glTranslated(x, y, z);
}

static void REGAL_CALL missing_glTranslatef(GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glTranslatef not available." );
}

static void REGAL_CALL loader_glTranslatef(GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTranslatef, "glTranslatef");
   if ( !driverTbl.glTranslatef ) {
      driverTbl.glTranslatef = missing_glTranslatef;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTranslatef == loader_glTranslatef) {
      rCtx->dsp->emuTbl.glTranslatef = driverTbl.glTranslatef;
   }
   driverTbl.glTranslatef(x, y, z);
}

static void REGAL_CALL missing_glVertex2d(GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertex2d not available." );
}

static void REGAL_CALL loader_glVertex2d(GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex2d, "glVertex2d");
   if ( !driverTbl.glVertex2d ) {
      driverTbl.glVertex2d = missing_glVertex2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex2d == loader_glVertex2d) {
      rCtx->dsp->emuTbl.glVertex2d = driverTbl.glVertex2d;
   }
   driverTbl.glVertex2d(x, y);
}

static void REGAL_CALL missing_glVertex2dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex2dv not available." );
}

static void REGAL_CALL loader_glVertex2dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex2dv, "glVertex2dv");
   if ( !driverTbl.glVertex2dv ) {
      driverTbl.glVertex2dv = missing_glVertex2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex2dv == loader_glVertex2dv) {
      rCtx->dsp->emuTbl.glVertex2dv = driverTbl.glVertex2dv;
   }
   driverTbl.glVertex2dv(v);
}

static void REGAL_CALL missing_glVertex2f(GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertex2f not available." );
}

static void REGAL_CALL loader_glVertex2f(GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex2f, "glVertex2f");
   if ( !driverTbl.glVertex2f ) {
      driverTbl.glVertex2f = missing_glVertex2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex2f == loader_glVertex2f) {
      rCtx->dsp->emuTbl.glVertex2f = driverTbl.glVertex2f;
   }
   driverTbl.glVertex2f(x, y);
}

static void REGAL_CALL missing_glVertex2fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex2fv not available." );
}

static void REGAL_CALL loader_glVertex2fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex2fv, "glVertex2fv");
   if ( !driverTbl.glVertex2fv ) {
      driverTbl.glVertex2fv = missing_glVertex2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex2fv == loader_glVertex2fv) {
      rCtx->dsp->emuTbl.glVertex2fv = driverTbl.glVertex2fv;
   }
   driverTbl.glVertex2fv(v);
}

static void REGAL_CALL missing_glVertex2i(GLint x, GLint y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertex2i not available." );
}

static void REGAL_CALL loader_glVertex2i(GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex2i, "glVertex2i");
   if ( !driverTbl.glVertex2i ) {
      driverTbl.glVertex2i = missing_glVertex2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex2i == loader_glVertex2i) {
      rCtx->dsp->emuTbl.glVertex2i = driverTbl.glVertex2i;
   }
   driverTbl.glVertex2i(x, y);
}

static void REGAL_CALL missing_glVertex2iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex2iv not available." );
}

static void REGAL_CALL loader_glVertex2iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex2iv, "glVertex2iv");
   if ( !driverTbl.glVertex2iv ) {
      driverTbl.glVertex2iv = missing_glVertex2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex2iv == loader_glVertex2iv) {
      rCtx->dsp->emuTbl.glVertex2iv = driverTbl.glVertex2iv;
   }
   driverTbl.glVertex2iv(v);
}

static void REGAL_CALL missing_glVertex2s(GLshort x, GLshort y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertex2s not available." );
}

static void REGAL_CALL loader_glVertex2s(GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex2s, "glVertex2s");
   if ( !driverTbl.glVertex2s ) {
      driverTbl.glVertex2s = missing_glVertex2s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex2s == loader_glVertex2s) {
      rCtx->dsp->emuTbl.glVertex2s = driverTbl.glVertex2s;
   }
   driverTbl.glVertex2s(x, y);
}

static void REGAL_CALL missing_glVertex2sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex2sv not available." );
}

static void REGAL_CALL loader_glVertex2sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex2sv, "glVertex2sv");
   if ( !driverTbl.glVertex2sv ) {
      driverTbl.glVertex2sv = missing_glVertex2sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex2sv == loader_glVertex2sv) {
      rCtx->dsp->emuTbl.glVertex2sv = driverTbl.glVertex2sv;
   }
   driverTbl.glVertex2sv(v);
}

static void REGAL_CALL missing_glVertex3d(GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertex3d not available." );
}

static void REGAL_CALL loader_glVertex3d(GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex3d, "glVertex3d");
   if ( !driverTbl.glVertex3d ) {
      driverTbl.glVertex3d = missing_glVertex3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex3d == loader_glVertex3d) {
      rCtx->dsp->emuTbl.glVertex3d = driverTbl.glVertex3d;
   }
   driverTbl.glVertex3d(x, y, z);
}

static void REGAL_CALL missing_glVertex3dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex3dv not available." );
}

static void REGAL_CALL loader_glVertex3dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex3dv, "glVertex3dv");
   if ( !driverTbl.glVertex3dv ) {
      driverTbl.glVertex3dv = missing_glVertex3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex3dv == loader_glVertex3dv) {
      rCtx->dsp->emuTbl.glVertex3dv = driverTbl.glVertex3dv;
   }
   driverTbl.glVertex3dv(v);
}

static void REGAL_CALL missing_glVertex3f(GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertex3f not available." );
}

static void REGAL_CALL loader_glVertex3f(GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex3f, "glVertex3f");
   if ( !driverTbl.glVertex3f ) {
      driverTbl.glVertex3f = missing_glVertex3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex3f == loader_glVertex3f) {
      rCtx->dsp->emuTbl.glVertex3f = driverTbl.glVertex3f;
   }
   driverTbl.glVertex3f(x, y, z);
}

static void REGAL_CALL missing_glVertex3fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex3fv not available." );
}

static void REGAL_CALL loader_glVertex3fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex3fv, "glVertex3fv");
   if ( !driverTbl.glVertex3fv ) {
      driverTbl.glVertex3fv = missing_glVertex3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex3fv == loader_glVertex3fv) {
      rCtx->dsp->emuTbl.glVertex3fv = driverTbl.glVertex3fv;
   }
   driverTbl.glVertex3fv(v);
}

static void REGAL_CALL missing_glVertex3i(GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertex3i not available." );
}

static void REGAL_CALL loader_glVertex3i(GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex3i, "glVertex3i");
   if ( !driverTbl.glVertex3i ) {
      driverTbl.glVertex3i = missing_glVertex3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex3i == loader_glVertex3i) {
      rCtx->dsp->emuTbl.glVertex3i = driverTbl.glVertex3i;
   }
   driverTbl.glVertex3i(x, y, z);
}

static void REGAL_CALL missing_glVertex3iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex3iv not available." );
}

static void REGAL_CALL loader_glVertex3iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex3iv, "glVertex3iv");
   if ( !driverTbl.glVertex3iv ) {
      driverTbl.glVertex3iv = missing_glVertex3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex3iv == loader_glVertex3iv) {
      rCtx->dsp->emuTbl.glVertex3iv = driverTbl.glVertex3iv;
   }
   driverTbl.glVertex3iv(v);
}

static void REGAL_CALL missing_glVertex3s(GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertex3s not available." );
}

static void REGAL_CALL loader_glVertex3s(GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex3s, "glVertex3s");
   if ( !driverTbl.glVertex3s ) {
      driverTbl.glVertex3s = missing_glVertex3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex3s == loader_glVertex3s) {
      rCtx->dsp->emuTbl.glVertex3s = driverTbl.glVertex3s;
   }
   driverTbl.glVertex3s(x, y, z);
}

static void REGAL_CALL missing_glVertex3sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex3sv not available." );
}

static void REGAL_CALL loader_glVertex3sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex3sv, "glVertex3sv");
   if ( !driverTbl.glVertex3sv ) {
      driverTbl.glVertex3sv = missing_glVertex3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex3sv == loader_glVertex3sv) {
      rCtx->dsp->emuTbl.glVertex3sv = driverTbl.glVertex3sv;
   }
   driverTbl.glVertex3sv(v);
}

static void REGAL_CALL missing_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertex4d not available." );
}

static void REGAL_CALL loader_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex4d, "glVertex4d");
   if ( !driverTbl.glVertex4d ) {
      driverTbl.glVertex4d = missing_glVertex4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex4d == loader_glVertex4d) {
      rCtx->dsp->emuTbl.glVertex4d = driverTbl.glVertex4d;
   }
   driverTbl.glVertex4d(x, y, z, w);
}

static void REGAL_CALL missing_glVertex4dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex4dv not available." );
}

static void REGAL_CALL loader_glVertex4dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex4dv, "glVertex4dv");
   if ( !driverTbl.glVertex4dv ) {
      driverTbl.glVertex4dv = missing_glVertex4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex4dv == loader_glVertex4dv) {
      rCtx->dsp->emuTbl.glVertex4dv = driverTbl.glVertex4dv;
   }
   driverTbl.glVertex4dv(v);
}

static void REGAL_CALL missing_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertex4f not available." );
}

static void REGAL_CALL loader_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex4f, "glVertex4f");
   if ( !driverTbl.glVertex4f ) {
      driverTbl.glVertex4f = missing_glVertex4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex4f == loader_glVertex4f) {
      rCtx->dsp->emuTbl.glVertex4f = driverTbl.glVertex4f;
   }
   driverTbl.glVertex4f(x, y, z, w);
}

static void REGAL_CALL missing_glVertex4fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex4fv not available." );
}

static void REGAL_CALL loader_glVertex4fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex4fv, "glVertex4fv");
   if ( !driverTbl.glVertex4fv ) {
      driverTbl.glVertex4fv = missing_glVertex4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex4fv == loader_glVertex4fv) {
      rCtx->dsp->emuTbl.glVertex4fv = driverTbl.glVertex4fv;
   }
   driverTbl.glVertex4fv(v);
}

static void REGAL_CALL missing_glVertex4i(GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertex4i not available." );
}

static void REGAL_CALL loader_glVertex4i(GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex4i, "glVertex4i");
   if ( !driverTbl.glVertex4i ) {
      driverTbl.glVertex4i = missing_glVertex4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex4i == loader_glVertex4i) {
      rCtx->dsp->emuTbl.glVertex4i = driverTbl.glVertex4i;
   }
   driverTbl.glVertex4i(x, y, z, w);
}

static void REGAL_CALL missing_glVertex4iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex4iv not available." );
}

static void REGAL_CALL loader_glVertex4iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex4iv, "glVertex4iv");
   if ( !driverTbl.glVertex4iv ) {
      driverTbl.glVertex4iv = missing_glVertex4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex4iv == loader_glVertex4iv) {
      rCtx->dsp->emuTbl.glVertex4iv = driverTbl.glVertex4iv;
   }
   driverTbl.glVertex4iv(v);
}

static void REGAL_CALL missing_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertex4s not available." );
}

static void REGAL_CALL loader_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex4s, "glVertex4s");
   if ( !driverTbl.glVertex4s ) {
      driverTbl.glVertex4s = missing_glVertex4s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex4s == loader_glVertex4s) {
      rCtx->dsp->emuTbl.glVertex4s = driverTbl.glVertex4s;
   }
   driverTbl.glVertex4s(x, y, z, w);
}

static void REGAL_CALL missing_glVertex4sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex4sv not available." );
}

static void REGAL_CALL loader_glVertex4sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex4sv, "glVertex4sv");
   if ( !driverTbl.glVertex4sv ) {
      driverTbl.glVertex4sv = missing_glVertex4sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex4sv == loader_glVertex4sv) {
      rCtx->dsp->emuTbl.glVertex4sv = driverTbl.glVertex4sv;
   }
   driverTbl.glVertex4sv(v);
}

static void REGAL_CALL missing_glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glViewport not available." );
}

static void REGAL_CALL loader_glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glViewport, "glViewport");
   if ( !driverTbl.glViewport ) {
      driverTbl.glViewport = missing_glViewport;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glViewport == loader_glViewport) {
      rCtx->dsp->emuTbl.glViewport = driverTbl.glViewport;
   }
   driverTbl.glViewport(x, y, width, height);
}

// GL_VERSION_1_1

static GLboolean REGAL_CALL missing_glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   UNUSED_PARAMETER(residences);
   Warning( "glAreTexturesResident not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glAreTexturesResident, "glAreTexturesResident");
   if ( !driverTbl.glAreTexturesResident ) {
      driverTbl.glAreTexturesResident = missing_glAreTexturesResident;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glAreTexturesResident == loader_glAreTexturesResident) {
      rCtx->dsp->emuTbl.glAreTexturesResident = driverTbl.glAreTexturesResident;
   }
   return driverTbl.glAreTexturesResident(n, textures, residences);
}

static void REGAL_CALL missing_glArrayElement(GLint index)
{
   UNUSED_PARAMETER(index);
   Warning( "glArrayElement not available." );
}

static void REGAL_CALL loader_glArrayElement(GLint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glArrayElement, "glArrayElement");
   if ( !driverTbl.glArrayElement ) {
      driverTbl.glArrayElement = missing_glArrayElement;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glArrayElement == loader_glArrayElement) {
      rCtx->dsp->emuTbl.glArrayElement = driverTbl.glArrayElement;
   }
   driverTbl.glArrayElement(index);
}

static void REGAL_CALL missing_glBindTexture(GLenum target, GLuint texture)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(texture);
   Warning( "glBindTexture not available." );
}

static void REGAL_CALL loader_glBindTexture(GLenum target, GLuint texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindTexture, "glBindTexture");
   if ( !driverTbl.glBindTexture ) {
      driverTbl.glBindTexture = missing_glBindTexture;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindTexture == loader_glBindTexture) {
      rCtx->dsp->emuTbl.glBindTexture = driverTbl.glBindTexture;
   }
   driverTbl.glBindTexture(target, texture);
}

static void REGAL_CALL missing_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glColorPointer not available." );
}

static void REGAL_CALL loader_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorPointer, "glColorPointer");
   if ( !driverTbl.glColorPointer ) {
      driverTbl.glColorPointer = missing_glColorPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorPointer == loader_glColorPointer) {
      rCtx->dsp->emuTbl.glColorPointer = driverTbl.glColorPointer;
   }
   driverTbl.glColorPointer(size, type, stride, pointer);
}

static void REGAL_CALL missing_glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   Warning( "glCopyTexImage1D not available." );
}

static void REGAL_CALL loader_glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTexImage1D, "glCopyTexImage1D");
   if ( !driverTbl.glCopyTexImage1D ) {
      driverTbl.glCopyTexImage1D = missing_glCopyTexImage1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTexImage1D == loader_glCopyTexImage1D) {
      rCtx->dsp->emuTbl.glCopyTexImage1D = driverTbl.glCopyTexImage1D;
   }
   driverTbl.glCopyTexImage1D(target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL missing_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   Warning( "glCopyTexImage2D not available." );
}

static void REGAL_CALL loader_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTexImage2D, "glCopyTexImage2D");
   if ( !driverTbl.glCopyTexImage2D ) {
      driverTbl.glCopyTexImage2D = missing_glCopyTexImage2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTexImage2D == loader_glCopyTexImage2D) {
      rCtx->dsp->emuTbl.glCopyTexImage2D = driverTbl.glCopyTexImage2D;
   }
   driverTbl.glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL missing_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "glCopyTexSubImage1D not available." );
}

static void REGAL_CALL loader_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTexSubImage1D, "glCopyTexSubImage1D");
   if ( !driverTbl.glCopyTexSubImage1D ) {
      driverTbl.glCopyTexSubImage1D = missing_glCopyTexSubImage1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTexSubImage1D == loader_glCopyTexSubImage1D) {
      rCtx->dsp->emuTbl.glCopyTexSubImage1D = driverTbl.glCopyTexSubImage1D;
   }
   driverTbl.glCopyTexSubImage1D(target, level, xoffset, x, y, width);
}

static void REGAL_CALL missing_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glCopyTexSubImage2D not available." );
}

static void REGAL_CALL loader_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTexSubImage2D, "glCopyTexSubImage2D");
   if ( !driverTbl.glCopyTexSubImage2D ) {
      driverTbl.glCopyTexSubImage2D = missing_glCopyTexSubImage2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTexSubImage2D == loader_glCopyTexSubImage2D) {
      rCtx->dsp->emuTbl.glCopyTexSubImage2D = driverTbl.glCopyTexSubImage2D;
   }
   driverTbl.glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL missing_glDeleteTextures(GLsizei n, const GLuint *textures)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   Warning( "glDeleteTextures not available." );
}

static void REGAL_CALL loader_glDeleteTextures(GLsizei n, const GLuint *textures)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteTextures, "glDeleteTextures");
   if ( !driverTbl.glDeleteTextures ) {
      driverTbl.glDeleteTextures = missing_glDeleteTextures;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteTextures == loader_glDeleteTextures) {
      rCtx->dsp->emuTbl.glDeleteTextures = driverTbl.glDeleteTextures;
   }
   driverTbl.glDeleteTextures(n, textures);
}

static void REGAL_CALL missing_glDisableClientState(GLenum cap)
{
   UNUSED_PARAMETER(cap);
   Warning( "glDisableClientState not available." );
}

static void REGAL_CALL loader_glDisableClientState(GLenum cap)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDisableClientState, "glDisableClientState");
   if ( !driverTbl.glDisableClientState ) {
      driverTbl.glDisableClientState = missing_glDisableClientState;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDisableClientState == loader_glDisableClientState) {
      rCtx->dsp->emuTbl.glDisableClientState = driverTbl.glDisableClientState;
   }
   driverTbl.glDisableClientState(cap);
}

static void REGAL_CALL missing_glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   Warning( "glDrawArrays not available." );
}

static void REGAL_CALL loader_glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawArrays, "glDrawArrays");
   if ( !driverTbl.glDrawArrays ) {
      driverTbl.glDrawArrays = missing_glDrawArrays;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawArrays == loader_glDrawArrays) {
      rCtx->dsp->emuTbl.glDrawArrays = driverTbl.glDrawArrays;
   }
   driverTbl.glDrawArrays(mode, first, count);
}

static void REGAL_CALL missing_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   Warning( "glDrawElements not available." );
}

static void REGAL_CALL loader_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawElements, "glDrawElements");
   if ( !driverTbl.glDrawElements ) {
      driverTbl.glDrawElements = missing_glDrawElements;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawElements == loader_glDrawElements) {
      rCtx->dsp->emuTbl.glDrawElements = driverTbl.glDrawElements;
   }
   driverTbl.glDrawElements(mode, count, type, indices);
}

static void REGAL_CALL missing_glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glEdgeFlagPointer not available." );
}

static void REGAL_CALL loader_glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEdgeFlagPointer, "glEdgeFlagPointer");
   if ( !driverTbl.glEdgeFlagPointer ) {
      driverTbl.glEdgeFlagPointer = missing_glEdgeFlagPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEdgeFlagPointer == loader_glEdgeFlagPointer) {
      rCtx->dsp->emuTbl.glEdgeFlagPointer = driverTbl.glEdgeFlagPointer;
   }
   driverTbl.glEdgeFlagPointer(stride, pointer);
}

static void REGAL_CALL missing_glEnableClientState(GLenum cap)
{
   UNUSED_PARAMETER(cap);
   Warning( "glEnableClientState not available." );
}

static void REGAL_CALL loader_glEnableClientState(GLenum cap)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEnableClientState, "glEnableClientState");
   if ( !driverTbl.glEnableClientState ) {
      driverTbl.glEnableClientState = missing_glEnableClientState;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEnableClientState == loader_glEnableClientState) {
      rCtx->dsp->emuTbl.glEnableClientState = driverTbl.glEnableClientState;
   }
   driverTbl.glEnableClientState(cap);
}

static void REGAL_CALL missing_glGenTextures(GLsizei n, GLuint *textures)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   Warning( "glGenTextures not available." );
}

static void REGAL_CALL loader_glGenTextures(GLsizei n, GLuint *textures)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenTextures, "glGenTextures");
   if ( !driverTbl.glGenTextures ) {
      driverTbl.glGenTextures = missing_glGenTextures;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenTextures == loader_glGenTextures) {
      rCtx->dsp->emuTbl.glGenTextures = driverTbl.glGenTextures;
   }
   driverTbl.glGenTextures(n, textures);
}

static void REGAL_CALL missing_glGetPointerv(GLenum pname, GLvoid **params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetPointerv not available." );
}

static void REGAL_CALL loader_glGetPointerv(GLenum pname, GLvoid **params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPointerv, "glGetPointerv");
   if ( !driverTbl.glGetPointerv ) {
      driverTbl.glGetPointerv = missing_glGetPointerv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPointerv == loader_glGetPointerv) {
      rCtx->dsp->emuTbl.glGetPointerv = driverTbl.glGetPointerv;
   }
   driverTbl.glGetPointerv(pname, params);
}

static void REGAL_CALL missing_glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glIndexPointer not available." );
}

static void REGAL_CALL loader_glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexPointer, "glIndexPointer");
   if ( !driverTbl.glIndexPointer ) {
      driverTbl.glIndexPointer = missing_glIndexPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexPointer == loader_glIndexPointer) {
      rCtx->dsp->emuTbl.glIndexPointer = driverTbl.glIndexPointer;
   }
   driverTbl.glIndexPointer(type, stride, pointer);
}

static void REGAL_CALL missing_glIndexub(GLubyte c)
{
   UNUSED_PARAMETER(c);
   Warning( "glIndexub not available." );
}

static void REGAL_CALL loader_glIndexub(GLubyte c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexub, "glIndexub");
   if ( !driverTbl.glIndexub ) {
      driverTbl.glIndexub = missing_glIndexub;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexub == loader_glIndexub) {
      rCtx->dsp->emuTbl.glIndexub = driverTbl.glIndexub;
   }
   driverTbl.glIndexub(c);
}

static void REGAL_CALL missing_glIndexubv(const GLubyte *c)
{
   UNUSED_PARAMETER(c);
   Warning( "glIndexubv not available." );
}

static void REGAL_CALL loader_glIndexubv(const GLubyte *c)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexubv, "glIndexubv");
   if ( !driverTbl.glIndexubv ) {
      driverTbl.glIndexubv = missing_glIndexubv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexubv == loader_glIndexubv) {
      rCtx->dsp->emuTbl.glIndexubv = driverTbl.glIndexubv;
   }
   driverTbl.glIndexubv(c);
}

static void REGAL_CALL missing_glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glInterleavedArrays not available." );
}

static void REGAL_CALL loader_glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glInterleavedArrays, "glInterleavedArrays");
   if ( !driverTbl.glInterleavedArrays ) {
      driverTbl.glInterleavedArrays = missing_glInterleavedArrays;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glInterleavedArrays == loader_glInterleavedArrays) {
      rCtx->dsp->emuTbl.glInterleavedArrays = driverTbl.glInterleavedArrays;
   }
   driverTbl.glInterleavedArrays(format, stride, pointer);
}

static GLboolean REGAL_CALL missing_glIsTexture(GLuint texture)
{
   UNUSED_PARAMETER(texture);
   Warning( "glIsTexture not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsTexture(GLuint texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsTexture, "glIsTexture");
   if ( !driverTbl.glIsTexture ) {
      driverTbl.glIsTexture = missing_glIsTexture;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsTexture == loader_glIsTexture) {
      rCtx->dsp->emuTbl.glIsTexture = driverTbl.glIsTexture;
   }
   return driverTbl.glIsTexture(texture);
}

static void REGAL_CALL missing_glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glNormalPointer not available." );
}

static void REGAL_CALL loader_glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalPointer, "glNormalPointer");
   if ( !driverTbl.glNormalPointer ) {
      driverTbl.glNormalPointer = missing_glNormalPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalPointer == loader_glNormalPointer) {
      rCtx->dsp->emuTbl.glNormalPointer = driverTbl.glNormalPointer;
   }
   driverTbl.glNormalPointer(type, stride, pointer);
}

static void REGAL_CALL missing_glPolygonOffset(GLfloat factor, GLfloat units)
{
   UNUSED_PARAMETER(factor);
   UNUSED_PARAMETER(units);
   Warning( "glPolygonOffset not available." );
}

static void REGAL_CALL loader_glPolygonOffset(GLfloat factor, GLfloat units)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPolygonOffset, "glPolygonOffset");
   if ( !driverTbl.glPolygonOffset ) {
      driverTbl.glPolygonOffset = missing_glPolygonOffset;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPolygonOffset == loader_glPolygonOffset) {
      rCtx->dsp->emuTbl.glPolygonOffset = driverTbl.glPolygonOffset;
   }
   driverTbl.glPolygonOffset(factor, units);
}

static void REGAL_CALL missing_glPopClientAttrib(void)
{
   Warning( "glPopClientAttrib not available." );
}

static void REGAL_CALL loader_glPopClientAttrib(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPopClientAttrib, "glPopClientAttrib");
   if ( !driverTbl.glPopClientAttrib ) {
      driverTbl.glPopClientAttrib = missing_glPopClientAttrib;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPopClientAttrib == loader_glPopClientAttrib) {
      rCtx->dsp->emuTbl.glPopClientAttrib = driverTbl.glPopClientAttrib;
   }
   driverTbl.glPopClientAttrib();
}

static void REGAL_CALL missing_glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   UNUSED_PARAMETER(priorities);
   Warning( "glPrioritizeTextures not available." );
}

static void REGAL_CALL loader_glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPrioritizeTextures, "glPrioritizeTextures");
   if ( !driverTbl.glPrioritizeTextures ) {
      driverTbl.glPrioritizeTextures = missing_glPrioritizeTextures;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPrioritizeTextures == loader_glPrioritizeTextures) {
      rCtx->dsp->emuTbl.glPrioritizeTextures = driverTbl.glPrioritizeTextures;
   }
   driverTbl.glPrioritizeTextures(n, textures, priorities);
}

static void REGAL_CALL missing_glPushClientAttrib(GLbitfield mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "glPushClientAttrib not available." );
}

static void REGAL_CALL loader_glPushClientAttrib(GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPushClientAttrib, "glPushClientAttrib");
   if ( !driverTbl.glPushClientAttrib ) {
      driverTbl.glPushClientAttrib = missing_glPushClientAttrib;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPushClientAttrib == loader_glPushClientAttrib) {
      rCtx->dsp->emuTbl.glPushClientAttrib = driverTbl.glPushClientAttrib;
   }
   driverTbl.glPushClientAttrib(mask);
}

static void REGAL_CALL missing_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glTexCoordPointer not available." );
}

static void REGAL_CALL loader_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoordPointer, "glTexCoordPointer");
   if ( !driverTbl.glTexCoordPointer ) {
      driverTbl.glTexCoordPointer = missing_glTexCoordPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoordPointer == loader_glTexCoordPointer) {
      rCtx->dsp->emuTbl.glTexCoordPointer = driverTbl.glTexCoordPointer;
   }
   driverTbl.glTexCoordPointer(size, type, stride, pointer);
}

static void REGAL_CALL missing_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTexSubImage1D not available." );
}

static void REGAL_CALL loader_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexSubImage1D, "glTexSubImage1D");
   if ( !driverTbl.glTexSubImage1D ) {
      driverTbl.glTexSubImage1D = missing_glTexSubImage1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexSubImage1D == loader_glTexSubImage1D) {
      rCtx->dsp->emuTbl.glTexSubImage1D = driverTbl.glTexSubImage1D;
   }
   driverTbl.glTexSubImage1D(target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL missing_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTexSubImage2D not available." );
}

static void REGAL_CALL loader_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexSubImage2D, "glTexSubImage2D");
   if ( !driverTbl.glTexSubImage2D ) {
      driverTbl.glTexSubImage2D = missing_glTexSubImage2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexSubImage2D == loader_glTexSubImage2D) {
      rCtx->dsp->emuTbl.glTexSubImage2D = driverTbl.glTexSubImage2D;
   }
   driverTbl.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL missing_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glVertexPointer not available." );
}

static void REGAL_CALL loader_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexPointer, "glVertexPointer");
   if ( !driverTbl.glVertexPointer ) {
      driverTbl.glVertexPointer = missing_glVertexPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexPointer == loader_glVertexPointer) {
      rCtx->dsp->emuTbl.glVertexPointer = driverTbl.glVertexPointer;
   }
   driverTbl.glVertexPointer(size, type, stride, pointer);
}

// GL_VERSION_1_2

static void REGAL_CALL missing_glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glBlendColor not available." );
}

static void REGAL_CALL loader_glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendColor, "glBlendColor");
   if ( !driverTbl.glBlendColor ) {
      driverTbl.glBlendColor = missing_glBlendColor;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendColor == loader_glBlendColor) {
      rCtx->dsp->emuTbl.glBlendColor = driverTbl.glBlendColor;
   }
   driverTbl.glBlendColor(red, green, blue, alpha);
}

static void REGAL_CALL missing_glBlendEquation(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glBlendEquation not available." );
}

static void REGAL_CALL loader_glBlendEquation(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendEquation, "glBlendEquation");
   if ( !driverTbl.glBlendEquation ) {
      driverTbl.glBlendEquation = missing_glBlendEquation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendEquation == loader_glBlendEquation) {
      rCtx->dsp->emuTbl.glBlendEquation = driverTbl.glBlendEquation;
   }
   driverTbl.glBlendEquation(mode);
}

static void REGAL_CALL missing_glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glCopyTexSubImage3D not available." );
}

static void REGAL_CALL loader_glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTexSubImage3D, "glCopyTexSubImage3D");
   if ( !driverTbl.glCopyTexSubImage3D ) {
      driverTbl.glCopyTexSubImage3D = missing_glCopyTexSubImage3D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTexSubImage3D == loader_glCopyTexSubImage3D) {
      rCtx->dsp->emuTbl.glCopyTexSubImage3D = driverTbl.glCopyTexSubImage3D;
   }
   driverTbl.glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

static void REGAL_CALL missing_glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(end);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   Warning( "glDrawRangeElements not available." );
}

static void REGAL_CALL loader_glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawRangeElements, "glDrawRangeElements");
   if ( !driverTbl.glDrawRangeElements ) {
      driverTbl.glDrawRangeElements = missing_glDrawRangeElements;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawRangeElements == loader_glDrawRangeElements) {
      rCtx->dsp->emuTbl.glDrawRangeElements = driverTbl.glDrawRangeElements;
   }
   driverTbl.glDrawRangeElements(mode, start, end, count, type, indices);
}

static void REGAL_CALL missing_glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTexImage3D not available." );
}

static void REGAL_CALL loader_glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexImage3D, "glTexImage3D");
   if ( !driverTbl.glTexImage3D ) {
      driverTbl.glTexImage3D = missing_glTexImage3D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexImage3D == loader_glTexImage3D) {
      rCtx->dsp->emuTbl.glTexImage3D = driverTbl.glTexImage3D;
   }
   driverTbl.glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

static void REGAL_CALL missing_glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTexSubImage3D not available." );
}

static void REGAL_CALL loader_glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexSubImage3D, "glTexSubImage3D");
   if ( !driverTbl.glTexSubImage3D ) {
      driverTbl.glTexSubImage3D = missing_glTexSubImage3D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexSubImage3D == loader_glTexSubImage3D) {
      rCtx->dsp->emuTbl.glTexSubImage3D = driverTbl.glTexSubImage3D;
   }
   driverTbl.glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

// GL_VERSION_1_3

static void REGAL_CALL missing_glActiveTexture(GLenum texture)
{
   UNUSED_PARAMETER(texture);
   Warning( "glActiveTexture not available." );
}

static void REGAL_CALL loader_glActiveTexture(GLenum texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glActiveTexture, "glActiveTexture");
   if ( !driverTbl.glActiveTexture ) {
      driverTbl.glActiveTexture = missing_glActiveTexture;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glActiveTexture == loader_glActiveTexture) {
      rCtx->dsp->emuTbl.glActiveTexture = driverTbl.glActiveTexture;
   }
   driverTbl.glActiveTexture(texture);
}

static void REGAL_CALL missing_glClientActiveTexture(GLenum texture)
{
   UNUSED_PARAMETER(texture);
   Warning( "glClientActiveTexture not available." );
}

static void REGAL_CALL loader_glClientActiveTexture(GLenum texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClientActiveTexture, "glClientActiveTexture");
   if ( !driverTbl.glClientActiveTexture ) {
      driverTbl.glClientActiveTexture = missing_glClientActiveTexture;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClientActiveTexture == loader_glClientActiveTexture) {
      rCtx->dsp->emuTbl.glClientActiveTexture = driverTbl.glClientActiveTexture;
   }
   driverTbl.glClientActiveTexture(texture);
}

static void REGAL_CALL missing_glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedTexImage1D not available." );
}

static void REGAL_CALL loader_glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTexImage1D, "glCompressedTexImage1D");
   if ( !driverTbl.glCompressedTexImage1D ) {
      driverTbl.glCompressedTexImage1D = missing_glCompressedTexImage1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTexImage1D == loader_glCompressedTexImage1D) {
      rCtx->dsp->emuTbl.glCompressedTexImage1D = driverTbl.glCompressedTexImage1D;
   }
   driverTbl.glCompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedTexImage2D not available." );
}

static void REGAL_CALL loader_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTexImage2D, "glCompressedTexImage2D");
   if ( !driverTbl.glCompressedTexImage2D ) {
      driverTbl.glCompressedTexImage2D = missing_glCompressedTexImage2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTexImage2D == loader_glCompressedTexImage2D) {
      rCtx->dsp->emuTbl.glCompressedTexImage2D = driverTbl.glCompressedTexImage2D;
   }
   driverTbl.glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedTexImage3D not available." );
}

static void REGAL_CALL loader_glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTexImage3D, "glCompressedTexImage3D");
   if ( !driverTbl.glCompressedTexImage3D ) {
      driverTbl.glCompressedTexImage3D = missing_glCompressedTexImage3D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTexImage3D == loader_glCompressedTexImage3D) {
      rCtx->dsp->emuTbl.glCompressedTexImage3D = driverTbl.glCompressedTexImage3D;
   }
   driverTbl.glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedTexSubImage1D not available." );
}

static void REGAL_CALL loader_glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTexSubImage1D, "glCompressedTexSubImage1D");
   if ( !driverTbl.glCompressedTexSubImage1D ) {
      driverTbl.glCompressedTexSubImage1D = missing_glCompressedTexSubImage1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTexSubImage1D == loader_glCompressedTexSubImage1D) {
      rCtx->dsp->emuTbl.glCompressedTexSubImage1D = driverTbl.glCompressedTexSubImage1D;
   }
   driverTbl.glCompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedTexSubImage2D not available." );
}

static void REGAL_CALL loader_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTexSubImage2D, "glCompressedTexSubImage2D");
   if ( !driverTbl.glCompressedTexSubImage2D ) {
      driverTbl.glCompressedTexSubImage2D = missing_glCompressedTexSubImage2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTexSubImage2D == loader_glCompressedTexSubImage2D) {
      rCtx->dsp->emuTbl.glCompressedTexSubImage2D = driverTbl.glCompressedTexSubImage2D;
   }
   driverTbl.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedTexSubImage3D not available." );
}

static void REGAL_CALL loader_glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTexSubImage3D, "glCompressedTexSubImage3D");
   if ( !driverTbl.glCompressedTexSubImage3D ) {
      driverTbl.glCompressedTexSubImage3D = missing_glCompressedTexSubImage3D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTexSubImage3D == loader_glCompressedTexSubImage3D) {
      rCtx->dsp->emuTbl.glCompressedTexSubImage3D = driverTbl.glCompressedTexSubImage3D;
   }
   driverTbl.glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

static void REGAL_CALL missing_glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(lod);
   UNUSED_PARAMETER(img);
   Warning( "glGetCompressedTexImage not available." );
}

static void REGAL_CALL loader_glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetCompressedTexImage, "glGetCompressedTexImage");
   if ( !driverTbl.glGetCompressedTexImage ) {
      driverTbl.glGetCompressedTexImage = missing_glGetCompressedTexImage;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetCompressedTexImage == loader_glGetCompressedTexImage) {
      rCtx->dsp->emuTbl.glGetCompressedTexImage = driverTbl.glGetCompressedTexImage;
   }
   driverTbl.glGetCompressedTexImage(target, lod, img);
}

static void REGAL_CALL missing_glLoadTransposeMatrixd(const GLdouble *m)
{
   UNUSED_PARAMETER(m);
   Warning( "glLoadTransposeMatrixd not available." );
}

static void REGAL_CALL loader_glLoadTransposeMatrixd(const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLoadTransposeMatrixd, "glLoadTransposeMatrixd");
   if ( !driverTbl.glLoadTransposeMatrixd ) {
      driverTbl.glLoadTransposeMatrixd = missing_glLoadTransposeMatrixd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLoadTransposeMatrixd == loader_glLoadTransposeMatrixd) {
      rCtx->dsp->emuTbl.glLoadTransposeMatrixd = driverTbl.glLoadTransposeMatrixd;
   }
   driverTbl.glLoadTransposeMatrixd(m);
}

static void REGAL_CALL missing_glLoadTransposeMatrixf(const GLfloat *m)
{
   UNUSED_PARAMETER(m);
   Warning( "glLoadTransposeMatrixf not available." );
}

static void REGAL_CALL loader_glLoadTransposeMatrixf(const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLoadTransposeMatrixf, "glLoadTransposeMatrixf");
   if ( !driverTbl.glLoadTransposeMatrixf ) {
      driverTbl.glLoadTransposeMatrixf = missing_glLoadTransposeMatrixf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLoadTransposeMatrixf == loader_glLoadTransposeMatrixf) {
      rCtx->dsp->emuTbl.glLoadTransposeMatrixf = driverTbl.glLoadTransposeMatrixf;
   }
   driverTbl.glLoadTransposeMatrixf(m);
}

static void REGAL_CALL missing_glMultTransposeMatrixd(const GLdouble *m)
{
   UNUSED_PARAMETER(m);
   Warning( "glMultTransposeMatrixd not available." );
}

static void REGAL_CALL loader_glMultTransposeMatrixd(const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultTransposeMatrixd, "glMultTransposeMatrixd");
   if ( !driverTbl.glMultTransposeMatrixd ) {
      driverTbl.glMultTransposeMatrixd = missing_glMultTransposeMatrixd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultTransposeMatrixd == loader_glMultTransposeMatrixd) {
      rCtx->dsp->emuTbl.glMultTransposeMatrixd = driverTbl.glMultTransposeMatrixd;
   }
   driverTbl.glMultTransposeMatrixd(m);
}

static void REGAL_CALL missing_glMultTransposeMatrixf(const GLfloat *m)
{
   UNUSED_PARAMETER(m);
   Warning( "glMultTransposeMatrixf not available." );
}

static void REGAL_CALL loader_glMultTransposeMatrixf(const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultTransposeMatrixf, "glMultTransposeMatrixf");
   if ( !driverTbl.glMultTransposeMatrixf ) {
      driverTbl.glMultTransposeMatrixf = missing_glMultTransposeMatrixf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultTransposeMatrixf == loader_glMultTransposeMatrixf) {
      rCtx->dsp->emuTbl.glMultTransposeMatrixf = driverTbl.glMultTransposeMatrixf;
   }
   driverTbl.glMultTransposeMatrixf(m);
}

static void REGAL_CALL missing_glMultiTexCoord1d(GLenum target, GLdouble s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "glMultiTexCoord1d not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1d(GLenum target, GLdouble s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1d, "glMultiTexCoord1d");
   if ( !driverTbl.glMultiTexCoord1d ) {
      driverTbl.glMultiTexCoord1d = missing_glMultiTexCoord1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1d == loader_glMultiTexCoord1d) {
      rCtx->dsp->emuTbl.glMultiTexCoord1d = driverTbl.glMultiTexCoord1d;
   }
   driverTbl.glMultiTexCoord1d(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1dv(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord1dv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1dv(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1dv, "glMultiTexCoord1dv");
   if ( !driverTbl.glMultiTexCoord1dv ) {
      driverTbl.glMultiTexCoord1dv = missing_glMultiTexCoord1dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1dv == loader_glMultiTexCoord1dv) {
      rCtx->dsp->emuTbl.glMultiTexCoord1dv = driverTbl.glMultiTexCoord1dv;
   }
   driverTbl.glMultiTexCoord1dv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord1f(GLenum target, GLfloat s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "glMultiTexCoord1f not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1f(GLenum target, GLfloat s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1f, "glMultiTexCoord1f");
   if ( !driverTbl.glMultiTexCoord1f ) {
      driverTbl.glMultiTexCoord1f = missing_glMultiTexCoord1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1f == loader_glMultiTexCoord1f) {
      rCtx->dsp->emuTbl.glMultiTexCoord1f = driverTbl.glMultiTexCoord1f;
   }
   driverTbl.glMultiTexCoord1f(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1fv(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord1fv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1fv(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1fv, "glMultiTexCoord1fv");
   if ( !driverTbl.glMultiTexCoord1fv ) {
      driverTbl.glMultiTexCoord1fv = missing_glMultiTexCoord1fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1fv == loader_glMultiTexCoord1fv) {
      rCtx->dsp->emuTbl.glMultiTexCoord1fv = driverTbl.glMultiTexCoord1fv;
   }
   driverTbl.glMultiTexCoord1fv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord1i(GLenum target, GLint s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "glMultiTexCoord1i not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1i(GLenum target, GLint s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1i, "glMultiTexCoord1i");
   if ( !driverTbl.glMultiTexCoord1i ) {
      driverTbl.glMultiTexCoord1i = missing_glMultiTexCoord1i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1i == loader_glMultiTexCoord1i) {
      rCtx->dsp->emuTbl.glMultiTexCoord1i = driverTbl.glMultiTexCoord1i;
   }
   driverTbl.glMultiTexCoord1i(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1iv(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord1iv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1iv(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1iv, "glMultiTexCoord1iv");
   if ( !driverTbl.glMultiTexCoord1iv ) {
      driverTbl.glMultiTexCoord1iv = missing_glMultiTexCoord1iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1iv == loader_glMultiTexCoord1iv) {
      rCtx->dsp->emuTbl.glMultiTexCoord1iv = driverTbl.glMultiTexCoord1iv;
   }
   driverTbl.glMultiTexCoord1iv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord1s(GLenum target, GLshort s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "glMultiTexCoord1s not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1s(GLenum target, GLshort s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1s, "glMultiTexCoord1s");
   if ( !driverTbl.glMultiTexCoord1s ) {
      driverTbl.glMultiTexCoord1s = missing_glMultiTexCoord1s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1s == loader_glMultiTexCoord1s) {
      rCtx->dsp->emuTbl.glMultiTexCoord1s = driverTbl.glMultiTexCoord1s;
   }
   driverTbl.glMultiTexCoord1s(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1sv(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord1sv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1sv(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1sv, "glMultiTexCoord1sv");
   if ( !driverTbl.glMultiTexCoord1sv ) {
      driverTbl.glMultiTexCoord1sv = missing_glMultiTexCoord1sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1sv == loader_glMultiTexCoord1sv) {
      rCtx->dsp->emuTbl.glMultiTexCoord1sv = driverTbl.glMultiTexCoord1sv;
   }
   driverTbl.glMultiTexCoord1sv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "glMultiTexCoord2d not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2d, "glMultiTexCoord2d");
   if ( !driverTbl.glMultiTexCoord2d ) {
      driverTbl.glMultiTexCoord2d = missing_glMultiTexCoord2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2d == loader_glMultiTexCoord2d) {
      rCtx->dsp->emuTbl.glMultiTexCoord2d = driverTbl.glMultiTexCoord2d;
   }
   driverTbl.glMultiTexCoord2d(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2dv(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord2dv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2dv(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2dv, "glMultiTexCoord2dv");
   if ( !driverTbl.glMultiTexCoord2dv ) {
      driverTbl.glMultiTexCoord2dv = missing_glMultiTexCoord2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2dv == loader_glMultiTexCoord2dv) {
      rCtx->dsp->emuTbl.glMultiTexCoord2dv = driverTbl.glMultiTexCoord2dv;
   }
   driverTbl.glMultiTexCoord2dv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "glMultiTexCoord2f not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2f, "glMultiTexCoord2f");
   if ( !driverTbl.glMultiTexCoord2f ) {
      driverTbl.glMultiTexCoord2f = missing_glMultiTexCoord2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2f == loader_glMultiTexCoord2f) {
      rCtx->dsp->emuTbl.glMultiTexCoord2f = driverTbl.glMultiTexCoord2f;
   }
   driverTbl.glMultiTexCoord2f(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2fv(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord2fv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2fv(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2fv, "glMultiTexCoord2fv");
   if ( !driverTbl.glMultiTexCoord2fv ) {
      driverTbl.glMultiTexCoord2fv = missing_glMultiTexCoord2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2fv == loader_glMultiTexCoord2fv) {
      rCtx->dsp->emuTbl.glMultiTexCoord2fv = driverTbl.glMultiTexCoord2fv;
   }
   driverTbl.glMultiTexCoord2fv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2i(GLenum target, GLint s, GLint t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "glMultiTexCoord2i not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2i(GLenum target, GLint s, GLint t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2i, "glMultiTexCoord2i");
   if ( !driverTbl.glMultiTexCoord2i ) {
      driverTbl.glMultiTexCoord2i = missing_glMultiTexCoord2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2i == loader_glMultiTexCoord2i) {
      rCtx->dsp->emuTbl.glMultiTexCoord2i = driverTbl.glMultiTexCoord2i;
   }
   driverTbl.glMultiTexCoord2i(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2iv(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord2iv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2iv(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2iv, "glMultiTexCoord2iv");
   if ( !driverTbl.glMultiTexCoord2iv ) {
      driverTbl.glMultiTexCoord2iv = missing_glMultiTexCoord2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2iv == loader_glMultiTexCoord2iv) {
      rCtx->dsp->emuTbl.glMultiTexCoord2iv = driverTbl.glMultiTexCoord2iv;
   }
   driverTbl.glMultiTexCoord2iv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "glMultiTexCoord2s not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2s, "glMultiTexCoord2s");
   if ( !driverTbl.glMultiTexCoord2s ) {
      driverTbl.glMultiTexCoord2s = missing_glMultiTexCoord2s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2s == loader_glMultiTexCoord2s) {
      rCtx->dsp->emuTbl.glMultiTexCoord2s = driverTbl.glMultiTexCoord2s;
   }
   driverTbl.glMultiTexCoord2s(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2sv(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord2sv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2sv(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2sv, "glMultiTexCoord2sv");
   if ( !driverTbl.glMultiTexCoord2sv ) {
      driverTbl.glMultiTexCoord2sv = missing_glMultiTexCoord2sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2sv == loader_glMultiTexCoord2sv) {
      rCtx->dsp->emuTbl.glMultiTexCoord2sv = driverTbl.glMultiTexCoord2sv;
   }
   driverTbl.glMultiTexCoord2sv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "glMultiTexCoord3d not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3d, "glMultiTexCoord3d");
   if ( !driverTbl.glMultiTexCoord3d ) {
      driverTbl.glMultiTexCoord3d = missing_glMultiTexCoord3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3d == loader_glMultiTexCoord3d) {
      rCtx->dsp->emuTbl.glMultiTexCoord3d = driverTbl.glMultiTexCoord3d;
   }
   driverTbl.glMultiTexCoord3d(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3dv(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord3dv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3dv(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3dv, "glMultiTexCoord3dv");
   if ( !driverTbl.glMultiTexCoord3dv ) {
      driverTbl.glMultiTexCoord3dv = missing_glMultiTexCoord3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3dv == loader_glMultiTexCoord3dv) {
      rCtx->dsp->emuTbl.glMultiTexCoord3dv = driverTbl.glMultiTexCoord3dv;
   }
   driverTbl.glMultiTexCoord3dv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "glMultiTexCoord3f not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3f, "glMultiTexCoord3f");
   if ( !driverTbl.glMultiTexCoord3f ) {
      driverTbl.glMultiTexCoord3f = missing_glMultiTexCoord3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3f == loader_glMultiTexCoord3f) {
      rCtx->dsp->emuTbl.glMultiTexCoord3f = driverTbl.glMultiTexCoord3f;
   }
   driverTbl.glMultiTexCoord3f(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3fv(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord3fv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3fv(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3fv, "glMultiTexCoord3fv");
   if ( !driverTbl.glMultiTexCoord3fv ) {
      driverTbl.glMultiTexCoord3fv = missing_glMultiTexCoord3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3fv == loader_glMultiTexCoord3fv) {
      rCtx->dsp->emuTbl.glMultiTexCoord3fv = driverTbl.glMultiTexCoord3fv;
   }
   driverTbl.glMultiTexCoord3fv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "glMultiTexCoord3i not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3i, "glMultiTexCoord3i");
   if ( !driverTbl.glMultiTexCoord3i ) {
      driverTbl.glMultiTexCoord3i = missing_glMultiTexCoord3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3i == loader_glMultiTexCoord3i) {
      rCtx->dsp->emuTbl.glMultiTexCoord3i = driverTbl.glMultiTexCoord3i;
   }
   driverTbl.glMultiTexCoord3i(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3iv(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord3iv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3iv(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3iv, "glMultiTexCoord3iv");
   if ( !driverTbl.glMultiTexCoord3iv ) {
      driverTbl.glMultiTexCoord3iv = missing_glMultiTexCoord3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3iv == loader_glMultiTexCoord3iv) {
      rCtx->dsp->emuTbl.glMultiTexCoord3iv = driverTbl.glMultiTexCoord3iv;
   }
   driverTbl.glMultiTexCoord3iv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "glMultiTexCoord3s not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3s, "glMultiTexCoord3s");
   if ( !driverTbl.glMultiTexCoord3s ) {
      driverTbl.glMultiTexCoord3s = missing_glMultiTexCoord3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3s == loader_glMultiTexCoord3s) {
      rCtx->dsp->emuTbl.glMultiTexCoord3s = driverTbl.glMultiTexCoord3s;
   }
   driverTbl.glMultiTexCoord3s(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3sv(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord3sv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3sv(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3sv, "glMultiTexCoord3sv");
   if ( !driverTbl.glMultiTexCoord3sv ) {
      driverTbl.glMultiTexCoord3sv = missing_glMultiTexCoord3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3sv == loader_glMultiTexCoord3sv) {
      rCtx->dsp->emuTbl.glMultiTexCoord3sv = driverTbl.glMultiTexCoord3sv;
   }
   driverTbl.glMultiTexCoord3sv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "glMultiTexCoord4d not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4d, "glMultiTexCoord4d");
   if ( !driverTbl.glMultiTexCoord4d ) {
      driverTbl.glMultiTexCoord4d = missing_glMultiTexCoord4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4d == loader_glMultiTexCoord4d) {
      rCtx->dsp->emuTbl.glMultiTexCoord4d = driverTbl.glMultiTexCoord4d;
   }
   driverTbl.glMultiTexCoord4d(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4dv(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord4dv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4dv(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4dv, "glMultiTexCoord4dv");
   if ( !driverTbl.glMultiTexCoord4dv ) {
      driverTbl.glMultiTexCoord4dv = missing_glMultiTexCoord4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4dv == loader_glMultiTexCoord4dv) {
      rCtx->dsp->emuTbl.glMultiTexCoord4dv = driverTbl.glMultiTexCoord4dv;
   }
   driverTbl.glMultiTexCoord4dv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "glMultiTexCoord4f not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4f, "glMultiTexCoord4f");
   if ( !driverTbl.glMultiTexCoord4f ) {
      driverTbl.glMultiTexCoord4f = missing_glMultiTexCoord4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4f == loader_glMultiTexCoord4f) {
      rCtx->dsp->emuTbl.glMultiTexCoord4f = driverTbl.glMultiTexCoord4f;
   }
   driverTbl.glMultiTexCoord4f(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4fv(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord4fv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4fv(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4fv, "glMultiTexCoord4fv");
   if ( !driverTbl.glMultiTexCoord4fv ) {
      driverTbl.glMultiTexCoord4fv = missing_glMultiTexCoord4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4fv == loader_glMultiTexCoord4fv) {
      rCtx->dsp->emuTbl.glMultiTexCoord4fv = driverTbl.glMultiTexCoord4fv;
   }
   driverTbl.glMultiTexCoord4fv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "glMultiTexCoord4i not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4i, "glMultiTexCoord4i");
   if ( !driverTbl.glMultiTexCoord4i ) {
      driverTbl.glMultiTexCoord4i = missing_glMultiTexCoord4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4i == loader_glMultiTexCoord4i) {
      rCtx->dsp->emuTbl.glMultiTexCoord4i = driverTbl.glMultiTexCoord4i;
   }
   driverTbl.glMultiTexCoord4i(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4iv(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord4iv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4iv(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4iv, "glMultiTexCoord4iv");
   if ( !driverTbl.glMultiTexCoord4iv ) {
      driverTbl.glMultiTexCoord4iv = missing_glMultiTexCoord4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4iv == loader_glMultiTexCoord4iv) {
      rCtx->dsp->emuTbl.glMultiTexCoord4iv = driverTbl.glMultiTexCoord4iv;
   }
   driverTbl.glMultiTexCoord4iv(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "glMultiTexCoord4s not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4s, "glMultiTexCoord4s");
   if ( !driverTbl.glMultiTexCoord4s ) {
      driverTbl.glMultiTexCoord4s = missing_glMultiTexCoord4s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4s == loader_glMultiTexCoord4s) {
      rCtx->dsp->emuTbl.glMultiTexCoord4s = driverTbl.glMultiTexCoord4s;
   }
   driverTbl.glMultiTexCoord4s(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4sv(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord4sv not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4sv(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4sv, "glMultiTexCoord4sv");
   if ( !driverTbl.glMultiTexCoord4sv ) {
      driverTbl.glMultiTexCoord4sv = missing_glMultiTexCoord4sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4sv == loader_glMultiTexCoord4sv) {
      rCtx->dsp->emuTbl.glMultiTexCoord4sv = driverTbl.glMultiTexCoord4sv;
   }
   driverTbl.glMultiTexCoord4sv(target, v);
}

static void REGAL_CALL missing_glSampleCoverage(GLclampf value, GLboolean invert)
{
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(invert);
   Warning( "glSampleCoverage not available." );
}

static void REGAL_CALL loader_glSampleCoverage(GLclampf value, GLboolean invert)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSampleCoverage, "glSampleCoverage");
   if ( !driverTbl.glSampleCoverage ) {
      driverTbl.glSampleCoverage = missing_glSampleCoverage;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSampleCoverage == loader_glSampleCoverage) {
      rCtx->dsp->emuTbl.glSampleCoverage = driverTbl.glSampleCoverage;
   }
   driverTbl.glSampleCoverage(value, invert);
}

// GL_VERSION_1_4

static void REGAL_CALL missing_glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
   UNUSED_PARAMETER(sfactorRGB);
   UNUSED_PARAMETER(dfactorRGB);
   UNUSED_PARAMETER(sfactorAlpha);
   UNUSED_PARAMETER(dfactorAlpha);
   Warning( "glBlendFuncSeparate not available." );
}

static void REGAL_CALL loader_glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendFuncSeparate, "glBlendFuncSeparate");
   if ( !driverTbl.glBlendFuncSeparate ) {
      driverTbl.glBlendFuncSeparate = missing_glBlendFuncSeparate;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendFuncSeparate == loader_glBlendFuncSeparate) {
      rCtx->dsp->emuTbl.glBlendFuncSeparate = driverTbl.glBlendFuncSeparate;
   }
   driverTbl.glBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

static void REGAL_CALL missing_glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glFogCoordPointer not available." );
}

static void REGAL_CALL loader_glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogCoordPointer, "glFogCoordPointer");
   if ( !driverTbl.glFogCoordPointer ) {
      driverTbl.glFogCoordPointer = missing_glFogCoordPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogCoordPointer == loader_glFogCoordPointer) {
      rCtx->dsp->emuTbl.glFogCoordPointer = driverTbl.glFogCoordPointer;
   }
   driverTbl.glFogCoordPointer(type, stride, pointer);
}

static void REGAL_CALL missing_glFogCoordd(GLdouble coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "glFogCoordd not available." );
}

static void REGAL_CALL loader_glFogCoordd(GLdouble coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogCoordd, "glFogCoordd");
   if ( !driverTbl.glFogCoordd ) {
      driverTbl.glFogCoordd = missing_glFogCoordd;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogCoordd == loader_glFogCoordd) {
      rCtx->dsp->emuTbl.glFogCoordd = driverTbl.glFogCoordd;
   }
   driverTbl.glFogCoordd(coord);
}

static void REGAL_CALL missing_glFogCoorddv(const GLdouble *coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "glFogCoorddv not available." );
}

static void REGAL_CALL loader_glFogCoorddv(const GLdouble *coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogCoorddv, "glFogCoorddv");
   if ( !driverTbl.glFogCoorddv ) {
      driverTbl.glFogCoorddv = missing_glFogCoorddv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogCoorddv == loader_glFogCoorddv) {
      rCtx->dsp->emuTbl.glFogCoorddv = driverTbl.glFogCoorddv;
   }
   driverTbl.glFogCoorddv(coord);
}

static void REGAL_CALL missing_glFogCoordf(GLfloat coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "glFogCoordf not available." );
}

static void REGAL_CALL loader_glFogCoordf(GLfloat coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogCoordf, "glFogCoordf");
   if ( !driverTbl.glFogCoordf ) {
      driverTbl.glFogCoordf = missing_glFogCoordf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogCoordf == loader_glFogCoordf) {
      rCtx->dsp->emuTbl.glFogCoordf = driverTbl.glFogCoordf;
   }
   driverTbl.glFogCoordf(coord);
}

static void REGAL_CALL missing_glFogCoordfv(const GLfloat *coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "glFogCoordfv not available." );
}

static void REGAL_CALL loader_glFogCoordfv(const GLfloat *coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogCoordfv, "glFogCoordfv");
   if ( !driverTbl.glFogCoordfv ) {
      driverTbl.glFogCoordfv = missing_glFogCoordfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogCoordfv == loader_glFogCoordfv) {
      rCtx->dsp->emuTbl.glFogCoordfv = driverTbl.glFogCoordfv;
   }
   driverTbl.glFogCoordfv(coord);
}

static void REGAL_CALL missing_glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   Warning( "glMultiDrawArrays not available." );
}

static void REGAL_CALL loader_glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiDrawArrays, "glMultiDrawArrays");
   if ( !driverTbl.glMultiDrawArrays ) {
      driverTbl.glMultiDrawArrays = missing_glMultiDrawArrays;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiDrawArrays == loader_glMultiDrawArrays) {
      rCtx->dsp->emuTbl.glMultiDrawArrays = driverTbl.glMultiDrawArrays;
   }
   driverTbl.glMultiDrawArrays(mode, first, count, primcount);
}

static void REGAL_CALL missing_glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   Warning( "glMultiDrawElements not available." );
}

static void REGAL_CALL loader_glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiDrawElements, "glMultiDrawElements");
   if ( !driverTbl.glMultiDrawElements ) {
      driverTbl.glMultiDrawElements = missing_glMultiDrawElements;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiDrawElements == loader_glMultiDrawElements) {
      rCtx->dsp->emuTbl.glMultiDrawElements = driverTbl.glMultiDrawElements;
   }
   driverTbl.glMultiDrawElements(mode, count, type, indices, primcount);
}

static void REGAL_CALL missing_glPointParameterf(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPointParameterf not available." );
}

static void REGAL_CALL loader_glPointParameterf(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPointParameterf, "glPointParameterf");
   if ( !driverTbl.glPointParameterf ) {
      driverTbl.glPointParameterf = missing_glPointParameterf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPointParameterf == loader_glPointParameterf) {
      rCtx->dsp->emuTbl.glPointParameterf = driverTbl.glPointParameterf;
   }
   driverTbl.glPointParameterf(pname, param);
}

static void REGAL_CALL missing_glPointParameterfv(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glPointParameterfv not available." );
}

static void REGAL_CALL loader_glPointParameterfv(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPointParameterfv, "glPointParameterfv");
   if ( !driverTbl.glPointParameterfv ) {
      driverTbl.glPointParameterfv = missing_glPointParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPointParameterfv == loader_glPointParameterfv) {
      rCtx->dsp->emuTbl.glPointParameterfv = driverTbl.glPointParameterfv;
   }
   driverTbl.glPointParameterfv(pname, params);
}

static void REGAL_CALL missing_glPointParameteri(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPointParameteri not available." );
}

static void REGAL_CALL loader_glPointParameteri(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPointParameteri, "glPointParameteri");
   if ( !driverTbl.glPointParameteri ) {
      driverTbl.glPointParameteri = missing_glPointParameteri;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPointParameteri == loader_glPointParameteri) {
      rCtx->dsp->emuTbl.glPointParameteri = driverTbl.glPointParameteri;
   }
   driverTbl.glPointParameteri(pname, param);
}

static void REGAL_CALL missing_glPointParameteriv(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glPointParameteriv not available." );
}

static void REGAL_CALL loader_glPointParameteriv(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPointParameteriv, "glPointParameteriv");
   if ( !driverTbl.glPointParameteriv ) {
      driverTbl.glPointParameteriv = missing_glPointParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPointParameteriv == loader_glPointParameteriv) {
      rCtx->dsp->emuTbl.glPointParameteriv = driverTbl.glPointParameteriv;
   }
   driverTbl.glPointParameteriv(pname, params);
}

static void REGAL_CALL missing_glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3b not available." );
}

static void REGAL_CALL loader_glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3b, "glSecondaryColor3b");
   if ( !driverTbl.glSecondaryColor3b ) {
      driverTbl.glSecondaryColor3b = missing_glSecondaryColor3b;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3b == loader_glSecondaryColor3b) {
      rCtx->dsp->emuTbl.glSecondaryColor3b = driverTbl.glSecondaryColor3b;
   }
   driverTbl.glSecondaryColor3b(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3bv(const GLbyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3bv not available." );
}

static void REGAL_CALL loader_glSecondaryColor3bv(const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3bv, "glSecondaryColor3bv");
   if ( !driverTbl.glSecondaryColor3bv ) {
      driverTbl.glSecondaryColor3bv = missing_glSecondaryColor3bv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3bv == loader_glSecondaryColor3bv) {
      rCtx->dsp->emuTbl.glSecondaryColor3bv = driverTbl.glSecondaryColor3bv;
   }
   driverTbl.glSecondaryColor3bv(v);
}

static void REGAL_CALL missing_glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3d not available." );
}

static void REGAL_CALL loader_glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3d, "glSecondaryColor3d");
   if ( !driverTbl.glSecondaryColor3d ) {
      driverTbl.glSecondaryColor3d = missing_glSecondaryColor3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3d == loader_glSecondaryColor3d) {
      rCtx->dsp->emuTbl.glSecondaryColor3d = driverTbl.glSecondaryColor3d;
   }
   driverTbl.glSecondaryColor3d(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3dv(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3dv not available." );
}

static void REGAL_CALL loader_glSecondaryColor3dv(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3dv, "glSecondaryColor3dv");
   if ( !driverTbl.glSecondaryColor3dv ) {
      driverTbl.glSecondaryColor3dv = missing_glSecondaryColor3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3dv == loader_glSecondaryColor3dv) {
      rCtx->dsp->emuTbl.glSecondaryColor3dv = driverTbl.glSecondaryColor3dv;
   }
   driverTbl.glSecondaryColor3dv(v);
}

static void REGAL_CALL missing_glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3f not available." );
}

static void REGAL_CALL loader_glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3f, "glSecondaryColor3f");
   if ( !driverTbl.glSecondaryColor3f ) {
      driverTbl.glSecondaryColor3f = missing_glSecondaryColor3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3f == loader_glSecondaryColor3f) {
      rCtx->dsp->emuTbl.glSecondaryColor3f = driverTbl.glSecondaryColor3f;
   }
   driverTbl.glSecondaryColor3f(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3fv(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3fv not available." );
}

static void REGAL_CALL loader_glSecondaryColor3fv(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3fv, "glSecondaryColor3fv");
   if ( !driverTbl.glSecondaryColor3fv ) {
      driverTbl.glSecondaryColor3fv = missing_glSecondaryColor3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3fv == loader_glSecondaryColor3fv) {
      rCtx->dsp->emuTbl.glSecondaryColor3fv = driverTbl.glSecondaryColor3fv;
   }
   driverTbl.glSecondaryColor3fv(v);
}

static void REGAL_CALL missing_glSecondaryColor3i(GLint red, GLint green, GLint blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3i not available." );
}

static void REGAL_CALL loader_glSecondaryColor3i(GLint red, GLint green, GLint blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3i, "glSecondaryColor3i");
   if ( !driverTbl.glSecondaryColor3i ) {
      driverTbl.glSecondaryColor3i = missing_glSecondaryColor3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3i == loader_glSecondaryColor3i) {
      rCtx->dsp->emuTbl.glSecondaryColor3i = driverTbl.glSecondaryColor3i;
   }
   driverTbl.glSecondaryColor3i(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3iv(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3iv not available." );
}

static void REGAL_CALL loader_glSecondaryColor3iv(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3iv, "glSecondaryColor3iv");
   if ( !driverTbl.glSecondaryColor3iv ) {
      driverTbl.glSecondaryColor3iv = missing_glSecondaryColor3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3iv == loader_glSecondaryColor3iv) {
      rCtx->dsp->emuTbl.glSecondaryColor3iv = driverTbl.glSecondaryColor3iv;
   }
   driverTbl.glSecondaryColor3iv(v);
}

static void REGAL_CALL missing_glSecondaryColor3s(GLshort red, GLshort green, GLshort blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3s not available." );
}

static void REGAL_CALL loader_glSecondaryColor3s(GLshort red, GLshort green, GLshort blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3s, "glSecondaryColor3s");
   if ( !driverTbl.glSecondaryColor3s ) {
      driverTbl.glSecondaryColor3s = missing_glSecondaryColor3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3s == loader_glSecondaryColor3s) {
      rCtx->dsp->emuTbl.glSecondaryColor3s = driverTbl.glSecondaryColor3s;
   }
   driverTbl.glSecondaryColor3s(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3sv(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3sv not available." );
}

static void REGAL_CALL loader_glSecondaryColor3sv(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3sv, "glSecondaryColor3sv");
   if ( !driverTbl.glSecondaryColor3sv ) {
      driverTbl.glSecondaryColor3sv = missing_glSecondaryColor3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3sv == loader_glSecondaryColor3sv) {
      rCtx->dsp->emuTbl.glSecondaryColor3sv = driverTbl.glSecondaryColor3sv;
   }
   driverTbl.glSecondaryColor3sv(v);
}

static void REGAL_CALL missing_glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3ub not available." );
}

static void REGAL_CALL loader_glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3ub, "glSecondaryColor3ub");
   if ( !driverTbl.glSecondaryColor3ub ) {
      driverTbl.glSecondaryColor3ub = missing_glSecondaryColor3ub;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3ub == loader_glSecondaryColor3ub) {
      rCtx->dsp->emuTbl.glSecondaryColor3ub = driverTbl.glSecondaryColor3ub;
   }
   driverTbl.glSecondaryColor3ub(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3ubv(const GLubyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3ubv not available." );
}

static void REGAL_CALL loader_glSecondaryColor3ubv(const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3ubv, "glSecondaryColor3ubv");
   if ( !driverTbl.glSecondaryColor3ubv ) {
      driverTbl.glSecondaryColor3ubv = missing_glSecondaryColor3ubv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3ubv == loader_glSecondaryColor3ubv) {
      rCtx->dsp->emuTbl.glSecondaryColor3ubv = driverTbl.glSecondaryColor3ubv;
   }
   driverTbl.glSecondaryColor3ubv(v);
}

static void REGAL_CALL missing_glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3ui not available." );
}

static void REGAL_CALL loader_glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3ui, "glSecondaryColor3ui");
   if ( !driverTbl.glSecondaryColor3ui ) {
      driverTbl.glSecondaryColor3ui = missing_glSecondaryColor3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3ui == loader_glSecondaryColor3ui) {
      rCtx->dsp->emuTbl.glSecondaryColor3ui = driverTbl.glSecondaryColor3ui;
   }
   driverTbl.glSecondaryColor3ui(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3uiv(const GLuint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3uiv not available." );
}

static void REGAL_CALL loader_glSecondaryColor3uiv(const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3uiv, "glSecondaryColor3uiv");
   if ( !driverTbl.glSecondaryColor3uiv ) {
      driverTbl.glSecondaryColor3uiv = missing_glSecondaryColor3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3uiv == loader_glSecondaryColor3uiv) {
      rCtx->dsp->emuTbl.glSecondaryColor3uiv = driverTbl.glSecondaryColor3uiv;
   }
   driverTbl.glSecondaryColor3uiv(v);
}

static void REGAL_CALL missing_glSecondaryColor3us(GLushort red, GLushort green, GLushort blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3us not available." );
}

static void REGAL_CALL loader_glSecondaryColor3us(GLushort red, GLushort green, GLushort blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3us, "glSecondaryColor3us");
   if ( !driverTbl.glSecondaryColor3us ) {
      driverTbl.glSecondaryColor3us = missing_glSecondaryColor3us;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3us == loader_glSecondaryColor3us) {
      rCtx->dsp->emuTbl.glSecondaryColor3us = driverTbl.glSecondaryColor3us;
   }
   driverTbl.glSecondaryColor3us(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3usv(const GLushort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3usv not available." );
}

static void REGAL_CALL loader_glSecondaryColor3usv(const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3usv, "glSecondaryColor3usv");
   if ( !driverTbl.glSecondaryColor3usv ) {
      driverTbl.glSecondaryColor3usv = missing_glSecondaryColor3usv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3usv == loader_glSecondaryColor3usv) {
      rCtx->dsp->emuTbl.glSecondaryColor3usv = driverTbl.glSecondaryColor3usv;
   }
   driverTbl.glSecondaryColor3usv(v);
}

static void REGAL_CALL missing_glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glSecondaryColorPointer not available." );
}

static void REGAL_CALL loader_glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColorPointer, "glSecondaryColorPointer");
   if ( !driverTbl.glSecondaryColorPointer ) {
      driverTbl.glSecondaryColorPointer = missing_glSecondaryColorPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColorPointer == loader_glSecondaryColorPointer) {
      rCtx->dsp->emuTbl.glSecondaryColorPointer = driverTbl.glSecondaryColorPointer;
   }
   driverTbl.glSecondaryColorPointer(size, type, stride, pointer);
}

static void REGAL_CALL missing_glWindowPos2d(GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glWindowPos2d not available." );
}

static void REGAL_CALL loader_glWindowPos2d(GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2d, "glWindowPos2d");
   if ( !driverTbl.glWindowPos2d ) {
      driverTbl.glWindowPos2d = missing_glWindowPos2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2d == loader_glWindowPos2d) {
      rCtx->dsp->emuTbl.glWindowPos2d = driverTbl.glWindowPos2d;
   }
   driverTbl.glWindowPos2d(x, y);
}

static void REGAL_CALL missing_glWindowPos2dv(const GLdouble *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos2dv not available." );
}

static void REGAL_CALL loader_glWindowPos2dv(const GLdouble *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2dv, "glWindowPos2dv");
   if ( !driverTbl.glWindowPos2dv ) {
      driverTbl.glWindowPos2dv = missing_glWindowPos2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2dv == loader_glWindowPos2dv) {
      rCtx->dsp->emuTbl.glWindowPos2dv = driverTbl.glWindowPos2dv;
   }
   driverTbl.glWindowPos2dv(p);
}

static void REGAL_CALL missing_glWindowPos2f(GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glWindowPos2f not available." );
}

static void REGAL_CALL loader_glWindowPos2f(GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2f, "glWindowPos2f");
   if ( !driverTbl.glWindowPos2f ) {
      driverTbl.glWindowPos2f = missing_glWindowPos2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2f == loader_glWindowPos2f) {
      rCtx->dsp->emuTbl.glWindowPos2f = driverTbl.glWindowPos2f;
   }
   driverTbl.glWindowPos2f(x, y);
}

static void REGAL_CALL missing_glWindowPos2fv(const GLfloat *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos2fv not available." );
}

static void REGAL_CALL loader_glWindowPos2fv(const GLfloat *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2fv, "glWindowPos2fv");
   if ( !driverTbl.glWindowPos2fv ) {
      driverTbl.glWindowPos2fv = missing_glWindowPos2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2fv == loader_glWindowPos2fv) {
      rCtx->dsp->emuTbl.glWindowPos2fv = driverTbl.glWindowPos2fv;
   }
   driverTbl.glWindowPos2fv(p);
}

static void REGAL_CALL missing_glWindowPos2i(GLint x, GLint y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glWindowPos2i not available." );
}

static void REGAL_CALL loader_glWindowPos2i(GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2i, "glWindowPos2i");
   if ( !driverTbl.glWindowPos2i ) {
      driverTbl.glWindowPos2i = missing_glWindowPos2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2i == loader_glWindowPos2i) {
      rCtx->dsp->emuTbl.glWindowPos2i = driverTbl.glWindowPos2i;
   }
   driverTbl.glWindowPos2i(x, y);
}

static void REGAL_CALL missing_glWindowPos2iv(const GLint *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos2iv not available." );
}

static void REGAL_CALL loader_glWindowPos2iv(const GLint *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2iv, "glWindowPos2iv");
   if ( !driverTbl.glWindowPos2iv ) {
      driverTbl.glWindowPos2iv = missing_glWindowPos2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2iv == loader_glWindowPos2iv) {
      rCtx->dsp->emuTbl.glWindowPos2iv = driverTbl.glWindowPos2iv;
   }
   driverTbl.glWindowPos2iv(p);
}

static void REGAL_CALL missing_glWindowPos2s(GLshort x, GLshort y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glWindowPos2s not available." );
}

static void REGAL_CALL loader_glWindowPos2s(GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2s, "glWindowPos2s");
   if ( !driverTbl.glWindowPos2s ) {
      driverTbl.glWindowPos2s = missing_glWindowPos2s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2s == loader_glWindowPos2s) {
      rCtx->dsp->emuTbl.glWindowPos2s = driverTbl.glWindowPos2s;
   }
   driverTbl.glWindowPos2s(x, y);
}

static void REGAL_CALL missing_glWindowPos2sv(const GLshort *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos2sv not available." );
}

static void REGAL_CALL loader_glWindowPos2sv(const GLshort *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2sv, "glWindowPos2sv");
   if ( !driverTbl.glWindowPos2sv ) {
      driverTbl.glWindowPos2sv = missing_glWindowPos2sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2sv == loader_glWindowPos2sv) {
      rCtx->dsp->emuTbl.glWindowPos2sv = driverTbl.glWindowPos2sv;
   }
   driverTbl.glWindowPos2sv(p);
}

static void REGAL_CALL missing_glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glWindowPos3d not available." );
}

static void REGAL_CALL loader_glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3d, "glWindowPos3d");
   if ( !driverTbl.glWindowPos3d ) {
      driverTbl.glWindowPos3d = missing_glWindowPos3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3d == loader_glWindowPos3d) {
      rCtx->dsp->emuTbl.glWindowPos3d = driverTbl.glWindowPos3d;
   }
   driverTbl.glWindowPos3d(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3dv(const GLdouble *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos3dv not available." );
}

static void REGAL_CALL loader_glWindowPos3dv(const GLdouble *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3dv, "glWindowPos3dv");
   if ( !driverTbl.glWindowPos3dv ) {
      driverTbl.glWindowPos3dv = missing_glWindowPos3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3dv == loader_glWindowPos3dv) {
      rCtx->dsp->emuTbl.glWindowPos3dv = driverTbl.glWindowPos3dv;
   }
   driverTbl.glWindowPos3dv(p);
}

static void REGAL_CALL missing_glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glWindowPos3f not available." );
}

static void REGAL_CALL loader_glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3f, "glWindowPos3f");
   if ( !driverTbl.glWindowPos3f ) {
      driverTbl.glWindowPos3f = missing_glWindowPos3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3f == loader_glWindowPos3f) {
      rCtx->dsp->emuTbl.glWindowPos3f = driverTbl.glWindowPos3f;
   }
   driverTbl.glWindowPos3f(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3fv(const GLfloat *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos3fv not available." );
}

static void REGAL_CALL loader_glWindowPos3fv(const GLfloat *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3fv, "glWindowPos3fv");
   if ( !driverTbl.glWindowPos3fv ) {
      driverTbl.glWindowPos3fv = missing_glWindowPos3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3fv == loader_glWindowPos3fv) {
      rCtx->dsp->emuTbl.glWindowPos3fv = driverTbl.glWindowPos3fv;
   }
   driverTbl.glWindowPos3fv(p);
}

static void REGAL_CALL missing_glWindowPos3i(GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glWindowPos3i not available." );
}

static void REGAL_CALL loader_glWindowPos3i(GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3i, "glWindowPos3i");
   if ( !driverTbl.glWindowPos3i ) {
      driverTbl.glWindowPos3i = missing_glWindowPos3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3i == loader_glWindowPos3i) {
      rCtx->dsp->emuTbl.glWindowPos3i = driverTbl.glWindowPos3i;
   }
   driverTbl.glWindowPos3i(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3iv(const GLint *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos3iv not available." );
}

static void REGAL_CALL loader_glWindowPos3iv(const GLint *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3iv, "glWindowPos3iv");
   if ( !driverTbl.glWindowPos3iv ) {
      driverTbl.glWindowPos3iv = missing_glWindowPos3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3iv == loader_glWindowPos3iv) {
      rCtx->dsp->emuTbl.glWindowPos3iv = driverTbl.glWindowPos3iv;
   }
   driverTbl.glWindowPos3iv(p);
}

static void REGAL_CALL missing_glWindowPos3s(GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glWindowPos3s not available." );
}

static void REGAL_CALL loader_glWindowPos3s(GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3s, "glWindowPos3s");
   if ( !driverTbl.glWindowPos3s ) {
      driverTbl.glWindowPos3s = missing_glWindowPos3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3s == loader_glWindowPos3s) {
      rCtx->dsp->emuTbl.glWindowPos3s = driverTbl.glWindowPos3s;
   }
   driverTbl.glWindowPos3s(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3sv(const GLshort *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos3sv not available." );
}

static void REGAL_CALL loader_glWindowPos3sv(const GLshort *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3sv, "glWindowPos3sv");
   if ( !driverTbl.glWindowPos3sv ) {
      driverTbl.glWindowPos3sv = missing_glWindowPos3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3sv == loader_glWindowPos3sv) {
      rCtx->dsp->emuTbl.glWindowPos3sv = driverTbl.glWindowPos3sv;
   }
   driverTbl.glWindowPos3sv(p);
}

// GL_VERSION_1_5

static void REGAL_CALL missing_glBeginQuery(GLenum target, GLuint id)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(id);
   Warning( "glBeginQuery not available." );
}

static void REGAL_CALL loader_glBeginQuery(GLenum target, GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBeginQuery, "glBeginQuery");
   if ( !driverTbl.glBeginQuery ) {
      driverTbl.glBeginQuery = missing_glBeginQuery;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBeginQuery == loader_glBeginQuery) {
      rCtx->dsp->emuTbl.glBeginQuery = driverTbl.glBeginQuery;
   }
   driverTbl.glBeginQuery(target, id);
}

static void REGAL_CALL missing_glBindBuffer(GLenum target, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(buffer);
   Warning( "glBindBuffer not available." );
}

static void REGAL_CALL loader_glBindBuffer(GLenum target, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindBuffer, "glBindBuffer");
   if ( !driverTbl.glBindBuffer ) {
      driverTbl.glBindBuffer = missing_glBindBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindBuffer == loader_glBindBuffer) {
      rCtx->dsp->emuTbl.glBindBuffer = driverTbl.glBindBuffer;
   }
   driverTbl.glBindBuffer(target, buffer);
}

static void REGAL_CALL missing_glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   UNUSED_PARAMETER(usage);
   Warning( "glBufferData not available." );
}

static void REGAL_CALL loader_glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBufferData, "glBufferData");
   if ( !driverTbl.glBufferData ) {
      driverTbl.glBufferData = missing_glBufferData;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBufferData == loader_glBufferData) {
      rCtx->dsp->emuTbl.glBufferData = driverTbl.glBufferData;
   }
   driverTbl.glBufferData(target, size, data, usage);
}

static void REGAL_CALL missing_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   Warning( "glBufferSubData not available." );
}

static void REGAL_CALL loader_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBufferSubData, "glBufferSubData");
   if ( !driverTbl.glBufferSubData ) {
      driverTbl.glBufferSubData = missing_glBufferSubData;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBufferSubData == loader_glBufferSubData) {
      rCtx->dsp->emuTbl.glBufferSubData = driverTbl.glBufferSubData;
   }
   driverTbl.glBufferSubData(target, offset, size, data);
}

static void REGAL_CALL missing_glDeleteBuffers(GLsizei n, const GLuint *buffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(buffers);
   Warning( "glDeleteBuffers not available." );
}

static void REGAL_CALL loader_glDeleteBuffers(GLsizei n, const GLuint *buffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteBuffers, "glDeleteBuffers");
   if ( !driverTbl.glDeleteBuffers ) {
      driverTbl.glDeleteBuffers = missing_glDeleteBuffers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteBuffers == loader_glDeleteBuffers) {
      rCtx->dsp->emuTbl.glDeleteBuffers = driverTbl.glDeleteBuffers;
   }
   driverTbl.glDeleteBuffers(n, buffers);
}

static void REGAL_CALL missing_glDeleteQueries(GLsizei n, const GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "glDeleteQueries not available." );
}

static void REGAL_CALL loader_glDeleteQueries(GLsizei n, const GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteQueries, "glDeleteQueries");
   if ( !driverTbl.glDeleteQueries ) {
      driverTbl.glDeleteQueries = missing_glDeleteQueries;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteQueries == loader_glDeleteQueries) {
      rCtx->dsp->emuTbl.glDeleteQueries = driverTbl.glDeleteQueries;
   }
   driverTbl.glDeleteQueries(n, ids);
}

static void REGAL_CALL missing_glEndQuery(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glEndQuery not available." );
}

static void REGAL_CALL loader_glEndQuery(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndQuery, "glEndQuery");
   if ( !driverTbl.glEndQuery ) {
      driverTbl.glEndQuery = missing_glEndQuery;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndQuery == loader_glEndQuery) {
      rCtx->dsp->emuTbl.glEndQuery = driverTbl.glEndQuery;
   }
   driverTbl.glEndQuery(target);
}

static void REGAL_CALL missing_glGenBuffers(GLsizei n, GLuint *buffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(buffers);
   Warning( "glGenBuffers not available." );
}

static void REGAL_CALL loader_glGenBuffers(GLsizei n, GLuint *buffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenBuffers, "glGenBuffers");
   if ( !driverTbl.glGenBuffers ) {
      driverTbl.glGenBuffers = missing_glGenBuffers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenBuffers == loader_glGenBuffers) {
      rCtx->dsp->emuTbl.glGenBuffers = driverTbl.glGenBuffers;
   }
   driverTbl.glGenBuffers(n, buffers);
}

static void REGAL_CALL missing_glGenQueries(GLsizei n, GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "glGenQueries not available." );
}

static void REGAL_CALL loader_glGenQueries(GLsizei n, GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenQueries, "glGenQueries");
   if ( !driverTbl.glGenQueries ) {
      driverTbl.glGenQueries = missing_glGenQueries;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenQueries == loader_glGenQueries) {
      rCtx->dsp->emuTbl.glGenQueries = driverTbl.glGenQueries;
   }
   driverTbl.glGenQueries(n, ids);
}

static void REGAL_CALL missing_glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetBufferParameteriv not available." );
}

static void REGAL_CALL loader_glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetBufferParameteriv, "glGetBufferParameteriv");
   if ( !driverTbl.glGetBufferParameteriv ) {
      driverTbl.glGetBufferParameteriv = missing_glGetBufferParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetBufferParameteriv == loader_glGetBufferParameteriv) {
      rCtx->dsp->emuTbl.glGetBufferParameteriv = driverTbl.glGetBufferParameteriv;
   }
   driverTbl.glGetBufferParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glGetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetBufferPointerv not available." );
}

static void REGAL_CALL loader_glGetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetBufferPointerv, "glGetBufferPointerv");
   if ( !driverTbl.glGetBufferPointerv ) {
      driverTbl.glGetBufferPointerv = missing_glGetBufferPointerv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetBufferPointerv == loader_glGetBufferPointerv) {
      rCtx->dsp->emuTbl.glGetBufferPointerv = driverTbl.glGetBufferPointerv;
   }
   driverTbl.glGetBufferPointerv(target, pname, params);
}

static void REGAL_CALL missing_glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   Warning( "glGetBufferSubData not available." );
}

static void REGAL_CALL loader_glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetBufferSubData, "glGetBufferSubData");
   if ( !driverTbl.glGetBufferSubData ) {
      driverTbl.glGetBufferSubData = missing_glGetBufferSubData;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetBufferSubData == loader_glGetBufferSubData) {
      rCtx->dsp->emuTbl.glGetBufferSubData = driverTbl.glGetBufferSubData;
   }
   driverTbl.glGetBufferSubData(target, offset, size, data);
}

static void REGAL_CALL missing_glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetQueryObjectiv not available." );
}

static void REGAL_CALL loader_glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetQueryObjectiv, "glGetQueryObjectiv");
   if ( !driverTbl.glGetQueryObjectiv ) {
      driverTbl.glGetQueryObjectiv = missing_glGetQueryObjectiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetQueryObjectiv == loader_glGetQueryObjectiv) {
      rCtx->dsp->emuTbl.glGetQueryObjectiv = driverTbl.glGetQueryObjectiv;
   }
   driverTbl.glGetQueryObjectiv(id, pname, params);
}

static void REGAL_CALL missing_glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetQueryObjectuiv not available." );
}

static void REGAL_CALL loader_glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetQueryObjectuiv, "glGetQueryObjectuiv");
   if ( !driverTbl.glGetQueryObjectuiv ) {
      driverTbl.glGetQueryObjectuiv = missing_glGetQueryObjectuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetQueryObjectuiv == loader_glGetQueryObjectuiv) {
      rCtx->dsp->emuTbl.glGetQueryObjectuiv = driverTbl.glGetQueryObjectuiv;
   }
   driverTbl.glGetQueryObjectuiv(id, pname, params);
}

static void REGAL_CALL missing_glGetQueryiv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetQueryiv not available." );
}

static void REGAL_CALL loader_glGetQueryiv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetQueryiv, "glGetQueryiv");
   if ( !driverTbl.glGetQueryiv ) {
      driverTbl.glGetQueryiv = missing_glGetQueryiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetQueryiv == loader_glGetQueryiv) {
      rCtx->dsp->emuTbl.glGetQueryiv = driverTbl.glGetQueryiv;
   }
   driverTbl.glGetQueryiv(target, pname, params);
}

static GLboolean REGAL_CALL missing_glIsBuffer(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "glIsBuffer not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsBuffer(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsBuffer, "glIsBuffer");
   if ( !driverTbl.glIsBuffer ) {
      driverTbl.glIsBuffer = missing_glIsBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsBuffer == loader_glIsBuffer) {
      rCtx->dsp->emuTbl.glIsBuffer = driverTbl.glIsBuffer;
   }
   return driverTbl.glIsBuffer(buffer);
}

static GLboolean REGAL_CALL missing_glIsQuery(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "glIsQuery not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsQuery(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsQuery, "glIsQuery");
   if ( !driverTbl.glIsQuery ) {
      driverTbl.glIsQuery = missing_glIsQuery;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsQuery == loader_glIsQuery) {
      rCtx->dsp->emuTbl.glIsQuery = driverTbl.glIsQuery;
   }
   return driverTbl.glIsQuery(id);
}

static GLvoid *REGAL_CALL missing_glMapBuffer(GLenum target, GLenum access)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(access);
   Warning( "glMapBuffer not available." );
  GLvoid * ret = NULL;
  return ret;
}

static GLvoid *REGAL_CALL loader_glMapBuffer(GLenum target, GLenum access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapBuffer, "glMapBuffer");
   if ( !driverTbl.glMapBuffer ) {
      driverTbl.glMapBuffer = missing_glMapBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapBuffer == loader_glMapBuffer) {
      rCtx->dsp->emuTbl.glMapBuffer = driverTbl.glMapBuffer;
   }
   return driverTbl.glMapBuffer(target, access);
}

static GLboolean REGAL_CALL missing_glUnmapBuffer(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glUnmapBuffer not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glUnmapBuffer(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUnmapBuffer, "glUnmapBuffer");
   if ( !driverTbl.glUnmapBuffer ) {
      driverTbl.glUnmapBuffer = missing_glUnmapBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUnmapBuffer == loader_glUnmapBuffer) {
      rCtx->dsp->emuTbl.glUnmapBuffer = driverTbl.glUnmapBuffer;
   }
   return driverTbl.glUnmapBuffer(target);
}

// GL_VERSION_2_0

static void REGAL_CALL missing_glAttachShader(GLuint program, GLuint shader)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shader);
   Warning( "glAttachShader not available." );
}

static void REGAL_CALL loader_glAttachShader(GLuint program, GLuint shader)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glAttachShader, "glAttachShader");
   if ( !driverTbl.glAttachShader ) {
      driverTbl.glAttachShader = missing_glAttachShader;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glAttachShader == loader_glAttachShader) {
      rCtx->dsp->emuTbl.glAttachShader = driverTbl.glAttachShader;
   }
   driverTbl.glAttachShader(program, shader);
}

static void REGAL_CALL missing_glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(name);
   Warning( "glBindAttribLocation not available." );
}

static void REGAL_CALL loader_glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindAttribLocation, "glBindAttribLocation");
   if ( !driverTbl.glBindAttribLocation ) {
      driverTbl.glBindAttribLocation = missing_glBindAttribLocation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindAttribLocation == loader_glBindAttribLocation) {
      rCtx->dsp->emuTbl.glBindAttribLocation = driverTbl.glBindAttribLocation;
   }
   driverTbl.glBindAttribLocation(program, index, name);
}

static void REGAL_CALL missing_glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
   UNUSED_PARAMETER(modeRGB);
   UNUSED_PARAMETER(modeAlpha);
   Warning( "glBlendEquationSeparate not available." );
}

static void REGAL_CALL loader_glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendEquationSeparate, "glBlendEquationSeparate");
   if ( !driverTbl.glBlendEquationSeparate ) {
      driverTbl.glBlendEquationSeparate = missing_glBlendEquationSeparate;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendEquationSeparate == loader_glBlendEquationSeparate) {
      rCtx->dsp->emuTbl.glBlendEquationSeparate = driverTbl.glBlendEquationSeparate;
   }
   driverTbl.glBlendEquationSeparate(modeRGB, modeAlpha);
}

static void REGAL_CALL missing_glCompileShader(GLuint shader)
{
   UNUSED_PARAMETER(shader);
   Warning( "glCompileShader not available." );
}

static void REGAL_CALL loader_glCompileShader(GLuint shader)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompileShader, "glCompileShader");
   if ( !driverTbl.glCompileShader ) {
      driverTbl.glCompileShader = missing_glCompileShader;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompileShader == loader_glCompileShader) {
      rCtx->dsp->emuTbl.glCompileShader = driverTbl.glCompileShader;
   }
   driverTbl.glCompileShader(shader);
}

static GLuint REGAL_CALL missing_glCreateProgram(void)
{
   Warning( "glCreateProgram not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glCreateProgram(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCreateProgram, "glCreateProgram");
   if ( !driverTbl.glCreateProgram ) {
      driverTbl.glCreateProgram = missing_glCreateProgram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCreateProgram == loader_glCreateProgram) {
      rCtx->dsp->emuTbl.glCreateProgram = driverTbl.glCreateProgram;
   }
   return driverTbl.glCreateProgram();
}

static GLuint REGAL_CALL missing_glCreateShader(GLenum type)
{
   UNUSED_PARAMETER(type);
   Warning( "glCreateShader not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glCreateShader(GLenum type)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCreateShader, "glCreateShader");
   if ( !driverTbl.glCreateShader ) {
      driverTbl.glCreateShader = missing_glCreateShader;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCreateShader == loader_glCreateShader) {
      rCtx->dsp->emuTbl.glCreateShader = driverTbl.glCreateShader;
   }
   return driverTbl.glCreateShader(type);
}

static void REGAL_CALL missing_glDeleteProgram(GLuint program)
{
   UNUSED_PARAMETER(program);
   Warning( "glDeleteProgram not available." );
}

static void REGAL_CALL loader_glDeleteProgram(GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteProgram, "glDeleteProgram");
   if ( !driverTbl.glDeleteProgram ) {
      driverTbl.glDeleteProgram = missing_glDeleteProgram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteProgram == loader_glDeleteProgram) {
      rCtx->dsp->emuTbl.glDeleteProgram = driverTbl.glDeleteProgram;
   }
   driverTbl.glDeleteProgram(program);
}

static void REGAL_CALL missing_glDeleteShader(GLuint shader)
{
   UNUSED_PARAMETER(shader);
   Warning( "glDeleteShader not available." );
}

static void REGAL_CALL loader_glDeleteShader(GLuint shader)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteShader, "glDeleteShader");
   if ( !driverTbl.glDeleteShader ) {
      driverTbl.glDeleteShader = missing_glDeleteShader;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteShader == loader_glDeleteShader) {
      rCtx->dsp->emuTbl.glDeleteShader = driverTbl.glDeleteShader;
   }
   driverTbl.glDeleteShader(shader);
}

static void REGAL_CALL missing_glDetachShader(GLuint program, GLuint shader)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shader);
   Warning( "glDetachShader not available." );
}

static void REGAL_CALL loader_glDetachShader(GLuint program, GLuint shader)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDetachShader, "glDetachShader");
   if ( !driverTbl.glDetachShader ) {
      driverTbl.glDetachShader = missing_glDetachShader;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDetachShader == loader_glDetachShader) {
      rCtx->dsp->emuTbl.glDetachShader = driverTbl.glDetachShader;
   }
   driverTbl.glDetachShader(program, shader);
}

static void REGAL_CALL missing_glDisableVertexAttribArray(GLuint index)
{
   UNUSED_PARAMETER(index);
   Warning( "glDisableVertexAttribArray not available." );
}

static void REGAL_CALL loader_glDisableVertexAttribArray(GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDisableVertexAttribArray, "glDisableVertexAttribArray");
   if ( !driverTbl.glDisableVertexAttribArray ) {
      driverTbl.glDisableVertexAttribArray = missing_glDisableVertexAttribArray;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDisableVertexAttribArray == loader_glDisableVertexAttribArray) {
      rCtx->dsp->emuTbl.glDisableVertexAttribArray = driverTbl.glDisableVertexAttribArray;
   }
   driverTbl.glDisableVertexAttribArray(index);
}

static void REGAL_CALL missing_glDrawBuffers(GLsizei n, const GLenum *bufs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(bufs);
   Warning( "glDrawBuffers not available." );
}

static void REGAL_CALL loader_glDrawBuffers(GLsizei n, const GLenum *bufs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawBuffers, "glDrawBuffers");
   if ( !driverTbl.glDrawBuffers ) {
      driverTbl.glDrawBuffers = missing_glDrawBuffers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawBuffers == loader_glDrawBuffers) {
      rCtx->dsp->emuTbl.glDrawBuffers = driverTbl.glDrawBuffers;
   }
   driverTbl.glDrawBuffers(n, bufs);
}

static void REGAL_CALL missing_glEnableVertexAttribArray(GLuint index)
{
   UNUSED_PARAMETER(index);
   Warning( "glEnableVertexAttribArray not available." );
}

static void REGAL_CALL loader_glEnableVertexAttribArray(GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEnableVertexAttribArray, "glEnableVertexAttribArray");
   if ( !driverTbl.glEnableVertexAttribArray ) {
      driverTbl.glEnableVertexAttribArray = missing_glEnableVertexAttribArray;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEnableVertexAttribArray == loader_glEnableVertexAttribArray) {
      rCtx->dsp->emuTbl.glEnableVertexAttribArray = driverTbl.glEnableVertexAttribArray;
   }
   driverTbl.glEnableVertexAttribArray(index);
}

static void REGAL_CALL missing_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(name);
   Warning( "glGetActiveAttrib not available." );
}

static void REGAL_CALL loader_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetActiveAttrib, "glGetActiveAttrib");
   if ( !driverTbl.glGetActiveAttrib ) {
      driverTbl.glGetActiveAttrib = missing_glGetActiveAttrib;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetActiveAttrib == loader_glGetActiveAttrib) {
      rCtx->dsp->emuTbl.glGetActiveAttrib = driverTbl.glGetActiveAttrib;
   }
   driverTbl.glGetActiveAttrib(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL missing_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(name);
   Warning( "glGetActiveUniform not available." );
}

static void REGAL_CALL loader_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetActiveUniform, "glGetActiveUniform");
   if ( !driverTbl.glGetActiveUniform ) {
      driverTbl.glGetActiveUniform = missing_glGetActiveUniform;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetActiveUniform == loader_glGetActiveUniform) {
      rCtx->dsp->emuTbl.glGetActiveUniform = driverTbl.glGetActiveUniform;
   }
   driverTbl.glGetActiveUniform(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL missing_glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(maxCount);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(shaders);
   Warning( "glGetAttachedShaders not available." );
}

static void REGAL_CALL loader_glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetAttachedShaders, "glGetAttachedShaders");
   if ( !driverTbl.glGetAttachedShaders ) {
      driverTbl.glGetAttachedShaders = missing_glGetAttachedShaders;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetAttachedShaders == loader_glGetAttachedShaders) {
      rCtx->dsp->emuTbl.glGetAttachedShaders = driverTbl.glGetAttachedShaders;
   }
   driverTbl.glGetAttachedShaders(program, maxCount, count, shaders);
}

static GLint REGAL_CALL missing_glGetAttribLocation(GLuint program, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(name);
   Warning( "glGetAttribLocation not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetAttribLocation(GLuint program, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetAttribLocation, "glGetAttribLocation");
   if ( !driverTbl.glGetAttribLocation ) {
      driverTbl.glGetAttribLocation = missing_glGetAttribLocation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetAttribLocation == loader_glGetAttribLocation) {
      rCtx->dsp->emuTbl.glGetAttribLocation = driverTbl.glGetAttribLocation;
   }
   return driverTbl.glGetAttribLocation(program, name);
}

static void REGAL_CALL missing_glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(infoLog);
   Warning( "glGetProgramInfoLog not available." );
}

static void REGAL_CALL loader_glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramInfoLog, "glGetProgramInfoLog");
   if ( !driverTbl.glGetProgramInfoLog ) {
      driverTbl.glGetProgramInfoLog = missing_glGetProgramInfoLog;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramInfoLog == loader_glGetProgramInfoLog) {
      rCtx->dsp->emuTbl.glGetProgramInfoLog = driverTbl.glGetProgramInfoLog;
   }
   driverTbl.glGetProgramInfoLog(program, bufSize, length, infoLog);
}

static void REGAL_CALL missing_glGetProgramiv(GLuint program, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramiv not available." );
}

static void REGAL_CALL loader_glGetProgramiv(GLuint program, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramiv, "glGetProgramiv");
   if ( !driverTbl.glGetProgramiv ) {
      driverTbl.glGetProgramiv = missing_glGetProgramiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramiv == loader_glGetProgramiv) {
      rCtx->dsp->emuTbl.glGetProgramiv = driverTbl.glGetProgramiv;
   }
   driverTbl.glGetProgramiv(program, pname, params);
}

static void REGAL_CALL missing_glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
   UNUSED_PARAMETER(shader);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(infoLog);
   Warning( "glGetShaderInfoLog not available." );
}

static void REGAL_CALL loader_glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetShaderInfoLog, "glGetShaderInfoLog");
   if ( !driverTbl.glGetShaderInfoLog ) {
      driverTbl.glGetShaderInfoLog = missing_glGetShaderInfoLog;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetShaderInfoLog == loader_glGetShaderInfoLog) {
      rCtx->dsp->emuTbl.glGetShaderInfoLog = driverTbl.glGetShaderInfoLog;
   }
   driverTbl.glGetShaderInfoLog(shader, bufSize, length, infoLog);
}

static void REGAL_CALL missing_glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)
{
   UNUSED_PARAMETER(shader);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(source);
   Warning( "glGetShaderSource not available." );
}

static void REGAL_CALL loader_glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetShaderSource, "glGetShaderSource");
   if ( !driverTbl.glGetShaderSource ) {
      driverTbl.glGetShaderSource = missing_glGetShaderSource;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetShaderSource == loader_glGetShaderSource) {
      rCtx->dsp->emuTbl.glGetShaderSource = driverTbl.glGetShaderSource;
   }
   driverTbl.glGetShaderSource(shader, bufSize, length, source);
}

static void REGAL_CALL missing_glGetShaderiv(GLuint shader, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(shader);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetShaderiv not available." );
}

static void REGAL_CALL loader_glGetShaderiv(GLuint shader, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetShaderiv, "glGetShaderiv");
   if ( !driverTbl.glGetShaderiv ) {
      driverTbl.glGetShaderiv = missing_glGetShaderiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetShaderiv == loader_glGetShaderiv) {
      rCtx->dsp->emuTbl.glGetShaderiv = driverTbl.glGetShaderiv;
   }
   driverTbl.glGetShaderiv(shader, pname, params);
}

static GLint REGAL_CALL missing_glGetUniformLocation(GLuint program, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(name);
   Warning( "glGetUniformLocation not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetUniformLocation(GLuint program, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformLocation, "glGetUniformLocation");
   if ( !driverTbl.glGetUniformLocation ) {
      driverTbl.glGetUniformLocation = missing_glGetUniformLocation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformLocation == loader_glGetUniformLocation) {
      rCtx->dsp->emuTbl.glGetUniformLocation = driverTbl.glGetUniformLocation;
   }
   return driverTbl.glGetUniformLocation(program, name);
}

static void REGAL_CALL missing_glGetUniformfv(GLuint program, GLint location, GLfloat *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "glGetUniformfv not available." );
}

static void REGAL_CALL loader_glGetUniformfv(GLuint program, GLint location, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformfv, "glGetUniformfv");
   if ( !driverTbl.glGetUniformfv ) {
      driverTbl.glGetUniformfv = missing_glGetUniformfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformfv == loader_glGetUniformfv) {
      rCtx->dsp->emuTbl.glGetUniformfv = driverTbl.glGetUniformfv;
   }
   driverTbl.glGetUniformfv(program, location, params);
}

static void REGAL_CALL missing_glGetUniformiv(GLuint program, GLint location, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "glGetUniformiv not available." );
}

static void REGAL_CALL loader_glGetUniformiv(GLuint program, GLint location, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformiv, "glGetUniformiv");
   if ( !driverTbl.glGetUniformiv ) {
      driverTbl.glGetUniformiv = missing_glGetUniformiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformiv == loader_glGetUniformiv) {
      rCtx->dsp->emuTbl.glGetUniformiv = driverTbl.glGetUniformiv;
   }
   driverTbl.glGetUniformiv(program, location, params);
}

static void REGAL_CALL missing_glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(pointer);
   Warning( "glGetVertexAttribPointerv not available." );
}

static void REGAL_CALL loader_glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribPointerv, "glGetVertexAttribPointerv");
   if ( !driverTbl.glGetVertexAttribPointerv ) {
      driverTbl.glGetVertexAttribPointerv = missing_glGetVertexAttribPointerv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribPointerv == loader_glGetVertexAttribPointerv) {
      rCtx->dsp->emuTbl.glGetVertexAttribPointerv = driverTbl.glGetVertexAttribPointerv;
   }
   driverTbl.glGetVertexAttribPointerv(index, pname, pointer);
}

static void REGAL_CALL missing_glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribdv not available." );
}

static void REGAL_CALL loader_glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribdv, "glGetVertexAttribdv");
   if ( !driverTbl.glGetVertexAttribdv ) {
      driverTbl.glGetVertexAttribdv = missing_glGetVertexAttribdv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribdv == loader_glGetVertexAttribdv) {
      rCtx->dsp->emuTbl.glGetVertexAttribdv = driverTbl.glGetVertexAttribdv;
   }
   driverTbl.glGetVertexAttribdv(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribfv not available." );
}

static void REGAL_CALL loader_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribfv, "glGetVertexAttribfv");
   if ( !driverTbl.glGetVertexAttribfv ) {
      driverTbl.glGetVertexAttribfv = missing_glGetVertexAttribfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribfv == loader_glGetVertexAttribfv) {
      rCtx->dsp->emuTbl.glGetVertexAttribfv = driverTbl.glGetVertexAttribfv;
   }
   driverTbl.glGetVertexAttribfv(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribiv not available." );
}

static void REGAL_CALL loader_glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribiv, "glGetVertexAttribiv");
   if ( !driverTbl.glGetVertexAttribiv ) {
      driverTbl.glGetVertexAttribiv = missing_glGetVertexAttribiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribiv == loader_glGetVertexAttribiv) {
      rCtx->dsp->emuTbl.glGetVertexAttribiv = driverTbl.glGetVertexAttribiv;
   }
   driverTbl.glGetVertexAttribiv(index, pname, params);
}

static GLboolean REGAL_CALL missing_glIsProgram(GLuint program)
{
   UNUSED_PARAMETER(program);
   Warning( "glIsProgram not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsProgram(GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsProgram, "glIsProgram");
   if ( !driverTbl.glIsProgram ) {
      driverTbl.glIsProgram = missing_glIsProgram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsProgram == loader_glIsProgram) {
      rCtx->dsp->emuTbl.glIsProgram = driverTbl.glIsProgram;
   }
   return driverTbl.glIsProgram(program);
}

static GLboolean REGAL_CALL missing_glIsShader(GLuint shader)
{
   UNUSED_PARAMETER(shader);
   Warning( "glIsShader not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsShader(GLuint shader)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsShader, "glIsShader");
   if ( !driverTbl.glIsShader ) {
      driverTbl.glIsShader = missing_glIsShader;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsShader == loader_glIsShader) {
      rCtx->dsp->emuTbl.glIsShader = driverTbl.glIsShader;
   }
   return driverTbl.glIsShader(shader);
}

static void REGAL_CALL missing_glLinkProgram(GLuint program)
{
   UNUSED_PARAMETER(program);
   Warning( "glLinkProgram not available." );
}

static void REGAL_CALL loader_glLinkProgram(GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLinkProgram, "glLinkProgram");
   if ( !driverTbl.glLinkProgram ) {
      driverTbl.glLinkProgram = missing_glLinkProgram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLinkProgram == loader_glLinkProgram) {
      rCtx->dsp->emuTbl.glLinkProgram = driverTbl.glLinkProgram;
   }
   driverTbl.glLinkProgram(program);
}

static void REGAL_CALL missing_glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length)
{
   UNUSED_PARAMETER(shader);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(string);
   UNUSED_PARAMETER(length);
   Warning( "glShaderSource not available." );
}

static void REGAL_CALL loader_glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glShaderSource, "glShaderSource");
   if ( !driverTbl.glShaderSource ) {
      driverTbl.glShaderSource = missing_glShaderSource;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glShaderSource == loader_glShaderSource) {
      rCtx->dsp->emuTbl.glShaderSource = driverTbl.glShaderSource;
   }
   driverTbl.glShaderSource(shader, count, string, length);
}

static void REGAL_CALL missing_glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(func);
   UNUSED_PARAMETER(ref);
   UNUSED_PARAMETER(mask);
   Warning( "glStencilFuncSeparate not available." );
}

static void REGAL_CALL loader_glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStencilFuncSeparate, "glStencilFuncSeparate");
   if ( !driverTbl.glStencilFuncSeparate ) {
      driverTbl.glStencilFuncSeparate = missing_glStencilFuncSeparate;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStencilFuncSeparate == loader_glStencilFuncSeparate) {
      rCtx->dsp->emuTbl.glStencilFuncSeparate = driverTbl.glStencilFuncSeparate;
   }
   driverTbl.glStencilFuncSeparate(face, func, ref, mask);
}

static void REGAL_CALL missing_glStencilMaskSeparate(GLenum face, GLuint mask)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(mask);
   Warning( "glStencilMaskSeparate not available." );
}

static void REGAL_CALL loader_glStencilMaskSeparate(GLenum face, GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStencilMaskSeparate, "glStencilMaskSeparate");
   if ( !driverTbl.glStencilMaskSeparate ) {
      driverTbl.glStencilMaskSeparate = missing_glStencilMaskSeparate;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStencilMaskSeparate == loader_glStencilMaskSeparate) {
      rCtx->dsp->emuTbl.glStencilMaskSeparate = driverTbl.glStencilMaskSeparate;
   }
   driverTbl.glStencilMaskSeparate(face, mask);
}

static void REGAL_CALL missing_glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(fail);
   UNUSED_PARAMETER(zfail);
   UNUSED_PARAMETER(zpass);
   Warning( "glStencilOpSeparate not available." );
}

static void REGAL_CALL loader_glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStencilOpSeparate, "glStencilOpSeparate");
   if ( !driverTbl.glStencilOpSeparate ) {
      driverTbl.glStencilOpSeparate = missing_glStencilOpSeparate;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStencilOpSeparate == loader_glStencilOpSeparate) {
      rCtx->dsp->emuTbl.glStencilOpSeparate = driverTbl.glStencilOpSeparate;
   }
   driverTbl.glStencilOpSeparate(face, fail, zfail, zpass);
}

static void REGAL_CALL missing_glUniform1f(GLint location, GLfloat v0)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "glUniform1f not available." );
}

static void REGAL_CALL loader_glUniform1f(GLint location, GLfloat v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1f, "glUniform1f");
   if ( !driverTbl.glUniform1f ) {
      driverTbl.glUniform1f = missing_glUniform1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1f == loader_glUniform1f) {
      rCtx->dsp->emuTbl.glUniform1f = driverTbl.glUniform1f;
   }
   driverTbl.glUniform1f(location, v0);
}

static void REGAL_CALL missing_glUniform1fv(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform1fv not available." );
}

static void REGAL_CALL loader_glUniform1fv(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1fv, "glUniform1fv");
   if ( !driverTbl.glUniform1fv ) {
      driverTbl.glUniform1fv = missing_glUniform1fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1fv == loader_glUniform1fv) {
      rCtx->dsp->emuTbl.glUniform1fv = driverTbl.glUniform1fv;
   }
   driverTbl.glUniform1fv(location, count, value);
}

static void REGAL_CALL missing_glUniform1i(GLint location, GLint v0)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "glUniform1i not available." );
}

static void REGAL_CALL loader_glUniform1i(GLint location, GLint v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1i, "glUniform1i");
   if ( !driverTbl.glUniform1i ) {
      driverTbl.glUniform1i = missing_glUniform1i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1i == loader_glUniform1i) {
      rCtx->dsp->emuTbl.glUniform1i = driverTbl.glUniform1i;
   }
   driverTbl.glUniform1i(location, v0);
}

static void REGAL_CALL missing_glUniform1iv(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform1iv not available." );
}

static void REGAL_CALL loader_glUniform1iv(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1iv, "glUniform1iv");
   if ( !driverTbl.glUniform1iv ) {
      driverTbl.glUniform1iv = missing_glUniform1iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1iv == loader_glUniform1iv) {
      rCtx->dsp->emuTbl.glUniform1iv = driverTbl.glUniform1iv;
   }
   driverTbl.glUniform1iv(location, count, value);
}

static void REGAL_CALL missing_glUniform2f(GLint location, GLfloat v0, GLfloat v1)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "glUniform2f not available." );
}

static void REGAL_CALL loader_glUniform2f(GLint location, GLfloat v0, GLfloat v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2f, "glUniform2f");
   if ( !driverTbl.glUniform2f ) {
      driverTbl.glUniform2f = missing_glUniform2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2f == loader_glUniform2f) {
      rCtx->dsp->emuTbl.glUniform2f = driverTbl.glUniform2f;
   }
   driverTbl.glUniform2f(location, v0, v1);
}

static void REGAL_CALL missing_glUniform2fv(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform2fv not available." );
}

static void REGAL_CALL loader_glUniform2fv(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2fv, "glUniform2fv");
   if ( !driverTbl.glUniform2fv ) {
      driverTbl.glUniform2fv = missing_glUniform2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2fv == loader_glUniform2fv) {
      rCtx->dsp->emuTbl.glUniform2fv = driverTbl.glUniform2fv;
   }
   driverTbl.glUniform2fv(location, count, value);
}

static void REGAL_CALL missing_glUniform2i(GLint location, GLint v0, GLint v1)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "glUniform2i not available." );
}

static void REGAL_CALL loader_glUniform2i(GLint location, GLint v0, GLint v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2i, "glUniform2i");
   if ( !driverTbl.glUniform2i ) {
      driverTbl.glUniform2i = missing_glUniform2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2i == loader_glUniform2i) {
      rCtx->dsp->emuTbl.glUniform2i = driverTbl.glUniform2i;
   }
   driverTbl.glUniform2i(location, v0, v1);
}

static void REGAL_CALL missing_glUniform2iv(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform2iv not available." );
}

static void REGAL_CALL loader_glUniform2iv(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2iv, "glUniform2iv");
   if ( !driverTbl.glUniform2iv ) {
      driverTbl.glUniform2iv = missing_glUniform2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2iv == loader_glUniform2iv) {
      rCtx->dsp->emuTbl.glUniform2iv = driverTbl.glUniform2iv;
   }
   driverTbl.glUniform2iv(location, count, value);
}

static void REGAL_CALL missing_glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glUniform3f not available." );
}

static void REGAL_CALL loader_glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3f, "glUniform3f");
   if ( !driverTbl.glUniform3f ) {
      driverTbl.glUniform3f = missing_glUniform3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3f == loader_glUniform3f) {
      rCtx->dsp->emuTbl.glUniform3f = driverTbl.glUniform3f;
   }
   driverTbl.glUniform3f(location, v0, v1, v2);
}

static void REGAL_CALL missing_glUniform3fv(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform3fv not available." );
}

static void REGAL_CALL loader_glUniform3fv(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3fv, "glUniform3fv");
   if ( !driverTbl.glUniform3fv ) {
      driverTbl.glUniform3fv = missing_glUniform3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3fv == loader_glUniform3fv) {
      rCtx->dsp->emuTbl.glUniform3fv = driverTbl.glUniform3fv;
   }
   driverTbl.glUniform3fv(location, count, value);
}

static void REGAL_CALL missing_glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glUniform3i not available." );
}

static void REGAL_CALL loader_glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3i, "glUniform3i");
   if ( !driverTbl.glUniform3i ) {
      driverTbl.glUniform3i = missing_glUniform3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3i == loader_glUniform3i) {
      rCtx->dsp->emuTbl.glUniform3i = driverTbl.glUniform3i;
   }
   driverTbl.glUniform3i(location, v0, v1, v2);
}

static void REGAL_CALL missing_glUniform3iv(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform3iv not available." );
}

static void REGAL_CALL loader_glUniform3iv(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3iv, "glUniform3iv");
   if ( !driverTbl.glUniform3iv ) {
      driverTbl.glUniform3iv = missing_glUniform3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3iv == loader_glUniform3iv) {
      rCtx->dsp->emuTbl.glUniform3iv = driverTbl.glUniform3iv;
   }
   driverTbl.glUniform3iv(location, count, value);
}

static void REGAL_CALL missing_glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "glUniform4f not available." );
}

static void REGAL_CALL loader_glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4f, "glUniform4f");
   if ( !driverTbl.glUniform4f ) {
      driverTbl.glUniform4f = missing_glUniform4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4f == loader_glUniform4f) {
      rCtx->dsp->emuTbl.glUniform4f = driverTbl.glUniform4f;
   }
   driverTbl.glUniform4f(location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glUniform4fv(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform4fv not available." );
}

static void REGAL_CALL loader_glUniform4fv(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4fv, "glUniform4fv");
   if ( !driverTbl.glUniform4fv ) {
      driverTbl.glUniform4fv = missing_glUniform4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4fv == loader_glUniform4fv) {
      rCtx->dsp->emuTbl.glUniform4fv = driverTbl.glUniform4fv;
   }
   driverTbl.glUniform4fv(location, count, value);
}

static void REGAL_CALL missing_glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "glUniform4i not available." );
}

static void REGAL_CALL loader_glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4i, "glUniform4i");
   if ( !driverTbl.glUniform4i ) {
      driverTbl.glUniform4i = missing_glUniform4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4i == loader_glUniform4i) {
      rCtx->dsp->emuTbl.glUniform4i = driverTbl.glUniform4i;
   }
   driverTbl.glUniform4i(location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glUniform4iv(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform4iv not available." );
}

static void REGAL_CALL loader_glUniform4iv(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4iv, "glUniform4iv");
   if ( !driverTbl.glUniform4iv ) {
      driverTbl.glUniform4iv = missing_glUniform4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4iv == loader_glUniform4iv) {
      rCtx->dsp->emuTbl.glUniform4iv = driverTbl.glUniform4iv;
   }
   driverTbl.glUniform4iv(location, count, value);
}

static void REGAL_CALL missing_glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix2fv not available." );
}

static void REGAL_CALL loader_glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix2fv, "glUniformMatrix2fv");
   if ( !driverTbl.glUniformMatrix2fv ) {
      driverTbl.glUniformMatrix2fv = missing_glUniformMatrix2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix2fv == loader_glUniformMatrix2fv) {
      rCtx->dsp->emuTbl.glUniformMatrix2fv = driverTbl.glUniformMatrix2fv;
   }
   driverTbl.glUniformMatrix2fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix3fv not available." );
}

static void REGAL_CALL loader_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix3fv, "glUniformMatrix3fv");
   if ( !driverTbl.glUniformMatrix3fv ) {
      driverTbl.glUniformMatrix3fv = missing_glUniformMatrix3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix3fv == loader_glUniformMatrix3fv) {
      rCtx->dsp->emuTbl.glUniformMatrix3fv = driverTbl.glUniformMatrix3fv;
   }
   driverTbl.glUniformMatrix3fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix4fv not available." );
}

static void REGAL_CALL loader_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix4fv, "glUniformMatrix4fv");
   if ( !driverTbl.glUniformMatrix4fv ) {
      driverTbl.glUniformMatrix4fv = missing_glUniformMatrix4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix4fv == loader_glUniformMatrix4fv) {
      rCtx->dsp->emuTbl.glUniformMatrix4fv = driverTbl.glUniformMatrix4fv;
   }
   driverTbl.glUniformMatrix4fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUseProgram(GLuint program)
{
   UNUSED_PARAMETER(program);
   Warning( "glUseProgram not available." );
}

static void REGAL_CALL loader_glUseProgram(GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUseProgram, "glUseProgram");
   if ( !driverTbl.glUseProgram ) {
      driverTbl.glUseProgram = missing_glUseProgram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUseProgram == loader_glUseProgram) {
      rCtx->dsp->emuTbl.glUseProgram = driverTbl.glUseProgram;
   }
   driverTbl.glUseProgram(program);
}

static void REGAL_CALL missing_glValidateProgram(GLuint program)
{
   UNUSED_PARAMETER(program);
   Warning( "glValidateProgram not available." );
}

static void REGAL_CALL loader_glValidateProgram(GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glValidateProgram, "glValidateProgram");
   if ( !driverTbl.glValidateProgram ) {
      driverTbl.glValidateProgram = missing_glValidateProgram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glValidateProgram == loader_glValidateProgram) {
      rCtx->dsp->emuTbl.glValidateProgram = driverTbl.glValidateProgram;
   }
   driverTbl.glValidateProgram(program);
}

static void REGAL_CALL missing_glVertexAttrib1d(GLuint index, GLdouble x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttrib1d not available." );
}

static void REGAL_CALL loader_glVertexAttrib1d(GLuint index, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1d, "glVertexAttrib1d");
   if ( !driverTbl.glVertexAttrib1d ) {
      driverTbl.glVertexAttrib1d = missing_glVertexAttrib1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1d == loader_glVertexAttrib1d) {
      rCtx->dsp->emuTbl.glVertexAttrib1d = driverTbl.glVertexAttrib1d;
   }
   driverTbl.glVertexAttrib1d(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib1dv not available." );
}

static void REGAL_CALL loader_glVertexAttrib1dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1dv, "glVertexAttrib1dv");
   if ( !driverTbl.glVertexAttrib1dv ) {
      driverTbl.glVertexAttrib1dv = missing_glVertexAttrib1dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1dv == loader_glVertexAttrib1dv) {
      rCtx->dsp->emuTbl.glVertexAttrib1dv = driverTbl.glVertexAttrib1dv;
   }
   driverTbl.glVertexAttrib1dv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib1f(GLuint index, GLfloat x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttrib1f not available." );
}

static void REGAL_CALL loader_glVertexAttrib1f(GLuint index, GLfloat x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1f, "glVertexAttrib1f");
   if ( !driverTbl.glVertexAttrib1f ) {
      driverTbl.glVertexAttrib1f = missing_glVertexAttrib1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1f == loader_glVertexAttrib1f) {
      rCtx->dsp->emuTbl.glVertexAttrib1f = driverTbl.glVertexAttrib1f;
   }
   driverTbl.glVertexAttrib1f(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1fv(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib1fv not available." );
}

static void REGAL_CALL loader_glVertexAttrib1fv(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1fv, "glVertexAttrib1fv");
   if ( !driverTbl.glVertexAttrib1fv ) {
      driverTbl.glVertexAttrib1fv = missing_glVertexAttrib1fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1fv == loader_glVertexAttrib1fv) {
      rCtx->dsp->emuTbl.glVertexAttrib1fv = driverTbl.glVertexAttrib1fv;
   }
   driverTbl.glVertexAttrib1fv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib1s(GLuint index, GLshort x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttrib1s not available." );
}

static void REGAL_CALL loader_glVertexAttrib1s(GLuint index, GLshort x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1s, "glVertexAttrib1s");
   if ( !driverTbl.glVertexAttrib1s ) {
      driverTbl.glVertexAttrib1s = missing_glVertexAttrib1s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1s == loader_glVertexAttrib1s) {
      rCtx->dsp->emuTbl.glVertexAttrib1s = driverTbl.glVertexAttrib1s;
   }
   driverTbl.glVertexAttrib1s(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1sv(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib1sv not available." );
}

static void REGAL_CALL loader_glVertexAttrib1sv(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1sv, "glVertexAttrib1sv");
   if ( !driverTbl.glVertexAttrib1sv ) {
      driverTbl.glVertexAttrib1sv = missing_glVertexAttrib1sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1sv == loader_glVertexAttrib1sv) {
      rCtx->dsp->emuTbl.glVertexAttrib1sv = driverTbl.glVertexAttrib1sv;
   }
   driverTbl.glVertexAttrib1sv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttrib2d not available." );
}

static void REGAL_CALL loader_glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2d, "glVertexAttrib2d");
   if ( !driverTbl.glVertexAttrib2d ) {
      driverTbl.glVertexAttrib2d = missing_glVertexAttrib2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2d == loader_glVertexAttrib2d) {
      rCtx->dsp->emuTbl.glVertexAttrib2d = driverTbl.glVertexAttrib2d;
   }
   driverTbl.glVertexAttrib2d(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib2dv not available." );
}

static void REGAL_CALL loader_glVertexAttrib2dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2dv, "glVertexAttrib2dv");
   if ( !driverTbl.glVertexAttrib2dv ) {
      driverTbl.glVertexAttrib2dv = missing_glVertexAttrib2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2dv == loader_glVertexAttrib2dv) {
      rCtx->dsp->emuTbl.glVertexAttrib2dv = driverTbl.glVertexAttrib2dv;
   }
   driverTbl.glVertexAttrib2dv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttrib2f not available." );
}

static void REGAL_CALL loader_glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2f, "glVertexAttrib2f");
   if ( !driverTbl.glVertexAttrib2f ) {
      driverTbl.glVertexAttrib2f = missing_glVertexAttrib2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2f == loader_glVertexAttrib2f) {
      rCtx->dsp->emuTbl.glVertexAttrib2f = driverTbl.glVertexAttrib2f;
   }
   driverTbl.glVertexAttrib2f(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2fv(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib2fv not available." );
}

static void REGAL_CALL loader_glVertexAttrib2fv(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2fv, "glVertexAttrib2fv");
   if ( !driverTbl.glVertexAttrib2fv ) {
      driverTbl.glVertexAttrib2fv = missing_glVertexAttrib2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2fv == loader_glVertexAttrib2fv) {
      rCtx->dsp->emuTbl.glVertexAttrib2fv = driverTbl.glVertexAttrib2fv;
   }
   driverTbl.glVertexAttrib2fv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2s(GLuint index, GLshort x, GLshort y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttrib2s not available." );
}

static void REGAL_CALL loader_glVertexAttrib2s(GLuint index, GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2s, "glVertexAttrib2s");
   if ( !driverTbl.glVertexAttrib2s ) {
      driverTbl.glVertexAttrib2s = missing_glVertexAttrib2s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2s == loader_glVertexAttrib2s) {
      rCtx->dsp->emuTbl.glVertexAttrib2s = driverTbl.glVertexAttrib2s;
   }
   driverTbl.glVertexAttrib2s(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2sv(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib2sv not available." );
}

static void REGAL_CALL loader_glVertexAttrib2sv(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2sv, "glVertexAttrib2sv");
   if ( !driverTbl.glVertexAttrib2sv ) {
      driverTbl.glVertexAttrib2sv = missing_glVertexAttrib2sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2sv == loader_glVertexAttrib2sv) {
      rCtx->dsp->emuTbl.glVertexAttrib2sv = driverTbl.glVertexAttrib2sv;
   }
   driverTbl.glVertexAttrib2sv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttrib3d not available." );
}

static void REGAL_CALL loader_glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3d, "glVertexAttrib3d");
   if ( !driverTbl.glVertexAttrib3d ) {
      driverTbl.glVertexAttrib3d = missing_glVertexAttrib3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3d == loader_glVertexAttrib3d) {
      rCtx->dsp->emuTbl.glVertexAttrib3d = driverTbl.glVertexAttrib3d;
   }
   driverTbl.glVertexAttrib3d(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib3dv not available." );
}

static void REGAL_CALL loader_glVertexAttrib3dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3dv, "glVertexAttrib3dv");
   if ( !driverTbl.glVertexAttrib3dv ) {
      driverTbl.glVertexAttrib3dv = missing_glVertexAttrib3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3dv == loader_glVertexAttrib3dv) {
      rCtx->dsp->emuTbl.glVertexAttrib3dv = driverTbl.glVertexAttrib3dv;
   }
   driverTbl.glVertexAttrib3dv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttrib3f not available." );
}

static void REGAL_CALL loader_glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3f, "glVertexAttrib3f");
   if ( !driverTbl.glVertexAttrib3f ) {
      driverTbl.glVertexAttrib3f = missing_glVertexAttrib3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3f == loader_glVertexAttrib3f) {
      rCtx->dsp->emuTbl.glVertexAttrib3f = driverTbl.glVertexAttrib3f;
   }
   driverTbl.glVertexAttrib3f(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3fv(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib3fv not available." );
}

static void REGAL_CALL loader_glVertexAttrib3fv(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3fv, "glVertexAttrib3fv");
   if ( !driverTbl.glVertexAttrib3fv ) {
      driverTbl.glVertexAttrib3fv = missing_glVertexAttrib3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3fv == loader_glVertexAttrib3fv) {
      rCtx->dsp->emuTbl.glVertexAttrib3fv = driverTbl.glVertexAttrib3fv;
   }
   driverTbl.glVertexAttrib3fv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttrib3s not available." );
}

static void REGAL_CALL loader_glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3s, "glVertexAttrib3s");
   if ( !driverTbl.glVertexAttrib3s ) {
      driverTbl.glVertexAttrib3s = missing_glVertexAttrib3s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3s == loader_glVertexAttrib3s) {
      rCtx->dsp->emuTbl.glVertexAttrib3s = driverTbl.glVertexAttrib3s;
   }
   driverTbl.glVertexAttrib3s(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3sv(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib3sv not available." );
}

static void REGAL_CALL loader_glVertexAttrib3sv(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3sv, "glVertexAttrib3sv");
   if ( !driverTbl.glVertexAttrib3sv ) {
      driverTbl.glVertexAttrib3sv = missing_glVertexAttrib3sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3sv == loader_glVertexAttrib3sv) {
      rCtx->dsp->emuTbl.glVertexAttrib3sv = driverTbl.glVertexAttrib3sv;
   }
   driverTbl.glVertexAttrib3sv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4Nbv(GLuint index, const GLbyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4Nbv not available." );
}

static void REGAL_CALL loader_glVertexAttrib4Nbv(GLuint index, const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4Nbv, "glVertexAttrib4Nbv");
   if ( !driverTbl.glVertexAttrib4Nbv ) {
      driverTbl.glVertexAttrib4Nbv = missing_glVertexAttrib4Nbv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4Nbv == loader_glVertexAttrib4Nbv) {
      rCtx->dsp->emuTbl.glVertexAttrib4Nbv = driverTbl.glVertexAttrib4Nbv;
   }
   driverTbl.glVertexAttrib4Nbv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4Niv(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4Niv not available." );
}

static void REGAL_CALL loader_glVertexAttrib4Niv(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4Niv, "glVertexAttrib4Niv");
   if ( !driverTbl.glVertexAttrib4Niv ) {
      driverTbl.glVertexAttrib4Niv = missing_glVertexAttrib4Niv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4Niv == loader_glVertexAttrib4Niv) {
      rCtx->dsp->emuTbl.glVertexAttrib4Niv = driverTbl.glVertexAttrib4Niv;
   }
   driverTbl.glVertexAttrib4Niv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4Nsv(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4Nsv not available." );
}

static void REGAL_CALL loader_glVertexAttrib4Nsv(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4Nsv, "glVertexAttrib4Nsv");
   if ( !driverTbl.glVertexAttrib4Nsv ) {
      driverTbl.glVertexAttrib4Nsv = missing_glVertexAttrib4Nsv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4Nsv == loader_glVertexAttrib4Nsv) {
      rCtx->dsp->emuTbl.glVertexAttrib4Nsv = driverTbl.glVertexAttrib4Nsv;
   }
   driverTbl.glVertexAttrib4Nsv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttrib4Nub not available." );
}

static void REGAL_CALL loader_glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4Nub, "glVertexAttrib4Nub");
   if ( !driverTbl.glVertexAttrib4Nub ) {
      driverTbl.glVertexAttrib4Nub = missing_glVertexAttrib4Nub;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4Nub == loader_glVertexAttrib4Nub) {
      rCtx->dsp->emuTbl.glVertexAttrib4Nub = driverTbl.glVertexAttrib4Nub;
   }
   driverTbl.glVertexAttrib4Nub(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4Nubv(GLuint index, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4Nubv not available." );
}

static void REGAL_CALL loader_glVertexAttrib4Nubv(GLuint index, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4Nubv, "glVertexAttrib4Nubv");
   if ( !driverTbl.glVertexAttrib4Nubv ) {
      driverTbl.glVertexAttrib4Nubv = missing_glVertexAttrib4Nubv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4Nubv == loader_glVertexAttrib4Nubv) {
      rCtx->dsp->emuTbl.glVertexAttrib4Nubv = driverTbl.glVertexAttrib4Nubv;
   }
   driverTbl.glVertexAttrib4Nubv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4Nuiv(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4Nuiv not available." );
}

static void REGAL_CALL loader_glVertexAttrib4Nuiv(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4Nuiv, "glVertexAttrib4Nuiv");
   if ( !driverTbl.glVertexAttrib4Nuiv ) {
      driverTbl.glVertexAttrib4Nuiv = missing_glVertexAttrib4Nuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4Nuiv == loader_glVertexAttrib4Nuiv) {
      rCtx->dsp->emuTbl.glVertexAttrib4Nuiv = driverTbl.glVertexAttrib4Nuiv;
   }
   driverTbl.glVertexAttrib4Nuiv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4Nusv(GLuint index, const GLushort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4Nusv not available." );
}

static void REGAL_CALL loader_glVertexAttrib4Nusv(GLuint index, const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4Nusv, "glVertexAttrib4Nusv");
   if ( !driverTbl.glVertexAttrib4Nusv ) {
      driverTbl.glVertexAttrib4Nusv = missing_glVertexAttrib4Nusv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4Nusv == loader_glVertexAttrib4Nusv) {
      rCtx->dsp->emuTbl.glVertexAttrib4Nusv = driverTbl.glVertexAttrib4Nusv;
   }
   driverTbl.glVertexAttrib4Nusv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4bv(GLuint index, const GLbyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4bv not available." );
}

static void REGAL_CALL loader_glVertexAttrib4bv(GLuint index, const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4bv, "glVertexAttrib4bv");
   if ( !driverTbl.glVertexAttrib4bv ) {
      driverTbl.glVertexAttrib4bv = missing_glVertexAttrib4bv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4bv == loader_glVertexAttrib4bv) {
      rCtx->dsp->emuTbl.glVertexAttrib4bv = driverTbl.glVertexAttrib4bv;
   }
   driverTbl.glVertexAttrib4bv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttrib4d not available." );
}

static void REGAL_CALL loader_glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4d, "glVertexAttrib4d");
   if ( !driverTbl.glVertexAttrib4d ) {
      driverTbl.glVertexAttrib4d = missing_glVertexAttrib4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4d == loader_glVertexAttrib4d) {
      rCtx->dsp->emuTbl.glVertexAttrib4d = driverTbl.glVertexAttrib4d;
   }
   driverTbl.glVertexAttrib4d(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4dv not available." );
}

static void REGAL_CALL loader_glVertexAttrib4dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4dv, "glVertexAttrib4dv");
   if ( !driverTbl.glVertexAttrib4dv ) {
      driverTbl.glVertexAttrib4dv = missing_glVertexAttrib4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4dv == loader_glVertexAttrib4dv) {
      rCtx->dsp->emuTbl.glVertexAttrib4dv = driverTbl.glVertexAttrib4dv;
   }
   driverTbl.glVertexAttrib4dv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttrib4f not available." );
}

static void REGAL_CALL loader_glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4f, "glVertexAttrib4f");
   if ( !driverTbl.glVertexAttrib4f ) {
      driverTbl.glVertexAttrib4f = missing_glVertexAttrib4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4f == loader_glVertexAttrib4f) {
      rCtx->dsp->emuTbl.glVertexAttrib4f = driverTbl.glVertexAttrib4f;
   }
   driverTbl.glVertexAttrib4f(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4fv(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4fv not available." );
}

static void REGAL_CALL loader_glVertexAttrib4fv(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4fv, "glVertexAttrib4fv");
   if ( !driverTbl.glVertexAttrib4fv ) {
      driverTbl.glVertexAttrib4fv = missing_glVertexAttrib4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4fv == loader_glVertexAttrib4fv) {
      rCtx->dsp->emuTbl.glVertexAttrib4fv = driverTbl.glVertexAttrib4fv;
   }
   driverTbl.glVertexAttrib4fv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4iv(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4iv not available." );
}

static void REGAL_CALL loader_glVertexAttrib4iv(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4iv, "glVertexAttrib4iv");
   if ( !driverTbl.glVertexAttrib4iv ) {
      driverTbl.glVertexAttrib4iv = missing_glVertexAttrib4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4iv == loader_glVertexAttrib4iv) {
      rCtx->dsp->emuTbl.glVertexAttrib4iv = driverTbl.glVertexAttrib4iv;
   }
   driverTbl.glVertexAttrib4iv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttrib4s not available." );
}

static void REGAL_CALL loader_glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4s, "glVertexAttrib4s");
   if ( !driverTbl.glVertexAttrib4s ) {
      driverTbl.glVertexAttrib4s = missing_glVertexAttrib4s;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4s == loader_glVertexAttrib4s) {
      rCtx->dsp->emuTbl.glVertexAttrib4s = driverTbl.glVertexAttrib4s;
   }
   driverTbl.glVertexAttrib4s(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4sv(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4sv not available." );
}

static void REGAL_CALL loader_glVertexAttrib4sv(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4sv, "glVertexAttrib4sv");
   if ( !driverTbl.glVertexAttrib4sv ) {
      driverTbl.glVertexAttrib4sv = missing_glVertexAttrib4sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4sv == loader_glVertexAttrib4sv) {
      rCtx->dsp->emuTbl.glVertexAttrib4sv = driverTbl.glVertexAttrib4sv;
   }
   driverTbl.glVertexAttrib4sv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4ubv(GLuint index, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4ubv not available." );
}

static void REGAL_CALL loader_glVertexAttrib4ubv(GLuint index, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4ubv, "glVertexAttrib4ubv");
   if ( !driverTbl.glVertexAttrib4ubv ) {
      driverTbl.glVertexAttrib4ubv = missing_glVertexAttrib4ubv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4ubv == loader_glVertexAttrib4ubv) {
      rCtx->dsp->emuTbl.glVertexAttrib4ubv = driverTbl.glVertexAttrib4ubv;
   }
   driverTbl.glVertexAttrib4ubv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4uiv(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4uiv not available." );
}

static void REGAL_CALL loader_glVertexAttrib4uiv(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4uiv, "glVertexAttrib4uiv");
   if ( !driverTbl.glVertexAttrib4uiv ) {
      driverTbl.glVertexAttrib4uiv = missing_glVertexAttrib4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4uiv == loader_glVertexAttrib4uiv) {
      rCtx->dsp->emuTbl.glVertexAttrib4uiv = driverTbl.glVertexAttrib4uiv;
   }
   driverTbl.glVertexAttrib4uiv(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4usv(GLuint index, const GLushort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4usv not available." );
}

static void REGAL_CALL loader_glVertexAttrib4usv(GLuint index, const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4usv, "glVertexAttrib4usv");
   if ( !driverTbl.glVertexAttrib4usv ) {
      driverTbl.glVertexAttrib4usv = missing_glVertexAttrib4usv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4usv == loader_glVertexAttrib4usv) {
      rCtx->dsp->emuTbl.glVertexAttrib4usv = driverTbl.glVertexAttrib4usv;
   }
   driverTbl.glVertexAttrib4usv(index, v);
}

static void REGAL_CALL missing_glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glVertexAttribPointer not available." );
}

static void REGAL_CALL loader_glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribPointer, "glVertexAttribPointer");
   if ( !driverTbl.glVertexAttribPointer ) {
      driverTbl.glVertexAttribPointer = missing_glVertexAttribPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribPointer == loader_glVertexAttribPointer) {
      rCtx->dsp->emuTbl.glVertexAttribPointer = driverTbl.glVertexAttribPointer;
   }
   driverTbl.glVertexAttribPointer(index, size, type, normalized, stride, pointer);
}

// GL_VERSION_2_1

static void REGAL_CALL missing_glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix2x3fv not available." );
}

static void REGAL_CALL loader_glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix2x3fv, "glUniformMatrix2x3fv");
   if ( !driverTbl.glUniformMatrix2x3fv ) {
      driverTbl.glUniformMatrix2x3fv = missing_glUniformMatrix2x3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix2x3fv == loader_glUniformMatrix2x3fv) {
      rCtx->dsp->emuTbl.glUniformMatrix2x3fv = driverTbl.glUniformMatrix2x3fv;
   }
   driverTbl.glUniformMatrix2x3fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix2x4fv not available." );
}

static void REGAL_CALL loader_glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix2x4fv, "glUniformMatrix2x4fv");
   if ( !driverTbl.glUniformMatrix2x4fv ) {
      driverTbl.glUniformMatrix2x4fv = missing_glUniformMatrix2x4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix2x4fv == loader_glUniformMatrix2x4fv) {
      rCtx->dsp->emuTbl.glUniformMatrix2x4fv = driverTbl.glUniformMatrix2x4fv;
   }
   driverTbl.glUniformMatrix2x4fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix3x2fv not available." );
}

static void REGAL_CALL loader_glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix3x2fv, "glUniformMatrix3x2fv");
   if ( !driverTbl.glUniformMatrix3x2fv ) {
      driverTbl.glUniformMatrix3x2fv = missing_glUniformMatrix3x2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix3x2fv == loader_glUniformMatrix3x2fv) {
      rCtx->dsp->emuTbl.glUniformMatrix3x2fv = driverTbl.glUniformMatrix3x2fv;
   }
   driverTbl.glUniformMatrix3x2fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix3x4fv not available." );
}

static void REGAL_CALL loader_glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix3x4fv, "glUniformMatrix3x4fv");
   if ( !driverTbl.glUniformMatrix3x4fv ) {
      driverTbl.glUniformMatrix3x4fv = missing_glUniformMatrix3x4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix3x4fv == loader_glUniformMatrix3x4fv) {
      rCtx->dsp->emuTbl.glUniformMatrix3x4fv = driverTbl.glUniformMatrix3x4fv;
   }
   driverTbl.glUniformMatrix3x4fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix4x2fv not available." );
}

static void REGAL_CALL loader_glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix4x2fv, "glUniformMatrix4x2fv");
   if ( !driverTbl.glUniformMatrix4x2fv ) {
      driverTbl.glUniformMatrix4x2fv = missing_glUniformMatrix4x2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix4x2fv == loader_glUniformMatrix4x2fv) {
      rCtx->dsp->emuTbl.glUniformMatrix4x2fv = driverTbl.glUniformMatrix4x2fv;
   }
   driverTbl.glUniformMatrix4x2fv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix4x3fv not available." );
}

static void REGAL_CALL loader_glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix4x3fv, "glUniformMatrix4x3fv");
   if ( !driverTbl.glUniformMatrix4x3fv ) {
      driverTbl.glUniformMatrix4x3fv = missing_glUniformMatrix4x3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix4x3fv == loader_glUniformMatrix4x3fv) {
      rCtx->dsp->emuTbl.glUniformMatrix4x3fv = driverTbl.glUniformMatrix4x3fv;
   }
   driverTbl.glUniformMatrix4x3fv(location, count, transpose, value);
}

// GL_VERSION_3_0

static void REGAL_CALL missing_glBeginConditionalRender(GLuint id, GLenum mode)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(mode);
   Warning( "glBeginConditionalRender not available." );
}

static void REGAL_CALL loader_glBeginConditionalRender(GLuint id, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBeginConditionalRender, "glBeginConditionalRender");
   if ( !driverTbl.glBeginConditionalRender ) {
      driverTbl.glBeginConditionalRender = missing_glBeginConditionalRender;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBeginConditionalRender == loader_glBeginConditionalRender) {
      rCtx->dsp->emuTbl.glBeginConditionalRender = driverTbl.glBeginConditionalRender;
   }
   driverTbl.glBeginConditionalRender(id, mode);
}

static void REGAL_CALL missing_glBeginTransformFeedback(GLenum primitiveMode)
{
   UNUSED_PARAMETER(primitiveMode);
   Warning( "glBeginTransformFeedback not available." );
}

static void REGAL_CALL loader_glBeginTransformFeedback(GLenum primitiveMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBeginTransformFeedback, "glBeginTransformFeedback");
   if ( !driverTbl.glBeginTransformFeedback ) {
      driverTbl.glBeginTransformFeedback = missing_glBeginTransformFeedback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBeginTransformFeedback == loader_glBeginTransformFeedback) {
      rCtx->dsp->emuTbl.glBeginTransformFeedback = driverTbl.glBeginTransformFeedback;
   }
   driverTbl.glBeginTransformFeedback(primitiveMode);
}

static void REGAL_CALL missing_glBindFragDataLocation(GLuint program, GLuint color, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(color);
   UNUSED_PARAMETER(name);
   Warning( "glBindFragDataLocation not available." );
}

static void REGAL_CALL loader_glBindFragDataLocation(GLuint program, GLuint color, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindFragDataLocation, "glBindFragDataLocation");
   if ( !driverTbl.glBindFragDataLocation ) {
      driverTbl.glBindFragDataLocation = missing_glBindFragDataLocation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindFragDataLocation == loader_glBindFragDataLocation) {
      rCtx->dsp->emuTbl.glBindFragDataLocation = driverTbl.glBindFragDataLocation;
   }
   driverTbl.glBindFragDataLocation(program, color, name);
}

static void REGAL_CALL missing_glClampColor(GLenum target, GLenum clamp)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(clamp);
   Warning( "glClampColor not available." );
}

static void REGAL_CALL loader_glClampColor(GLenum target, GLenum clamp)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClampColor, "glClampColor");
   if ( !driverTbl.glClampColor ) {
      driverTbl.glClampColor = missing_glClampColor;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClampColor == loader_glClampColor) {
      rCtx->dsp->emuTbl.glClampColor = driverTbl.glClampColor;
   }
   driverTbl.glClampColor(target, clamp);
}

static void REGAL_CALL missing_glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(drawbuffer);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(stencil);
   Warning( "glClearBufferfi not available." );
}

static void REGAL_CALL loader_glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearBufferfi, "glClearBufferfi");
   if ( !driverTbl.glClearBufferfi ) {
      driverTbl.glClearBufferfi = missing_glClearBufferfi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearBufferfi == loader_glClearBufferfi) {
      rCtx->dsp->emuTbl.glClearBufferfi = driverTbl.glClearBufferfi;
   }
   driverTbl.glClearBufferfi(buffer, drawbuffer, depth, stencil);
}

static void REGAL_CALL missing_glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(drawbuffer);
   UNUSED_PARAMETER(value);
   Warning( "glClearBufferfv not available." );
}

static void REGAL_CALL loader_glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearBufferfv, "glClearBufferfv");
   if ( !driverTbl.glClearBufferfv ) {
      driverTbl.glClearBufferfv = missing_glClearBufferfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearBufferfv == loader_glClearBufferfv) {
      rCtx->dsp->emuTbl.glClearBufferfv = driverTbl.glClearBufferfv;
   }
   driverTbl.glClearBufferfv(buffer, drawbuffer, value);
}

static void REGAL_CALL missing_glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(drawbuffer);
   UNUSED_PARAMETER(value);
   Warning( "glClearBufferiv not available." );
}

static void REGAL_CALL loader_glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearBufferiv, "glClearBufferiv");
   if ( !driverTbl.glClearBufferiv ) {
      driverTbl.glClearBufferiv = missing_glClearBufferiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearBufferiv == loader_glClearBufferiv) {
      rCtx->dsp->emuTbl.glClearBufferiv = driverTbl.glClearBufferiv;
   }
   driverTbl.glClearBufferiv(buffer, drawbuffer, value);
}

static void REGAL_CALL missing_glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(drawbuffer);
   UNUSED_PARAMETER(value);
   Warning( "glClearBufferuiv not available." );
}

static void REGAL_CALL loader_glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearBufferuiv, "glClearBufferuiv");
   if ( !driverTbl.glClearBufferuiv ) {
      driverTbl.glClearBufferuiv = missing_glClearBufferuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearBufferuiv == loader_glClearBufferuiv) {
      rCtx->dsp->emuTbl.glClearBufferuiv = driverTbl.glClearBufferuiv;
   }
   driverTbl.glClearBufferuiv(buffer, drawbuffer, value);
}

static void REGAL_CALL missing_glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   Warning( "glColorMaski not available." );
}

static void REGAL_CALL loader_glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorMaski, "glColorMaski");
   if ( !driverTbl.glColorMaski ) {
      driverTbl.glColorMaski = missing_glColorMaski;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorMaski == loader_glColorMaski) {
      rCtx->dsp->emuTbl.glColorMaski = driverTbl.glColorMaski;
   }
   driverTbl.glColorMaski(index, r, g, b, a);
}

static void REGAL_CALL missing_glDisablei(GLenum cap, GLuint index)
{
   UNUSED_PARAMETER(cap);
   UNUSED_PARAMETER(index);
   Warning( "glDisablei not available." );
}

static void REGAL_CALL loader_glDisablei(GLenum cap, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDisablei, "glDisablei");
   if ( !driverTbl.glDisablei ) {
      driverTbl.glDisablei = missing_glDisablei;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDisablei == loader_glDisablei) {
      rCtx->dsp->emuTbl.glDisablei = driverTbl.glDisablei;
   }
   driverTbl.glDisablei(cap, index);
}

static void REGAL_CALL missing_glEnablei(GLenum cap, GLuint index)
{
   UNUSED_PARAMETER(cap);
   UNUSED_PARAMETER(index);
   Warning( "glEnablei not available." );
}

static void REGAL_CALL loader_glEnablei(GLenum cap, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEnablei, "glEnablei");
   if ( !driverTbl.glEnablei ) {
      driverTbl.glEnablei = missing_glEnablei;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEnablei == loader_glEnablei) {
      rCtx->dsp->emuTbl.glEnablei = driverTbl.glEnablei;
   }
   driverTbl.glEnablei(cap, index);
}

static void REGAL_CALL missing_glEndConditionalRender(void)
{
   Warning( "glEndConditionalRender not available." );
}

static void REGAL_CALL loader_glEndConditionalRender(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndConditionalRender, "glEndConditionalRender");
   if ( !driverTbl.glEndConditionalRender ) {
      driverTbl.glEndConditionalRender = missing_glEndConditionalRender;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndConditionalRender == loader_glEndConditionalRender) {
      rCtx->dsp->emuTbl.glEndConditionalRender = driverTbl.glEndConditionalRender;
   }
   driverTbl.glEndConditionalRender();
}

static void REGAL_CALL missing_glEndTransformFeedback(void)
{
   Warning( "glEndTransformFeedback not available." );
}

static void REGAL_CALL loader_glEndTransformFeedback(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndTransformFeedback, "glEndTransformFeedback");
   if ( !driverTbl.glEndTransformFeedback ) {
      driverTbl.glEndTransformFeedback = missing_glEndTransformFeedback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndTransformFeedback == loader_glEndTransformFeedback) {
      rCtx->dsp->emuTbl.glEndTransformFeedback = driverTbl.glEndTransformFeedback;
   }
   driverTbl.glEndTransformFeedback();
}

static void REGAL_CALL missing_glGetBooleani_v(GLenum target, GLuint index, GLboolean *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "glGetBooleani_v not available." );
}

static void REGAL_CALL loader_glGetBooleani_v(GLenum target, GLuint index, GLboolean *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetBooleani_v, "glGetBooleani_v");
   if ( !driverTbl.glGetBooleani_v ) {
      driverTbl.glGetBooleani_v = missing_glGetBooleani_v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetBooleani_v == loader_glGetBooleani_v) {
      rCtx->dsp->emuTbl.glGetBooleani_v = driverTbl.glGetBooleani_v;
   }
   driverTbl.glGetBooleani_v(target, index, data);
}

static GLint REGAL_CALL missing_glGetFragDataLocation(GLuint program, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(name);
   Warning( "glGetFragDataLocation not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetFragDataLocation(GLuint program, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFragDataLocation, "glGetFragDataLocation");
   if ( !driverTbl.glGetFragDataLocation ) {
      driverTbl.glGetFragDataLocation = missing_glGetFragDataLocation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFragDataLocation == loader_glGetFragDataLocation) {
      rCtx->dsp->emuTbl.glGetFragDataLocation = driverTbl.glGetFragDataLocation;
   }
   return driverTbl.glGetFragDataLocation(program, name);
}

static const GLubyte *REGAL_CALL missing_glGetStringi(GLenum name, GLuint index)
{
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(index);
   Warning( "glGetStringi not available." );
  const GLubyte * ret = NULL;
  return ret;
}

static const GLubyte *REGAL_CALL loader_glGetStringi(GLenum name, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetStringi, "glGetStringi");
   if ( !driverTbl.glGetStringi ) {
      driverTbl.glGetStringi = missing_glGetStringi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetStringi == loader_glGetStringi) {
      rCtx->dsp->emuTbl.glGetStringi = driverTbl.glGetStringi;
   }
   return driverTbl.glGetStringi(name, index);
}

static void REGAL_CALL missing_glGetTexParameterIiv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTexParameterIiv not available." );
}

static void REGAL_CALL loader_glGetTexParameterIiv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexParameterIiv, "glGetTexParameterIiv");
   if ( !driverTbl.glGetTexParameterIiv ) {
      driverTbl.glGetTexParameterIiv = missing_glGetTexParameterIiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexParameterIiv == loader_glGetTexParameterIiv) {
      rCtx->dsp->emuTbl.glGetTexParameterIiv = driverTbl.glGetTexParameterIiv;
   }
   driverTbl.glGetTexParameterIiv(target, pname, params);
}

static void REGAL_CALL missing_glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTexParameterIuiv not available." );
}

static void REGAL_CALL loader_glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexParameterIuiv, "glGetTexParameterIuiv");
   if ( !driverTbl.glGetTexParameterIuiv ) {
      driverTbl.glGetTexParameterIuiv = missing_glGetTexParameterIuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexParameterIuiv == loader_glGetTexParameterIuiv) {
      rCtx->dsp->emuTbl.glGetTexParameterIuiv = driverTbl.glGetTexParameterIuiv;
   }
   driverTbl.glGetTexParameterIuiv(target, pname, params);
}

static void REGAL_CALL missing_glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(name);
   Warning( "glGetTransformFeedbackVarying not available." );
}

static void REGAL_CALL loader_glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTransformFeedbackVarying, "glGetTransformFeedbackVarying");
   if ( !driverTbl.glGetTransformFeedbackVarying ) {
      driverTbl.glGetTransformFeedbackVarying = missing_glGetTransformFeedbackVarying;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTransformFeedbackVarying == loader_glGetTransformFeedbackVarying) {
      rCtx->dsp->emuTbl.glGetTransformFeedbackVarying = driverTbl.glGetTransformFeedbackVarying;
   }
   driverTbl.glGetTransformFeedbackVarying(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL missing_glGetUniformuiv(GLuint program, GLint location, GLuint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "glGetUniformuiv not available." );
}

static void REGAL_CALL loader_glGetUniformuiv(GLuint program, GLint location, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformuiv, "glGetUniformuiv");
   if ( !driverTbl.glGetUniformuiv ) {
      driverTbl.glGetUniformuiv = missing_glGetUniformuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformuiv == loader_glGetUniformuiv) {
      rCtx->dsp->emuTbl.glGetUniformuiv = driverTbl.glGetUniformuiv;
   }
   driverTbl.glGetUniformuiv(program, location, params);
}

static void REGAL_CALL missing_glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribIiv not available." );
}

static void REGAL_CALL loader_glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribIiv, "glGetVertexAttribIiv");
   if ( !driverTbl.glGetVertexAttribIiv ) {
      driverTbl.glGetVertexAttribIiv = missing_glGetVertexAttribIiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribIiv == loader_glGetVertexAttribIiv) {
      rCtx->dsp->emuTbl.glGetVertexAttribIiv = driverTbl.glGetVertexAttribIiv;
   }
   driverTbl.glGetVertexAttribIiv(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribIuiv not available." );
}

static void REGAL_CALL loader_glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribIuiv, "glGetVertexAttribIuiv");
   if ( !driverTbl.glGetVertexAttribIuiv ) {
      driverTbl.glGetVertexAttribIuiv = missing_glGetVertexAttribIuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribIuiv == loader_glGetVertexAttribIuiv) {
      rCtx->dsp->emuTbl.glGetVertexAttribIuiv = driverTbl.glGetVertexAttribIuiv;
   }
   driverTbl.glGetVertexAttribIuiv(index, pname, params);
}

static GLboolean REGAL_CALL missing_glIsEnabledi(GLenum target, GLuint index)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   Warning( "glIsEnabledi not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsEnabledi(GLenum target, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsEnabledi, "glIsEnabledi");
   if ( !driverTbl.glIsEnabledi ) {
      driverTbl.glIsEnabledi = missing_glIsEnabledi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsEnabledi == loader_glIsEnabledi) {
      rCtx->dsp->emuTbl.glIsEnabledi = driverTbl.glIsEnabledi;
   }
   return driverTbl.glIsEnabledi(target, index);
}

static void REGAL_CALL missing_glTexParameterIiv(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glTexParameterIiv not available." );
}

static void REGAL_CALL loader_glTexParameterIiv(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexParameterIiv, "glTexParameterIiv");
   if ( !driverTbl.glTexParameterIiv ) {
      driverTbl.glTexParameterIiv = missing_glTexParameterIiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexParameterIiv == loader_glTexParameterIiv) {
      rCtx->dsp->emuTbl.glTexParameterIiv = driverTbl.glTexParameterIiv;
   }
   driverTbl.glTexParameterIiv(target, pname, params);
}

static void REGAL_CALL missing_glTexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glTexParameterIuiv not available." );
}

static void REGAL_CALL loader_glTexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexParameterIuiv, "glTexParameterIuiv");
   if ( !driverTbl.glTexParameterIuiv ) {
      driverTbl.glTexParameterIuiv = missing_glTexParameterIuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexParameterIuiv == loader_glTexParameterIuiv) {
      rCtx->dsp->emuTbl.glTexParameterIuiv = driverTbl.glTexParameterIuiv;
   }
   driverTbl.glTexParameterIuiv(target, pname, params);
}

static void REGAL_CALL missing_glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar **varyings, GLenum bufferMode)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(varyings);
   UNUSED_PARAMETER(bufferMode);
   Warning( "glTransformFeedbackVaryings not available." );
}

static void REGAL_CALL loader_glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar **varyings, GLenum bufferMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTransformFeedbackVaryings, "glTransformFeedbackVaryings");
   if ( !driverTbl.glTransformFeedbackVaryings ) {
      driverTbl.glTransformFeedbackVaryings = missing_glTransformFeedbackVaryings;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTransformFeedbackVaryings == loader_glTransformFeedbackVaryings) {
      rCtx->dsp->emuTbl.glTransformFeedbackVaryings = driverTbl.glTransformFeedbackVaryings;
   }
   driverTbl.glTransformFeedbackVaryings(program, count, varyings, bufferMode);
}

static void REGAL_CALL missing_glUniform1ui(GLint location, GLuint v0)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "glUniform1ui not available." );
}

static void REGAL_CALL loader_glUniform1ui(GLint location, GLuint v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1ui, "glUniform1ui");
   if ( !driverTbl.glUniform1ui ) {
      driverTbl.glUniform1ui = missing_glUniform1ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1ui == loader_glUniform1ui) {
      rCtx->dsp->emuTbl.glUniform1ui = driverTbl.glUniform1ui;
   }
   driverTbl.glUniform1ui(location, v0);
}

static void REGAL_CALL missing_glUniform1uiv(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform1uiv not available." );
}

static void REGAL_CALL loader_glUniform1uiv(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1uiv, "glUniform1uiv");
   if ( !driverTbl.glUniform1uiv ) {
      driverTbl.glUniform1uiv = missing_glUniform1uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1uiv == loader_glUniform1uiv) {
      rCtx->dsp->emuTbl.glUniform1uiv = driverTbl.glUniform1uiv;
   }
   driverTbl.glUniform1uiv(location, count, value);
}

static void REGAL_CALL missing_glUniform2ui(GLint location, GLuint v0, GLuint v1)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "glUniform2ui not available." );
}

static void REGAL_CALL loader_glUniform2ui(GLint location, GLuint v0, GLuint v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2ui, "glUniform2ui");
   if ( !driverTbl.glUniform2ui ) {
      driverTbl.glUniform2ui = missing_glUniform2ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2ui == loader_glUniform2ui) {
      rCtx->dsp->emuTbl.glUniform2ui = driverTbl.glUniform2ui;
   }
   driverTbl.glUniform2ui(location, v0, v1);
}

static void REGAL_CALL missing_glUniform2uiv(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform2uiv not available." );
}

static void REGAL_CALL loader_glUniform2uiv(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2uiv, "glUniform2uiv");
   if ( !driverTbl.glUniform2uiv ) {
      driverTbl.glUniform2uiv = missing_glUniform2uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2uiv == loader_glUniform2uiv) {
      rCtx->dsp->emuTbl.glUniform2uiv = driverTbl.glUniform2uiv;
   }
   driverTbl.glUniform2uiv(location, count, value);
}

static void REGAL_CALL missing_glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glUniform3ui not available." );
}

static void REGAL_CALL loader_glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3ui, "glUniform3ui");
   if ( !driverTbl.glUniform3ui ) {
      driverTbl.glUniform3ui = missing_glUniform3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3ui == loader_glUniform3ui) {
      rCtx->dsp->emuTbl.glUniform3ui = driverTbl.glUniform3ui;
   }
   driverTbl.glUniform3ui(location, v0, v1, v2);
}

static void REGAL_CALL missing_glUniform3uiv(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform3uiv not available." );
}

static void REGAL_CALL loader_glUniform3uiv(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3uiv, "glUniform3uiv");
   if ( !driverTbl.glUniform3uiv ) {
      driverTbl.glUniform3uiv = missing_glUniform3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3uiv == loader_glUniform3uiv) {
      rCtx->dsp->emuTbl.glUniform3uiv = driverTbl.glUniform3uiv;
   }
   driverTbl.glUniform3uiv(location, count, value);
}

static void REGAL_CALL missing_glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "glUniform4ui not available." );
}

static void REGAL_CALL loader_glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4ui, "glUniform4ui");
   if ( !driverTbl.glUniform4ui ) {
      driverTbl.glUniform4ui = missing_glUniform4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4ui == loader_glUniform4ui) {
      rCtx->dsp->emuTbl.glUniform4ui = driverTbl.glUniform4ui;
   }
   driverTbl.glUniform4ui(location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glUniform4uiv(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform4uiv not available." );
}

static void REGAL_CALL loader_glUniform4uiv(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4uiv, "glUniform4uiv");
   if ( !driverTbl.glUniform4uiv ) {
      driverTbl.glUniform4uiv = missing_glUniform4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4uiv == loader_glUniform4uiv) {
      rCtx->dsp->emuTbl.glUniform4uiv = driverTbl.glUniform4uiv;
   }
   driverTbl.glUniform4uiv(location, count, value);
}

static void REGAL_CALL missing_glVertexAttribI1i(GLuint index, GLint x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttribI1i not available." );
}

static void REGAL_CALL loader_glVertexAttribI1i(GLuint index, GLint x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI1i, "glVertexAttribI1i");
   if ( !driverTbl.glVertexAttribI1i ) {
      driverTbl.glVertexAttribI1i = missing_glVertexAttribI1i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI1i == loader_glVertexAttribI1i) {
      rCtx->dsp->emuTbl.glVertexAttribI1i = driverTbl.glVertexAttribI1i;
   }
   driverTbl.glVertexAttribI1i(index, x);
}

static void REGAL_CALL missing_glVertexAttribI1iv(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI1iv not available." );
}

static void REGAL_CALL loader_glVertexAttribI1iv(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI1iv, "glVertexAttribI1iv");
   if ( !driverTbl.glVertexAttribI1iv ) {
      driverTbl.glVertexAttribI1iv = missing_glVertexAttribI1iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI1iv == loader_glVertexAttribI1iv) {
      rCtx->dsp->emuTbl.glVertexAttribI1iv = driverTbl.glVertexAttribI1iv;
   }
   driverTbl.glVertexAttribI1iv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI1ui(GLuint index, GLuint x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttribI1ui not available." );
}

static void REGAL_CALL loader_glVertexAttribI1ui(GLuint index, GLuint x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI1ui, "glVertexAttribI1ui");
   if ( !driverTbl.glVertexAttribI1ui ) {
      driverTbl.glVertexAttribI1ui = missing_glVertexAttribI1ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI1ui == loader_glVertexAttribI1ui) {
      rCtx->dsp->emuTbl.glVertexAttribI1ui = driverTbl.glVertexAttribI1ui;
   }
   driverTbl.glVertexAttribI1ui(index, x);
}

static void REGAL_CALL missing_glVertexAttribI1uiv(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI1uiv not available." );
}

static void REGAL_CALL loader_glVertexAttribI1uiv(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI1uiv, "glVertexAttribI1uiv");
   if ( !driverTbl.glVertexAttribI1uiv ) {
      driverTbl.glVertexAttribI1uiv = missing_glVertexAttribI1uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI1uiv == loader_glVertexAttribI1uiv) {
      rCtx->dsp->emuTbl.glVertexAttribI1uiv = driverTbl.glVertexAttribI1uiv;
   }
   driverTbl.glVertexAttribI1uiv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI2i(GLuint index, GLint x, GLint y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttribI2i not available." );
}

static void REGAL_CALL loader_glVertexAttribI2i(GLuint index, GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI2i, "glVertexAttribI2i");
   if ( !driverTbl.glVertexAttribI2i ) {
      driverTbl.glVertexAttribI2i = missing_glVertexAttribI2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI2i == loader_glVertexAttribI2i) {
      rCtx->dsp->emuTbl.glVertexAttribI2i = driverTbl.glVertexAttribI2i;
   }
   driverTbl.glVertexAttribI2i(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribI2iv(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI2iv not available." );
}

static void REGAL_CALL loader_glVertexAttribI2iv(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI2iv, "glVertexAttribI2iv");
   if ( !driverTbl.glVertexAttribI2iv ) {
      driverTbl.glVertexAttribI2iv = missing_glVertexAttribI2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI2iv == loader_glVertexAttribI2iv) {
      rCtx->dsp->emuTbl.glVertexAttribI2iv = driverTbl.glVertexAttribI2iv;
   }
   driverTbl.glVertexAttribI2iv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI2ui(GLuint index, GLuint x, GLuint y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttribI2ui not available." );
}

static void REGAL_CALL loader_glVertexAttribI2ui(GLuint index, GLuint x, GLuint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI2ui, "glVertexAttribI2ui");
   if ( !driverTbl.glVertexAttribI2ui ) {
      driverTbl.glVertexAttribI2ui = missing_glVertexAttribI2ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI2ui == loader_glVertexAttribI2ui) {
      rCtx->dsp->emuTbl.glVertexAttribI2ui = driverTbl.glVertexAttribI2ui;
   }
   driverTbl.glVertexAttribI2ui(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribI2uiv(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI2uiv not available." );
}

static void REGAL_CALL loader_glVertexAttribI2uiv(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI2uiv, "glVertexAttribI2uiv");
   if ( !driverTbl.glVertexAttribI2uiv ) {
      driverTbl.glVertexAttribI2uiv = missing_glVertexAttribI2uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI2uiv == loader_glVertexAttribI2uiv) {
      rCtx->dsp->emuTbl.glVertexAttribI2uiv = driverTbl.glVertexAttribI2uiv;
   }
   driverTbl.glVertexAttribI2uiv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttribI3i not available." );
}

static void REGAL_CALL loader_glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI3i, "glVertexAttribI3i");
   if ( !driverTbl.glVertexAttribI3i ) {
      driverTbl.glVertexAttribI3i = missing_glVertexAttribI3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI3i == loader_glVertexAttribI3i) {
      rCtx->dsp->emuTbl.glVertexAttribI3i = driverTbl.glVertexAttribI3i;
   }
   driverTbl.glVertexAttribI3i(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribI3iv(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI3iv not available." );
}

static void REGAL_CALL loader_glVertexAttribI3iv(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI3iv, "glVertexAttribI3iv");
   if ( !driverTbl.glVertexAttribI3iv ) {
      driverTbl.glVertexAttribI3iv = missing_glVertexAttribI3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI3iv == loader_glVertexAttribI3iv) {
      rCtx->dsp->emuTbl.glVertexAttribI3iv = driverTbl.glVertexAttribI3iv;
   }
   driverTbl.glVertexAttribI3iv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttribI3ui not available." );
}

static void REGAL_CALL loader_glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI3ui, "glVertexAttribI3ui");
   if ( !driverTbl.glVertexAttribI3ui ) {
      driverTbl.glVertexAttribI3ui = missing_glVertexAttribI3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI3ui == loader_glVertexAttribI3ui) {
      rCtx->dsp->emuTbl.glVertexAttribI3ui = driverTbl.glVertexAttribI3ui;
   }
   driverTbl.glVertexAttribI3ui(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribI3uiv(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI3uiv not available." );
}

static void REGAL_CALL loader_glVertexAttribI3uiv(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI3uiv, "glVertexAttribI3uiv");
   if ( !driverTbl.glVertexAttribI3uiv ) {
      driverTbl.glVertexAttribI3uiv = missing_glVertexAttribI3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI3uiv == loader_glVertexAttribI3uiv) {
      rCtx->dsp->emuTbl.glVertexAttribI3uiv = driverTbl.glVertexAttribI3uiv;
   }
   driverTbl.glVertexAttribI3uiv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4bv(GLuint index, const GLbyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI4bv not available." );
}

static void REGAL_CALL loader_glVertexAttribI4bv(GLuint index, const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4bv, "glVertexAttribI4bv");
   if ( !driverTbl.glVertexAttribI4bv ) {
      driverTbl.glVertexAttribI4bv = missing_glVertexAttribI4bv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4bv == loader_glVertexAttribI4bv) {
      rCtx->dsp->emuTbl.glVertexAttribI4bv = driverTbl.glVertexAttribI4bv;
   }
   driverTbl.glVertexAttribI4bv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttribI4i not available." );
}

static void REGAL_CALL loader_glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4i, "glVertexAttribI4i");
   if ( !driverTbl.glVertexAttribI4i ) {
      driverTbl.glVertexAttribI4i = missing_glVertexAttribI4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4i == loader_glVertexAttribI4i) {
      rCtx->dsp->emuTbl.glVertexAttribI4i = driverTbl.glVertexAttribI4i;
   }
   driverTbl.glVertexAttribI4i(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribI4iv(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI4iv not available." );
}

static void REGAL_CALL loader_glVertexAttribI4iv(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4iv, "glVertexAttribI4iv");
   if ( !driverTbl.glVertexAttribI4iv ) {
      driverTbl.glVertexAttribI4iv = missing_glVertexAttribI4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4iv == loader_glVertexAttribI4iv) {
      rCtx->dsp->emuTbl.glVertexAttribI4iv = driverTbl.glVertexAttribI4iv;
   }
   driverTbl.glVertexAttribI4iv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4sv(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI4sv not available." );
}

static void REGAL_CALL loader_glVertexAttribI4sv(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4sv, "glVertexAttribI4sv");
   if ( !driverTbl.glVertexAttribI4sv ) {
      driverTbl.glVertexAttribI4sv = missing_glVertexAttribI4sv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4sv == loader_glVertexAttribI4sv) {
      rCtx->dsp->emuTbl.glVertexAttribI4sv = driverTbl.glVertexAttribI4sv;
   }
   driverTbl.glVertexAttribI4sv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4ubv(GLuint index, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI4ubv not available." );
}

static void REGAL_CALL loader_glVertexAttribI4ubv(GLuint index, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4ubv, "glVertexAttribI4ubv");
   if ( !driverTbl.glVertexAttribI4ubv ) {
      driverTbl.glVertexAttribI4ubv = missing_glVertexAttribI4ubv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4ubv == loader_glVertexAttribI4ubv) {
      rCtx->dsp->emuTbl.glVertexAttribI4ubv = driverTbl.glVertexAttribI4ubv;
   }
   driverTbl.glVertexAttribI4ubv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttribI4ui not available." );
}

static void REGAL_CALL loader_glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4ui, "glVertexAttribI4ui");
   if ( !driverTbl.glVertexAttribI4ui ) {
      driverTbl.glVertexAttribI4ui = missing_glVertexAttribI4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4ui == loader_glVertexAttribI4ui) {
      rCtx->dsp->emuTbl.glVertexAttribI4ui = driverTbl.glVertexAttribI4ui;
   }
   driverTbl.glVertexAttribI4ui(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribI4uiv(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI4uiv not available." );
}

static void REGAL_CALL loader_glVertexAttribI4uiv(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4uiv, "glVertexAttribI4uiv");
   if ( !driverTbl.glVertexAttribI4uiv ) {
      driverTbl.glVertexAttribI4uiv = missing_glVertexAttribI4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4uiv == loader_glVertexAttribI4uiv) {
      rCtx->dsp->emuTbl.glVertexAttribI4uiv = driverTbl.glVertexAttribI4uiv;
   }
   driverTbl.glVertexAttribI4uiv(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4usv(GLuint index, const GLushort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI4usv not available." );
}

static void REGAL_CALL loader_glVertexAttribI4usv(GLuint index, const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4usv, "glVertexAttribI4usv");
   if ( !driverTbl.glVertexAttribI4usv ) {
      driverTbl.glVertexAttribI4usv = missing_glVertexAttribI4usv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4usv == loader_glVertexAttribI4usv) {
      rCtx->dsp->emuTbl.glVertexAttribI4usv = driverTbl.glVertexAttribI4usv;
   }
   driverTbl.glVertexAttribI4usv(index, v);
}

static void REGAL_CALL missing_glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glVertexAttribIPointer not available." );
}

static void REGAL_CALL loader_glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribIPointer, "glVertexAttribIPointer");
   if ( !driverTbl.glVertexAttribIPointer ) {
      driverTbl.glVertexAttribIPointer = missing_glVertexAttribIPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribIPointer == loader_glVertexAttribIPointer) {
      rCtx->dsp->emuTbl.glVertexAttribIPointer = driverTbl.glVertexAttribIPointer;
   }
   driverTbl.glVertexAttribIPointer(index, size, type, stride, pointer);
}

// GL_VERSION_3_1

static void REGAL_CALL missing_glDrawArraysInstanced(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   Warning( "glDrawArraysInstanced not available." );
}

static void REGAL_CALL loader_glDrawArraysInstanced(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawArraysInstanced, "glDrawArraysInstanced");
   if ( !driverTbl.glDrawArraysInstanced ) {
      driverTbl.glDrawArraysInstanced = missing_glDrawArraysInstanced;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawArraysInstanced == loader_glDrawArraysInstanced) {
      rCtx->dsp->emuTbl.glDrawArraysInstanced = driverTbl.glDrawArraysInstanced;
   }
   driverTbl.glDrawArraysInstanced(mode, start, count, primcount);
}

static void REGAL_CALL missing_glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   Warning( "glDrawElementsInstanced not available." );
}

static void REGAL_CALL loader_glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawElementsInstanced, "glDrawElementsInstanced");
   if ( !driverTbl.glDrawElementsInstanced ) {
      driverTbl.glDrawElementsInstanced = missing_glDrawElementsInstanced;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawElementsInstanced == loader_glDrawElementsInstanced) {
      rCtx->dsp->emuTbl.glDrawElementsInstanced = driverTbl.glDrawElementsInstanced;
   }
   driverTbl.glDrawElementsInstanced(mode, count, type, indices, primcount);
}

static void REGAL_CALL missing_glPrimitiveRestartIndex(GLuint index)
{
   UNUSED_PARAMETER(index);
   Warning( "glPrimitiveRestartIndex not available." );
}

static void REGAL_CALL loader_glPrimitiveRestartIndex(GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPrimitiveRestartIndex, "glPrimitiveRestartIndex");
   if ( !driverTbl.glPrimitiveRestartIndex ) {
      driverTbl.glPrimitiveRestartIndex = missing_glPrimitiveRestartIndex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPrimitiveRestartIndex == loader_glPrimitiveRestartIndex) {
      rCtx->dsp->emuTbl.glPrimitiveRestartIndex = driverTbl.glPrimitiveRestartIndex;
   }
   driverTbl.glPrimitiveRestartIndex(index);
}

static void REGAL_CALL missing_glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(buffer);
   Warning( "glTexBuffer not available." );
}

static void REGAL_CALL loader_glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexBuffer, "glTexBuffer");
   if ( !driverTbl.glTexBuffer ) {
      driverTbl.glTexBuffer = missing_glTexBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexBuffer == loader_glTexBuffer) {
      rCtx->dsp->emuTbl.glTexBuffer = driverTbl.glTexBuffer;
   }
   driverTbl.glTexBuffer(target, internalformat, buffer);
}

// GL_VERSION_3_2

static void REGAL_CALL missing_glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "glFramebufferTexture not available." );
}

static void REGAL_CALL loader_glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTexture, "glFramebufferTexture");
   if ( !driverTbl.glFramebufferTexture ) {
      driverTbl.glFramebufferTexture = missing_glFramebufferTexture;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTexture == loader_glFramebufferTexture) {
      rCtx->dsp->emuTbl.glFramebufferTexture = driverTbl.glFramebufferTexture;
   }
   driverTbl.glFramebufferTexture(target, attachment, texture, level);
}

static void REGAL_CALL missing_glFramebufferTextureFace(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(face);
   Warning( "glFramebufferTextureFace not available." );
}

static void REGAL_CALL loader_glFramebufferTextureFace(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTextureFace, "glFramebufferTextureFace");
   if ( !driverTbl.glFramebufferTextureFace ) {
      driverTbl.glFramebufferTextureFace = missing_glFramebufferTextureFace;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTextureFace == loader_glFramebufferTextureFace) {
      rCtx->dsp->emuTbl.glFramebufferTextureFace = driverTbl.glFramebufferTextureFace;
   }
   driverTbl.glFramebufferTextureFace(target, attachment, texture, level, face);
}

static void REGAL_CALL missing_glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetBufferParameteri64v not available." );
}

static void REGAL_CALL loader_glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetBufferParameteri64v, "glGetBufferParameteri64v");
   if ( !driverTbl.glGetBufferParameteri64v ) {
      driverTbl.glGetBufferParameteri64v = missing_glGetBufferParameteri64v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetBufferParameteri64v == loader_glGetBufferParameteri64v) {
      rCtx->dsp->emuTbl.glGetBufferParameteri64v = driverTbl.glGetBufferParameteri64v;
   }
   driverTbl.glGetBufferParameteri64v(target, pname, params);
}

static void REGAL_CALL missing_glGetInteger64i_v(GLenum target, GLuint index, GLint64 *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "glGetInteger64i_v not available." );
}

static void REGAL_CALL loader_glGetInteger64i_v(GLenum target, GLuint index, GLint64 *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetInteger64i_v, "glGetInteger64i_v");
   if ( !driverTbl.glGetInteger64i_v ) {
      driverTbl.glGetInteger64i_v = missing_glGetInteger64i_v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetInteger64i_v == loader_glGetInteger64i_v) {
      rCtx->dsp->emuTbl.glGetInteger64i_v = driverTbl.glGetInteger64i_v;
   }
   driverTbl.glGetInteger64i_v(target, index, data);
}

// GL_VERSION_3_3

static void REGAL_CALL missing_glVertexAttribDivisor(GLuint index, GLuint divisor)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(divisor);
   Warning( "glVertexAttribDivisor not available." );
}

static void REGAL_CALL loader_glVertexAttribDivisor(GLuint index, GLuint divisor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribDivisor, "glVertexAttribDivisor");
   if ( !driverTbl.glVertexAttribDivisor ) {
      driverTbl.glVertexAttribDivisor = missing_glVertexAttribDivisor;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribDivisor == loader_glVertexAttribDivisor) {
      rCtx->dsp->emuTbl.glVertexAttribDivisor = driverTbl.glVertexAttribDivisor;
   }
   driverTbl.glVertexAttribDivisor(index, divisor);
}

// GL_VERSION_4_0

static void REGAL_CALL missing_glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(modeRGB);
   UNUSED_PARAMETER(modeAlpha);
   Warning( "glBlendEquationSeparatei not available." );
}

static void REGAL_CALL loader_glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendEquationSeparatei, "glBlendEquationSeparatei");
   if ( !driverTbl.glBlendEquationSeparatei ) {
      driverTbl.glBlendEquationSeparatei = missing_glBlendEquationSeparatei;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendEquationSeparatei == loader_glBlendEquationSeparatei) {
      rCtx->dsp->emuTbl.glBlendEquationSeparatei = driverTbl.glBlendEquationSeparatei;
   }
   driverTbl.glBlendEquationSeparatei(buf, modeRGB, modeAlpha);
}

static void REGAL_CALL missing_glBlendEquationi(GLuint buf, GLenum mode)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(mode);
   Warning( "glBlendEquationi not available." );
}

static void REGAL_CALL loader_glBlendEquationi(GLuint buf, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendEquationi, "glBlendEquationi");
   if ( !driverTbl.glBlendEquationi ) {
      driverTbl.glBlendEquationi = missing_glBlendEquationi;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendEquationi == loader_glBlendEquationi) {
      rCtx->dsp->emuTbl.glBlendEquationi = driverTbl.glBlendEquationi;
   }
   driverTbl.glBlendEquationi(buf, mode);
}

static void REGAL_CALL missing_glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(srcRGB);
   UNUSED_PARAMETER(dstRGB);
   UNUSED_PARAMETER(srcAlpha);
   UNUSED_PARAMETER(dstAlpha);
   Warning( "glBlendFuncSeparatei not available." );
}

static void REGAL_CALL loader_glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendFuncSeparatei, "glBlendFuncSeparatei");
   if ( !driverTbl.glBlendFuncSeparatei ) {
      driverTbl.glBlendFuncSeparatei = missing_glBlendFuncSeparatei;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendFuncSeparatei == loader_glBlendFuncSeparatei) {
      rCtx->dsp->emuTbl.glBlendFuncSeparatei = driverTbl.glBlendFuncSeparatei;
   }
   driverTbl.glBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

static void REGAL_CALL missing_glBlendFunci(GLuint buf, GLenum src, GLenum dst)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(src);
   UNUSED_PARAMETER(dst);
   Warning( "glBlendFunci not available." );
}

static void REGAL_CALL loader_glBlendFunci(GLuint buf, GLenum src, GLenum dst)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendFunci, "glBlendFunci");
   if ( !driverTbl.glBlendFunci ) {
      driverTbl.glBlendFunci = missing_glBlendFunci;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendFunci == loader_glBlendFunci) {
      rCtx->dsp->emuTbl.glBlendFunci = driverTbl.glBlendFunci;
   }
   driverTbl.glBlendFunci(buf, src, dst);
}

// GL_3DFX_tbuffer

static void REGAL_CALL missing_glTbufferMask3DFX(GLuint mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "glTbufferMask3DFX not available." );
}

static void REGAL_CALL loader_glTbufferMask3DFX(GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTbufferMask3DFX, "glTbufferMask3DFX");
   if ( !driverTbl.glTbufferMask3DFX ) {
      driverTbl.glTbufferMask3DFX = missing_glTbufferMask3DFX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTbufferMask3DFX == loader_glTbufferMask3DFX) {
      rCtx->dsp->emuTbl.glTbufferMask3DFX = driverTbl.glTbufferMask3DFX;
   }
   driverTbl.glTbufferMask3DFX(mask);
}

// GL_AMD_debug_output

static void REGAL_CALL missing_glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, GLvoid *userParam)
{
   UNUSED_PARAMETER(callback);
   UNUSED_PARAMETER(userParam);
   Warning( "glDebugMessageCallbackAMD not available." );
}

static void REGAL_CALL loader_glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, GLvoid *userParam)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDebugMessageCallbackAMD, "glDebugMessageCallbackAMD");
   if ( !driverTbl.glDebugMessageCallbackAMD ) {
      driverTbl.glDebugMessageCallbackAMD = missing_glDebugMessageCallbackAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDebugMessageCallbackAMD == loader_glDebugMessageCallbackAMD) {
      rCtx->dsp->emuTbl.glDebugMessageCallbackAMD = driverTbl.glDebugMessageCallbackAMD;
   }
   driverTbl.glDebugMessageCallbackAMD(callback, userParam);
}

static void REGAL_CALL missing_glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
   UNUSED_PARAMETER(category);
   UNUSED_PARAMETER(severity);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(ids);
   UNUSED_PARAMETER(enabled);
   Warning( "glDebugMessageEnableAMD not available." );
}

static void REGAL_CALL loader_glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDebugMessageEnableAMD, "glDebugMessageEnableAMD");
   if ( !driverTbl.glDebugMessageEnableAMD ) {
      driverTbl.glDebugMessageEnableAMD = missing_glDebugMessageEnableAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDebugMessageEnableAMD == loader_glDebugMessageEnableAMD) {
      rCtx->dsp->emuTbl.glDebugMessageEnableAMD = driverTbl.glDebugMessageEnableAMD;
   }
   driverTbl.glDebugMessageEnableAMD(category, severity, count, ids, enabled);
}

static void REGAL_CALL missing_glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf)
{
   UNUSED_PARAMETER(category);
   UNUSED_PARAMETER(severity);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(buf);
   Warning( "glDebugMessageInsertAMD not available." );
}

static void REGAL_CALL loader_glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDebugMessageInsertAMD, "glDebugMessageInsertAMD");
   if ( !driverTbl.glDebugMessageInsertAMD ) {
      driverTbl.glDebugMessageInsertAMD = missing_glDebugMessageInsertAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDebugMessageInsertAMD == loader_glDebugMessageInsertAMD) {
      rCtx->dsp->emuTbl.glDebugMessageInsertAMD = driverTbl.glDebugMessageInsertAMD;
   }
   driverTbl.glDebugMessageInsertAMD(category, severity, id, length, buf);
}

static GLuint REGAL_CALL missing_glGetDebugMessageLogAMD(GLuint count, GLsizei bufsize, GLenum *categories, GLuint *severities, GLuint *ids, GLsizei *lengths, GLchar *message)
{
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(bufsize);
   UNUSED_PARAMETER(categories);
   UNUSED_PARAMETER(severities);
   UNUSED_PARAMETER(ids);
   UNUSED_PARAMETER(lengths);
   UNUSED_PARAMETER(message);
   Warning( "glGetDebugMessageLogAMD not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGetDebugMessageLogAMD(GLuint count, GLsizei bufsize, GLenum *categories, GLuint *severities, GLuint *ids, GLsizei *lengths, GLchar *message)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetDebugMessageLogAMD, "glGetDebugMessageLogAMD");
   if ( !driverTbl.glGetDebugMessageLogAMD ) {
      driverTbl.glGetDebugMessageLogAMD = missing_glGetDebugMessageLogAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetDebugMessageLogAMD == loader_glGetDebugMessageLogAMD) {
      rCtx->dsp->emuTbl.glGetDebugMessageLogAMD = driverTbl.glGetDebugMessageLogAMD;
   }
   return driverTbl.glGetDebugMessageLogAMD(count, bufsize, categories, severities, ids, lengths, message);
}

// GL_AMD_draw_buffers_blend

static void REGAL_CALL missing_glBlendEquationIndexedAMD(GLuint buf, GLenum mode)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(mode);
   Warning( "glBlendEquationIndexedAMD not available." );
}

static void REGAL_CALL loader_glBlendEquationIndexedAMD(GLuint buf, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendEquationIndexedAMD, "glBlendEquationIndexedAMD");
   if ( !driverTbl.glBlendEquationIndexedAMD ) {
      driverTbl.glBlendEquationIndexedAMD = missing_glBlendEquationIndexedAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendEquationIndexedAMD == loader_glBlendEquationIndexedAMD) {
      rCtx->dsp->emuTbl.glBlendEquationIndexedAMD = driverTbl.glBlendEquationIndexedAMD;
   }
   driverTbl.glBlendEquationIndexedAMD(buf, mode);
}

static void REGAL_CALL missing_glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(modeRGB);
   UNUSED_PARAMETER(modeAlpha);
   Warning( "glBlendEquationSeparateIndexedAMD not available." );
}

static void REGAL_CALL loader_glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendEquationSeparateIndexedAMD, "glBlendEquationSeparateIndexedAMD");
   if ( !driverTbl.glBlendEquationSeparateIndexedAMD ) {
      driverTbl.glBlendEquationSeparateIndexedAMD = missing_glBlendEquationSeparateIndexedAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendEquationSeparateIndexedAMD == loader_glBlendEquationSeparateIndexedAMD) {
      rCtx->dsp->emuTbl.glBlendEquationSeparateIndexedAMD = driverTbl.glBlendEquationSeparateIndexedAMD;
   }
   driverTbl.glBlendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha);
}

static void REGAL_CALL missing_glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(src);
   UNUSED_PARAMETER(dst);
   Warning( "glBlendFuncIndexedAMD not available." );
}

static void REGAL_CALL loader_glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendFuncIndexedAMD, "glBlendFuncIndexedAMD");
   if ( !driverTbl.glBlendFuncIndexedAMD ) {
      driverTbl.glBlendFuncIndexedAMD = missing_glBlendFuncIndexedAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendFuncIndexedAMD == loader_glBlendFuncIndexedAMD) {
      rCtx->dsp->emuTbl.glBlendFuncIndexedAMD = driverTbl.glBlendFuncIndexedAMD;
   }
   driverTbl.glBlendFuncIndexedAMD(buf, src, dst);
}

static void REGAL_CALL missing_glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(srcRGB);
   UNUSED_PARAMETER(dstRGB);
   UNUSED_PARAMETER(srcAlpha);
   UNUSED_PARAMETER(dstAlpha);
   Warning( "glBlendFuncSeparateIndexedAMD not available." );
}

static void REGAL_CALL loader_glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendFuncSeparateIndexedAMD, "glBlendFuncSeparateIndexedAMD");
   if ( !driverTbl.glBlendFuncSeparateIndexedAMD ) {
      driverTbl.glBlendFuncSeparateIndexedAMD = missing_glBlendFuncSeparateIndexedAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendFuncSeparateIndexedAMD == loader_glBlendFuncSeparateIndexedAMD) {
      rCtx->dsp->emuTbl.glBlendFuncSeparateIndexedAMD = driverTbl.glBlendFuncSeparateIndexedAMD;
   }
   driverTbl.glBlendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

// GL_AMD_multi_draw_indirect

static void REGAL_CALL missing_glMultiDrawArraysIndirectAMD(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(indirect);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(stride);
   Warning( "glMultiDrawArraysIndirectAMD not available." );
}

static void REGAL_CALL loader_glMultiDrawArraysIndirectAMD(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiDrawArraysIndirectAMD, "glMultiDrawArraysIndirectAMD");
   if ( !driverTbl.glMultiDrawArraysIndirectAMD ) {
      driverTbl.glMultiDrawArraysIndirectAMD = missing_glMultiDrawArraysIndirectAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiDrawArraysIndirectAMD == loader_glMultiDrawArraysIndirectAMD) {
      rCtx->dsp->emuTbl.glMultiDrawArraysIndirectAMD = driverTbl.glMultiDrawArraysIndirectAMD;
   }
   driverTbl.glMultiDrawArraysIndirectAMD(mode, indirect, primcount, stride);
}

static void REGAL_CALL missing_glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indirect);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(stride);
   Warning( "glMultiDrawElementsIndirectAMD not available." );
}

static void REGAL_CALL loader_glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiDrawElementsIndirectAMD, "glMultiDrawElementsIndirectAMD");
   if ( !driverTbl.glMultiDrawElementsIndirectAMD ) {
      driverTbl.glMultiDrawElementsIndirectAMD = missing_glMultiDrawElementsIndirectAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiDrawElementsIndirectAMD == loader_glMultiDrawElementsIndirectAMD) {
      rCtx->dsp->emuTbl.glMultiDrawElementsIndirectAMD = driverTbl.glMultiDrawElementsIndirectAMD;
   }
   driverTbl.glMultiDrawElementsIndirectAMD(mode, type, indirect, primcount, stride);
}

// GL_AMD_name_gen_delete

static void REGAL_CALL missing_glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint *names)
{
   UNUSED_PARAMETER(identifier);
   UNUSED_PARAMETER(num);
   UNUSED_PARAMETER(names);
   Warning( "glDeleteNamesAMD not available." );
}

static void REGAL_CALL loader_glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint *names)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteNamesAMD, "glDeleteNamesAMD");
   if ( !driverTbl.glDeleteNamesAMD ) {
      driverTbl.glDeleteNamesAMD = missing_glDeleteNamesAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteNamesAMD == loader_glDeleteNamesAMD) {
      rCtx->dsp->emuTbl.glDeleteNamesAMD = driverTbl.glDeleteNamesAMD;
   }
   driverTbl.glDeleteNamesAMD(identifier, num, names);
}

static void REGAL_CALL missing_glGenNamesAMD(GLenum identifier, GLuint num, GLuint *names)
{
   UNUSED_PARAMETER(identifier);
   UNUSED_PARAMETER(num);
   UNUSED_PARAMETER(names);
   Warning( "glGenNamesAMD not available." );
}

static void REGAL_CALL loader_glGenNamesAMD(GLenum identifier, GLuint num, GLuint *names)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenNamesAMD, "glGenNamesAMD");
   if ( !driverTbl.glGenNamesAMD ) {
      driverTbl.glGenNamesAMD = missing_glGenNamesAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenNamesAMD == loader_glGenNamesAMD) {
      rCtx->dsp->emuTbl.glGenNamesAMD = driverTbl.glGenNamesAMD;
   }
   driverTbl.glGenNamesAMD(identifier, num, names);
}

static GLboolean REGAL_CALL missing_glIsNameAMD(GLenum identifier, GLuint name)
{
   UNUSED_PARAMETER(identifier);
   UNUSED_PARAMETER(name);
   Warning( "glIsNameAMD not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsNameAMD(GLenum identifier, GLuint name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsNameAMD, "glIsNameAMD");
   if ( !driverTbl.glIsNameAMD ) {
      driverTbl.glIsNameAMD = missing_glIsNameAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsNameAMD == loader_glIsNameAMD) {
      rCtx->dsp->emuTbl.glIsNameAMD = driverTbl.glIsNameAMD;
   }
   return driverTbl.glIsNameAMD(identifier, name);
}

// GL_AMD_performance_monitor

static void REGAL_CALL missing_glBeginPerfMonitorAMD(GLuint monitor)
{
   UNUSED_PARAMETER(monitor);
   Warning( "glBeginPerfMonitorAMD not available." );
}

static void REGAL_CALL loader_glBeginPerfMonitorAMD(GLuint monitor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBeginPerfMonitorAMD, "glBeginPerfMonitorAMD");
   if ( !driverTbl.glBeginPerfMonitorAMD ) {
      driverTbl.glBeginPerfMonitorAMD = missing_glBeginPerfMonitorAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBeginPerfMonitorAMD == loader_glBeginPerfMonitorAMD) {
      rCtx->dsp->emuTbl.glBeginPerfMonitorAMD = driverTbl.glBeginPerfMonitorAMD;
   }
   driverTbl.glBeginPerfMonitorAMD(monitor);
}

static void REGAL_CALL missing_glDeletePerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(monitors);
   Warning( "glDeletePerfMonitorsAMD not available." );
}

static void REGAL_CALL loader_glDeletePerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeletePerfMonitorsAMD, "glDeletePerfMonitorsAMD");
   if ( !driverTbl.glDeletePerfMonitorsAMD ) {
      driverTbl.glDeletePerfMonitorsAMD = missing_glDeletePerfMonitorsAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeletePerfMonitorsAMD == loader_glDeletePerfMonitorsAMD) {
      rCtx->dsp->emuTbl.glDeletePerfMonitorsAMD = driverTbl.glDeletePerfMonitorsAMD;
   }
   driverTbl.glDeletePerfMonitorsAMD(n, monitors);
}

static void REGAL_CALL missing_glEndPerfMonitorAMD(GLuint monitor)
{
   UNUSED_PARAMETER(monitor);
   Warning( "glEndPerfMonitorAMD not available." );
}

static void REGAL_CALL loader_glEndPerfMonitorAMD(GLuint monitor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndPerfMonitorAMD, "glEndPerfMonitorAMD");
   if ( !driverTbl.glEndPerfMonitorAMD ) {
      driverTbl.glEndPerfMonitorAMD = missing_glEndPerfMonitorAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndPerfMonitorAMD == loader_glEndPerfMonitorAMD) {
      rCtx->dsp->emuTbl.glEndPerfMonitorAMD = driverTbl.glEndPerfMonitorAMD;
   }
   driverTbl.glEndPerfMonitorAMD(monitor);
}

static void REGAL_CALL missing_glGenPerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(monitors);
   Warning( "glGenPerfMonitorsAMD not available." );
}

static void REGAL_CALL loader_glGenPerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenPerfMonitorsAMD, "glGenPerfMonitorsAMD");
   if ( !driverTbl.glGenPerfMonitorsAMD ) {
      driverTbl.glGenPerfMonitorsAMD = missing_glGenPerfMonitorsAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenPerfMonitorsAMD == loader_glGenPerfMonitorsAMD) {
      rCtx->dsp->emuTbl.glGenPerfMonitorsAMD = driverTbl.glGenPerfMonitorsAMD;
   }
   driverTbl.glGenPerfMonitorsAMD(n, monitors);
}

static void REGAL_CALL missing_glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten)
{
   UNUSED_PARAMETER(monitor);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(dataSize);
   UNUSED_PARAMETER(data);
   UNUSED_PARAMETER(bytesWritten);
   Warning( "glGetPerfMonitorCounterDataAMD not available." );
}

static void REGAL_CALL loader_glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPerfMonitorCounterDataAMD, "glGetPerfMonitorCounterDataAMD");
   if ( !driverTbl.glGetPerfMonitorCounterDataAMD ) {
      driverTbl.glGetPerfMonitorCounterDataAMD = missing_glGetPerfMonitorCounterDataAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPerfMonitorCounterDataAMD == loader_glGetPerfMonitorCounterDataAMD) {
      rCtx->dsp->emuTbl.glGetPerfMonitorCounterDataAMD = driverTbl.glGetPerfMonitorCounterDataAMD;
   }
   driverTbl.glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
}

static void REGAL_CALL missing_glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid *data)
{
   UNUSED_PARAMETER(group);
   UNUSED_PARAMETER(counter);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(data);
   Warning( "glGetPerfMonitorCounterInfoAMD not available." );
}

static void REGAL_CALL loader_glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPerfMonitorCounterInfoAMD, "glGetPerfMonitorCounterInfoAMD");
   if ( !driverTbl.glGetPerfMonitorCounterInfoAMD ) {
      driverTbl.glGetPerfMonitorCounterInfoAMD = missing_glGetPerfMonitorCounterInfoAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPerfMonitorCounterInfoAMD == loader_glGetPerfMonitorCounterInfoAMD) {
      rCtx->dsp->emuTbl.glGetPerfMonitorCounterInfoAMD = driverTbl.glGetPerfMonitorCounterInfoAMD;
   }
   driverTbl.glGetPerfMonitorCounterInfoAMD(group, counter, pname, data);
}

static void REGAL_CALL missing_glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString)
{
   UNUSED_PARAMETER(group);
   UNUSED_PARAMETER(counter);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(counterString);
   Warning( "glGetPerfMonitorCounterStringAMD not available." );
}

static void REGAL_CALL loader_glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPerfMonitorCounterStringAMD, "glGetPerfMonitorCounterStringAMD");
   if ( !driverTbl.glGetPerfMonitorCounterStringAMD ) {
      driverTbl.glGetPerfMonitorCounterStringAMD = missing_glGetPerfMonitorCounterStringAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPerfMonitorCounterStringAMD == loader_glGetPerfMonitorCounterStringAMD) {
      rCtx->dsp->emuTbl.glGetPerfMonitorCounterStringAMD = driverTbl.glGetPerfMonitorCounterStringAMD;
   }
   driverTbl.glGetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
}

static void REGAL_CALL missing_glGetPerfMonitorCountersAMD(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters)
{
   UNUSED_PARAMETER(group);
   UNUSED_PARAMETER(numCounters);
   UNUSED_PARAMETER(maxActiveCounters);
   UNUSED_PARAMETER(countersSize);
   UNUSED_PARAMETER(counters);
   Warning( "glGetPerfMonitorCountersAMD not available." );
}

static void REGAL_CALL loader_glGetPerfMonitorCountersAMD(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPerfMonitorCountersAMD, "glGetPerfMonitorCountersAMD");
   if ( !driverTbl.glGetPerfMonitorCountersAMD ) {
      driverTbl.glGetPerfMonitorCountersAMD = missing_glGetPerfMonitorCountersAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPerfMonitorCountersAMD == loader_glGetPerfMonitorCountersAMD) {
      rCtx->dsp->emuTbl.glGetPerfMonitorCountersAMD = driverTbl.glGetPerfMonitorCountersAMD;
   }
   driverTbl.glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, countersSize, counters);
}

static void REGAL_CALL missing_glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString)
{
   UNUSED_PARAMETER(group);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(groupString);
   Warning( "glGetPerfMonitorGroupStringAMD not available." );
}

static void REGAL_CALL loader_glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPerfMonitorGroupStringAMD, "glGetPerfMonitorGroupStringAMD");
   if ( !driverTbl.glGetPerfMonitorGroupStringAMD ) {
      driverTbl.glGetPerfMonitorGroupStringAMD = missing_glGetPerfMonitorGroupStringAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPerfMonitorGroupStringAMD == loader_glGetPerfMonitorGroupStringAMD) {
      rCtx->dsp->emuTbl.glGetPerfMonitorGroupStringAMD = driverTbl.glGetPerfMonitorGroupStringAMD;
   }
   driverTbl.glGetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
}

static void REGAL_CALL missing_glGetPerfMonitorGroupsAMD(GLint *numGroups, GLsizei groupsSize, GLuint *groups)
{
   UNUSED_PARAMETER(numGroups);
   UNUSED_PARAMETER(groupsSize);
   UNUSED_PARAMETER(groups);
   Warning( "glGetPerfMonitorGroupsAMD not available." );
}

static void REGAL_CALL loader_glGetPerfMonitorGroupsAMD(GLint *numGroups, GLsizei groupsSize, GLuint *groups)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPerfMonitorGroupsAMD, "glGetPerfMonitorGroupsAMD");
   if ( !driverTbl.glGetPerfMonitorGroupsAMD ) {
      driverTbl.glGetPerfMonitorGroupsAMD = missing_glGetPerfMonitorGroupsAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPerfMonitorGroupsAMD == loader_glGetPerfMonitorGroupsAMD) {
      rCtx->dsp->emuTbl.glGetPerfMonitorGroupsAMD = driverTbl.glGetPerfMonitorGroupsAMD;
   }
   driverTbl.glGetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
}

static void REGAL_CALL missing_glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList)
{
   UNUSED_PARAMETER(monitor);
   UNUSED_PARAMETER(enable);
   UNUSED_PARAMETER(group);
   UNUSED_PARAMETER(numCounters);
   UNUSED_PARAMETER(counterList);
   Warning( "glSelectPerfMonitorCountersAMD not available." );
}

static void REGAL_CALL loader_glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSelectPerfMonitorCountersAMD, "glSelectPerfMonitorCountersAMD");
   if ( !driverTbl.glSelectPerfMonitorCountersAMD ) {
      driverTbl.glSelectPerfMonitorCountersAMD = missing_glSelectPerfMonitorCountersAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSelectPerfMonitorCountersAMD == loader_glSelectPerfMonitorCountersAMD) {
      rCtx->dsp->emuTbl.glSelectPerfMonitorCountersAMD = driverTbl.glSelectPerfMonitorCountersAMD;
   }
   driverTbl.glSelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);
}

// GL_AMD_sample_positions

static void REGAL_CALL missing_glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat *val)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(val);
   Warning( "glSetMultisamplefvAMD not available." );
}

static void REGAL_CALL loader_glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat *val)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSetMultisamplefvAMD, "glSetMultisamplefvAMD");
   if ( !driverTbl.glSetMultisamplefvAMD ) {
      driverTbl.glSetMultisamplefvAMD = missing_glSetMultisamplefvAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSetMultisamplefvAMD == loader_glSetMultisamplefvAMD) {
      rCtx->dsp->emuTbl.glSetMultisamplefvAMD = driverTbl.glSetMultisamplefvAMD;
   }
   driverTbl.glSetMultisamplefvAMD(pname, index, val);
}

// GL_AMD_stencil_operation_extended

static void REGAL_CALL missing_glStencilOpValueAMD(GLenum face, GLuint value)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(value);
   Warning( "glStencilOpValueAMD not available." );
}

static void REGAL_CALL loader_glStencilOpValueAMD(GLenum face, GLuint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStencilOpValueAMD, "glStencilOpValueAMD");
   if ( !driverTbl.glStencilOpValueAMD ) {
      driverTbl.glStencilOpValueAMD = missing_glStencilOpValueAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStencilOpValueAMD == loader_glStencilOpValueAMD) {
      rCtx->dsp->emuTbl.glStencilOpValueAMD = driverTbl.glStencilOpValueAMD;
   }
   driverTbl.glStencilOpValueAMD(face, value);
}

// GL_AMD_vertex_shader_tessellator

static void REGAL_CALL missing_glTessellationFactorAMD(GLfloat factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "glTessellationFactorAMD not available." );
}

static void REGAL_CALL loader_glTessellationFactorAMD(GLfloat factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTessellationFactorAMD, "glTessellationFactorAMD");
   if ( !driverTbl.glTessellationFactorAMD ) {
      driverTbl.glTessellationFactorAMD = missing_glTessellationFactorAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTessellationFactorAMD == loader_glTessellationFactorAMD) {
      rCtx->dsp->emuTbl.glTessellationFactorAMD = driverTbl.glTessellationFactorAMD;
   }
   driverTbl.glTessellationFactorAMD(factor);
}

static void REGAL_CALL missing_glTessellationModeAMD(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glTessellationModeAMD not available." );
}

static void REGAL_CALL loader_glTessellationModeAMD(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTessellationModeAMD, "glTessellationModeAMD");
   if ( !driverTbl.glTessellationModeAMD ) {
      driverTbl.glTessellationModeAMD = missing_glTessellationModeAMD;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTessellationModeAMD == loader_glTessellationModeAMD) {
      rCtx->dsp->emuTbl.glTessellationModeAMD = driverTbl.glTessellationModeAMD;
   }
   driverTbl.glTessellationModeAMD(mode);
}

// GL_APPLE_element_array

static void REGAL_CALL missing_glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   Warning( "glDrawElementArrayAPPLE not available." );
}

static void REGAL_CALL loader_glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawElementArrayAPPLE, "glDrawElementArrayAPPLE");
   if ( !driverTbl.glDrawElementArrayAPPLE ) {
      driverTbl.glDrawElementArrayAPPLE = missing_glDrawElementArrayAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawElementArrayAPPLE == loader_glDrawElementArrayAPPLE) {
      rCtx->dsp->emuTbl.glDrawElementArrayAPPLE = driverTbl.glDrawElementArrayAPPLE;
   }
   driverTbl.glDrawElementArrayAPPLE(mode, first, count);
}

static void REGAL_CALL missing_glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(end);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   Warning( "glDrawRangeElementArrayAPPLE not available." );
}

static void REGAL_CALL loader_glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawRangeElementArrayAPPLE, "glDrawRangeElementArrayAPPLE");
   if ( !driverTbl.glDrawRangeElementArrayAPPLE ) {
      driverTbl.glDrawRangeElementArrayAPPLE = missing_glDrawRangeElementArrayAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawRangeElementArrayAPPLE == loader_glDrawRangeElementArrayAPPLE) {
      rCtx->dsp->emuTbl.glDrawRangeElementArrayAPPLE = driverTbl.glDrawRangeElementArrayAPPLE;
   }
   driverTbl.glDrawRangeElementArrayAPPLE(mode, start, end, first, count);
}

static void REGAL_CALL missing_glElementPointerAPPLE(GLenum type, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pointer);
   Warning( "glElementPointerAPPLE not available." );
}

static void REGAL_CALL loader_glElementPointerAPPLE(GLenum type, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glElementPointerAPPLE, "glElementPointerAPPLE");
   if ( !driverTbl.glElementPointerAPPLE ) {
      driverTbl.glElementPointerAPPLE = missing_glElementPointerAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glElementPointerAPPLE == loader_glElementPointerAPPLE) {
      rCtx->dsp->emuTbl.glElementPointerAPPLE = driverTbl.glElementPointerAPPLE;
   }
   driverTbl.glElementPointerAPPLE(type, pointer);
}

static void REGAL_CALL missing_glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   Warning( "glMultiDrawElementArrayAPPLE not available." );
}

static void REGAL_CALL loader_glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiDrawElementArrayAPPLE, "glMultiDrawElementArrayAPPLE");
   if ( !driverTbl.glMultiDrawElementArrayAPPLE ) {
      driverTbl.glMultiDrawElementArrayAPPLE = missing_glMultiDrawElementArrayAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiDrawElementArrayAPPLE == loader_glMultiDrawElementArrayAPPLE) {
      rCtx->dsp->emuTbl.glMultiDrawElementArrayAPPLE = driverTbl.glMultiDrawElementArrayAPPLE;
   }
   driverTbl.glMultiDrawElementArrayAPPLE(mode, first, count, primcount);
}

static void REGAL_CALL missing_glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(end);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   Warning( "glMultiDrawRangeElementArrayAPPLE not available." );
}

static void REGAL_CALL loader_glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiDrawRangeElementArrayAPPLE, "glMultiDrawRangeElementArrayAPPLE");
   if ( !driverTbl.glMultiDrawRangeElementArrayAPPLE ) {
      driverTbl.glMultiDrawRangeElementArrayAPPLE = missing_glMultiDrawRangeElementArrayAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiDrawRangeElementArrayAPPLE == loader_glMultiDrawRangeElementArrayAPPLE) {
      rCtx->dsp->emuTbl.glMultiDrawRangeElementArrayAPPLE = driverTbl.glMultiDrawRangeElementArrayAPPLE;
   }
   driverTbl.glMultiDrawRangeElementArrayAPPLE(mode, start, end, first, count, primcount);
}

// GL_APPLE_fence

static void REGAL_CALL missing_glDeleteFencesAPPLE(GLsizei n, const GLuint *fences)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(fences);
   Warning( "glDeleteFencesAPPLE not available." );
}

static void REGAL_CALL loader_glDeleteFencesAPPLE(GLsizei n, const GLuint *fences)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteFencesAPPLE, "glDeleteFencesAPPLE");
   if ( !driverTbl.glDeleteFencesAPPLE ) {
      driverTbl.glDeleteFencesAPPLE = missing_glDeleteFencesAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteFencesAPPLE == loader_glDeleteFencesAPPLE) {
      rCtx->dsp->emuTbl.glDeleteFencesAPPLE = driverTbl.glDeleteFencesAPPLE;
   }
   driverTbl.glDeleteFencesAPPLE(n, fences);
}

static void REGAL_CALL missing_glFinishFenceAPPLE(GLuint fence)
{
   UNUSED_PARAMETER(fence);
   Warning( "glFinishFenceAPPLE not available." );
}

static void REGAL_CALL loader_glFinishFenceAPPLE(GLuint fence)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFinishFenceAPPLE, "glFinishFenceAPPLE");
   if ( !driverTbl.glFinishFenceAPPLE ) {
      driverTbl.glFinishFenceAPPLE = missing_glFinishFenceAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFinishFenceAPPLE == loader_glFinishFenceAPPLE) {
      rCtx->dsp->emuTbl.glFinishFenceAPPLE = driverTbl.glFinishFenceAPPLE;
   }
   driverTbl.glFinishFenceAPPLE(fence);
}

static void REGAL_CALL missing_glFinishObjectAPPLE(GLenum object, GLint name)
{
   UNUSED_PARAMETER(object);
   UNUSED_PARAMETER(name);
   Warning( "glFinishObjectAPPLE not available." );
}

static void REGAL_CALL loader_glFinishObjectAPPLE(GLenum object, GLint name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFinishObjectAPPLE, "glFinishObjectAPPLE");
   if ( !driverTbl.glFinishObjectAPPLE ) {
      driverTbl.glFinishObjectAPPLE = missing_glFinishObjectAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFinishObjectAPPLE == loader_glFinishObjectAPPLE) {
      rCtx->dsp->emuTbl.glFinishObjectAPPLE = driverTbl.glFinishObjectAPPLE;
   }
   driverTbl.glFinishObjectAPPLE(object, name);
}

static void REGAL_CALL missing_glGenFencesAPPLE(GLsizei n, GLuint *fences)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(fences);
   Warning( "glGenFencesAPPLE not available." );
}

static void REGAL_CALL loader_glGenFencesAPPLE(GLsizei n, GLuint *fences)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenFencesAPPLE, "glGenFencesAPPLE");
   if ( !driverTbl.glGenFencesAPPLE ) {
      driverTbl.glGenFencesAPPLE = missing_glGenFencesAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenFencesAPPLE == loader_glGenFencesAPPLE) {
      rCtx->dsp->emuTbl.glGenFencesAPPLE = driverTbl.glGenFencesAPPLE;
   }
   driverTbl.glGenFencesAPPLE(n, fences);
}

static GLboolean REGAL_CALL missing_glIsFenceAPPLE(GLuint fence)
{
   UNUSED_PARAMETER(fence);
   Warning( "glIsFenceAPPLE not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsFenceAPPLE(GLuint fence)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsFenceAPPLE, "glIsFenceAPPLE");
   if ( !driverTbl.glIsFenceAPPLE ) {
      driverTbl.glIsFenceAPPLE = missing_glIsFenceAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsFenceAPPLE == loader_glIsFenceAPPLE) {
      rCtx->dsp->emuTbl.glIsFenceAPPLE = driverTbl.glIsFenceAPPLE;
   }
   return driverTbl.glIsFenceAPPLE(fence);
}

static void REGAL_CALL missing_glSetFenceAPPLE(GLuint fence)
{
   UNUSED_PARAMETER(fence);
   Warning( "glSetFenceAPPLE not available." );
}

static void REGAL_CALL loader_glSetFenceAPPLE(GLuint fence)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSetFenceAPPLE, "glSetFenceAPPLE");
   if ( !driverTbl.glSetFenceAPPLE ) {
      driverTbl.glSetFenceAPPLE = missing_glSetFenceAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSetFenceAPPLE == loader_glSetFenceAPPLE) {
      rCtx->dsp->emuTbl.glSetFenceAPPLE = driverTbl.glSetFenceAPPLE;
   }
   driverTbl.glSetFenceAPPLE(fence);
}

static GLboolean REGAL_CALL missing_glTestFenceAPPLE(GLuint fence)
{
   UNUSED_PARAMETER(fence);
   Warning( "glTestFenceAPPLE not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glTestFenceAPPLE(GLuint fence)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTestFenceAPPLE, "glTestFenceAPPLE");
   if ( !driverTbl.glTestFenceAPPLE ) {
      driverTbl.glTestFenceAPPLE = missing_glTestFenceAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTestFenceAPPLE == loader_glTestFenceAPPLE) {
      rCtx->dsp->emuTbl.glTestFenceAPPLE = driverTbl.glTestFenceAPPLE;
   }
   return driverTbl.glTestFenceAPPLE(fence);
}

static GLboolean REGAL_CALL missing_glTestObjectAPPLE(GLenum object, GLuint name)
{
   UNUSED_PARAMETER(object);
   UNUSED_PARAMETER(name);
   Warning( "glTestObjectAPPLE not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glTestObjectAPPLE(GLenum object, GLuint name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTestObjectAPPLE, "glTestObjectAPPLE");
   if ( !driverTbl.glTestObjectAPPLE ) {
      driverTbl.glTestObjectAPPLE = missing_glTestObjectAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTestObjectAPPLE == loader_glTestObjectAPPLE) {
      rCtx->dsp->emuTbl.glTestObjectAPPLE = driverTbl.glTestObjectAPPLE;
   }
   return driverTbl.glTestObjectAPPLE(object, name);
}

// GL_APPLE_flush_buffer_range

static void REGAL_CALL missing_glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glBufferParameteriAPPLE not available." );
}

static void REGAL_CALL loader_glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBufferParameteriAPPLE, "glBufferParameteriAPPLE");
   if ( !driverTbl.glBufferParameteriAPPLE ) {
      driverTbl.glBufferParameteriAPPLE = missing_glBufferParameteriAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBufferParameteriAPPLE == loader_glBufferParameteriAPPLE) {
      rCtx->dsp->emuTbl.glBufferParameteriAPPLE = driverTbl.glBufferParameteriAPPLE;
   }
   driverTbl.glBufferParameteriAPPLE(target, pname, param);
}

static void REGAL_CALL missing_glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   Warning( "glFlushMappedBufferRangeAPPLE not available." );
}

static void REGAL_CALL loader_glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFlushMappedBufferRangeAPPLE, "glFlushMappedBufferRangeAPPLE");
   if ( !driverTbl.glFlushMappedBufferRangeAPPLE ) {
      driverTbl.glFlushMappedBufferRangeAPPLE = missing_glFlushMappedBufferRangeAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFlushMappedBufferRangeAPPLE == loader_glFlushMappedBufferRangeAPPLE) {
      rCtx->dsp->emuTbl.glFlushMappedBufferRangeAPPLE = driverTbl.glFlushMappedBufferRangeAPPLE;
   }
   driverTbl.glFlushMappedBufferRangeAPPLE(target, offset, size);
}

// GL_APPLE_flush_render

static void REGAL_CALL missing_glFinishRenderAPPLE(void)
{
   Warning( "glFinishRenderAPPLE not available." );
}

static void REGAL_CALL loader_glFinishRenderAPPLE(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFinishRenderAPPLE, "glFinishRenderAPPLE");
   if ( !driverTbl.glFinishRenderAPPLE ) {
      driverTbl.glFinishRenderAPPLE = missing_glFinishRenderAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFinishRenderAPPLE == loader_glFinishRenderAPPLE) {
      rCtx->dsp->emuTbl.glFinishRenderAPPLE = driverTbl.glFinishRenderAPPLE;
   }
   driverTbl.glFinishRenderAPPLE();
}

static void REGAL_CALL missing_glFlushRenderAPPLE(void)
{
   Warning( "glFlushRenderAPPLE not available." );
}

static void REGAL_CALL loader_glFlushRenderAPPLE(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFlushRenderAPPLE, "glFlushRenderAPPLE");
   if ( !driverTbl.glFlushRenderAPPLE ) {
      driverTbl.glFlushRenderAPPLE = missing_glFlushRenderAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFlushRenderAPPLE == loader_glFlushRenderAPPLE) {
      rCtx->dsp->emuTbl.glFlushRenderAPPLE = driverTbl.glFlushRenderAPPLE;
   }
   driverTbl.glFlushRenderAPPLE();
}

static void REGAL_CALL missing_glSwapAPPLE(void)
{
   Warning( "glSwapAPPLE not available." );
}

static void REGAL_CALL loader_glSwapAPPLE(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSwapAPPLE, "glSwapAPPLE");
   if ( !driverTbl.glSwapAPPLE ) {
      driverTbl.glSwapAPPLE = missing_glSwapAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSwapAPPLE == loader_glSwapAPPLE) {
      rCtx->dsp->emuTbl.glSwapAPPLE = driverTbl.glSwapAPPLE;
   }
   driverTbl.glSwapAPPLE();
}

// GL_APPLE_object_purgeable

static void REGAL_CALL missing_glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(objectType);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetObjectParameterivAPPLE not available." );
}

static void REGAL_CALL loader_glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetObjectParameterivAPPLE, "glGetObjectParameterivAPPLE");
   if ( !driverTbl.glGetObjectParameterivAPPLE ) {
      driverTbl.glGetObjectParameterivAPPLE = missing_glGetObjectParameterivAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetObjectParameterivAPPLE == loader_glGetObjectParameterivAPPLE) {
      rCtx->dsp->emuTbl.glGetObjectParameterivAPPLE = driverTbl.glGetObjectParameterivAPPLE;
   }
   driverTbl.glGetObjectParameterivAPPLE(objectType, name, pname, params);
}

static GLenum REGAL_CALL missing_glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
   UNUSED_PARAMETER(objectType);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(option);
   Warning( "glObjectPurgeableAPPLE not available." );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glObjectPurgeableAPPLE, "glObjectPurgeableAPPLE");
   if ( !driverTbl.glObjectPurgeableAPPLE ) {
      driverTbl.glObjectPurgeableAPPLE = missing_glObjectPurgeableAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glObjectPurgeableAPPLE == loader_glObjectPurgeableAPPLE) {
      rCtx->dsp->emuTbl.glObjectPurgeableAPPLE = driverTbl.glObjectPurgeableAPPLE;
   }
   return driverTbl.glObjectPurgeableAPPLE(objectType, name, option);
}

static GLenum REGAL_CALL missing_glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
   UNUSED_PARAMETER(objectType);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(option);
   Warning( "glObjectUnpurgeableAPPLE not available." );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glObjectUnpurgeableAPPLE, "glObjectUnpurgeableAPPLE");
   if ( !driverTbl.glObjectUnpurgeableAPPLE ) {
      driverTbl.glObjectUnpurgeableAPPLE = missing_glObjectUnpurgeableAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glObjectUnpurgeableAPPLE == loader_glObjectUnpurgeableAPPLE) {
      rCtx->dsp->emuTbl.glObjectUnpurgeableAPPLE = driverTbl.glObjectUnpurgeableAPPLE;
   }
   return driverTbl.glObjectUnpurgeableAPPLE(objectType, name, option);
}

// GL_APPLE_texture_range

static void REGAL_CALL missing_glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTexParameterPointervAPPLE not available." );
}

static void REGAL_CALL loader_glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexParameterPointervAPPLE, "glGetTexParameterPointervAPPLE");
   if ( !driverTbl.glGetTexParameterPointervAPPLE ) {
      driverTbl.glGetTexParameterPointervAPPLE = missing_glGetTexParameterPointervAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexParameterPointervAPPLE == loader_glGetTexParameterPointervAPPLE) {
      rCtx->dsp->emuTbl.glGetTexParameterPointervAPPLE = driverTbl.glGetTexParameterPointervAPPLE;
   }
   driverTbl.glGetTexParameterPointervAPPLE(target, pname, params);
}

static void REGAL_CALL missing_glTextureRangeAPPLE(GLenum target, GLsizei length, GLvoid *pointer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(pointer);
   Warning( "glTextureRangeAPPLE not available." );
}

static void REGAL_CALL loader_glTextureRangeAPPLE(GLenum target, GLsizei length, GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureRangeAPPLE, "glTextureRangeAPPLE");
   if ( !driverTbl.glTextureRangeAPPLE ) {
      driverTbl.glTextureRangeAPPLE = missing_glTextureRangeAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureRangeAPPLE == loader_glTextureRangeAPPLE) {
      rCtx->dsp->emuTbl.glTextureRangeAPPLE = driverTbl.glTextureRangeAPPLE;
   }
   driverTbl.glTextureRangeAPPLE(target, length, pointer);
}

// GL_APPLE_vertex_array_object

static void REGAL_CALL missing_glBindVertexArrayAPPLE(GLuint array)
{
   UNUSED_PARAMETER(array);
   Warning( "glBindVertexArrayAPPLE not available." );
}

static void REGAL_CALL loader_glBindVertexArrayAPPLE(GLuint array)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindVertexArrayAPPLE, "glBindVertexArrayAPPLE");
   if ( !driverTbl.glBindVertexArrayAPPLE ) {
      driverTbl.glBindVertexArrayAPPLE = missing_glBindVertexArrayAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindVertexArrayAPPLE == loader_glBindVertexArrayAPPLE) {
      rCtx->dsp->emuTbl.glBindVertexArrayAPPLE = driverTbl.glBindVertexArrayAPPLE;
   }
   driverTbl.glBindVertexArrayAPPLE(array);
}

static void REGAL_CALL missing_glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *arrays)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(arrays);
   Warning( "glDeleteVertexArraysAPPLE not available." );
}

static void REGAL_CALL loader_glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *arrays)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteVertexArraysAPPLE, "glDeleteVertexArraysAPPLE");
   if ( !driverTbl.glDeleteVertexArraysAPPLE ) {
      driverTbl.glDeleteVertexArraysAPPLE = missing_glDeleteVertexArraysAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteVertexArraysAPPLE == loader_glDeleteVertexArraysAPPLE) {
      rCtx->dsp->emuTbl.glDeleteVertexArraysAPPLE = driverTbl.glDeleteVertexArraysAPPLE;
   }
   driverTbl.glDeleteVertexArraysAPPLE(n, arrays);
}

static void REGAL_CALL missing_glGenVertexArraysAPPLE(GLsizei n, const GLuint *arrays)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(arrays);
   Warning( "glGenVertexArraysAPPLE not available." );
}

static void REGAL_CALL loader_glGenVertexArraysAPPLE(GLsizei n, const GLuint *arrays)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenVertexArraysAPPLE, "glGenVertexArraysAPPLE");
   if ( !driverTbl.glGenVertexArraysAPPLE ) {
      driverTbl.glGenVertexArraysAPPLE = missing_glGenVertexArraysAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenVertexArraysAPPLE == loader_glGenVertexArraysAPPLE) {
      rCtx->dsp->emuTbl.glGenVertexArraysAPPLE = driverTbl.glGenVertexArraysAPPLE;
   }
   driverTbl.glGenVertexArraysAPPLE(n, arrays);
}

static GLboolean REGAL_CALL missing_glIsVertexArrayAPPLE(GLuint array)
{
   UNUSED_PARAMETER(array);
   Warning( "glIsVertexArrayAPPLE not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsVertexArrayAPPLE(GLuint array)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsVertexArrayAPPLE, "glIsVertexArrayAPPLE");
   if ( !driverTbl.glIsVertexArrayAPPLE ) {
      driverTbl.glIsVertexArrayAPPLE = missing_glIsVertexArrayAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsVertexArrayAPPLE == loader_glIsVertexArrayAPPLE) {
      rCtx->dsp->emuTbl.glIsVertexArrayAPPLE = driverTbl.glIsVertexArrayAPPLE;
   }
   return driverTbl.glIsVertexArrayAPPLE(array);
}

// GL_APPLE_vertex_array_range

static void REGAL_CALL missing_glFlushVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
{
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(pointer);
   Warning( "glFlushVertexArrayRangeAPPLE not available." );
}

static void REGAL_CALL loader_glFlushVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFlushVertexArrayRangeAPPLE, "glFlushVertexArrayRangeAPPLE");
   if ( !driverTbl.glFlushVertexArrayRangeAPPLE ) {
      driverTbl.glFlushVertexArrayRangeAPPLE = missing_glFlushVertexArrayRangeAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFlushVertexArrayRangeAPPLE == loader_glFlushVertexArrayRangeAPPLE) {
      rCtx->dsp->emuTbl.glFlushVertexArrayRangeAPPLE = driverTbl.glFlushVertexArrayRangeAPPLE;
   }
   driverTbl.glFlushVertexArrayRangeAPPLE(length, pointer);
}

static void REGAL_CALL missing_glVertexArrayParameteriAPPLE(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glVertexArrayParameteriAPPLE not available." );
}

static void REGAL_CALL loader_glVertexArrayParameteriAPPLE(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArrayParameteriAPPLE, "glVertexArrayParameteriAPPLE");
   if ( !driverTbl.glVertexArrayParameteriAPPLE ) {
      driverTbl.glVertexArrayParameteriAPPLE = missing_glVertexArrayParameteriAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArrayParameteriAPPLE == loader_glVertexArrayParameteriAPPLE) {
      rCtx->dsp->emuTbl.glVertexArrayParameteriAPPLE = driverTbl.glVertexArrayParameteriAPPLE;
   }
   driverTbl.glVertexArrayParameteriAPPLE(pname, param);
}

static void REGAL_CALL missing_glVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
{
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(pointer);
   Warning( "glVertexArrayRangeAPPLE not available." );
}

static void REGAL_CALL loader_glVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArrayRangeAPPLE, "glVertexArrayRangeAPPLE");
   if ( !driverTbl.glVertexArrayRangeAPPLE ) {
      driverTbl.glVertexArrayRangeAPPLE = missing_glVertexArrayRangeAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArrayRangeAPPLE == loader_glVertexArrayRangeAPPLE) {
      rCtx->dsp->emuTbl.glVertexArrayRangeAPPLE = driverTbl.glVertexArrayRangeAPPLE;
   }
   driverTbl.glVertexArrayRangeAPPLE(length, pointer);
}

// GL_APPLE_vertex_program_evaluators

static void REGAL_CALL missing_glDisableVertexAttribAPPLE(GLuint index, GLenum pname)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   Warning( "glDisableVertexAttribAPPLE not available." );
}

static void REGAL_CALL loader_glDisableVertexAttribAPPLE(GLuint index, GLenum pname)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDisableVertexAttribAPPLE, "glDisableVertexAttribAPPLE");
   if ( !driverTbl.glDisableVertexAttribAPPLE ) {
      driverTbl.glDisableVertexAttribAPPLE = missing_glDisableVertexAttribAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDisableVertexAttribAPPLE == loader_glDisableVertexAttribAPPLE) {
      rCtx->dsp->emuTbl.glDisableVertexAttribAPPLE = driverTbl.glDisableVertexAttribAPPLE;
   }
   driverTbl.glDisableVertexAttribAPPLE(index, pname);
}

static void REGAL_CALL missing_glEnableVertexAttribAPPLE(GLuint index, GLenum pname)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   Warning( "glEnableVertexAttribAPPLE not available." );
}

static void REGAL_CALL loader_glEnableVertexAttribAPPLE(GLuint index, GLenum pname)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEnableVertexAttribAPPLE, "glEnableVertexAttribAPPLE");
   if ( !driverTbl.glEnableVertexAttribAPPLE ) {
      driverTbl.glEnableVertexAttribAPPLE = missing_glEnableVertexAttribAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEnableVertexAttribAPPLE == loader_glEnableVertexAttribAPPLE) {
      rCtx->dsp->emuTbl.glEnableVertexAttribAPPLE = driverTbl.glEnableVertexAttribAPPLE;
   }
   driverTbl.glEnableVertexAttribAPPLE(index, pname);
}

static GLboolean REGAL_CALL missing_glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   Warning( "glIsVertexAttribEnabledAPPLE not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsVertexAttribEnabledAPPLE, "glIsVertexAttribEnabledAPPLE");
   if ( !driverTbl.glIsVertexAttribEnabledAPPLE ) {
      driverTbl.glIsVertexAttribEnabledAPPLE = missing_glIsVertexAttribEnabledAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsVertexAttribEnabledAPPLE == loader_glIsVertexAttribEnabledAPPLE) {
      rCtx->dsp->emuTbl.glIsVertexAttribEnabledAPPLE = driverTbl.glIsVertexAttribEnabledAPPLE;
   }
   return driverTbl.glIsVertexAttribEnabledAPPLE(index, pname);
}

static void REGAL_CALL missing_glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(order);
   UNUSED_PARAMETER(points);
   Warning( "glMapVertexAttrib1dAPPLE not available." );
}

static void REGAL_CALL loader_glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapVertexAttrib1dAPPLE, "glMapVertexAttrib1dAPPLE");
   if ( !driverTbl.glMapVertexAttrib1dAPPLE ) {
      driverTbl.glMapVertexAttrib1dAPPLE = missing_glMapVertexAttrib1dAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapVertexAttrib1dAPPLE == loader_glMapVertexAttrib1dAPPLE) {
      rCtx->dsp->emuTbl.glMapVertexAttrib1dAPPLE = driverTbl.glMapVertexAttrib1dAPPLE;
   }
   driverTbl.glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);
}

static void REGAL_CALL missing_glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(order);
   UNUSED_PARAMETER(points);
   Warning( "glMapVertexAttrib1fAPPLE not available." );
}

static void REGAL_CALL loader_glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapVertexAttrib1fAPPLE, "glMapVertexAttrib1fAPPLE");
   if ( !driverTbl.glMapVertexAttrib1fAPPLE ) {
      driverTbl.glMapVertexAttrib1fAPPLE = missing_glMapVertexAttrib1fAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapVertexAttrib1fAPPLE == loader_glMapVertexAttrib1fAPPLE) {
      rCtx->dsp->emuTbl.glMapVertexAttrib1fAPPLE = driverTbl.glMapVertexAttrib1fAPPLE;
   }
   driverTbl.glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);
}

static void REGAL_CALL missing_glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(uorder);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(vorder);
   UNUSED_PARAMETER(points);
   Warning( "glMapVertexAttrib2dAPPLE not available." );
}

static void REGAL_CALL loader_glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapVertexAttrib2dAPPLE, "glMapVertexAttrib2dAPPLE");
   if ( !driverTbl.glMapVertexAttrib2dAPPLE ) {
      driverTbl.glMapVertexAttrib2dAPPLE = missing_glMapVertexAttrib2dAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapVertexAttrib2dAPPLE == loader_glMapVertexAttrib2dAPPLE) {
      rCtx->dsp->emuTbl.glMapVertexAttrib2dAPPLE = driverTbl.glMapVertexAttrib2dAPPLE;
   }
   driverTbl.glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

static void REGAL_CALL missing_glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(uorder);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(vorder);
   UNUSED_PARAMETER(points);
   Warning( "glMapVertexAttrib2fAPPLE not available." );
}

static void REGAL_CALL loader_glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapVertexAttrib2fAPPLE, "glMapVertexAttrib2fAPPLE");
   if ( !driverTbl.glMapVertexAttrib2fAPPLE ) {
      driverTbl.glMapVertexAttrib2fAPPLE = missing_glMapVertexAttrib2fAPPLE;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapVertexAttrib2fAPPLE == loader_glMapVertexAttrib2fAPPLE) {
      rCtx->dsp->emuTbl.glMapVertexAttrib2fAPPLE = driverTbl.glMapVertexAttrib2fAPPLE;
   }
   driverTbl.glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

// GL_ARB_ES2_compatibility

static void REGAL_CALL missing_glClearDepthf(GLclampf d)
{
   UNUSED_PARAMETER(d);
   Warning( "glClearDepthf not available." );
}

static void REGAL_CALL loader_glClearDepthf(GLclampf d)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearDepthf, "glClearDepthf");
   if ( !driverTbl.glClearDepthf ) {
      driverTbl.glClearDepthf = missing_glClearDepthf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearDepthf == loader_glClearDepthf) {
      rCtx->dsp->emuTbl.glClearDepthf = driverTbl.glClearDepthf;
   }
   driverTbl.glClearDepthf(d);
}

static void REGAL_CALL missing_glDepthRangef(GLclampf n, GLclampf f)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(f);
   Warning( "glDepthRangef not available." );
}

static void REGAL_CALL loader_glDepthRangef(GLclampf n, GLclampf f)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDepthRangef, "glDepthRangef");
   if ( !driverTbl.glDepthRangef ) {
      driverTbl.glDepthRangef = missing_glDepthRangef;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDepthRangef == loader_glDepthRangef) {
      rCtx->dsp->emuTbl.glDepthRangef = driverTbl.glDepthRangef;
   }
   driverTbl.glDepthRangef(n, f);
}

static void REGAL_CALL missing_glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision)
{
   UNUSED_PARAMETER(shadertype);
   UNUSED_PARAMETER(precisiontype);
   UNUSED_PARAMETER(range);
   UNUSED_PARAMETER(precision);
   Warning( "glGetShaderPrecisionFormat not available." );
}

static void REGAL_CALL loader_glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetShaderPrecisionFormat, "glGetShaderPrecisionFormat");
   if ( !driverTbl.glGetShaderPrecisionFormat ) {
      driverTbl.glGetShaderPrecisionFormat = missing_glGetShaderPrecisionFormat;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetShaderPrecisionFormat == loader_glGetShaderPrecisionFormat) {
      rCtx->dsp->emuTbl.glGetShaderPrecisionFormat = driverTbl.glGetShaderPrecisionFormat;
   }
   driverTbl.glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision);
}

static void REGAL_CALL missing_glReleaseShaderCompiler(void)
{
   Warning( "glReleaseShaderCompiler not available." );
}

static void REGAL_CALL loader_glReleaseShaderCompiler(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReleaseShaderCompiler, "glReleaseShaderCompiler");
   if ( !driverTbl.glReleaseShaderCompiler ) {
      driverTbl.glReleaseShaderCompiler = missing_glReleaseShaderCompiler;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReleaseShaderCompiler == loader_glReleaseShaderCompiler) {
      rCtx->dsp->emuTbl.glReleaseShaderCompiler = driverTbl.glReleaseShaderCompiler;
   }
   driverTbl.glReleaseShaderCompiler();
}

static void REGAL_CALL missing_glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length)
{
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(shaders);
   UNUSED_PARAMETER(binaryformat);
   UNUSED_PARAMETER(binary);
   UNUSED_PARAMETER(length);
   Warning( "glShaderBinary not available." );
}

static void REGAL_CALL loader_glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glShaderBinary, "glShaderBinary");
   if ( !driverTbl.glShaderBinary ) {
      driverTbl.glShaderBinary = missing_glShaderBinary;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glShaderBinary == loader_glShaderBinary) {
      rCtx->dsp->emuTbl.glShaderBinary = driverTbl.glShaderBinary;
   }
   driverTbl.glShaderBinary(count, shaders, binaryformat, binary, length);
}

// GL_ARB_base_instance

static void REGAL_CALL missing_glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(baseinstance);
   Warning( "glDrawArraysInstancedBaseInstance not available." );
}

static void REGAL_CALL loader_glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawArraysInstancedBaseInstance, "glDrawArraysInstancedBaseInstance");
   if ( !driverTbl.glDrawArraysInstancedBaseInstance ) {
      driverTbl.glDrawArraysInstancedBaseInstance = missing_glDrawArraysInstancedBaseInstance;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawArraysInstancedBaseInstance == loader_glDrawArraysInstancedBaseInstance) {
      rCtx->dsp->emuTbl.glDrawArraysInstancedBaseInstance = driverTbl.glDrawArraysInstancedBaseInstance;
   }
   driverTbl.glDrawArraysInstancedBaseInstance(mode, first, count, primcount, baseinstance);
}

static void REGAL_CALL missing_glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLuint baseinstance)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(baseinstance);
   Warning( "glDrawElementsInstancedBaseInstance not available." );
}

static void REGAL_CALL loader_glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLuint baseinstance)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawElementsInstancedBaseInstance, "glDrawElementsInstancedBaseInstance");
   if ( !driverTbl.glDrawElementsInstancedBaseInstance ) {
      driverTbl.glDrawElementsInstancedBaseInstance = missing_glDrawElementsInstancedBaseInstance;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawElementsInstancedBaseInstance == loader_glDrawElementsInstancedBaseInstance) {
      rCtx->dsp->emuTbl.glDrawElementsInstancedBaseInstance = driverTbl.glDrawElementsInstancedBaseInstance;
   }
   driverTbl.glDrawElementsInstancedBaseInstance(mode, count, type, indices, primcount, baseinstance);
}

static void REGAL_CALL missing_glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(basevertex);
   UNUSED_PARAMETER(baseinstance);
   Warning( "glDrawElementsInstancedBaseVertexBaseInstance not available." );
}

static void REGAL_CALL loader_glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawElementsInstancedBaseVertexBaseInstance, "glDrawElementsInstancedBaseVertexBaseInstance");
   if ( !driverTbl.glDrawElementsInstancedBaseVertexBaseInstance ) {
      driverTbl.glDrawElementsInstancedBaseVertexBaseInstance = missing_glDrawElementsInstancedBaseVertexBaseInstance;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawElementsInstancedBaseVertexBaseInstance == loader_glDrawElementsInstancedBaseVertexBaseInstance) {
      rCtx->dsp->emuTbl.glDrawElementsInstancedBaseVertexBaseInstance = driverTbl.glDrawElementsInstancedBaseVertexBaseInstance;
   }
   driverTbl.glDrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, primcount, basevertex, baseinstance);
}

// GL_ARB_blend_func_extended

static void REGAL_CALL missing_glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(colorNumber);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(name);
   Warning( "glBindFragDataLocationIndexed not available." );
}

static void REGAL_CALL loader_glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindFragDataLocationIndexed, "glBindFragDataLocationIndexed");
   if ( !driverTbl.glBindFragDataLocationIndexed ) {
      driverTbl.glBindFragDataLocationIndexed = missing_glBindFragDataLocationIndexed;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindFragDataLocationIndexed == loader_glBindFragDataLocationIndexed) {
      rCtx->dsp->emuTbl.glBindFragDataLocationIndexed = driverTbl.glBindFragDataLocationIndexed;
   }
   driverTbl.glBindFragDataLocationIndexed(program, colorNumber, index, name);
}

static GLint REGAL_CALL missing_glGetFragDataIndex(GLuint program, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(name);
   Warning( "glGetFragDataIndex not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetFragDataIndex(GLuint program, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFragDataIndex, "glGetFragDataIndex");
   if ( !driverTbl.glGetFragDataIndex ) {
      driverTbl.glGetFragDataIndex = missing_glGetFragDataIndex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFragDataIndex == loader_glGetFragDataIndex) {
      rCtx->dsp->emuTbl.glGetFragDataIndex = driverTbl.glGetFragDataIndex;
   }
   return driverTbl.glGetFragDataIndex(program, name);
}

// GL_ARB_cl_event

static GLsync REGAL_CALL missing_glCreateSyncFromCLeventARB(cl_context context, cl_event event, GLbitfield flags)
{
   UNUSED_PARAMETER(context);
   UNUSED_PARAMETER(event);
   UNUSED_PARAMETER(flags);
   Warning( "glCreateSyncFromCLeventARB not available." );
  GLsync  ret = (GLsync )0;
  return ret;
}

static GLsync REGAL_CALL loader_glCreateSyncFromCLeventARB(cl_context context, cl_event event, GLbitfield flags)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCreateSyncFromCLeventARB, "glCreateSyncFromCLeventARB");
   if ( !driverTbl.glCreateSyncFromCLeventARB ) {
      driverTbl.glCreateSyncFromCLeventARB = missing_glCreateSyncFromCLeventARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCreateSyncFromCLeventARB == loader_glCreateSyncFromCLeventARB) {
      rCtx->dsp->emuTbl.glCreateSyncFromCLeventARB = driverTbl.glCreateSyncFromCLeventARB;
   }
   return driverTbl.glCreateSyncFromCLeventARB(context, event, flags);
}

// GL_ARB_clear_buffer_object

static void REGAL_CALL missing_glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(data);
   Warning( "glClearBufferData not available." );
}

static void REGAL_CALL loader_glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearBufferData, "glClearBufferData");
   if ( !driverTbl.glClearBufferData ) {
      driverTbl.glClearBufferData = missing_glClearBufferData;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearBufferData == loader_glClearBufferData) {
      rCtx->dsp->emuTbl.glClearBufferData = driverTbl.glClearBufferData;
   }
   driverTbl.glClearBufferData(target, internalformat, format, type, data);
}

static void REGAL_CALL missing_glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(data);
   Warning( "glClearBufferSubData not available." );
}

static void REGAL_CALL loader_glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearBufferSubData, "glClearBufferSubData");
   if ( !driverTbl.glClearBufferSubData ) {
      driverTbl.glClearBufferSubData = missing_glClearBufferSubData;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearBufferSubData == loader_glClearBufferSubData) {
      rCtx->dsp->emuTbl.glClearBufferSubData = driverTbl.glClearBufferSubData;
   }
   driverTbl.glClearBufferSubData(target, internalformat, offset, size, format, type, data);
}

static void REGAL_CALL missing_glClearNamedBufferDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(data);
   Warning( "glClearNamedBufferDataEXT not available." );
}

static void REGAL_CALL loader_glClearNamedBufferDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearNamedBufferDataEXT, "glClearNamedBufferDataEXT");
   if ( !driverTbl.glClearNamedBufferDataEXT ) {
      driverTbl.glClearNamedBufferDataEXT = missing_glClearNamedBufferDataEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearNamedBufferDataEXT == loader_glClearNamedBufferDataEXT) {
      rCtx->dsp->emuTbl.glClearNamedBufferDataEXT = driverTbl.glClearNamedBufferDataEXT;
   }
   driverTbl.glClearNamedBufferDataEXT(buffer, internalformat, format, type, data);
}

static void REGAL_CALL missing_glClearNamedBufferSubDataEXT(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid *data)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(data);
   Warning( "glClearNamedBufferSubDataEXT not available." );
}

static void REGAL_CALL loader_glClearNamedBufferSubDataEXT(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearNamedBufferSubDataEXT, "glClearNamedBufferSubDataEXT");
   if ( !driverTbl.glClearNamedBufferSubDataEXT ) {
      driverTbl.glClearNamedBufferSubDataEXT = missing_glClearNamedBufferSubDataEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearNamedBufferSubDataEXT == loader_glClearNamedBufferSubDataEXT) {
      rCtx->dsp->emuTbl.glClearNamedBufferSubDataEXT = driverTbl.glClearNamedBufferSubDataEXT;
   }
   driverTbl.glClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, type, data);
}

// GL_ARB_color_buffer_float

static void REGAL_CALL missing_glClampColorARB(GLenum target, GLenum clamp)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(clamp);
   Warning( "glClampColorARB not available." );
}

static void REGAL_CALL loader_glClampColorARB(GLenum target, GLenum clamp)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClampColorARB, "glClampColorARB");
   if ( !driverTbl.glClampColorARB ) {
      driverTbl.glClampColorARB = missing_glClampColorARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClampColorARB == loader_glClampColorARB) {
      rCtx->dsp->emuTbl.glClampColorARB = driverTbl.glClampColorARB;
   }
   driverTbl.glClampColorARB(target, clamp);
}

// GL_ARB_compute_shader

static void REGAL_CALL missing_glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)
{
   UNUSED_PARAMETER(num_groups_x);
   UNUSED_PARAMETER(num_groups_y);
   UNUSED_PARAMETER(num_groups_z);
   Warning( "glDispatchCompute not available." );
}

static void REGAL_CALL loader_glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDispatchCompute, "glDispatchCompute");
   if ( !driverTbl.glDispatchCompute ) {
      driverTbl.glDispatchCompute = missing_glDispatchCompute;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDispatchCompute == loader_glDispatchCompute) {
      rCtx->dsp->emuTbl.glDispatchCompute = driverTbl.glDispatchCompute;
   }
   driverTbl.glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
}

static void REGAL_CALL missing_glDispatchComputeIndirect(GLintptr indirect)
{
   UNUSED_PARAMETER(indirect);
   Warning( "glDispatchComputeIndirect not available." );
}

static void REGAL_CALL loader_glDispatchComputeIndirect(GLintptr indirect)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDispatchComputeIndirect, "glDispatchComputeIndirect");
   if ( !driverTbl.glDispatchComputeIndirect ) {
      driverTbl.glDispatchComputeIndirect = missing_glDispatchComputeIndirect;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDispatchComputeIndirect == loader_glDispatchComputeIndirect) {
      rCtx->dsp->emuTbl.glDispatchComputeIndirect = driverTbl.glDispatchComputeIndirect;
   }
   driverTbl.glDispatchComputeIndirect(indirect);
}

// GL_ARB_copy_buffer

static void REGAL_CALL missing_glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
{
   UNUSED_PARAMETER(readtarget);
   UNUSED_PARAMETER(writetarget);
   UNUSED_PARAMETER(readoffset);
   UNUSED_PARAMETER(writeoffset);
   UNUSED_PARAMETER(size);
   Warning( "glCopyBufferSubData not available." );
}

static void REGAL_CALL loader_glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyBufferSubData, "glCopyBufferSubData");
   if ( !driverTbl.glCopyBufferSubData ) {
      driverTbl.glCopyBufferSubData = missing_glCopyBufferSubData;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyBufferSubData == loader_glCopyBufferSubData) {
      rCtx->dsp->emuTbl.glCopyBufferSubData = driverTbl.glCopyBufferSubData;
   }
   driverTbl.glCopyBufferSubData(readtarget, writetarget, readoffset, writeoffset, size);
}

// GL_ARB_copy_image

static void REGAL_CALL missing_glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)
{
   UNUSED_PARAMETER(srcName);
   UNUSED_PARAMETER(srcTarget);
   UNUSED_PARAMETER(srcLevel);
   UNUSED_PARAMETER(srcX);
   UNUSED_PARAMETER(srcY);
   UNUSED_PARAMETER(srcZ);
   UNUSED_PARAMETER(dstName);
   UNUSED_PARAMETER(dstTarget);
   UNUSED_PARAMETER(dstLevel);
   UNUSED_PARAMETER(dstX);
   UNUSED_PARAMETER(dstY);
   UNUSED_PARAMETER(dstZ);
   UNUSED_PARAMETER(srcWidth);
   UNUSED_PARAMETER(srcHeight);
   UNUSED_PARAMETER(srcDepth);
   Warning( "glCopyImageSubData not available." );
}

static void REGAL_CALL loader_glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyImageSubData, "glCopyImageSubData");
   if ( !driverTbl.glCopyImageSubData ) {
      driverTbl.glCopyImageSubData = missing_glCopyImageSubData;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyImageSubData == loader_glCopyImageSubData) {
      rCtx->dsp->emuTbl.glCopyImageSubData = driverTbl.glCopyImageSubData;
   }
   driverTbl.glCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
}

// GL_ARB_debug_output

static void REGAL_CALL missing_glDebugMessageCallbackARB(GLDEBUGPROCARB callback, GLvoid *userParam)
{
   UNUSED_PARAMETER(callback);
   UNUSED_PARAMETER(userParam);
   Warning( "glDebugMessageCallbackARB not available." );
}

static void REGAL_CALL loader_glDebugMessageCallbackARB(GLDEBUGPROCARB callback, GLvoid *userParam)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDebugMessageCallbackARB, "glDebugMessageCallbackARB");
   if ( !driverTbl.glDebugMessageCallbackARB ) {
      driverTbl.glDebugMessageCallbackARB = missing_glDebugMessageCallbackARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDebugMessageCallbackARB == loader_glDebugMessageCallbackARB) {
      rCtx->dsp->emuTbl.glDebugMessageCallbackARB = driverTbl.glDebugMessageCallbackARB;
   }
   driverTbl.glDebugMessageCallbackARB(callback, userParam);
}

static void REGAL_CALL missing_glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
   UNUSED_PARAMETER(source);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(severity);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(ids);
   UNUSED_PARAMETER(enabled);
   Warning( "glDebugMessageControlARB not available." );
}

static void REGAL_CALL loader_glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDebugMessageControlARB, "glDebugMessageControlARB");
   if ( !driverTbl.glDebugMessageControlARB ) {
      driverTbl.glDebugMessageControlARB = missing_glDebugMessageControlARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDebugMessageControlARB == loader_glDebugMessageControlARB) {
      rCtx->dsp->emuTbl.glDebugMessageControlARB = driverTbl.glDebugMessageControlARB;
   }
   driverTbl.glDebugMessageControlARB(source, type, severity, count, ids, enabled);
}

static void REGAL_CALL missing_glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
{
   UNUSED_PARAMETER(source);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(severity);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(buf);
   Warning( "glDebugMessageInsertARB not available." );
}

static void REGAL_CALL loader_glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDebugMessageInsertARB, "glDebugMessageInsertARB");
   if ( !driverTbl.glDebugMessageInsertARB ) {
      driverTbl.glDebugMessageInsertARB = missing_glDebugMessageInsertARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDebugMessageInsertARB == loader_glDebugMessageInsertARB) {
      rCtx->dsp->emuTbl.glDebugMessageInsertARB = driverTbl.glDebugMessageInsertARB;
   }
   driverTbl.glDebugMessageInsertARB(source, type, id, severity, length, buf);
}

static GLuint REGAL_CALL missing_glGetDebugMessageLogARB(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
{
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(bufsize);
   UNUSED_PARAMETER(sources);
   UNUSED_PARAMETER(types);
   UNUSED_PARAMETER(ids);
   UNUSED_PARAMETER(severities);
   UNUSED_PARAMETER(lengths);
   UNUSED_PARAMETER(messageLog);
   Warning( "glGetDebugMessageLogARB not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGetDebugMessageLogARB(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetDebugMessageLogARB, "glGetDebugMessageLogARB");
   if ( !driverTbl.glGetDebugMessageLogARB ) {
      driverTbl.glGetDebugMessageLogARB = missing_glGetDebugMessageLogARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetDebugMessageLogARB == loader_glGetDebugMessageLogARB) {
      rCtx->dsp->emuTbl.glGetDebugMessageLogARB = driverTbl.glGetDebugMessageLogARB;
   }
   return driverTbl.glGetDebugMessageLogARB(count, bufsize, sources, types, ids, severities, lengths, messageLog);
}

// GL_ARB_draw_buffers

static void REGAL_CALL missing_glDrawBuffersARB(GLsizei n, const GLenum *bufs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(bufs);
   Warning( "glDrawBuffersARB not available." );
}

static void REGAL_CALL loader_glDrawBuffersARB(GLsizei n, const GLenum *bufs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawBuffersARB, "glDrawBuffersARB");
   if ( !driverTbl.glDrawBuffersARB ) {
      driverTbl.glDrawBuffersARB = missing_glDrawBuffersARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawBuffersARB == loader_glDrawBuffersARB) {
      rCtx->dsp->emuTbl.glDrawBuffersARB = driverTbl.glDrawBuffersARB;
   }
   driverTbl.glDrawBuffersARB(n, bufs);
}

// GL_ARB_draw_buffers_blend

static void REGAL_CALL missing_glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(modeRGB);
   UNUSED_PARAMETER(modeAlpha);
   Warning( "glBlendEquationSeparateiARB not available." );
}

static void REGAL_CALL loader_glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendEquationSeparateiARB, "glBlendEquationSeparateiARB");
   if ( !driverTbl.glBlendEquationSeparateiARB ) {
      driverTbl.glBlendEquationSeparateiARB = missing_glBlendEquationSeparateiARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendEquationSeparateiARB == loader_glBlendEquationSeparateiARB) {
      rCtx->dsp->emuTbl.glBlendEquationSeparateiARB = driverTbl.glBlendEquationSeparateiARB;
   }
   driverTbl.glBlendEquationSeparateiARB(buf, modeRGB, modeAlpha);
}

static void REGAL_CALL missing_glBlendEquationiARB(GLuint buf, GLenum mode)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(mode);
   Warning( "glBlendEquationiARB not available." );
}

static void REGAL_CALL loader_glBlendEquationiARB(GLuint buf, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendEquationiARB, "glBlendEquationiARB");
   if ( !driverTbl.glBlendEquationiARB ) {
      driverTbl.glBlendEquationiARB = missing_glBlendEquationiARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendEquationiARB == loader_glBlendEquationiARB) {
      rCtx->dsp->emuTbl.glBlendEquationiARB = driverTbl.glBlendEquationiARB;
   }
   driverTbl.glBlendEquationiARB(buf, mode);
}

static void REGAL_CALL missing_glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(srcRGB);
   UNUSED_PARAMETER(dstRGB);
   UNUSED_PARAMETER(srcAlpha);
   UNUSED_PARAMETER(dstAlpha);
   Warning( "glBlendFuncSeparateiARB not available." );
}

static void REGAL_CALL loader_glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendFuncSeparateiARB, "glBlendFuncSeparateiARB");
   if ( !driverTbl.glBlendFuncSeparateiARB ) {
      driverTbl.glBlendFuncSeparateiARB = missing_glBlendFuncSeparateiARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendFuncSeparateiARB == loader_glBlendFuncSeparateiARB) {
      rCtx->dsp->emuTbl.glBlendFuncSeparateiARB = driverTbl.glBlendFuncSeparateiARB;
   }
   driverTbl.glBlendFuncSeparateiARB(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}

static void REGAL_CALL missing_glBlendFunciARB(GLuint buf, GLenum src, GLenum dst)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(src);
   UNUSED_PARAMETER(dst);
   Warning( "glBlendFunciARB not available." );
}

static void REGAL_CALL loader_glBlendFunciARB(GLuint buf, GLenum src, GLenum dst)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendFunciARB, "glBlendFunciARB");
   if ( !driverTbl.glBlendFunciARB ) {
      driverTbl.glBlendFunciARB = missing_glBlendFunciARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendFunciARB == loader_glBlendFunciARB) {
      rCtx->dsp->emuTbl.glBlendFunciARB = driverTbl.glBlendFunciARB;
   }
   driverTbl.glBlendFunciARB(buf, src, dst);
}

// GL_ARB_draw_elements_base_vertex

static void REGAL_CALL missing_glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, GLvoid *indices, GLint basevertex)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(basevertex);
   Warning( "glDrawElementsBaseVertex not available." );
}

static void REGAL_CALL loader_glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, GLvoid *indices, GLint basevertex)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawElementsBaseVertex, "glDrawElementsBaseVertex");
   if ( !driverTbl.glDrawElementsBaseVertex ) {
      driverTbl.glDrawElementsBaseVertex = missing_glDrawElementsBaseVertex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawElementsBaseVertex == loader_glDrawElementsBaseVertex) {
      rCtx->dsp->emuTbl.glDrawElementsBaseVertex = driverTbl.glDrawElementsBaseVertex;
   }
   driverTbl.glDrawElementsBaseVertex(mode, count, type, indices, basevertex);
}

static void REGAL_CALL missing_glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(basevertex);
   Warning( "glDrawElementsInstancedBaseVertex not available." );
}

static void REGAL_CALL loader_glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawElementsInstancedBaseVertex, "glDrawElementsInstancedBaseVertex");
   if ( !driverTbl.glDrawElementsInstancedBaseVertex ) {
      driverTbl.glDrawElementsInstancedBaseVertex = missing_glDrawElementsInstancedBaseVertex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawElementsInstancedBaseVertex == loader_glDrawElementsInstancedBaseVertex) {
      rCtx->dsp->emuTbl.glDrawElementsInstancedBaseVertex = driverTbl.glDrawElementsInstancedBaseVertex;
   }
   driverTbl.glDrawElementsInstancedBaseVertex(mode, count, type, indices, primcount, basevertex);
}

static void REGAL_CALL missing_glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLvoid *indices, GLint basevertex)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(end);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(basevertex);
   Warning( "glDrawRangeElementsBaseVertex not available." );
}

static void REGAL_CALL loader_glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLvoid *indices, GLint basevertex)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawRangeElementsBaseVertex, "glDrawRangeElementsBaseVertex");
   if ( !driverTbl.glDrawRangeElementsBaseVertex ) {
      driverTbl.glDrawRangeElementsBaseVertex = missing_glDrawRangeElementsBaseVertex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawRangeElementsBaseVertex == loader_glDrawRangeElementsBaseVertex) {
      rCtx->dsp->emuTbl.glDrawRangeElementsBaseVertex = driverTbl.glDrawRangeElementsBaseVertex;
   }
   driverTbl.glDrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
}

static void REGAL_CALL missing_glMultiDrawElementsBaseVertex(GLenum mode, GLsizei *count, GLenum type, GLvoid **indices, GLsizei primcount, GLint *basevertex)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(basevertex);
   Warning( "glMultiDrawElementsBaseVertex not available." );
}

static void REGAL_CALL loader_glMultiDrawElementsBaseVertex(GLenum mode, GLsizei *count, GLenum type, GLvoid **indices, GLsizei primcount, GLint *basevertex)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiDrawElementsBaseVertex, "glMultiDrawElementsBaseVertex");
   if ( !driverTbl.glMultiDrawElementsBaseVertex ) {
      driverTbl.glMultiDrawElementsBaseVertex = missing_glMultiDrawElementsBaseVertex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiDrawElementsBaseVertex == loader_glMultiDrawElementsBaseVertex) {
      rCtx->dsp->emuTbl.glMultiDrawElementsBaseVertex = driverTbl.glMultiDrawElementsBaseVertex;
   }
   driverTbl.glMultiDrawElementsBaseVertex(mode, count, type, indices, primcount, basevertex);
}

// GL_ARB_draw_indirect

static void REGAL_CALL missing_glDrawArraysIndirect(GLenum mode, const GLvoid *indirect)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(indirect);
   Warning( "glDrawArraysIndirect not available." );
}

static void REGAL_CALL loader_glDrawArraysIndirect(GLenum mode, const GLvoid *indirect)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawArraysIndirect, "glDrawArraysIndirect");
   if ( !driverTbl.glDrawArraysIndirect ) {
      driverTbl.glDrawArraysIndirect = missing_glDrawArraysIndirect;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawArraysIndirect == loader_glDrawArraysIndirect) {
      rCtx->dsp->emuTbl.glDrawArraysIndirect = driverTbl.glDrawArraysIndirect;
   }
   driverTbl.glDrawArraysIndirect(mode, indirect);
}

static void REGAL_CALL missing_glDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indirect);
   Warning( "glDrawElementsIndirect not available." );
}

static void REGAL_CALL loader_glDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawElementsIndirect, "glDrawElementsIndirect");
   if ( !driverTbl.glDrawElementsIndirect ) {
      driverTbl.glDrawElementsIndirect = missing_glDrawElementsIndirect;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawElementsIndirect == loader_glDrawElementsIndirect) {
      rCtx->dsp->emuTbl.glDrawElementsIndirect = driverTbl.glDrawElementsIndirect;
   }
   driverTbl.glDrawElementsIndirect(mode, type, indirect);
}

// GL_ARB_draw_instanced

static void REGAL_CALL missing_glDrawArraysInstancedARB(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   Warning( "glDrawArraysInstancedARB not available." );
}

static void REGAL_CALL loader_glDrawArraysInstancedARB(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawArraysInstancedARB, "glDrawArraysInstancedARB");
   if ( !driverTbl.glDrawArraysInstancedARB ) {
      driverTbl.glDrawArraysInstancedARB = missing_glDrawArraysInstancedARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawArraysInstancedARB == loader_glDrawArraysInstancedARB) {
      rCtx->dsp->emuTbl.glDrawArraysInstancedARB = driverTbl.glDrawArraysInstancedARB;
   }
   driverTbl.glDrawArraysInstancedARB(mode, start, count, primcount);
}

static void REGAL_CALL missing_glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   Warning( "glDrawElementsInstancedARB not available." );
}

static void REGAL_CALL loader_glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawElementsInstancedARB, "glDrawElementsInstancedARB");
   if ( !driverTbl.glDrawElementsInstancedARB ) {
      driverTbl.glDrawElementsInstancedARB = missing_glDrawElementsInstancedARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawElementsInstancedARB == loader_glDrawElementsInstancedARB) {
      rCtx->dsp->emuTbl.glDrawElementsInstancedARB = driverTbl.glDrawElementsInstancedARB;
   }
   driverTbl.glDrawElementsInstancedARB(mode, count, type, indices, primcount);
}

// GL_ARB_framebuffer_no_attachments

static void REGAL_CALL missing_glFramebufferParameteri(GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFramebufferParameteri not available." );
}

static void REGAL_CALL loader_glFramebufferParameteri(GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferParameteri, "glFramebufferParameteri");
   if ( !driverTbl.glFramebufferParameteri ) {
      driverTbl.glFramebufferParameteri = missing_glFramebufferParameteri;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferParameteri == loader_glFramebufferParameteri) {
      rCtx->dsp->emuTbl.glFramebufferParameteri = driverTbl.glFramebufferParameteri;
   }
   driverTbl.glFramebufferParameteri(target, pname, param);
}

static void REGAL_CALL missing_glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFramebufferParameteriv not available." );
}

static void REGAL_CALL loader_glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFramebufferParameteriv, "glGetFramebufferParameteriv");
   if ( !driverTbl.glGetFramebufferParameteriv ) {
      driverTbl.glGetFramebufferParameteriv = missing_glGetFramebufferParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFramebufferParameteriv == loader_glGetFramebufferParameteriv) {
      rCtx->dsp->emuTbl.glGetFramebufferParameteriv = driverTbl.glGetFramebufferParameteriv;
   }
   driverTbl.glGetFramebufferParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glGetNamedFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetNamedFramebufferParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetNamedFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedFramebufferParameterivEXT, "glGetNamedFramebufferParameterivEXT");
   if ( !driverTbl.glGetNamedFramebufferParameterivEXT ) {
      driverTbl.glGetNamedFramebufferParameterivEXT = missing_glGetNamedFramebufferParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedFramebufferParameterivEXT == loader_glGetNamedFramebufferParameterivEXT) {
      rCtx->dsp->emuTbl.glGetNamedFramebufferParameterivEXT = driverTbl.glGetNamedFramebufferParameterivEXT;
   }
   driverTbl.glGetNamedFramebufferParameterivEXT(framebuffer, pname, params);
}

static void REGAL_CALL missing_glNamedFramebufferParameteriEXT(GLuint framebuffer, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glNamedFramebufferParameteriEXT not available." );
}

static void REGAL_CALL loader_glNamedFramebufferParameteriEXT(GLuint framebuffer, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedFramebufferParameteriEXT, "glNamedFramebufferParameteriEXT");
   if ( !driverTbl.glNamedFramebufferParameteriEXT ) {
      driverTbl.glNamedFramebufferParameteriEXT = missing_glNamedFramebufferParameteriEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedFramebufferParameteriEXT == loader_glNamedFramebufferParameteriEXT) {
      rCtx->dsp->emuTbl.glNamedFramebufferParameteriEXT = driverTbl.glNamedFramebufferParameteriEXT;
   }
   driverTbl.glNamedFramebufferParameteriEXT(framebuffer, pname, param);
}

// GL_ARB_framebuffer_object

static void REGAL_CALL missing_glBindFramebuffer(GLenum target, GLuint framebuffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(framebuffer);
   Warning( "glBindFramebuffer not available." );
}

static void REGAL_CALL loader_glBindFramebuffer(GLenum target, GLuint framebuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindFramebuffer, "glBindFramebuffer");
   if ( !driverTbl.glBindFramebuffer ) {
      driverTbl.glBindFramebuffer = missing_glBindFramebuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindFramebuffer == loader_glBindFramebuffer) {
      rCtx->dsp->emuTbl.glBindFramebuffer = driverTbl.glBindFramebuffer;
   }
   driverTbl.glBindFramebuffer(target, framebuffer);
}

static void REGAL_CALL missing_glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "glBindRenderbuffer not available." );
}

static void REGAL_CALL loader_glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindRenderbuffer, "glBindRenderbuffer");
   if ( !driverTbl.glBindRenderbuffer ) {
      driverTbl.glBindRenderbuffer = missing_glBindRenderbuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindRenderbuffer == loader_glBindRenderbuffer) {
      rCtx->dsp->emuTbl.glBindRenderbuffer = driverTbl.glBindRenderbuffer;
   }
   driverTbl.glBindRenderbuffer(target, renderbuffer);
}

static void REGAL_CALL missing_glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
   UNUSED_PARAMETER(srcX0);
   UNUSED_PARAMETER(srcY0);
   UNUSED_PARAMETER(srcX1);
   UNUSED_PARAMETER(srcY1);
   UNUSED_PARAMETER(dstX0);
   UNUSED_PARAMETER(dstY0);
   UNUSED_PARAMETER(dstX1);
   UNUSED_PARAMETER(dstY1);
   UNUSED_PARAMETER(mask);
   UNUSED_PARAMETER(filter);
   Warning( "glBlitFramebuffer not available." );
}

static void REGAL_CALL loader_glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlitFramebuffer, "glBlitFramebuffer");
   if ( !driverTbl.glBlitFramebuffer ) {
      driverTbl.glBlitFramebuffer = missing_glBlitFramebuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlitFramebuffer == loader_glBlitFramebuffer) {
      rCtx->dsp->emuTbl.glBlitFramebuffer = driverTbl.glBlitFramebuffer;
   }
   driverTbl.glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

static GLenum REGAL_CALL missing_glCheckFramebufferStatus(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glCheckFramebufferStatus not available." );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glCheckFramebufferStatus(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCheckFramebufferStatus, "glCheckFramebufferStatus");
   if ( !driverTbl.glCheckFramebufferStatus ) {
      driverTbl.glCheckFramebufferStatus = missing_glCheckFramebufferStatus;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCheckFramebufferStatus == loader_glCheckFramebufferStatus) {
      rCtx->dsp->emuTbl.glCheckFramebufferStatus = driverTbl.glCheckFramebufferStatus;
   }
   return driverTbl.glCheckFramebufferStatus(target);
}

static void REGAL_CALL missing_glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(framebuffers);
   Warning( "glDeleteFramebuffers not available." );
}

static void REGAL_CALL loader_glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteFramebuffers, "glDeleteFramebuffers");
   if ( !driverTbl.glDeleteFramebuffers ) {
      driverTbl.glDeleteFramebuffers = missing_glDeleteFramebuffers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteFramebuffers == loader_glDeleteFramebuffers) {
      rCtx->dsp->emuTbl.glDeleteFramebuffers = driverTbl.glDeleteFramebuffers;
   }
   driverTbl.glDeleteFramebuffers(n, framebuffers);
}

static void REGAL_CALL missing_glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(renderbuffers);
   Warning( "glDeleteRenderbuffers not available." );
}

static void REGAL_CALL loader_glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteRenderbuffers, "glDeleteRenderbuffers");
   if ( !driverTbl.glDeleteRenderbuffers ) {
      driverTbl.glDeleteRenderbuffers = missing_glDeleteRenderbuffers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteRenderbuffers == loader_glDeleteRenderbuffers) {
      rCtx->dsp->emuTbl.glDeleteRenderbuffers = driverTbl.glDeleteRenderbuffers;
   }
   driverTbl.glDeleteRenderbuffers(n, renderbuffers);
}

static void REGAL_CALL missing_glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(renderbuffertarget);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "glFramebufferRenderbuffer not available." );
}

static void REGAL_CALL loader_glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferRenderbuffer, "glFramebufferRenderbuffer");
   if ( !driverTbl.glFramebufferRenderbuffer ) {
      driverTbl.glFramebufferRenderbuffer = missing_glFramebufferRenderbuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferRenderbuffer == loader_glFramebufferRenderbuffer) {
      rCtx->dsp->emuTbl.glFramebufferRenderbuffer = driverTbl.glFramebufferRenderbuffer;
   }
   driverTbl.glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
}

static void REGAL_CALL missing_glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "glFramebufferTexture1D not available." );
}

static void REGAL_CALL loader_glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTexture1D, "glFramebufferTexture1D");
   if ( !driverTbl.glFramebufferTexture1D ) {
      driverTbl.glFramebufferTexture1D = missing_glFramebufferTexture1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTexture1D == loader_glFramebufferTexture1D) {
      rCtx->dsp->emuTbl.glFramebufferTexture1D = driverTbl.glFramebufferTexture1D;
   }
   driverTbl.glFramebufferTexture1D(target, attachment, textarget, texture, level);
}

static void REGAL_CALL missing_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "glFramebufferTexture2D not available." );
}

static void REGAL_CALL loader_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTexture2D, "glFramebufferTexture2D");
   if ( !driverTbl.glFramebufferTexture2D ) {
      driverTbl.glFramebufferTexture2D = missing_glFramebufferTexture2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTexture2D == loader_glFramebufferTexture2D) {
      rCtx->dsp->emuTbl.glFramebufferTexture2D = driverTbl.glFramebufferTexture2D;
   }
   driverTbl.glFramebufferTexture2D(target, attachment, textarget, texture, level);
}

static void REGAL_CALL missing_glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layer);
   Warning( "glFramebufferTexture3D not available." );
}

static void REGAL_CALL loader_glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTexture3D, "glFramebufferTexture3D");
   if ( !driverTbl.glFramebufferTexture3D ) {
      driverTbl.glFramebufferTexture3D = missing_glFramebufferTexture3D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTexture3D == loader_glFramebufferTexture3D) {
      rCtx->dsp->emuTbl.glFramebufferTexture3D = driverTbl.glFramebufferTexture3D;
   }
   driverTbl.glFramebufferTexture3D(target, attachment, textarget, texture, level, layer);
}

static void REGAL_CALL missing_glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layer);
   Warning( "glFramebufferTextureLayer not available." );
}

static void REGAL_CALL loader_glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTextureLayer, "glFramebufferTextureLayer");
   if ( !driverTbl.glFramebufferTextureLayer ) {
      driverTbl.glFramebufferTextureLayer = missing_glFramebufferTextureLayer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTextureLayer == loader_glFramebufferTextureLayer) {
      rCtx->dsp->emuTbl.glFramebufferTextureLayer = driverTbl.glFramebufferTextureLayer;
   }
   driverTbl.glFramebufferTextureLayer(target, attachment, texture, level, layer);
}

static void REGAL_CALL missing_glGenFramebuffers(GLsizei n, GLuint *framebuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(framebuffers);
   Warning( "glGenFramebuffers not available." );
}

static void REGAL_CALL loader_glGenFramebuffers(GLsizei n, GLuint *framebuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenFramebuffers, "glGenFramebuffers");
   if ( !driverTbl.glGenFramebuffers ) {
      driverTbl.glGenFramebuffers = missing_glGenFramebuffers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenFramebuffers == loader_glGenFramebuffers) {
      rCtx->dsp->emuTbl.glGenFramebuffers = driverTbl.glGenFramebuffers;
   }
   driverTbl.glGenFramebuffers(n, framebuffers);
}

static void REGAL_CALL missing_glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(renderbuffers);
   Warning( "glGenRenderbuffers not available." );
}

static void REGAL_CALL loader_glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenRenderbuffers, "glGenRenderbuffers");
   if ( !driverTbl.glGenRenderbuffers ) {
      driverTbl.glGenRenderbuffers = missing_glGenRenderbuffers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenRenderbuffers == loader_glGenRenderbuffers) {
      rCtx->dsp->emuTbl.glGenRenderbuffers = driverTbl.glGenRenderbuffers;
   }
   driverTbl.glGenRenderbuffers(n, renderbuffers);
}

static void REGAL_CALL missing_glGenerateMipmap(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glGenerateMipmap not available." );
}

static void REGAL_CALL loader_glGenerateMipmap(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenerateMipmap, "glGenerateMipmap");
   if ( !driverTbl.glGenerateMipmap ) {
      driverTbl.glGenerateMipmap = missing_glGenerateMipmap;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenerateMipmap == loader_glGenerateMipmap) {
      rCtx->dsp->emuTbl.glGenerateMipmap = driverTbl.glGenerateMipmap;
   }
   driverTbl.glGenerateMipmap(target);
}

static void REGAL_CALL missing_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFramebufferAttachmentParameteriv not available." );
}

static void REGAL_CALL loader_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFramebufferAttachmentParameteriv, "glGetFramebufferAttachmentParameteriv");
   if ( !driverTbl.glGetFramebufferAttachmentParameteriv ) {
      driverTbl.glGetFramebufferAttachmentParameteriv = missing_glGetFramebufferAttachmentParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFramebufferAttachmentParameteriv == loader_glGetFramebufferAttachmentParameteriv) {
      rCtx->dsp->emuTbl.glGetFramebufferAttachmentParameteriv = driverTbl.glGetFramebufferAttachmentParameteriv;
   }
   driverTbl.glGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
}

static void REGAL_CALL missing_glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetRenderbufferParameteriv not available." );
}

static void REGAL_CALL loader_glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetRenderbufferParameteriv, "glGetRenderbufferParameteriv");
   if ( !driverTbl.glGetRenderbufferParameteriv ) {
      driverTbl.glGetRenderbufferParameteriv = missing_glGetRenderbufferParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetRenderbufferParameteriv == loader_glGetRenderbufferParameteriv) {
      rCtx->dsp->emuTbl.glGetRenderbufferParameteriv = driverTbl.glGetRenderbufferParameteriv;
   }
   driverTbl.glGetRenderbufferParameteriv(target, pname, params);
}

static GLboolean REGAL_CALL missing_glIsFramebuffer(GLuint framebuffer)
{
   UNUSED_PARAMETER(framebuffer);
   Warning( "glIsFramebuffer not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsFramebuffer(GLuint framebuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsFramebuffer, "glIsFramebuffer");
   if ( !driverTbl.glIsFramebuffer ) {
      driverTbl.glIsFramebuffer = missing_glIsFramebuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsFramebuffer == loader_glIsFramebuffer) {
      rCtx->dsp->emuTbl.glIsFramebuffer = driverTbl.glIsFramebuffer;
   }
   return driverTbl.glIsFramebuffer(framebuffer);
}

static GLboolean REGAL_CALL missing_glIsRenderbuffer(GLuint renderbuffer)
{
   UNUSED_PARAMETER(renderbuffer);
   Warning( "glIsRenderbuffer not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsRenderbuffer(GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsRenderbuffer, "glIsRenderbuffer");
   if ( !driverTbl.glIsRenderbuffer ) {
      driverTbl.glIsRenderbuffer = missing_glIsRenderbuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsRenderbuffer == loader_glIsRenderbuffer) {
      rCtx->dsp->emuTbl.glIsRenderbuffer = driverTbl.glIsRenderbuffer;
   }
   return driverTbl.glIsRenderbuffer(renderbuffer);
}

static void REGAL_CALL missing_glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glRenderbufferStorage not available." );
}

static void REGAL_CALL loader_glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRenderbufferStorage, "glRenderbufferStorage");
   if ( !driverTbl.glRenderbufferStorage ) {
      driverTbl.glRenderbufferStorage = missing_glRenderbufferStorage;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRenderbufferStorage == loader_glRenderbufferStorage) {
      rCtx->dsp->emuTbl.glRenderbufferStorage = driverTbl.glRenderbufferStorage;
   }
   driverTbl.glRenderbufferStorage(target, internalformat, width, height);
}

static void REGAL_CALL missing_glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glRenderbufferStorageMultisample not available." );
}

static void REGAL_CALL loader_glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRenderbufferStorageMultisample, "glRenderbufferStorageMultisample");
   if ( !driverTbl.glRenderbufferStorageMultisample ) {
      driverTbl.glRenderbufferStorageMultisample = missing_glRenderbufferStorageMultisample;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRenderbufferStorageMultisample == loader_glRenderbufferStorageMultisample) {
      rCtx->dsp->emuTbl.glRenderbufferStorageMultisample = driverTbl.glRenderbufferStorageMultisample;
   }
   driverTbl.glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
}

// GL_ARB_geometry_shader4

static void REGAL_CALL missing_glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "glFramebufferTextureARB not available." );
}

static void REGAL_CALL loader_glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTextureARB, "glFramebufferTextureARB");
   if ( !driverTbl.glFramebufferTextureARB ) {
      driverTbl.glFramebufferTextureARB = missing_glFramebufferTextureARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTextureARB == loader_glFramebufferTextureARB) {
      rCtx->dsp->emuTbl.glFramebufferTextureARB = driverTbl.glFramebufferTextureARB;
   }
   driverTbl.glFramebufferTextureARB(target, attachment, texture, level);
}

static void REGAL_CALL missing_glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(face);
   Warning( "glFramebufferTextureFaceARB not available." );
}

static void REGAL_CALL loader_glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTextureFaceARB, "glFramebufferTextureFaceARB");
   if ( !driverTbl.glFramebufferTextureFaceARB ) {
      driverTbl.glFramebufferTextureFaceARB = missing_glFramebufferTextureFaceARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTextureFaceARB == loader_glFramebufferTextureFaceARB) {
      rCtx->dsp->emuTbl.glFramebufferTextureFaceARB = driverTbl.glFramebufferTextureFaceARB;
   }
   driverTbl.glFramebufferTextureFaceARB(target, attachment, texture, level, face);
}

static void REGAL_CALL missing_glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layer);
   Warning( "glFramebufferTextureLayerARB not available." );
}

static void REGAL_CALL loader_glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTextureLayerARB, "glFramebufferTextureLayerARB");
   if ( !driverTbl.glFramebufferTextureLayerARB ) {
      driverTbl.glFramebufferTextureLayerARB = missing_glFramebufferTextureLayerARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTextureLayerARB == loader_glFramebufferTextureLayerARB) {
      rCtx->dsp->emuTbl.glFramebufferTextureLayerARB = driverTbl.glFramebufferTextureLayerARB;
   }
   driverTbl.glFramebufferTextureLayerARB(target, attachment, texture, level, layer);
}

static void REGAL_CALL missing_glProgramParameteriARB(GLuint program, GLenum pname, GLint value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "glProgramParameteriARB not available." );
}

static void REGAL_CALL loader_glProgramParameteriARB(GLuint program, GLenum pname, GLint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramParameteriARB, "glProgramParameteriARB");
   if ( !driverTbl.glProgramParameteriARB ) {
      driverTbl.glProgramParameteriARB = missing_glProgramParameteriARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramParameteriARB == loader_glProgramParameteriARB) {
      rCtx->dsp->emuTbl.glProgramParameteriARB = driverTbl.glProgramParameteriARB;
   }
   driverTbl.glProgramParameteriARB(program, pname, value);
}

// GL_ARB_get_program_binary

static void REGAL_CALL missing_glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(binaryFormat);
   UNUSED_PARAMETER(binary);
   Warning( "glGetProgramBinary not available." );
}

static void REGAL_CALL loader_glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramBinary, "glGetProgramBinary");
   if ( !driverTbl.glGetProgramBinary ) {
      driverTbl.glGetProgramBinary = missing_glGetProgramBinary;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramBinary == loader_glGetProgramBinary) {
      rCtx->dsp->emuTbl.glGetProgramBinary = driverTbl.glGetProgramBinary;
   }
   driverTbl.glGetProgramBinary(program, bufSize, length, binaryFormat, binary);
}

static void REGAL_CALL missing_glProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(binaryFormat);
   UNUSED_PARAMETER(binary);
   UNUSED_PARAMETER(length);
   Warning( "glProgramBinary not available." );
}

static void REGAL_CALL loader_glProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramBinary, "glProgramBinary");
   if ( !driverTbl.glProgramBinary ) {
      driverTbl.glProgramBinary = missing_glProgramBinary;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramBinary == loader_glProgramBinary) {
      rCtx->dsp->emuTbl.glProgramBinary = driverTbl.glProgramBinary;
   }
   driverTbl.glProgramBinary(program, binaryFormat, binary, length);
}

static void REGAL_CALL missing_glProgramParameteri(GLuint program, GLenum pname, GLint value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "glProgramParameteri not available." );
}

static void REGAL_CALL loader_glProgramParameteri(GLuint program, GLenum pname, GLint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramParameteri, "glProgramParameteri");
   if ( !driverTbl.glProgramParameteri ) {
      driverTbl.glProgramParameteri = missing_glProgramParameteri;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramParameteri == loader_glProgramParameteri) {
      rCtx->dsp->emuTbl.glProgramParameteri = driverTbl.glProgramParameteri;
   }
   driverTbl.glProgramParameteri(program, pname, value);
}

// GL_ARB_gpu_shader_fp64

static void REGAL_CALL missing_glGetUniformdv(GLuint program, GLint location, GLdouble *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "glGetUniformdv not available." );
}

static void REGAL_CALL loader_glGetUniformdv(GLuint program, GLint location, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformdv, "glGetUniformdv");
   if ( !driverTbl.glGetUniformdv ) {
      driverTbl.glGetUniformdv = missing_glGetUniformdv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformdv == loader_glGetUniformdv) {
      rCtx->dsp->emuTbl.glGetUniformdv = driverTbl.glGetUniformdv;
   }
   driverTbl.glGetUniformdv(program, location, params);
}

static void REGAL_CALL missing_glUniform1d(GLint location, GLdouble x)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "glUniform1d not available." );
}

static void REGAL_CALL loader_glUniform1d(GLint location, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1d, "glUniform1d");
   if ( !driverTbl.glUniform1d ) {
      driverTbl.glUniform1d = missing_glUniform1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1d == loader_glUniform1d) {
      rCtx->dsp->emuTbl.glUniform1d = driverTbl.glUniform1d;
   }
   driverTbl.glUniform1d(location, x);
}

static void REGAL_CALL missing_glUniform1dv(GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform1dv not available." );
}

static void REGAL_CALL loader_glUniform1dv(GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1dv, "glUniform1dv");
   if ( !driverTbl.glUniform1dv ) {
      driverTbl.glUniform1dv = missing_glUniform1dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1dv == loader_glUniform1dv) {
      rCtx->dsp->emuTbl.glUniform1dv = driverTbl.glUniform1dv;
   }
   driverTbl.glUniform1dv(location, count, value);
}

static void REGAL_CALL missing_glUniform2d(GLint location, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glUniform2d not available." );
}

static void REGAL_CALL loader_glUniform2d(GLint location, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2d, "glUniform2d");
   if ( !driverTbl.glUniform2d ) {
      driverTbl.glUniform2d = missing_glUniform2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2d == loader_glUniform2d) {
      rCtx->dsp->emuTbl.glUniform2d = driverTbl.glUniform2d;
   }
   driverTbl.glUniform2d(location, x, y);
}

static void REGAL_CALL missing_glUniform2dv(GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform2dv not available." );
}

static void REGAL_CALL loader_glUniform2dv(GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2dv, "glUniform2dv");
   if ( !driverTbl.glUniform2dv ) {
      driverTbl.glUniform2dv = missing_glUniform2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2dv == loader_glUniform2dv) {
      rCtx->dsp->emuTbl.glUniform2dv = driverTbl.glUniform2dv;
   }
   driverTbl.glUniform2dv(location, count, value);
}

static void REGAL_CALL missing_glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glUniform3d not available." );
}

static void REGAL_CALL loader_glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3d, "glUniform3d");
   if ( !driverTbl.glUniform3d ) {
      driverTbl.glUniform3d = missing_glUniform3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3d == loader_glUniform3d) {
      rCtx->dsp->emuTbl.glUniform3d = driverTbl.glUniform3d;
   }
   driverTbl.glUniform3d(location, x, y, z);
}

static void REGAL_CALL missing_glUniform3dv(GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform3dv not available." );
}

static void REGAL_CALL loader_glUniform3dv(GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3dv, "glUniform3dv");
   if ( !driverTbl.glUniform3dv ) {
      driverTbl.glUniform3dv = missing_glUniform3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3dv == loader_glUniform3dv) {
      rCtx->dsp->emuTbl.glUniform3dv = driverTbl.glUniform3dv;
   }
   driverTbl.glUniform3dv(location, count, value);
}

static void REGAL_CALL missing_glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glUniform4d not available." );
}

static void REGAL_CALL loader_glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4d, "glUniform4d");
   if ( !driverTbl.glUniform4d ) {
      driverTbl.glUniform4d = missing_glUniform4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4d == loader_glUniform4d) {
      rCtx->dsp->emuTbl.glUniform4d = driverTbl.glUniform4d;
   }
   driverTbl.glUniform4d(location, x, y, z, w);
}

static void REGAL_CALL missing_glUniform4dv(GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform4dv not available." );
}

static void REGAL_CALL loader_glUniform4dv(GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4dv, "glUniform4dv");
   if ( !driverTbl.glUniform4dv ) {
      driverTbl.glUniform4dv = missing_glUniform4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4dv == loader_glUniform4dv) {
      rCtx->dsp->emuTbl.glUniform4dv = driverTbl.glUniform4dv;
   }
   driverTbl.glUniform4dv(location, count, value);
}

static void REGAL_CALL missing_glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix2dv not available." );
}

static void REGAL_CALL loader_glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix2dv, "glUniformMatrix2dv");
   if ( !driverTbl.glUniformMatrix2dv ) {
      driverTbl.glUniformMatrix2dv = missing_glUniformMatrix2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix2dv == loader_glUniformMatrix2dv) {
      rCtx->dsp->emuTbl.glUniformMatrix2dv = driverTbl.glUniformMatrix2dv;
   }
   driverTbl.glUniformMatrix2dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix2x3dv not available." );
}

static void REGAL_CALL loader_glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix2x3dv, "glUniformMatrix2x3dv");
   if ( !driverTbl.glUniformMatrix2x3dv ) {
      driverTbl.glUniformMatrix2x3dv = missing_glUniformMatrix2x3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix2x3dv == loader_glUniformMatrix2x3dv) {
      rCtx->dsp->emuTbl.glUniformMatrix2x3dv = driverTbl.glUniformMatrix2x3dv;
   }
   driverTbl.glUniformMatrix2x3dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix2x4dv not available." );
}

static void REGAL_CALL loader_glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix2x4dv, "glUniformMatrix2x4dv");
   if ( !driverTbl.glUniformMatrix2x4dv ) {
      driverTbl.glUniformMatrix2x4dv = missing_glUniformMatrix2x4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix2x4dv == loader_glUniformMatrix2x4dv) {
      rCtx->dsp->emuTbl.glUniformMatrix2x4dv = driverTbl.glUniformMatrix2x4dv;
   }
   driverTbl.glUniformMatrix2x4dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix3dv not available." );
}

static void REGAL_CALL loader_glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix3dv, "glUniformMatrix3dv");
   if ( !driverTbl.glUniformMatrix3dv ) {
      driverTbl.glUniformMatrix3dv = missing_glUniformMatrix3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix3dv == loader_glUniformMatrix3dv) {
      rCtx->dsp->emuTbl.glUniformMatrix3dv = driverTbl.glUniformMatrix3dv;
   }
   driverTbl.glUniformMatrix3dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix3x2dv not available." );
}

static void REGAL_CALL loader_glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix3x2dv, "glUniformMatrix3x2dv");
   if ( !driverTbl.glUniformMatrix3x2dv ) {
      driverTbl.glUniformMatrix3x2dv = missing_glUniformMatrix3x2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix3x2dv == loader_glUniformMatrix3x2dv) {
      rCtx->dsp->emuTbl.glUniformMatrix3x2dv = driverTbl.glUniformMatrix3x2dv;
   }
   driverTbl.glUniformMatrix3x2dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix3x4dv not available." );
}

static void REGAL_CALL loader_glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix3x4dv, "glUniformMatrix3x4dv");
   if ( !driverTbl.glUniformMatrix3x4dv ) {
      driverTbl.glUniformMatrix3x4dv = missing_glUniformMatrix3x4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix3x4dv == loader_glUniformMatrix3x4dv) {
      rCtx->dsp->emuTbl.glUniformMatrix3x4dv = driverTbl.glUniformMatrix3x4dv;
   }
   driverTbl.glUniformMatrix3x4dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix4dv not available." );
}

static void REGAL_CALL loader_glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix4dv, "glUniformMatrix4dv");
   if ( !driverTbl.glUniformMatrix4dv ) {
      driverTbl.glUniformMatrix4dv = missing_glUniformMatrix4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix4dv == loader_glUniformMatrix4dv) {
      rCtx->dsp->emuTbl.glUniformMatrix4dv = driverTbl.glUniformMatrix4dv;
   }
   driverTbl.glUniformMatrix4dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix4x2dv not available." );
}

static void REGAL_CALL loader_glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix4x2dv, "glUniformMatrix4x2dv");
   if ( !driverTbl.glUniformMatrix4x2dv ) {
      driverTbl.glUniformMatrix4x2dv = missing_glUniformMatrix4x2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix4x2dv == loader_glUniformMatrix4x2dv) {
      rCtx->dsp->emuTbl.glUniformMatrix4x2dv = driverTbl.glUniformMatrix4x2dv;
   }
   driverTbl.glUniformMatrix4x2dv(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix4x3dv not available." );
}

static void REGAL_CALL loader_glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix4x3dv, "glUniformMatrix4x3dv");
   if ( !driverTbl.glUniformMatrix4x3dv ) {
      driverTbl.glUniformMatrix4x3dv = missing_glUniformMatrix4x3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix4x3dv == loader_glUniformMatrix4x3dv) {
      rCtx->dsp->emuTbl.glUniformMatrix4x3dv = driverTbl.glUniformMatrix4x3dv;
   }
   driverTbl.glUniformMatrix4x3dv(location, count, transpose, value);
}

// GL_ARB_imaging

static void REGAL_CALL missing_glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(data);
   Warning( "glColorSubTable not available." );
}

static void REGAL_CALL loader_glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorSubTable, "glColorSubTable");
   if ( !driverTbl.glColorSubTable ) {
      driverTbl.glColorSubTable = missing_glColorSubTable;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorSubTable == loader_glColorSubTable) {
      rCtx->dsp->emuTbl.glColorSubTable = driverTbl.glColorSubTable;
   }
   driverTbl.glColorSubTable(target, start, count, format, type, data);
}

static void REGAL_CALL missing_glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(table);
   Warning( "glColorTable not available." );
}

static void REGAL_CALL loader_glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorTable, "glColorTable");
   if ( !driverTbl.glColorTable ) {
      driverTbl.glColorTable = missing_glColorTable;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorTable == loader_glColorTable) {
      rCtx->dsp->emuTbl.glColorTable = driverTbl.glColorTable;
   }
   driverTbl.glColorTable(target, internalformat, width, format, type, table);
}

static void REGAL_CALL missing_glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glColorTableParameterfv not available." );
}

static void REGAL_CALL loader_glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorTableParameterfv, "glColorTableParameterfv");
   if ( !driverTbl.glColorTableParameterfv ) {
      driverTbl.glColorTableParameterfv = missing_glColorTableParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorTableParameterfv == loader_glColorTableParameterfv) {
      rCtx->dsp->emuTbl.glColorTableParameterfv = driverTbl.glColorTableParameterfv;
   }
   driverTbl.glColorTableParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glColorTableParameteriv not available." );
}

static void REGAL_CALL loader_glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorTableParameteriv, "glColorTableParameteriv");
   if ( !driverTbl.glColorTableParameteriv ) {
      driverTbl.glColorTableParameteriv = missing_glColorTableParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorTableParameteriv == loader_glColorTableParameteriv) {
      rCtx->dsp->emuTbl.glColorTableParameteriv = driverTbl.glColorTableParameteriv;
   }
   driverTbl.glColorTableParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(image);
   Warning( "glConvolutionFilter1D not available." );
}

static void REGAL_CALL loader_glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glConvolutionFilter1D, "glConvolutionFilter1D");
   if ( !driverTbl.glConvolutionFilter1D ) {
      driverTbl.glConvolutionFilter1D = missing_glConvolutionFilter1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glConvolutionFilter1D == loader_glConvolutionFilter1D) {
      rCtx->dsp->emuTbl.glConvolutionFilter1D = driverTbl.glConvolutionFilter1D;
   }
   driverTbl.glConvolutionFilter1D(target, internalformat, width, format, type, image);
}

static void REGAL_CALL missing_glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(image);
   Warning( "glConvolutionFilter2D not available." );
}

static void REGAL_CALL loader_glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glConvolutionFilter2D, "glConvolutionFilter2D");
   if ( !driverTbl.glConvolutionFilter2D ) {
      driverTbl.glConvolutionFilter2D = missing_glConvolutionFilter2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glConvolutionFilter2D == loader_glConvolutionFilter2D) {
      rCtx->dsp->emuTbl.glConvolutionFilter2D = driverTbl.glConvolutionFilter2D;
   }
   driverTbl.glConvolutionFilter2D(target, internalformat, width, height, format, type, image);
}

static void REGAL_CALL missing_glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glConvolutionParameterf not available." );
}

static void REGAL_CALL loader_glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glConvolutionParameterf, "glConvolutionParameterf");
   if ( !driverTbl.glConvolutionParameterf ) {
      driverTbl.glConvolutionParameterf = missing_glConvolutionParameterf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glConvolutionParameterf == loader_glConvolutionParameterf) {
      rCtx->dsp->emuTbl.glConvolutionParameterf = driverTbl.glConvolutionParameterf;
   }
   driverTbl.glConvolutionParameterf(target, pname, params);
}

static void REGAL_CALL missing_glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glConvolutionParameterfv not available." );
}

static void REGAL_CALL loader_glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glConvolutionParameterfv, "glConvolutionParameterfv");
   if ( !driverTbl.glConvolutionParameterfv ) {
      driverTbl.glConvolutionParameterfv = missing_glConvolutionParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glConvolutionParameterfv == loader_glConvolutionParameterfv) {
      rCtx->dsp->emuTbl.glConvolutionParameterfv = driverTbl.glConvolutionParameterfv;
   }
   driverTbl.glConvolutionParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glConvolutionParameteri not available." );
}

static void REGAL_CALL loader_glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glConvolutionParameteri, "glConvolutionParameteri");
   if ( !driverTbl.glConvolutionParameteri ) {
      driverTbl.glConvolutionParameteri = missing_glConvolutionParameteri;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glConvolutionParameteri == loader_glConvolutionParameteri) {
      rCtx->dsp->emuTbl.glConvolutionParameteri = driverTbl.glConvolutionParameteri;
   }
   driverTbl.glConvolutionParameteri(target, pname, params);
}

static void REGAL_CALL missing_glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glConvolutionParameteriv not available." );
}

static void REGAL_CALL loader_glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glConvolutionParameteriv, "glConvolutionParameteriv");
   if ( !driverTbl.glConvolutionParameteriv ) {
      driverTbl.glConvolutionParameteriv = missing_glConvolutionParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glConvolutionParameteriv == loader_glConvolutionParameteriv) {
      rCtx->dsp->emuTbl.glConvolutionParameteriv = driverTbl.glConvolutionParameteriv;
   }
   driverTbl.glConvolutionParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "glCopyColorSubTable not available." );
}

static void REGAL_CALL loader_glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyColorSubTable, "glCopyColorSubTable");
   if ( !driverTbl.glCopyColorSubTable ) {
      driverTbl.glCopyColorSubTable = missing_glCopyColorSubTable;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyColorSubTable == loader_glCopyColorSubTable) {
      rCtx->dsp->emuTbl.glCopyColorSubTable = driverTbl.glCopyColorSubTable;
   }
   driverTbl.glCopyColorSubTable(target, start, x, y, width);
}

static void REGAL_CALL missing_glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "glCopyColorTable not available." );
}

static void REGAL_CALL loader_glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyColorTable, "glCopyColorTable");
   if ( !driverTbl.glCopyColorTable ) {
      driverTbl.glCopyColorTable = missing_glCopyColorTable;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyColorTable == loader_glCopyColorTable) {
      rCtx->dsp->emuTbl.glCopyColorTable = driverTbl.glCopyColorTable;
   }
   driverTbl.glCopyColorTable(target, internalformat, x, y, width);
}

static void REGAL_CALL missing_glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "glCopyConvolutionFilter1D not available." );
}

static void REGAL_CALL loader_glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyConvolutionFilter1D, "glCopyConvolutionFilter1D");
   if ( !driverTbl.glCopyConvolutionFilter1D ) {
      driverTbl.glCopyConvolutionFilter1D = missing_glCopyConvolutionFilter1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyConvolutionFilter1D == loader_glCopyConvolutionFilter1D) {
      rCtx->dsp->emuTbl.glCopyConvolutionFilter1D = driverTbl.glCopyConvolutionFilter1D;
   }
   driverTbl.glCopyConvolutionFilter1D(target, internalformat, x, y, width);
}

static void REGAL_CALL missing_glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glCopyConvolutionFilter2D not available." );
}

static void REGAL_CALL loader_glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyConvolutionFilter2D, "glCopyConvolutionFilter2D");
   if ( !driverTbl.glCopyConvolutionFilter2D ) {
      driverTbl.glCopyConvolutionFilter2D = missing_glCopyConvolutionFilter2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyConvolutionFilter2D == loader_glCopyConvolutionFilter2D) {
      rCtx->dsp->emuTbl.glCopyConvolutionFilter2D = driverTbl.glCopyConvolutionFilter2D;
   }
   driverTbl.glCopyConvolutionFilter2D(target, internalformat, x, y, width, height);
}

static void REGAL_CALL missing_glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(table);
   Warning( "glGetColorTable not available." );
}

static void REGAL_CALL loader_glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetColorTable, "glGetColorTable");
   if ( !driverTbl.glGetColorTable ) {
      driverTbl.glGetColorTable = missing_glGetColorTable;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetColorTable == loader_glGetColorTable) {
      rCtx->dsp->emuTbl.glGetColorTable = driverTbl.glGetColorTable;
   }
   driverTbl.glGetColorTable(target, format, type, table);
}

static void REGAL_CALL missing_glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetColorTableParameterfv not available." );
}

static void REGAL_CALL loader_glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetColorTableParameterfv, "glGetColorTableParameterfv");
   if ( !driverTbl.glGetColorTableParameterfv ) {
      driverTbl.glGetColorTableParameterfv = missing_glGetColorTableParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetColorTableParameterfv == loader_glGetColorTableParameterfv) {
      rCtx->dsp->emuTbl.glGetColorTableParameterfv = driverTbl.glGetColorTableParameterfv;
   }
   driverTbl.glGetColorTableParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetColorTableParameteriv not available." );
}

static void REGAL_CALL loader_glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetColorTableParameteriv, "glGetColorTableParameteriv");
   if ( !driverTbl.glGetColorTableParameteriv ) {
      driverTbl.glGetColorTableParameteriv = missing_glGetColorTableParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetColorTableParameteriv == loader_glGetColorTableParameteriv) {
      rCtx->dsp->emuTbl.glGetColorTableParameteriv = driverTbl.glGetColorTableParameteriv;
   }
   driverTbl.glGetColorTableParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(image);
   Warning( "glGetConvolutionFilter not available." );
}

static void REGAL_CALL loader_glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetConvolutionFilter, "glGetConvolutionFilter");
   if ( !driverTbl.glGetConvolutionFilter ) {
      driverTbl.glGetConvolutionFilter = missing_glGetConvolutionFilter;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetConvolutionFilter == loader_glGetConvolutionFilter) {
      rCtx->dsp->emuTbl.glGetConvolutionFilter = driverTbl.glGetConvolutionFilter;
   }
   driverTbl.glGetConvolutionFilter(target, format, type, image);
}

static void REGAL_CALL missing_glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetConvolutionParameterfv not available." );
}

static void REGAL_CALL loader_glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetConvolutionParameterfv, "glGetConvolutionParameterfv");
   if ( !driverTbl.glGetConvolutionParameterfv ) {
      driverTbl.glGetConvolutionParameterfv = missing_glGetConvolutionParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetConvolutionParameterfv == loader_glGetConvolutionParameterfv) {
      rCtx->dsp->emuTbl.glGetConvolutionParameterfv = driverTbl.glGetConvolutionParameterfv;
   }
   driverTbl.glGetConvolutionParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetConvolutionParameteriv not available." );
}

static void REGAL_CALL loader_glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetConvolutionParameteriv, "glGetConvolutionParameteriv");
   if ( !driverTbl.glGetConvolutionParameteriv ) {
      driverTbl.glGetConvolutionParameteriv = missing_glGetConvolutionParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetConvolutionParameteriv == loader_glGetConvolutionParameteriv) {
      rCtx->dsp->emuTbl.glGetConvolutionParameteriv = driverTbl.glGetConvolutionParameteriv;
   }
   driverTbl.glGetConvolutionParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(reset);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(values);
   Warning( "glGetHistogram not available." );
}

static void REGAL_CALL loader_glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetHistogram, "glGetHistogram");
   if ( !driverTbl.glGetHistogram ) {
      driverTbl.glGetHistogram = missing_glGetHistogram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetHistogram == loader_glGetHistogram) {
      rCtx->dsp->emuTbl.glGetHistogram = driverTbl.glGetHistogram;
   }
   driverTbl.glGetHistogram(target, reset, format, type, values);
}

static void REGAL_CALL missing_glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetHistogramParameterfv not available." );
}

static void REGAL_CALL loader_glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetHistogramParameterfv, "glGetHistogramParameterfv");
   if ( !driverTbl.glGetHistogramParameterfv ) {
      driverTbl.glGetHistogramParameterfv = missing_glGetHistogramParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetHistogramParameterfv == loader_glGetHistogramParameterfv) {
      rCtx->dsp->emuTbl.glGetHistogramParameterfv = driverTbl.glGetHistogramParameterfv;
   }
   driverTbl.glGetHistogramParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetHistogramParameteriv not available." );
}

static void REGAL_CALL loader_glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetHistogramParameteriv, "glGetHistogramParameteriv");
   if ( !driverTbl.glGetHistogramParameteriv ) {
      driverTbl.glGetHistogramParameteriv = missing_glGetHistogramParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetHistogramParameteriv == loader_glGetHistogramParameteriv) {
      rCtx->dsp->emuTbl.glGetHistogramParameteriv = driverTbl.glGetHistogramParameteriv;
   }
   driverTbl.glGetHistogramParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(reset);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(types);
   UNUSED_PARAMETER(values);
   Warning( "glGetMinmax not available." );
}

static void REGAL_CALL loader_glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMinmax, "glGetMinmax");
   if ( !driverTbl.glGetMinmax ) {
      driverTbl.glGetMinmax = missing_glGetMinmax;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMinmax == loader_glGetMinmax) {
      rCtx->dsp->emuTbl.glGetMinmax = driverTbl.glGetMinmax;
   }
   driverTbl.glGetMinmax(target, reset, format, types, values);
}

static void REGAL_CALL missing_glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMinmaxParameterfv not available." );
}

static void REGAL_CALL loader_glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMinmaxParameterfv, "glGetMinmaxParameterfv");
   if ( !driverTbl.glGetMinmaxParameterfv ) {
      driverTbl.glGetMinmaxParameterfv = missing_glGetMinmaxParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMinmaxParameterfv == loader_glGetMinmaxParameterfv) {
      rCtx->dsp->emuTbl.glGetMinmaxParameterfv = driverTbl.glGetMinmaxParameterfv;
   }
   driverTbl.glGetMinmaxParameterfv(target, pname, params);
}

static void REGAL_CALL missing_glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMinmaxParameteriv not available." );
}

static void REGAL_CALL loader_glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMinmaxParameteriv, "glGetMinmaxParameteriv");
   if ( !driverTbl.glGetMinmaxParameteriv ) {
      driverTbl.glGetMinmaxParameteriv = missing_glGetMinmaxParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMinmaxParameteriv == loader_glGetMinmaxParameteriv) {
      rCtx->dsp->emuTbl.glGetMinmaxParameteriv = driverTbl.glGetMinmaxParameteriv;
   }
   driverTbl.glGetMinmaxParameteriv(target, pname, params);
}

static void REGAL_CALL missing_glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(row);
   UNUSED_PARAMETER(column);
   UNUSED_PARAMETER(span);
   Warning( "glGetSeparableFilter not available." );
}

static void REGAL_CALL loader_glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetSeparableFilter, "glGetSeparableFilter");
   if ( !driverTbl.glGetSeparableFilter ) {
      driverTbl.glGetSeparableFilter = missing_glGetSeparableFilter;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetSeparableFilter == loader_glGetSeparableFilter) {
      rCtx->dsp->emuTbl.glGetSeparableFilter = driverTbl.glGetSeparableFilter;
   }
   driverTbl.glGetSeparableFilter(target, format, type, row, column, span);
}

static void REGAL_CALL missing_glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(sink);
   Warning( "glHistogram not available." );
}

static void REGAL_CALL loader_glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glHistogram, "glHistogram");
   if ( !driverTbl.glHistogram ) {
      driverTbl.glHistogram = missing_glHistogram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glHistogram == loader_glHistogram) {
      rCtx->dsp->emuTbl.glHistogram = driverTbl.glHistogram;
   }
   driverTbl.glHistogram(target, width, internalformat, sink);
}

static void REGAL_CALL missing_glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(sink);
   Warning( "glMinmax not available." );
}

static void REGAL_CALL loader_glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMinmax, "glMinmax");
   if ( !driverTbl.glMinmax ) {
      driverTbl.glMinmax = missing_glMinmax;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMinmax == loader_glMinmax) {
      rCtx->dsp->emuTbl.glMinmax = driverTbl.glMinmax;
   }
   driverTbl.glMinmax(target, internalformat, sink);
}

static void REGAL_CALL missing_glResetHistogram(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glResetHistogram not available." );
}

static void REGAL_CALL loader_glResetHistogram(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glResetHistogram, "glResetHistogram");
   if ( !driverTbl.glResetHistogram ) {
      driverTbl.glResetHistogram = missing_glResetHistogram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glResetHistogram == loader_glResetHistogram) {
      rCtx->dsp->emuTbl.glResetHistogram = driverTbl.glResetHistogram;
   }
   driverTbl.glResetHistogram(target);
}

static void REGAL_CALL missing_glResetMinmax(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glResetMinmax not available." );
}

static void REGAL_CALL loader_glResetMinmax(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glResetMinmax, "glResetMinmax");
   if ( !driverTbl.glResetMinmax ) {
      driverTbl.glResetMinmax = missing_glResetMinmax;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glResetMinmax == loader_glResetMinmax) {
      rCtx->dsp->emuTbl.glResetMinmax = driverTbl.glResetMinmax;
   }
   driverTbl.glResetMinmax(target);
}

static void REGAL_CALL missing_glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(row);
   UNUSED_PARAMETER(column);
   Warning( "glSeparableFilter2D not available." );
}

static void REGAL_CALL loader_glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSeparableFilter2D, "glSeparableFilter2D");
   if ( !driverTbl.glSeparableFilter2D ) {
      driverTbl.glSeparableFilter2D = missing_glSeparableFilter2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSeparableFilter2D == loader_glSeparableFilter2D) {
      rCtx->dsp->emuTbl.glSeparableFilter2D = driverTbl.glSeparableFilter2D;
   }
   driverTbl.glSeparableFilter2D(target, internalformat, width, height, format, type, row, column);
}

// GL_ARB_instanced_arrays

static void REGAL_CALL missing_glVertexAttribDivisorARB(GLuint index, GLuint divisor)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(divisor);
   Warning( "glVertexAttribDivisorARB not available." );
}

static void REGAL_CALL loader_glVertexAttribDivisorARB(GLuint index, GLuint divisor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribDivisorARB, "glVertexAttribDivisorARB");
   if ( !driverTbl.glVertexAttribDivisorARB ) {
      driverTbl.glVertexAttribDivisorARB = missing_glVertexAttribDivisorARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribDivisorARB == loader_glVertexAttribDivisorARB) {
      rCtx->dsp->emuTbl.glVertexAttribDivisorARB = driverTbl.glVertexAttribDivisorARB;
   }
   driverTbl.glVertexAttribDivisorARB(index, divisor);
}

// GL_ARB_internalformat_query

static void REGAL_CALL missing_glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(params);
   Warning( "glGetInternalformativ not available." );
}

static void REGAL_CALL loader_glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetInternalformativ, "glGetInternalformativ");
   if ( !driverTbl.glGetInternalformativ ) {
      driverTbl.glGetInternalformativ = missing_glGetInternalformativ;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetInternalformativ == loader_glGetInternalformativ) {
      rCtx->dsp->emuTbl.glGetInternalformativ = driverTbl.glGetInternalformativ;
   }
   driverTbl.glGetInternalformativ(target, internalformat, pname, bufSize, params);
}

// GL_ARB_internalformat_query2

static void REGAL_CALL missing_glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(params);
   Warning( "glGetInternalformati64v not available." );
}

static void REGAL_CALL loader_glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetInternalformati64v, "glGetInternalformati64v");
   if ( !driverTbl.glGetInternalformati64v ) {
      driverTbl.glGetInternalformati64v = missing_glGetInternalformati64v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetInternalformati64v == loader_glGetInternalformati64v) {
      rCtx->dsp->emuTbl.glGetInternalformati64v = driverTbl.glGetInternalformati64v;
   }
   driverTbl.glGetInternalformati64v(target, internalformat, pname, bufSize, params);
}

// GL_ARB_invalidate_subdata

static void REGAL_CALL missing_glInvalidateBufferData(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "glInvalidateBufferData not available." );
}

static void REGAL_CALL loader_glInvalidateBufferData(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glInvalidateBufferData, "glInvalidateBufferData");
   if ( !driverTbl.glInvalidateBufferData ) {
      driverTbl.glInvalidateBufferData = missing_glInvalidateBufferData;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glInvalidateBufferData == loader_glInvalidateBufferData) {
      rCtx->dsp->emuTbl.glInvalidateBufferData = driverTbl.glInvalidateBufferData;
   }
   driverTbl.glInvalidateBufferData(buffer);
}

static void REGAL_CALL missing_glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(length);
   Warning( "glInvalidateBufferSubData not available." );
}

static void REGAL_CALL loader_glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glInvalidateBufferSubData, "glInvalidateBufferSubData");
   if ( !driverTbl.glInvalidateBufferSubData ) {
      driverTbl.glInvalidateBufferSubData = missing_glInvalidateBufferSubData;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glInvalidateBufferSubData == loader_glInvalidateBufferSubData) {
      rCtx->dsp->emuTbl.glInvalidateBufferSubData = driverTbl.glInvalidateBufferSubData;
   }
   driverTbl.glInvalidateBufferSubData(buffer, offset, length);
}

static void REGAL_CALL missing_glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(numAttachments);
   UNUSED_PARAMETER(attachments);
   Warning( "glInvalidateFramebuffer not available." );
}

static void REGAL_CALL loader_glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glInvalidateFramebuffer, "glInvalidateFramebuffer");
   if ( !driverTbl.glInvalidateFramebuffer ) {
      driverTbl.glInvalidateFramebuffer = missing_glInvalidateFramebuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glInvalidateFramebuffer == loader_glInvalidateFramebuffer) {
      rCtx->dsp->emuTbl.glInvalidateFramebuffer = driverTbl.glInvalidateFramebuffer;
   }
   driverTbl.glInvalidateFramebuffer(target, numAttachments, attachments);
}

static void REGAL_CALL missing_glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(numAttachments);
   UNUSED_PARAMETER(attachments);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glInvalidateSubFramebuffer not available." );
}

static void REGAL_CALL loader_glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glInvalidateSubFramebuffer, "glInvalidateSubFramebuffer");
   if ( !driverTbl.glInvalidateSubFramebuffer ) {
      driverTbl.glInvalidateSubFramebuffer = missing_glInvalidateSubFramebuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glInvalidateSubFramebuffer == loader_glInvalidateSubFramebuffer) {
      rCtx->dsp->emuTbl.glInvalidateSubFramebuffer = driverTbl.glInvalidateSubFramebuffer;
   }
   driverTbl.glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
}

static void REGAL_CALL missing_glInvalidateTexImage(GLuint texture, GLint level)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "glInvalidateTexImage not available." );
}

static void REGAL_CALL loader_glInvalidateTexImage(GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glInvalidateTexImage, "glInvalidateTexImage");
   if ( !driverTbl.glInvalidateTexImage ) {
      driverTbl.glInvalidateTexImage = missing_glInvalidateTexImage;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glInvalidateTexImage == loader_glInvalidateTexImage) {
      rCtx->dsp->emuTbl.glInvalidateTexImage = driverTbl.glInvalidateTexImage;
   }
   driverTbl.glInvalidateTexImage(texture, level);
}

static void REGAL_CALL missing_glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   Warning( "glInvalidateTexSubImage not available." );
}

static void REGAL_CALL loader_glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glInvalidateTexSubImage, "glInvalidateTexSubImage");
   if ( !driverTbl.glInvalidateTexSubImage ) {
      driverTbl.glInvalidateTexSubImage = missing_glInvalidateTexSubImage;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glInvalidateTexSubImage == loader_glInvalidateTexSubImage) {
      rCtx->dsp->emuTbl.glInvalidateTexSubImage = driverTbl.glInvalidateTexSubImage;
   }
   driverTbl.glInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);
}

// GL_ARB_map_buffer_range

static void REGAL_CALL missing_glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(length);
   Warning( "glFlushMappedBufferRange not available." );
}

static void REGAL_CALL loader_glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFlushMappedBufferRange, "glFlushMappedBufferRange");
   if ( !driverTbl.glFlushMappedBufferRange ) {
      driverTbl.glFlushMappedBufferRange = missing_glFlushMappedBufferRange;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFlushMappedBufferRange == loader_glFlushMappedBufferRange) {
      rCtx->dsp->emuTbl.glFlushMappedBufferRange = driverTbl.glFlushMappedBufferRange;
   }
   driverTbl.glFlushMappedBufferRange(target, offset, length);
}

static GLvoid *REGAL_CALL missing_glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(access);
   Warning( "glMapBufferRange not available." );
  GLvoid * ret = NULL;
  return ret;
}

static GLvoid *REGAL_CALL loader_glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapBufferRange, "glMapBufferRange");
   if ( !driverTbl.glMapBufferRange ) {
      driverTbl.glMapBufferRange = missing_glMapBufferRange;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapBufferRange == loader_glMapBufferRange) {
      rCtx->dsp->emuTbl.glMapBufferRange = driverTbl.glMapBufferRange;
   }
   return driverTbl.glMapBufferRange(target, offset, length, access);
}

// GL_ARB_matrix_palette

static void REGAL_CALL missing_glCurrentPaletteMatrixARB(GLint index)
{
   UNUSED_PARAMETER(index);
   Warning( "glCurrentPaletteMatrixARB not available." );
}

static void REGAL_CALL loader_glCurrentPaletteMatrixARB(GLint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCurrentPaletteMatrixARB, "glCurrentPaletteMatrixARB");
   if ( !driverTbl.glCurrentPaletteMatrixARB ) {
      driverTbl.glCurrentPaletteMatrixARB = missing_glCurrentPaletteMatrixARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCurrentPaletteMatrixARB == loader_glCurrentPaletteMatrixARB) {
      rCtx->dsp->emuTbl.glCurrentPaletteMatrixARB = driverTbl.glCurrentPaletteMatrixARB;
   }
   driverTbl.glCurrentPaletteMatrixARB(index);
}

static void REGAL_CALL missing_glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glMatrixIndexPointerARB not available." );
}

static void REGAL_CALL loader_glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixIndexPointerARB, "glMatrixIndexPointerARB");
   if ( !driverTbl.glMatrixIndexPointerARB ) {
      driverTbl.glMatrixIndexPointerARB = missing_glMatrixIndexPointerARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixIndexPointerARB == loader_glMatrixIndexPointerARB) {
      rCtx->dsp->emuTbl.glMatrixIndexPointerARB = driverTbl.glMatrixIndexPointerARB;
   }
   driverTbl.glMatrixIndexPointerARB(size, type, stride, pointer);
}

static void REGAL_CALL missing_glMatrixIndexubvARB(GLint size, GLubyte *indices)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(indices);
   Warning( "glMatrixIndexubvARB not available." );
}

static void REGAL_CALL loader_glMatrixIndexubvARB(GLint size, GLubyte *indices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixIndexubvARB, "glMatrixIndexubvARB");
   if ( !driverTbl.glMatrixIndexubvARB ) {
      driverTbl.glMatrixIndexubvARB = missing_glMatrixIndexubvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixIndexubvARB == loader_glMatrixIndexubvARB) {
      rCtx->dsp->emuTbl.glMatrixIndexubvARB = driverTbl.glMatrixIndexubvARB;
   }
   driverTbl.glMatrixIndexubvARB(size, indices);
}

static void REGAL_CALL missing_glMatrixIndexuivARB(GLint size, GLuint *indices)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(indices);
   Warning( "glMatrixIndexuivARB not available." );
}

static void REGAL_CALL loader_glMatrixIndexuivARB(GLint size, GLuint *indices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixIndexuivARB, "glMatrixIndexuivARB");
   if ( !driverTbl.glMatrixIndexuivARB ) {
      driverTbl.glMatrixIndexuivARB = missing_glMatrixIndexuivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixIndexuivARB == loader_glMatrixIndexuivARB) {
      rCtx->dsp->emuTbl.glMatrixIndexuivARB = driverTbl.glMatrixIndexuivARB;
   }
   driverTbl.glMatrixIndexuivARB(size, indices);
}

static void REGAL_CALL missing_glMatrixIndexusvARB(GLint size, GLushort *indices)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(indices);
   Warning( "glMatrixIndexusvARB not available." );
}

static void REGAL_CALL loader_glMatrixIndexusvARB(GLint size, GLushort *indices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixIndexusvARB, "glMatrixIndexusvARB");
   if ( !driverTbl.glMatrixIndexusvARB ) {
      driverTbl.glMatrixIndexusvARB = missing_glMatrixIndexusvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixIndexusvARB == loader_glMatrixIndexusvARB) {
      rCtx->dsp->emuTbl.glMatrixIndexusvARB = driverTbl.glMatrixIndexusvARB;
   }
   driverTbl.glMatrixIndexusvARB(size, indices);
}

// GL_ARB_multi_draw_indirect

static void REGAL_CALL missing_glMultiDrawArraysIndirect(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(indirect);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(stride);
   Warning( "glMultiDrawArraysIndirect not available." );
}

static void REGAL_CALL loader_glMultiDrawArraysIndirect(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiDrawArraysIndirect, "glMultiDrawArraysIndirect");
   if ( !driverTbl.glMultiDrawArraysIndirect ) {
      driverTbl.glMultiDrawArraysIndirect = missing_glMultiDrawArraysIndirect;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiDrawArraysIndirect == loader_glMultiDrawArraysIndirect) {
      rCtx->dsp->emuTbl.glMultiDrawArraysIndirect = driverTbl.glMultiDrawArraysIndirect;
   }
   driverTbl.glMultiDrawArraysIndirect(mode, indirect, primcount, stride);
}

static void REGAL_CALL missing_glMultiDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indirect);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(stride);
   Warning( "glMultiDrawElementsIndirect not available." );
}

static void REGAL_CALL loader_glMultiDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiDrawElementsIndirect, "glMultiDrawElementsIndirect");
   if ( !driverTbl.glMultiDrawElementsIndirect ) {
      driverTbl.glMultiDrawElementsIndirect = missing_glMultiDrawElementsIndirect;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiDrawElementsIndirect == loader_glMultiDrawElementsIndirect) {
      rCtx->dsp->emuTbl.glMultiDrawElementsIndirect = driverTbl.glMultiDrawElementsIndirect;
   }
   driverTbl.glMultiDrawElementsIndirect(mode, type, indirect, primcount, stride);
}

// GL_ARB_multisample

static void REGAL_CALL missing_glSampleCoverageARB(GLclampf value, GLboolean invert)
{
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(invert);
   Warning( "glSampleCoverageARB not available." );
}

static void REGAL_CALL loader_glSampleCoverageARB(GLclampf value, GLboolean invert)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSampleCoverageARB, "glSampleCoverageARB");
   if ( !driverTbl.glSampleCoverageARB ) {
      driverTbl.glSampleCoverageARB = missing_glSampleCoverageARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSampleCoverageARB == loader_glSampleCoverageARB) {
      rCtx->dsp->emuTbl.glSampleCoverageARB = driverTbl.glSampleCoverageARB;
   }
   driverTbl.glSampleCoverageARB(value, invert);
}

// GL_ARB_multitexture

static void REGAL_CALL missing_glActiveTextureARB(GLenum texture)
{
   UNUSED_PARAMETER(texture);
   Warning( "glActiveTextureARB not available." );
}

static void REGAL_CALL loader_glActiveTextureARB(GLenum texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glActiveTextureARB, "glActiveTextureARB");
   if ( !driverTbl.glActiveTextureARB ) {
      driverTbl.glActiveTextureARB = missing_glActiveTextureARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glActiveTextureARB == loader_glActiveTextureARB) {
      rCtx->dsp->emuTbl.glActiveTextureARB = driverTbl.glActiveTextureARB;
   }
   driverTbl.glActiveTextureARB(texture);
}

static void REGAL_CALL missing_glClientActiveTextureARB(GLenum texture)
{
   UNUSED_PARAMETER(texture);
   Warning( "glClientActiveTextureARB not available." );
}

static void REGAL_CALL loader_glClientActiveTextureARB(GLenum texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClientActiveTextureARB, "glClientActiveTextureARB");
   if ( !driverTbl.glClientActiveTextureARB ) {
      driverTbl.glClientActiveTextureARB = missing_glClientActiveTextureARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClientActiveTextureARB == loader_glClientActiveTextureARB) {
      rCtx->dsp->emuTbl.glClientActiveTextureARB = driverTbl.glClientActiveTextureARB;
   }
   driverTbl.glClientActiveTextureARB(texture);
}

static void REGAL_CALL missing_glMultiTexCoord1dARB(GLenum target, GLdouble s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "glMultiTexCoord1dARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1dARB(GLenum target, GLdouble s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1dARB, "glMultiTexCoord1dARB");
   if ( !driverTbl.glMultiTexCoord1dARB ) {
      driverTbl.glMultiTexCoord1dARB = missing_glMultiTexCoord1dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1dARB == loader_glMultiTexCoord1dARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord1dARB = driverTbl.glMultiTexCoord1dARB;
   }
   driverTbl.glMultiTexCoord1dARB(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord1dvARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1dvARB, "glMultiTexCoord1dvARB");
   if ( !driverTbl.glMultiTexCoord1dvARB ) {
      driverTbl.glMultiTexCoord1dvARB = missing_glMultiTexCoord1dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1dvARB == loader_glMultiTexCoord1dvARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord1dvARB = driverTbl.glMultiTexCoord1dvARB;
   }
   driverTbl.glMultiTexCoord1dvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord1fARB(GLenum target, GLfloat s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "glMultiTexCoord1fARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1fARB(GLenum target, GLfloat s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1fARB, "glMultiTexCoord1fARB");
   if ( !driverTbl.glMultiTexCoord1fARB ) {
      driverTbl.glMultiTexCoord1fARB = missing_glMultiTexCoord1fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1fARB == loader_glMultiTexCoord1fARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord1fARB = driverTbl.glMultiTexCoord1fARB;
   }
   driverTbl.glMultiTexCoord1fARB(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord1fvARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1fvARB, "glMultiTexCoord1fvARB");
   if ( !driverTbl.glMultiTexCoord1fvARB ) {
      driverTbl.glMultiTexCoord1fvARB = missing_glMultiTexCoord1fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1fvARB == loader_glMultiTexCoord1fvARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord1fvARB = driverTbl.glMultiTexCoord1fvARB;
   }
   driverTbl.glMultiTexCoord1fvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord1iARB(GLenum target, GLint s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "glMultiTexCoord1iARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1iARB(GLenum target, GLint s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1iARB, "glMultiTexCoord1iARB");
   if ( !driverTbl.glMultiTexCoord1iARB ) {
      driverTbl.glMultiTexCoord1iARB = missing_glMultiTexCoord1iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1iARB == loader_glMultiTexCoord1iARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord1iARB = driverTbl.glMultiTexCoord1iARB;
   }
   driverTbl.glMultiTexCoord1iARB(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1ivARB(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord1ivARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1ivARB(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1ivARB, "glMultiTexCoord1ivARB");
   if ( !driverTbl.glMultiTexCoord1ivARB ) {
      driverTbl.glMultiTexCoord1ivARB = missing_glMultiTexCoord1ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1ivARB == loader_glMultiTexCoord1ivARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord1ivARB = driverTbl.glMultiTexCoord1ivARB;
   }
   driverTbl.glMultiTexCoord1ivARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord1sARB(GLenum target, GLshort s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "glMultiTexCoord1sARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1sARB(GLenum target, GLshort s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1sARB, "glMultiTexCoord1sARB");
   if ( !driverTbl.glMultiTexCoord1sARB ) {
      driverTbl.glMultiTexCoord1sARB = missing_glMultiTexCoord1sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1sARB == loader_glMultiTexCoord1sARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord1sARB = driverTbl.glMultiTexCoord1sARB;
   }
   driverTbl.glMultiTexCoord1sARB(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1svARB(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord1svARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1svARB(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1svARB, "glMultiTexCoord1svARB");
   if ( !driverTbl.glMultiTexCoord1svARB ) {
      driverTbl.glMultiTexCoord1svARB = missing_glMultiTexCoord1svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1svARB == loader_glMultiTexCoord1svARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord1svARB = driverTbl.glMultiTexCoord1svARB;
   }
   driverTbl.glMultiTexCoord1svARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "glMultiTexCoord2dARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2dARB, "glMultiTexCoord2dARB");
   if ( !driverTbl.glMultiTexCoord2dARB ) {
      driverTbl.glMultiTexCoord2dARB = missing_glMultiTexCoord2dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2dARB == loader_glMultiTexCoord2dARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord2dARB = driverTbl.glMultiTexCoord2dARB;
   }
   driverTbl.glMultiTexCoord2dARB(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord2dvARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2dvARB, "glMultiTexCoord2dvARB");
   if ( !driverTbl.glMultiTexCoord2dvARB ) {
      driverTbl.glMultiTexCoord2dvARB = missing_glMultiTexCoord2dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2dvARB == loader_glMultiTexCoord2dvARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord2dvARB = driverTbl.glMultiTexCoord2dvARB;
   }
   driverTbl.glMultiTexCoord2dvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "glMultiTexCoord2fARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2fARB, "glMultiTexCoord2fARB");
   if ( !driverTbl.glMultiTexCoord2fARB ) {
      driverTbl.glMultiTexCoord2fARB = missing_glMultiTexCoord2fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2fARB == loader_glMultiTexCoord2fARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord2fARB = driverTbl.glMultiTexCoord2fARB;
   }
   driverTbl.glMultiTexCoord2fARB(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord2fvARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2fvARB, "glMultiTexCoord2fvARB");
   if ( !driverTbl.glMultiTexCoord2fvARB ) {
      driverTbl.glMultiTexCoord2fvARB = missing_glMultiTexCoord2fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2fvARB == loader_glMultiTexCoord2fvARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord2fvARB = driverTbl.glMultiTexCoord2fvARB;
   }
   driverTbl.glMultiTexCoord2fvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "glMultiTexCoord2iARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2iARB, "glMultiTexCoord2iARB");
   if ( !driverTbl.glMultiTexCoord2iARB ) {
      driverTbl.glMultiTexCoord2iARB = missing_glMultiTexCoord2iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2iARB == loader_glMultiTexCoord2iARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord2iARB = driverTbl.glMultiTexCoord2iARB;
   }
   driverTbl.glMultiTexCoord2iARB(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2ivARB(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord2ivARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2ivARB(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2ivARB, "glMultiTexCoord2ivARB");
   if ( !driverTbl.glMultiTexCoord2ivARB ) {
      driverTbl.glMultiTexCoord2ivARB = missing_glMultiTexCoord2ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2ivARB == loader_glMultiTexCoord2ivARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord2ivARB = driverTbl.glMultiTexCoord2ivARB;
   }
   driverTbl.glMultiTexCoord2ivARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "glMultiTexCoord2sARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2sARB, "glMultiTexCoord2sARB");
   if ( !driverTbl.glMultiTexCoord2sARB ) {
      driverTbl.glMultiTexCoord2sARB = missing_glMultiTexCoord2sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2sARB == loader_glMultiTexCoord2sARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord2sARB = driverTbl.glMultiTexCoord2sARB;
   }
   driverTbl.glMultiTexCoord2sARB(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2svARB(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord2svARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2svARB(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2svARB, "glMultiTexCoord2svARB");
   if ( !driverTbl.glMultiTexCoord2svARB ) {
      driverTbl.glMultiTexCoord2svARB = missing_glMultiTexCoord2svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2svARB == loader_glMultiTexCoord2svARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord2svARB = driverTbl.glMultiTexCoord2svARB;
   }
   driverTbl.glMultiTexCoord2svARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "glMultiTexCoord3dARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3dARB, "glMultiTexCoord3dARB");
   if ( !driverTbl.glMultiTexCoord3dARB ) {
      driverTbl.glMultiTexCoord3dARB = missing_glMultiTexCoord3dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3dARB == loader_glMultiTexCoord3dARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord3dARB = driverTbl.glMultiTexCoord3dARB;
   }
   driverTbl.glMultiTexCoord3dARB(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord3dvARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3dvARB, "glMultiTexCoord3dvARB");
   if ( !driverTbl.glMultiTexCoord3dvARB ) {
      driverTbl.glMultiTexCoord3dvARB = missing_glMultiTexCoord3dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3dvARB == loader_glMultiTexCoord3dvARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord3dvARB = driverTbl.glMultiTexCoord3dvARB;
   }
   driverTbl.glMultiTexCoord3dvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "glMultiTexCoord3fARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3fARB, "glMultiTexCoord3fARB");
   if ( !driverTbl.glMultiTexCoord3fARB ) {
      driverTbl.glMultiTexCoord3fARB = missing_glMultiTexCoord3fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3fARB == loader_glMultiTexCoord3fARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord3fARB = driverTbl.glMultiTexCoord3fARB;
   }
   driverTbl.glMultiTexCoord3fARB(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord3fvARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3fvARB, "glMultiTexCoord3fvARB");
   if ( !driverTbl.glMultiTexCoord3fvARB ) {
      driverTbl.glMultiTexCoord3fvARB = missing_glMultiTexCoord3fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3fvARB == loader_glMultiTexCoord3fvARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord3fvARB = driverTbl.glMultiTexCoord3fvARB;
   }
   driverTbl.glMultiTexCoord3fvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "glMultiTexCoord3iARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3iARB, "glMultiTexCoord3iARB");
   if ( !driverTbl.glMultiTexCoord3iARB ) {
      driverTbl.glMultiTexCoord3iARB = missing_glMultiTexCoord3iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3iARB == loader_glMultiTexCoord3iARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord3iARB = driverTbl.glMultiTexCoord3iARB;
   }
   driverTbl.glMultiTexCoord3iARB(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3ivARB(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord3ivARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3ivARB(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3ivARB, "glMultiTexCoord3ivARB");
   if ( !driverTbl.glMultiTexCoord3ivARB ) {
      driverTbl.glMultiTexCoord3ivARB = missing_glMultiTexCoord3ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3ivARB == loader_glMultiTexCoord3ivARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord3ivARB = driverTbl.glMultiTexCoord3ivARB;
   }
   driverTbl.glMultiTexCoord3ivARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "glMultiTexCoord3sARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3sARB, "glMultiTexCoord3sARB");
   if ( !driverTbl.glMultiTexCoord3sARB ) {
      driverTbl.glMultiTexCoord3sARB = missing_glMultiTexCoord3sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3sARB == loader_glMultiTexCoord3sARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord3sARB = driverTbl.glMultiTexCoord3sARB;
   }
   driverTbl.glMultiTexCoord3sARB(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3svARB(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord3svARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3svARB(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3svARB, "glMultiTexCoord3svARB");
   if ( !driverTbl.glMultiTexCoord3svARB ) {
      driverTbl.glMultiTexCoord3svARB = missing_glMultiTexCoord3svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3svARB == loader_glMultiTexCoord3svARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord3svARB = driverTbl.glMultiTexCoord3svARB;
   }
   driverTbl.glMultiTexCoord3svARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "glMultiTexCoord4dARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4dARB, "glMultiTexCoord4dARB");
   if ( !driverTbl.glMultiTexCoord4dARB ) {
      driverTbl.glMultiTexCoord4dARB = missing_glMultiTexCoord4dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4dARB == loader_glMultiTexCoord4dARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord4dARB = driverTbl.glMultiTexCoord4dARB;
   }
   driverTbl.glMultiTexCoord4dARB(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord4dvARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4dvARB, "glMultiTexCoord4dvARB");
   if ( !driverTbl.glMultiTexCoord4dvARB ) {
      driverTbl.glMultiTexCoord4dvARB = missing_glMultiTexCoord4dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4dvARB == loader_glMultiTexCoord4dvARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord4dvARB = driverTbl.glMultiTexCoord4dvARB;
   }
   driverTbl.glMultiTexCoord4dvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "glMultiTexCoord4fARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4fARB, "glMultiTexCoord4fARB");
   if ( !driverTbl.glMultiTexCoord4fARB ) {
      driverTbl.glMultiTexCoord4fARB = missing_glMultiTexCoord4fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4fARB == loader_glMultiTexCoord4fARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord4fARB = driverTbl.glMultiTexCoord4fARB;
   }
   driverTbl.glMultiTexCoord4fARB(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord4fvARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4fvARB, "glMultiTexCoord4fvARB");
   if ( !driverTbl.glMultiTexCoord4fvARB ) {
      driverTbl.glMultiTexCoord4fvARB = missing_glMultiTexCoord4fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4fvARB == loader_glMultiTexCoord4fvARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord4fvARB = driverTbl.glMultiTexCoord4fvARB;
   }
   driverTbl.glMultiTexCoord4fvARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "glMultiTexCoord4iARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4iARB, "glMultiTexCoord4iARB");
   if ( !driverTbl.glMultiTexCoord4iARB ) {
      driverTbl.glMultiTexCoord4iARB = missing_glMultiTexCoord4iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4iARB == loader_glMultiTexCoord4iARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord4iARB = driverTbl.glMultiTexCoord4iARB;
   }
   driverTbl.glMultiTexCoord4iARB(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4ivARB(GLenum target, const GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord4ivARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4ivARB(GLenum target, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4ivARB, "glMultiTexCoord4ivARB");
   if ( !driverTbl.glMultiTexCoord4ivARB ) {
      driverTbl.glMultiTexCoord4ivARB = missing_glMultiTexCoord4ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4ivARB == loader_glMultiTexCoord4ivARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord4ivARB = driverTbl.glMultiTexCoord4ivARB;
   }
   driverTbl.glMultiTexCoord4ivARB(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "glMultiTexCoord4sARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4sARB, "glMultiTexCoord4sARB");
   if ( !driverTbl.glMultiTexCoord4sARB ) {
      driverTbl.glMultiTexCoord4sARB = missing_glMultiTexCoord4sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4sARB == loader_glMultiTexCoord4sARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord4sARB = driverTbl.glMultiTexCoord4sARB;
   }
   driverTbl.glMultiTexCoord4sARB(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4svARB(GLenum target, const GLshort *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord4svARB not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4svARB(GLenum target, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4svARB, "glMultiTexCoord4svARB");
   if ( !driverTbl.glMultiTexCoord4svARB ) {
      driverTbl.glMultiTexCoord4svARB = missing_glMultiTexCoord4svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4svARB == loader_glMultiTexCoord4svARB) {
      rCtx->dsp->emuTbl.glMultiTexCoord4svARB = driverTbl.glMultiTexCoord4svARB;
   }
   driverTbl.glMultiTexCoord4svARB(target, v);
}

// GL_ARB_occlusion_query

static void REGAL_CALL missing_glBeginQueryARB(GLenum target, GLuint id)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(id);
   Warning( "glBeginQueryARB not available." );
}

static void REGAL_CALL loader_glBeginQueryARB(GLenum target, GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBeginQueryARB, "glBeginQueryARB");
   if ( !driverTbl.glBeginQueryARB ) {
      driverTbl.glBeginQueryARB = missing_glBeginQueryARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBeginQueryARB == loader_glBeginQueryARB) {
      rCtx->dsp->emuTbl.glBeginQueryARB = driverTbl.glBeginQueryARB;
   }
   driverTbl.glBeginQueryARB(target, id);
}

static void REGAL_CALL missing_glDeleteQueriesARB(GLsizei n, const GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "glDeleteQueriesARB not available." );
}

static void REGAL_CALL loader_glDeleteQueriesARB(GLsizei n, const GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteQueriesARB, "glDeleteQueriesARB");
   if ( !driverTbl.glDeleteQueriesARB ) {
      driverTbl.glDeleteQueriesARB = missing_glDeleteQueriesARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteQueriesARB == loader_glDeleteQueriesARB) {
      rCtx->dsp->emuTbl.glDeleteQueriesARB = driverTbl.glDeleteQueriesARB;
   }
   driverTbl.glDeleteQueriesARB(n, ids);
}

static void REGAL_CALL missing_glEndQueryARB(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glEndQueryARB not available." );
}

static void REGAL_CALL loader_glEndQueryARB(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndQueryARB, "glEndQueryARB");
   if ( !driverTbl.glEndQueryARB ) {
      driverTbl.glEndQueryARB = missing_glEndQueryARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndQueryARB == loader_glEndQueryARB) {
      rCtx->dsp->emuTbl.glEndQueryARB = driverTbl.glEndQueryARB;
   }
   driverTbl.glEndQueryARB(target);
}

static void REGAL_CALL missing_glGenQueriesARB(GLsizei n, GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "glGenQueriesARB not available." );
}

static void REGAL_CALL loader_glGenQueriesARB(GLsizei n, GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenQueriesARB, "glGenQueriesARB");
   if ( !driverTbl.glGenQueriesARB ) {
      driverTbl.glGenQueriesARB = missing_glGenQueriesARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenQueriesARB == loader_glGenQueriesARB) {
      rCtx->dsp->emuTbl.glGenQueriesARB = driverTbl.glGenQueriesARB;
   }
   driverTbl.glGenQueriesARB(n, ids);
}

static void REGAL_CALL missing_glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetQueryObjectivARB not available." );
}

static void REGAL_CALL loader_glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetQueryObjectivARB, "glGetQueryObjectivARB");
   if ( !driverTbl.glGetQueryObjectivARB ) {
      driverTbl.glGetQueryObjectivARB = missing_glGetQueryObjectivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetQueryObjectivARB == loader_glGetQueryObjectivARB) {
      rCtx->dsp->emuTbl.glGetQueryObjectivARB = driverTbl.glGetQueryObjectivARB;
   }
   driverTbl.glGetQueryObjectivARB(id, pname, params);
}

static void REGAL_CALL missing_glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetQueryObjectuivARB not available." );
}

static void REGAL_CALL loader_glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetQueryObjectuivARB, "glGetQueryObjectuivARB");
   if ( !driverTbl.glGetQueryObjectuivARB ) {
      driverTbl.glGetQueryObjectuivARB = missing_glGetQueryObjectuivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetQueryObjectuivARB == loader_glGetQueryObjectuivARB) {
      rCtx->dsp->emuTbl.glGetQueryObjectuivARB = driverTbl.glGetQueryObjectuivARB;
   }
   driverTbl.glGetQueryObjectuivARB(id, pname, params);
}

static void REGAL_CALL missing_glGetQueryivARB(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetQueryivARB not available." );
}

static void REGAL_CALL loader_glGetQueryivARB(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetQueryivARB, "glGetQueryivARB");
   if ( !driverTbl.glGetQueryivARB ) {
      driverTbl.glGetQueryivARB = missing_glGetQueryivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetQueryivARB == loader_glGetQueryivARB) {
      rCtx->dsp->emuTbl.glGetQueryivARB = driverTbl.glGetQueryivARB;
   }
   driverTbl.glGetQueryivARB(target, pname, params);
}

static GLboolean REGAL_CALL missing_glIsQueryARB(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "glIsQueryARB not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsQueryARB(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsQueryARB, "glIsQueryARB");
   if ( !driverTbl.glIsQueryARB ) {
      driverTbl.glIsQueryARB = missing_glIsQueryARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsQueryARB == loader_glIsQueryARB) {
      rCtx->dsp->emuTbl.glIsQueryARB = driverTbl.glIsQueryARB;
   }
   return driverTbl.glIsQueryARB(id);
}

// GL_ARB_point_parameters

static void REGAL_CALL missing_glPointParameterfARB(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPointParameterfARB not available." );
}

static void REGAL_CALL loader_glPointParameterfARB(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPointParameterfARB, "glPointParameterfARB");
   if ( !driverTbl.glPointParameterfARB ) {
      driverTbl.glPointParameterfARB = missing_glPointParameterfARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPointParameterfARB == loader_glPointParameterfARB) {
      rCtx->dsp->emuTbl.glPointParameterfARB = driverTbl.glPointParameterfARB;
   }
   driverTbl.glPointParameterfARB(pname, param);
}

static void REGAL_CALL missing_glPointParameterfvARB(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glPointParameterfvARB not available." );
}

static void REGAL_CALL loader_glPointParameterfvARB(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPointParameterfvARB, "glPointParameterfvARB");
   if ( !driverTbl.glPointParameterfvARB ) {
      driverTbl.glPointParameterfvARB = missing_glPointParameterfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPointParameterfvARB == loader_glPointParameterfvARB) {
      rCtx->dsp->emuTbl.glPointParameterfvARB = driverTbl.glPointParameterfvARB;
   }
   driverTbl.glPointParameterfvARB(pname, params);
}

// GL_ARB_program_interface_query

static void REGAL_CALL missing_glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(programInterface);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramInterfaceiv not available." );
}

static void REGAL_CALL loader_glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramInterfaceiv, "glGetProgramInterfaceiv");
   if ( !driverTbl.glGetProgramInterfaceiv ) {
      driverTbl.glGetProgramInterfaceiv = missing_glGetProgramInterfaceiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramInterfaceiv == loader_glGetProgramInterfaceiv) {
      rCtx->dsp->emuTbl.glGetProgramInterfaceiv = driverTbl.glGetProgramInterfaceiv;
   }
   driverTbl.glGetProgramInterfaceiv(program, programInterface, pname, params);
}

static GLuint REGAL_CALL missing_glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(programInterface);
   UNUSED_PARAMETER(name);
   Warning( "glGetProgramResourceIndex not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramResourceIndex, "glGetProgramResourceIndex");
   if ( !driverTbl.glGetProgramResourceIndex ) {
      driverTbl.glGetProgramResourceIndex = missing_glGetProgramResourceIndex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramResourceIndex == loader_glGetProgramResourceIndex) {
      rCtx->dsp->emuTbl.glGetProgramResourceIndex = driverTbl.glGetProgramResourceIndex;
   }
   return driverTbl.glGetProgramResourceIndex(program, programInterface, name);
}

static GLint REGAL_CALL missing_glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(programInterface);
   UNUSED_PARAMETER(name);
   Warning( "glGetProgramResourceLocation not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramResourceLocation, "glGetProgramResourceLocation");
   if ( !driverTbl.glGetProgramResourceLocation ) {
      driverTbl.glGetProgramResourceLocation = missing_glGetProgramResourceLocation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramResourceLocation == loader_glGetProgramResourceLocation) {
      rCtx->dsp->emuTbl.glGetProgramResourceLocation = driverTbl.glGetProgramResourceLocation;
   }
   return driverTbl.glGetProgramResourceLocation(program, programInterface, name);
}

static GLint REGAL_CALL missing_glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(programInterface);
   UNUSED_PARAMETER(name);
   Warning( "glGetProgramResourceLocationIndex not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramResourceLocationIndex, "glGetProgramResourceLocationIndex");
   if ( !driverTbl.glGetProgramResourceLocationIndex ) {
      driverTbl.glGetProgramResourceLocationIndex = missing_glGetProgramResourceLocationIndex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramResourceLocationIndex == loader_glGetProgramResourceLocationIndex) {
      rCtx->dsp->emuTbl.glGetProgramResourceLocationIndex = driverTbl.glGetProgramResourceLocationIndex;
   }
   return driverTbl.glGetProgramResourceLocationIndex(program, programInterface, name);
}

static void REGAL_CALL missing_glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(programInterface);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(name);
   Warning( "glGetProgramResourceName not available." );
}

static void REGAL_CALL loader_glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramResourceName, "glGetProgramResourceName");
   if ( !driverTbl.glGetProgramResourceName ) {
      driverTbl.glGetProgramResourceName = missing_glGetProgramResourceName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramResourceName == loader_glGetProgramResourceName) {
      rCtx->dsp->emuTbl.glGetProgramResourceName = driverTbl.glGetProgramResourceName;
   }
   driverTbl.glGetProgramResourceName(program, programInterface, index, bufSize, length, name);
}

static void REGAL_CALL missing_glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(programInterface);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(propCount);
   UNUSED_PARAMETER(props);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramResourceiv not available." );
}

static void REGAL_CALL loader_glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramResourceiv, "glGetProgramResourceiv");
   if ( !driverTbl.glGetProgramResourceiv ) {
      driverTbl.glGetProgramResourceiv = missing_glGetProgramResourceiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramResourceiv == loader_glGetProgramResourceiv) {
      rCtx->dsp->emuTbl.glGetProgramResourceiv = driverTbl.glGetProgramResourceiv;
   }
   driverTbl.glGetProgramResourceiv(program, programInterface, index, propCount, props, bufSize, length, params);
}

// GL_ARB_provoking_vertex

static void REGAL_CALL missing_glProvokingVertex(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glProvokingVertex not available." );
}

static void REGAL_CALL loader_glProvokingVertex(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProvokingVertex, "glProvokingVertex");
   if ( !driverTbl.glProvokingVertex ) {
      driverTbl.glProvokingVertex = missing_glProvokingVertex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProvokingVertex == loader_glProvokingVertex) {
      rCtx->dsp->emuTbl.glProvokingVertex = driverTbl.glProvokingVertex;
   }
   driverTbl.glProvokingVertex(mode);
}

// GL_ARB_robustness

static GLenum REGAL_CALL missing_glGetGraphicsResetStatusARB(void)
{
   Warning( "glGetGraphicsResetStatusARB not available." );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glGetGraphicsResetStatusARB(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetGraphicsResetStatusARB, "glGetGraphicsResetStatusARB");
   if ( !driverTbl.glGetGraphicsResetStatusARB ) {
      driverTbl.glGetGraphicsResetStatusARB = missing_glGetGraphicsResetStatusARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetGraphicsResetStatusARB == loader_glGetGraphicsResetStatusARB) {
      rCtx->dsp->emuTbl.glGetGraphicsResetStatusARB = driverTbl.glGetGraphicsResetStatusARB;
   }
   return driverTbl.glGetGraphicsResetStatusARB();
}

static void REGAL_CALL missing_glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *table)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(table);
   Warning( "glGetnColorTableARB not available." );
}

static void REGAL_CALL loader_glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *table)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnColorTableARB, "glGetnColorTableARB");
   if ( !driverTbl.glGetnColorTableARB ) {
      driverTbl.glGetnColorTableARB = missing_glGetnColorTableARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnColorTableARB == loader_glGetnColorTableARB) {
      rCtx->dsp->emuTbl.glGetnColorTableARB = driverTbl.glGetnColorTableARB;
   }
   driverTbl.glGetnColorTableARB(target, format, type, bufSize, table);
}

static void REGAL_CALL missing_glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, GLvoid *img)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(lod);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(img);
   Warning( "glGetnCompressedTexImageARB not available." );
}

static void REGAL_CALL loader_glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, GLvoid *img)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnCompressedTexImageARB, "glGetnCompressedTexImageARB");
   if ( !driverTbl.glGetnCompressedTexImageARB ) {
      driverTbl.glGetnCompressedTexImageARB = missing_glGetnCompressedTexImageARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnCompressedTexImageARB == loader_glGetnCompressedTexImageARB) {
      rCtx->dsp->emuTbl.glGetnCompressedTexImageARB = driverTbl.glGetnCompressedTexImageARB;
   }
   driverTbl.glGetnCompressedTexImageARB(target, lod, bufSize, img);
}

static void REGAL_CALL missing_glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *image)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(image);
   Warning( "glGetnConvolutionFilterARB not available." );
}

static void REGAL_CALL loader_glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *image)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnConvolutionFilterARB, "glGetnConvolutionFilterARB");
   if ( !driverTbl.glGetnConvolutionFilterARB ) {
      driverTbl.glGetnConvolutionFilterARB = missing_glGetnConvolutionFilterARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnConvolutionFilterARB == loader_glGetnConvolutionFilterARB) {
      rCtx->dsp->emuTbl.glGetnConvolutionFilterARB = driverTbl.glGetnConvolutionFilterARB;
   }
   driverTbl.glGetnConvolutionFilterARB(target, format, type, bufSize, image);
}

static void REGAL_CALL missing_glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(reset);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(values);
   Warning( "glGetnHistogramARB not available." );
}

static void REGAL_CALL loader_glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnHistogramARB, "glGetnHistogramARB");
   if ( !driverTbl.glGetnHistogramARB ) {
      driverTbl.glGetnHistogramARB = missing_glGetnHistogramARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnHistogramARB == loader_glGetnHistogramARB) {
      rCtx->dsp->emuTbl.glGetnHistogramARB = driverTbl.glGetnHistogramARB;
   }
   driverTbl.glGetnHistogramARB(target, reset, format, type, bufSize, values);
}

static void REGAL_CALL missing_glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(query);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(v);
   Warning( "glGetnMapdvARB not available." );
}

static void REGAL_CALL loader_glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnMapdvARB, "glGetnMapdvARB");
   if ( !driverTbl.glGetnMapdvARB ) {
      driverTbl.glGetnMapdvARB = missing_glGetnMapdvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnMapdvARB == loader_glGetnMapdvARB) {
      rCtx->dsp->emuTbl.glGetnMapdvARB = driverTbl.glGetnMapdvARB;
   }
   driverTbl.glGetnMapdvARB(target, query, bufSize, v);
}

static void REGAL_CALL missing_glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(query);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(v);
   Warning( "glGetnMapfvARB not available." );
}

static void REGAL_CALL loader_glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnMapfvARB, "glGetnMapfvARB");
   if ( !driverTbl.glGetnMapfvARB ) {
      driverTbl.glGetnMapfvARB = missing_glGetnMapfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnMapfvARB == loader_glGetnMapfvARB) {
      rCtx->dsp->emuTbl.glGetnMapfvARB = driverTbl.glGetnMapfvARB;
   }
   driverTbl.glGetnMapfvARB(target, query, bufSize, v);
}

static void REGAL_CALL missing_glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(query);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(v);
   Warning( "glGetnMapivARB not available." );
}

static void REGAL_CALL loader_glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnMapivARB, "glGetnMapivARB");
   if ( !driverTbl.glGetnMapivARB ) {
      driverTbl.glGetnMapivARB = missing_glGetnMapivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnMapivARB == loader_glGetnMapivARB) {
      rCtx->dsp->emuTbl.glGetnMapivARB = driverTbl.glGetnMapivARB;
   }
   driverTbl.glGetnMapivARB(target, query, bufSize, v);
}

static void REGAL_CALL missing_glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(reset);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(values);
   Warning( "glGetnMinmaxARB not available." );
}

static void REGAL_CALL loader_glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnMinmaxARB, "glGetnMinmaxARB");
   if ( !driverTbl.glGetnMinmaxARB ) {
      driverTbl.glGetnMinmaxARB = missing_glGetnMinmaxARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnMinmaxARB == loader_glGetnMinmaxARB) {
      rCtx->dsp->emuTbl.glGetnMinmaxARB = driverTbl.glGetnMinmaxARB;
   }
   driverTbl.glGetnMinmaxARB(target, reset, format, type, bufSize, values);
}

static void REGAL_CALL missing_glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(values);
   Warning( "glGetnPixelMapfvARB not available." );
}

static void REGAL_CALL loader_glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnPixelMapfvARB, "glGetnPixelMapfvARB");
   if ( !driverTbl.glGetnPixelMapfvARB ) {
      driverTbl.glGetnPixelMapfvARB = missing_glGetnPixelMapfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnPixelMapfvARB == loader_glGetnPixelMapfvARB) {
      rCtx->dsp->emuTbl.glGetnPixelMapfvARB = driverTbl.glGetnPixelMapfvARB;
   }
   driverTbl.glGetnPixelMapfvARB(map, bufSize, values);
}

static void REGAL_CALL missing_glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(values);
   Warning( "glGetnPixelMapuivARB not available." );
}

static void REGAL_CALL loader_glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnPixelMapuivARB, "glGetnPixelMapuivARB");
   if ( !driverTbl.glGetnPixelMapuivARB ) {
      driverTbl.glGetnPixelMapuivARB = missing_glGetnPixelMapuivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnPixelMapuivARB == loader_glGetnPixelMapuivARB) {
      rCtx->dsp->emuTbl.glGetnPixelMapuivARB = driverTbl.glGetnPixelMapuivARB;
   }
   driverTbl.glGetnPixelMapuivARB(map, bufSize, values);
}

static void REGAL_CALL missing_glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort *values)
{
   UNUSED_PARAMETER(map);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(values);
   Warning( "glGetnPixelMapusvARB not available." );
}

static void REGAL_CALL loader_glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnPixelMapusvARB, "glGetnPixelMapusvARB");
   if ( !driverTbl.glGetnPixelMapusvARB ) {
      driverTbl.glGetnPixelMapusvARB = missing_glGetnPixelMapusvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnPixelMapusvARB == loader_glGetnPixelMapusvARB) {
      rCtx->dsp->emuTbl.glGetnPixelMapusvARB = driverTbl.glGetnPixelMapusvARB;
   }
   driverTbl.glGetnPixelMapusvARB(map, bufSize, values);
}

static void REGAL_CALL missing_glGetnPolygonStippleARB(GLsizei bufSize, GLubyte *pattern)
{
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(pattern);
   Warning( "glGetnPolygonStippleARB not available." );
}

static void REGAL_CALL loader_glGetnPolygonStippleARB(GLsizei bufSize, GLubyte *pattern)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnPolygonStippleARB, "glGetnPolygonStippleARB");
   if ( !driverTbl.glGetnPolygonStippleARB ) {
      driverTbl.glGetnPolygonStippleARB = missing_glGetnPolygonStippleARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnPolygonStippleARB == loader_glGetnPolygonStippleARB) {
      rCtx->dsp->emuTbl.glGetnPolygonStippleARB = driverTbl.glGetnPolygonStippleARB;
   }
   driverTbl.glGetnPolygonStippleARB(bufSize, pattern);
}

static void REGAL_CALL missing_glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *row, GLsizei columnBufSize, GLvoid *column, GLvoid *span)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(rowBufSize);
   UNUSED_PARAMETER(row);
   UNUSED_PARAMETER(columnBufSize);
   UNUSED_PARAMETER(column);
   UNUSED_PARAMETER(span);
   Warning( "glGetnSeparableFilterARB not available." );
}

static void REGAL_CALL loader_glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *row, GLsizei columnBufSize, GLvoid *column, GLvoid *span)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnSeparableFilterARB, "glGetnSeparableFilterARB");
   if ( !driverTbl.glGetnSeparableFilterARB ) {
      driverTbl.glGetnSeparableFilterARB = missing_glGetnSeparableFilterARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnSeparableFilterARB == loader_glGetnSeparableFilterARB) {
      rCtx->dsp->emuTbl.glGetnSeparableFilterARB = driverTbl.glGetnSeparableFilterARB;
   }
   driverTbl.glGetnSeparableFilterARB(target, format, type, rowBufSize, row, columnBufSize, column, span);
}

static void REGAL_CALL missing_glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(img);
   Warning( "glGetnTexImageARB not available." );
}

static void REGAL_CALL loader_glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnTexImageARB, "glGetnTexImageARB");
   if ( !driverTbl.glGetnTexImageARB ) {
      driverTbl.glGetnTexImageARB = missing_glGetnTexImageARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnTexImageARB == loader_glGetnTexImageARB) {
      rCtx->dsp->emuTbl.glGetnTexImageARB = driverTbl.glGetnTexImageARB;
   }
   driverTbl.glGetnTexImageARB(target, level, format, type, bufSize, img);
}

static void REGAL_CALL missing_glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(params);
   Warning( "glGetnUniformdvARB not available." );
}

static void REGAL_CALL loader_glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnUniformdvARB, "glGetnUniformdvARB");
   if ( !driverTbl.glGetnUniformdvARB ) {
      driverTbl.glGetnUniformdvARB = missing_glGetnUniformdvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnUniformdvARB == loader_glGetnUniformdvARB) {
      rCtx->dsp->emuTbl.glGetnUniformdvARB = driverTbl.glGetnUniformdvARB;
   }
   driverTbl.glGetnUniformdvARB(program, location, bufSize, params);
}

static void REGAL_CALL missing_glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(params);
   Warning( "glGetnUniformfvARB not available." );
}

static void REGAL_CALL loader_glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnUniformfvARB, "glGetnUniformfvARB");
   if ( !driverTbl.glGetnUniformfvARB ) {
      driverTbl.glGetnUniformfvARB = missing_glGetnUniformfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnUniformfvARB == loader_glGetnUniformfvARB) {
      rCtx->dsp->emuTbl.glGetnUniformfvARB = driverTbl.glGetnUniformfvARB;
   }
   driverTbl.glGetnUniformfvARB(program, location, bufSize, params);
}

static void REGAL_CALL missing_glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(params);
   Warning( "glGetnUniformivARB not available." );
}

static void REGAL_CALL loader_glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnUniformivARB, "glGetnUniformivARB");
   if ( !driverTbl.glGetnUniformivARB ) {
      driverTbl.glGetnUniformivARB = missing_glGetnUniformivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnUniformivARB == loader_glGetnUniformivARB) {
      rCtx->dsp->emuTbl.glGetnUniformivARB = driverTbl.glGetnUniformivARB;
   }
   driverTbl.glGetnUniformivARB(program, location, bufSize, params);
}

static void REGAL_CALL missing_glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(params);
   Warning( "glGetnUniformuivARB not available." );
}

static void REGAL_CALL loader_glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetnUniformuivARB, "glGetnUniformuivARB");
   if ( !driverTbl.glGetnUniformuivARB ) {
      driverTbl.glGetnUniformuivARB = missing_glGetnUniformuivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetnUniformuivARB == loader_glGetnUniformuivARB) {
      rCtx->dsp->emuTbl.glGetnUniformuivARB = driverTbl.glGetnUniformuivARB;
   }
   driverTbl.glGetnUniformuivARB(program, location, bufSize, params);
}

static void REGAL_CALL missing_glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(data);
   Warning( "glReadnPixelsARB not available." );
}

static void REGAL_CALL loader_glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReadnPixelsARB, "glReadnPixelsARB");
   if ( !driverTbl.glReadnPixelsARB ) {
      driverTbl.glReadnPixelsARB = missing_glReadnPixelsARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReadnPixelsARB == loader_glReadnPixelsARB) {
      rCtx->dsp->emuTbl.glReadnPixelsARB = driverTbl.glReadnPixelsARB;
   }
   driverTbl.glReadnPixelsARB(x, y, width, height, format, type, bufSize, data);
}

// GL_ARB_sample_shading

static void REGAL_CALL missing_glMinSampleShading(GLclampf value)
{
   UNUSED_PARAMETER(value);
   Warning( "glMinSampleShading not available." );
}

static void REGAL_CALL loader_glMinSampleShading(GLclampf value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMinSampleShading, "glMinSampleShading");
   if ( !driverTbl.glMinSampleShading ) {
      driverTbl.glMinSampleShading = missing_glMinSampleShading;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMinSampleShading == loader_glMinSampleShading) {
      rCtx->dsp->emuTbl.glMinSampleShading = driverTbl.glMinSampleShading;
   }
   driverTbl.glMinSampleShading(value);
}

static void REGAL_CALL missing_glMinSampleShadingARB(GLclampf value)
{
   UNUSED_PARAMETER(value);
   Warning( "glMinSampleShadingARB not available." );
}

static void REGAL_CALL loader_glMinSampleShadingARB(GLclampf value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMinSampleShadingARB, "glMinSampleShadingARB");
   if ( !driverTbl.glMinSampleShadingARB ) {
      driverTbl.glMinSampleShadingARB = missing_glMinSampleShadingARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMinSampleShadingARB == loader_glMinSampleShadingARB) {
      rCtx->dsp->emuTbl.glMinSampleShadingARB = driverTbl.glMinSampleShadingARB;
   }
   driverTbl.glMinSampleShadingARB(value);
}

// GL_ARB_sampler_objects

static void REGAL_CALL missing_glBindSampler(GLuint unit, GLuint sampler)
{
   UNUSED_PARAMETER(unit);
   UNUSED_PARAMETER(sampler);
   Warning( "glBindSampler not available." );
}

static void REGAL_CALL loader_glBindSampler(GLuint unit, GLuint sampler)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindSampler, "glBindSampler");
   if ( !driverTbl.glBindSampler ) {
      driverTbl.glBindSampler = missing_glBindSampler;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindSampler == loader_glBindSampler) {
      rCtx->dsp->emuTbl.glBindSampler = driverTbl.glBindSampler;
   }
   driverTbl.glBindSampler(unit, sampler);
}

static void REGAL_CALL missing_glDeleteSamplers(GLsizei count, const GLuint *samplers)
{
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(samplers);
   Warning( "glDeleteSamplers not available." );
}

static void REGAL_CALL loader_glDeleteSamplers(GLsizei count, const GLuint *samplers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteSamplers, "glDeleteSamplers");
   if ( !driverTbl.glDeleteSamplers ) {
      driverTbl.glDeleteSamplers = missing_glDeleteSamplers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteSamplers == loader_glDeleteSamplers) {
      rCtx->dsp->emuTbl.glDeleteSamplers = driverTbl.glDeleteSamplers;
   }
   driverTbl.glDeleteSamplers(count, samplers);
}

static void REGAL_CALL missing_glGenSamplers(GLsizei count, GLuint *samplers)
{
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(samplers);
   Warning( "glGenSamplers not available." );
}

static void REGAL_CALL loader_glGenSamplers(GLsizei count, GLuint *samplers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenSamplers, "glGenSamplers");
   if ( !driverTbl.glGenSamplers ) {
      driverTbl.glGenSamplers = missing_glGenSamplers;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenSamplers == loader_glGenSamplers) {
      rCtx->dsp->emuTbl.glGenSamplers = driverTbl.glGenSamplers;
   }
   driverTbl.glGenSamplers(count, samplers);
}

static void REGAL_CALL missing_glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetSamplerParameterIiv not available." );
}

static void REGAL_CALL loader_glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetSamplerParameterIiv, "glGetSamplerParameterIiv");
   if ( !driverTbl.glGetSamplerParameterIiv ) {
      driverTbl.glGetSamplerParameterIiv = missing_glGetSamplerParameterIiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetSamplerParameterIiv == loader_glGetSamplerParameterIiv) {
      rCtx->dsp->emuTbl.glGetSamplerParameterIiv = driverTbl.glGetSamplerParameterIiv;
   }
   driverTbl.glGetSamplerParameterIiv(sampler, pname, params);
}

static void REGAL_CALL missing_glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetSamplerParameterIuiv not available." );
}

static void REGAL_CALL loader_glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetSamplerParameterIuiv, "glGetSamplerParameterIuiv");
   if ( !driverTbl.glGetSamplerParameterIuiv ) {
      driverTbl.glGetSamplerParameterIuiv = missing_glGetSamplerParameterIuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetSamplerParameterIuiv == loader_glGetSamplerParameterIuiv) {
      rCtx->dsp->emuTbl.glGetSamplerParameterIuiv = driverTbl.glGetSamplerParameterIuiv;
   }
   driverTbl.glGetSamplerParameterIuiv(sampler, pname, params);
}

static void REGAL_CALL missing_glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetSamplerParameterfv not available." );
}

static void REGAL_CALL loader_glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetSamplerParameterfv, "glGetSamplerParameterfv");
   if ( !driverTbl.glGetSamplerParameterfv ) {
      driverTbl.glGetSamplerParameterfv = missing_glGetSamplerParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetSamplerParameterfv == loader_glGetSamplerParameterfv) {
      rCtx->dsp->emuTbl.glGetSamplerParameterfv = driverTbl.glGetSamplerParameterfv;
   }
   driverTbl.glGetSamplerParameterfv(sampler, pname, params);
}

static void REGAL_CALL missing_glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetSamplerParameteriv not available." );
}

static void REGAL_CALL loader_glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetSamplerParameteriv, "glGetSamplerParameteriv");
   if ( !driverTbl.glGetSamplerParameteriv ) {
      driverTbl.glGetSamplerParameteriv = missing_glGetSamplerParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetSamplerParameteriv == loader_glGetSamplerParameteriv) {
      rCtx->dsp->emuTbl.glGetSamplerParameteriv = driverTbl.glGetSamplerParameteriv;
   }
   driverTbl.glGetSamplerParameteriv(sampler, pname, params);
}

static GLboolean REGAL_CALL missing_glIsSampler(GLuint sampler)
{
   UNUSED_PARAMETER(sampler);
   Warning( "glIsSampler not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsSampler(GLuint sampler)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsSampler, "glIsSampler");
   if ( !driverTbl.glIsSampler ) {
      driverTbl.glIsSampler = missing_glIsSampler;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsSampler == loader_glIsSampler) {
      rCtx->dsp->emuTbl.glIsSampler = driverTbl.glIsSampler;
   }
   return driverTbl.glIsSampler(sampler);
}

static void REGAL_CALL missing_glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glSamplerParameterIiv not available." );
}

static void REGAL_CALL loader_glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSamplerParameterIiv, "glSamplerParameterIiv");
   if ( !driverTbl.glSamplerParameterIiv ) {
      driverTbl.glSamplerParameterIiv = missing_glSamplerParameterIiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSamplerParameterIiv == loader_glSamplerParameterIiv) {
      rCtx->dsp->emuTbl.glSamplerParameterIiv = driverTbl.glSamplerParameterIiv;
   }
   driverTbl.glSamplerParameterIiv(sampler, pname, params);
}

static void REGAL_CALL missing_glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glSamplerParameterIuiv not available." );
}

static void REGAL_CALL loader_glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSamplerParameterIuiv, "glSamplerParameterIuiv");
   if ( !driverTbl.glSamplerParameterIuiv ) {
      driverTbl.glSamplerParameterIuiv = missing_glSamplerParameterIuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSamplerParameterIuiv == loader_glSamplerParameterIuiv) {
      rCtx->dsp->emuTbl.glSamplerParameterIuiv = driverTbl.glSamplerParameterIuiv;
   }
   driverTbl.glSamplerParameterIuiv(sampler, pname, params);
}

static void REGAL_CALL missing_glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glSamplerParameterf not available." );
}

static void REGAL_CALL loader_glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSamplerParameterf, "glSamplerParameterf");
   if ( !driverTbl.glSamplerParameterf ) {
      driverTbl.glSamplerParameterf = missing_glSamplerParameterf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSamplerParameterf == loader_glSamplerParameterf) {
      rCtx->dsp->emuTbl.glSamplerParameterf = driverTbl.glSamplerParameterf;
   }
   driverTbl.glSamplerParameterf(sampler, pname, param);
}

static void REGAL_CALL missing_glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glSamplerParameterfv not available." );
}

static void REGAL_CALL loader_glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSamplerParameterfv, "glSamplerParameterfv");
   if ( !driverTbl.glSamplerParameterfv ) {
      driverTbl.glSamplerParameterfv = missing_glSamplerParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSamplerParameterfv == loader_glSamplerParameterfv) {
      rCtx->dsp->emuTbl.glSamplerParameterfv = driverTbl.glSamplerParameterfv;
   }
   driverTbl.glSamplerParameterfv(sampler, pname, params);
}

static void REGAL_CALL missing_glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glSamplerParameteri not available." );
}

static void REGAL_CALL loader_glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSamplerParameteri, "glSamplerParameteri");
   if ( !driverTbl.glSamplerParameteri ) {
      driverTbl.glSamplerParameteri = missing_glSamplerParameteri;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSamplerParameteri == loader_glSamplerParameteri) {
      rCtx->dsp->emuTbl.glSamplerParameteri = driverTbl.glSamplerParameteri;
   }
   driverTbl.glSamplerParameteri(sampler, pname, param);
}

static void REGAL_CALL missing_glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(sampler);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glSamplerParameteriv not available." );
}

static void REGAL_CALL loader_glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSamplerParameteriv, "glSamplerParameteriv");
   if ( !driverTbl.glSamplerParameteriv ) {
      driverTbl.glSamplerParameteriv = missing_glSamplerParameteriv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSamplerParameteriv == loader_glSamplerParameteriv) {
      rCtx->dsp->emuTbl.glSamplerParameteriv = driverTbl.glSamplerParameteriv;
   }
   driverTbl.glSamplerParameteriv(sampler, pname, params);
}

// GL_ARB_separate_shader_objects

static void REGAL_CALL missing_glActiveShaderProgram(GLuint pipeline, GLuint program)
{
   UNUSED_PARAMETER(pipeline);
   UNUSED_PARAMETER(program);
   Warning( "glActiveShaderProgram not available." );
}

static void REGAL_CALL loader_glActiveShaderProgram(GLuint pipeline, GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glActiveShaderProgram, "glActiveShaderProgram");
   if ( !driverTbl.glActiveShaderProgram ) {
      driverTbl.glActiveShaderProgram = missing_glActiveShaderProgram;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glActiveShaderProgram == loader_glActiveShaderProgram) {
      rCtx->dsp->emuTbl.glActiveShaderProgram = driverTbl.glActiveShaderProgram;
   }
   driverTbl.glActiveShaderProgram(pipeline, program);
}

static void REGAL_CALL missing_glBindProgramPipeline(GLuint pipeline)
{
   UNUSED_PARAMETER(pipeline);
   Warning( "glBindProgramPipeline not available." );
}

static void REGAL_CALL loader_glBindProgramPipeline(GLuint pipeline)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindProgramPipeline, "glBindProgramPipeline");
   if ( !driverTbl.glBindProgramPipeline ) {
      driverTbl.glBindProgramPipeline = missing_glBindProgramPipeline;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindProgramPipeline == loader_glBindProgramPipeline) {
      rCtx->dsp->emuTbl.glBindProgramPipeline = driverTbl.glBindProgramPipeline;
   }
   driverTbl.glBindProgramPipeline(pipeline);
}

static GLuint REGAL_CALL missing_glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar **strings)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(strings);
   Warning( "glCreateShaderProgramv not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar **strings)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCreateShaderProgramv, "glCreateShaderProgramv");
   if ( !driverTbl.glCreateShaderProgramv ) {
      driverTbl.glCreateShaderProgramv = missing_glCreateShaderProgramv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCreateShaderProgramv == loader_glCreateShaderProgramv) {
      rCtx->dsp->emuTbl.glCreateShaderProgramv = driverTbl.glCreateShaderProgramv;
   }
   return driverTbl.glCreateShaderProgramv(type, count, strings);
}

static void REGAL_CALL missing_glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(pipelines);
   Warning( "glDeleteProgramPipelines not available." );
}

static void REGAL_CALL loader_glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteProgramPipelines, "glDeleteProgramPipelines");
   if ( !driverTbl.glDeleteProgramPipelines ) {
      driverTbl.glDeleteProgramPipelines = missing_glDeleteProgramPipelines;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteProgramPipelines == loader_glDeleteProgramPipelines) {
      rCtx->dsp->emuTbl.glDeleteProgramPipelines = driverTbl.glDeleteProgramPipelines;
   }
   driverTbl.glDeleteProgramPipelines(n, pipelines);
}

static void REGAL_CALL missing_glGenProgramPipelines(GLsizei n, GLuint *pipelines)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(pipelines);
   Warning( "glGenProgramPipelines not available." );
}

static void REGAL_CALL loader_glGenProgramPipelines(GLsizei n, GLuint *pipelines)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenProgramPipelines, "glGenProgramPipelines");
   if ( !driverTbl.glGenProgramPipelines ) {
      driverTbl.glGenProgramPipelines = missing_glGenProgramPipelines;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenProgramPipelines == loader_glGenProgramPipelines) {
      rCtx->dsp->emuTbl.glGenProgramPipelines = driverTbl.glGenProgramPipelines;
   }
   driverTbl.glGenProgramPipelines(n, pipelines);
}

static void REGAL_CALL missing_glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
   UNUSED_PARAMETER(pipeline);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(infoLog);
   Warning( "glGetProgramPipelineInfoLog not available." );
}

static void REGAL_CALL loader_glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramPipelineInfoLog, "glGetProgramPipelineInfoLog");
   if ( !driverTbl.glGetProgramPipelineInfoLog ) {
      driverTbl.glGetProgramPipelineInfoLog = missing_glGetProgramPipelineInfoLog;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramPipelineInfoLog == loader_glGetProgramPipelineInfoLog) {
      rCtx->dsp->emuTbl.glGetProgramPipelineInfoLog = driverTbl.glGetProgramPipelineInfoLog;
   }
   driverTbl.glGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
}

static void REGAL_CALL missing_glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(pipeline);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramPipelineiv not available." );
}

static void REGAL_CALL loader_glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramPipelineiv, "glGetProgramPipelineiv");
   if ( !driverTbl.glGetProgramPipelineiv ) {
      driverTbl.glGetProgramPipelineiv = missing_glGetProgramPipelineiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramPipelineiv == loader_glGetProgramPipelineiv) {
      rCtx->dsp->emuTbl.glGetProgramPipelineiv = driverTbl.glGetProgramPipelineiv;
   }
   driverTbl.glGetProgramPipelineiv(pipeline, pname, params);
}

static GLboolean REGAL_CALL missing_glIsProgramPipeline(GLuint pipeline)
{
   UNUSED_PARAMETER(pipeline);
   Warning( "glIsProgramPipeline not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsProgramPipeline(GLuint pipeline)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsProgramPipeline, "glIsProgramPipeline");
   if ( !driverTbl.glIsProgramPipeline ) {
      driverTbl.glIsProgramPipeline = missing_glIsProgramPipeline;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsProgramPipeline == loader_glIsProgramPipeline) {
      rCtx->dsp->emuTbl.glIsProgramPipeline = driverTbl.glIsProgramPipeline;
   }
   return driverTbl.glIsProgramPipeline(pipeline);
}

static void REGAL_CALL missing_glProgramUniform1d(GLuint program, GLint location, GLdouble x)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "glProgramUniform1d not available." );
}

static void REGAL_CALL loader_glProgramUniform1d(GLuint program, GLint location, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1d, "glProgramUniform1d");
   if ( !driverTbl.glProgramUniform1d ) {
      driverTbl.glProgramUniform1d = missing_glProgramUniform1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1d == loader_glProgramUniform1d) {
      rCtx->dsp->emuTbl.glProgramUniform1d = driverTbl.glProgramUniform1d;
   }
   driverTbl.glProgramUniform1d(program, location, x);
}

static void REGAL_CALL missing_glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform1dv not available." );
}

static void REGAL_CALL loader_glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1dv, "glProgramUniform1dv");
   if ( !driverTbl.glProgramUniform1dv ) {
      driverTbl.glProgramUniform1dv = missing_glProgramUniform1dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1dv == loader_glProgramUniform1dv) {
      rCtx->dsp->emuTbl.glProgramUniform1dv = driverTbl.glProgramUniform1dv;
   }
   driverTbl.glProgramUniform1dv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform1f(GLuint program, GLint location, GLfloat x)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "glProgramUniform1f not available." );
}

static void REGAL_CALL loader_glProgramUniform1f(GLuint program, GLint location, GLfloat x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1f, "glProgramUniform1f");
   if ( !driverTbl.glProgramUniform1f ) {
      driverTbl.glProgramUniform1f = missing_glProgramUniform1f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1f == loader_glProgramUniform1f) {
      rCtx->dsp->emuTbl.glProgramUniform1f = driverTbl.glProgramUniform1f;
   }
   driverTbl.glProgramUniform1f(program, location, x);
}

static void REGAL_CALL missing_glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform1fv not available." );
}

static void REGAL_CALL loader_glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1fv, "glProgramUniform1fv");
   if ( !driverTbl.glProgramUniform1fv ) {
      driverTbl.glProgramUniform1fv = missing_glProgramUniform1fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1fv == loader_glProgramUniform1fv) {
      rCtx->dsp->emuTbl.glProgramUniform1fv = driverTbl.glProgramUniform1fv;
   }
   driverTbl.glProgramUniform1fv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform1i(GLuint program, GLint location, GLint x)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "glProgramUniform1i not available." );
}

static void REGAL_CALL loader_glProgramUniform1i(GLuint program, GLint location, GLint x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1i, "glProgramUniform1i");
   if ( !driverTbl.glProgramUniform1i ) {
      driverTbl.glProgramUniform1i = missing_glProgramUniform1i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1i == loader_glProgramUniform1i) {
      rCtx->dsp->emuTbl.glProgramUniform1i = driverTbl.glProgramUniform1i;
   }
   driverTbl.glProgramUniform1i(program, location, x);
}

static void REGAL_CALL missing_glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform1iv not available." );
}

static void REGAL_CALL loader_glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1iv, "glProgramUniform1iv");
   if ( !driverTbl.glProgramUniform1iv ) {
      driverTbl.glProgramUniform1iv = missing_glProgramUniform1iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1iv == loader_glProgramUniform1iv) {
      rCtx->dsp->emuTbl.glProgramUniform1iv = driverTbl.glProgramUniform1iv;
   }
   driverTbl.glProgramUniform1iv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform1ui(GLuint program, GLint location, GLuint v0)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "glProgramUniform1ui not available." );
}

static void REGAL_CALL loader_glProgramUniform1ui(GLuint program, GLint location, GLuint v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1ui, "glProgramUniform1ui");
   if ( !driverTbl.glProgramUniform1ui ) {
      driverTbl.glProgramUniform1ui = missing_glProgramUniform1ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1ui == loader_glProgramUniform1ui) {
      rCtx->dsp->emuTbl.glProgramUniform1ui = driverTbl.glProgramUniform1ui;
   }
   driverTbl.glProgramUniform1ui(program, location, v0);
}

static void REGAL_CALL missing_glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform1uiv not available." );
}

static void REGAL_CALL loader_glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1uiv, "glProgramUniform1uiv");
   if ( !driverTbl.glProgramUniform1uiv ) {
      driverTbl.glProgramUniform1uiv = missing_glProgramUniform1uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1uiv == loader_glProgramUniform1uiv) {
      rCtx->dsp->emuTbl.glProgramUniform1uiv = driverTbl.glProgramUniform1uiv;
   }
   driverTbl.glProgramUniform1uiv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2d(GLuint program, GLint location, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glProgramUniform2d not available." );
}

static void REGAL_CALL loader_glProgramUniform2d(GLuint program, GLint location, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2d, "glProgramUniform2d");
   if ( !driverTbl.glProgramUniform2d ) {
      driverTbl.glProgramUniform2d = missing_glProgramUniform2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2d == loader_glProgramUniform2d) {
      rCtx->dsp->emuTbl.glProgramUniform2d = driverTbl.glProgramUniform2d;
   }
   driverTbl.glProgramUniform2d(program, location, x, y);
}

static void REGAL_CALL missing_glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform2dv not available." );
}

static void REGAL_CALL loader_glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2dv, "glProgramUniform2dv");
   if ( !driverTbl.glProgramUniform2dv ) {
      driverTbl.glProgramUniform2dv = missing_glProgramUniform2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2dv == loader_glProgramUniform2dv) {
      rCtx->dsp->emuTbl.glProgramUniform2dv = driverTbl.glProgramUniform2dv;
   }
   driverTbl.glProgramUniform2dv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2f(GLuint program, GLint location, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glProgramUniform2f not available." );
}

static void REGAL_CALL loader_glProgramUniform2f(GLuint program, GLint location, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2f, "glProgramUniform2f");
   if ( !driverTbl.glProgramUniform2f ) {
      driverTbl.glProgramUniform2f = missing_glProgramUniform2f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2f == loader_glProgramUniform2f) {
      rCtx->dsp->emuTbl.glProgramUniform2f = driverTbl.glProgramUniform2f;
   }
   driverTbl.glProgramUniform2f(program, location, x, y);
}

static void REGAL_CALL missing_glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform2fv not available." );
}

static void REGAL_CALL loader_glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2fv, "glProgramUniform2fv");
   if ( !driverTbl.glProgramUniform2fv ) {
      driverTbl.glProgramUniform2fv = missing_glProgramUniform2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2fv == loader_glProgramUniform2fv) {
      rCtx->dsp->emuTbl.glProgramUniform2fv = driverTbl.glProgramUniform2fv;
   }
   driverTbl.glProgramUniform2fv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2i(GLuint program, GLint location, GLint x, GLint y)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glProgramUniform2i not available." );
}

static void REGAL_CALL loader_glProgramUniform2i(GLuint program, GLint location, GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2i, "glProgramUniform2i");
   if ( !driverTbl.glProgramUniform2i ) {
      driverTbl.glProgramUniform2i = missing_glProgramUniform2i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2i == loader_glProgramUniform2i) {
      rCtx->dsp->emuTbl.glProgramUniform2i = driverTbl.glProgramUniform2i;
   }
   driverTbl.glProgramUniform2i(program, location, x, y);
}

static void REGAL_CALL missing_glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform2iv not available." );
}

static void REGAL_CALL loader_glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2iv, "glProgramUniform2iv");
   if ( !driverTbl.glProgramUniform2iv ) {
      driverTbl.glProgramUniform2iv = missing_glProgramUniform2iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2iv == loader_glProgramUniform2iv) {
      rCtx->dsp->emuTbl.glProgramUniform2iv = driverTbl.glProgramUniform2iv;
   }
   driverTbl.glProgramUniform2iv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2ui(GLuint program, GLint location, GLuint x, GLuint y)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glProgramUniform2ui not available." );
}

static void REGAL_CALL loader_glProgramUniform2ui(GLuint program, GLint location, GLuint x, GLuint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2ui, "glProgramUniform2ui");
   if ( !driverTbl.glProgramUniform2ui ) {
      driverTbl.glProgramUniform2ui = missing_glProgramUniform2ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2ui == loader_glProgramUniform2ui) {
      rCtx->dsp->emuTbl.glProgramUniform2ui = driverTbl.glProgramUniform2ui;
   }
   driverTbl.glProgramUniform2ui(program, location, x, y);
}

static void REGAL_CALL missing_glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform2uiv not available." );
}

static void REGAL_CALL loader_glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2uiv, "glProgramUniform2uiv");
   if ( !driverTbl.glProgramUniform2uiv ) {
      driverTbl.glProgramUniform2uiv = missing_glProgramUniform2uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2uiv == loader_glProgramUniform2uiv) {
      rCtx->dsp->emuTbl.glProgramUniform2uiv = driverTbl.glProgramUniform2uiv;
   }
   driverTbl.glProgramUniform2uiv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glProgramUniform3d not available." );
}

static void REGAL_CALL loader_glProgramUniform3d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3d, "glProgramUniform3d");
   if ( !driverTbl.glProgramUniform3d ) {
      driverTbl.glProgramUniform3d = missing_glProgramUniform3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3d == loader_glProgramUniform3d) {
      rCtx->dsp->emuTbl.glProgramUniform3d = driverTbl.glProgramUniform3d;
   }
   driverTbl.glProgramUniform3d(program, location, x, y, z);
}

static void REGAL_CALL missing_glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform3dv not available." );
}

static void REGAL_CALL loader_glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3dv, "glProgramUniform3dv");
   if ( !driverTbl.glProgramUniform3dv ) {
      driverTbl.glProgramUniform3dv = missing_glProgramUniform3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3dv == loader_glProgramUniform3dv) {
      rCtx->dsp->emuTbl.glProgramUniform3dv = driverTbl.glProgramUniform3dv;
   }
   driverTbl.glProgramUniform3dv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glProgramUniform3f not available." );
}

static void REGAL_CALL loader_glProgramUniform3f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3f, "glProgramUniform3f");
   if ( !driverTbl.glProgramUniform3f ) {
      driverTbl.glProgramUniform3f = missing_glProgramUniform3f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3f == loader_glProgramUniform3f) {
      rCtx->dsp->emuTbl.glProgramUniform3f = driverTbl.glProgramUniform3f;
   }
   driverTbl.glProgramUniform3f(program, location, x, y, z);
}

static void REGAL_CALL missing_glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform3fv not available." );
}

static void REGAL_CALL loader_glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3fv, "glProgramUniform3fv");
   if ( !driverTbl.glProgramUniform3fv ) {
      driverTbl.glProgramUniform3fv = missing_glProgramUniform3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3fv == loader_glProgramUniform3fv) {
      rCtx->dsp->emuTbl.glProgramUniform3fv = driverTbl.glProgramUniform3fv;
   }
   driverTbl.glProgramUniform3fv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3i(GLuint program, GLint location, GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glProgramUniform3i not available." );
}

static void REGAL_CALL loader_glProgramUniform3i(GLuint program, GLint location, GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3i, "glProgramUniform3i");
   if ( !driverTbl.glProgramUniform3i ) {
      driverTbl.glProgramUniform3i = missing_glProgramUniform3i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3i == loader_glProgramUniform3i) {
      rCtx->dsp->emuTbl.glProgramUniform3i = driverTbl.glProgramUniform3i;
   }
   driverTbl.glProgramUniform3i(program, location, x, y, z);
}

static void REGAL_CALL missing_glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform3iv not available." );
}

static void REGAL_CALL loader_glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3iv, "glProgramUniform3iv");
   if ( !driverTbl.glProgramUniform3iv ) {
      driverTbl.glProgramUniform3iv = missing_glProgramUniform3iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3iv == loader_glProgramUniform3iv) {
      rCtx->dsp->emuTbl.glProgramUniform3iv = driverTbl.glProgramUniform3iv;
   }
   driverTbl.glProgramUniform3iv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glProgramUniform3ui not available." );
}

static void REGAL_CALL loader_glProgramUniform3ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3ui, "glProgramUniform3ui");
   if ( !driverTbl.glProgramUniform3ui ) {
      driverTbl.glProgramUniform3ui = missing_glProgramUniform3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3ui == loader_glProgramUniform3ui) {
      rCtx->dsp->emuTbl.glProgramUniform3ui = driverTbl.glProgramUniform3ui;
   }
   driverTbl.glProgramUniform3ui(program, location, x, y, z);
}

static void REGAL_CALL missing_glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform3uiv not available." );
}

static void REGAL_CALL loader_glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3uiv, "glProgramUniform3uiv");
   if ( !driverTbl.glProgramUniform3uiv ) {
      driverTbl.glProgramUniform3uiv = missing_glProgramUniform3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3uiv == loader_glProgramUniform3uiv) {
      rCtx->dsp->emuTbl.glProgramUniform3uiv = driverTbl.glProgramUniform3uiv;
   }
   driverTbl.glProgramUniform3uiv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramUniform4d not available." );
}

static void REGAL_CALL loader_glProgramUniform4d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4d, "glProgramUniform4d");
   if ( !driverTbl.glProgramUniform4d ) {
      driverTbl.glProgramUniform4d = missing_glProgramUniform4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4d == loader_glProgramUniform4d) {
      rCtx->dsp->emuTbl.glProgramUniform4d = driverTbl.glProgramUniform4d;
   }
   driverTbl.glProgramUniform4d(program, location, x, y, z, w);
}

static void REGAL_CALL missing_glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform4dv not available." );
}

static void REGAL_CALL loader_glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4dv, "glProgramUniform4dv");
   if ( !driverTbl.glProgramUniform4dv ) {
      driverTbl.glProgramUniform4dv = missing_glProgramUniform4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4dv == loader_glProgramUniform4dv) {
      rCtx->dsp->emuTbl.glProgramUniform4dv = driverTbl.glProgramUniform4dv;
   }
   driverTbl.glProgramUniform4dv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramUniform4f not available." );
}

static void REGAL_CALL loader_glProgramUniform4f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4f, "glProgramUniform4f");
   if ( !driverTbl.glProgramUniform4f ) {
      driverTbl.glProgramUniform4f = missing_glProgramUniform4f;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4f == loader_glProgramUniform4f) {
      rCtx->dsp->emuTbl.glProgramUniform4f = driverTbl.glProgramUniform4f;
   }
   driverTbl.glProgramUniform4f(program, location, x, y, z, w);
}

static void REGAL_CALL missing_glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform4fv not available." );
}

static void REGAL_CALL loader_glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4fv, "glProgramUniform4fv");
   if ( !driverTbl.glProgramUniform4fv ) {
      driverTbl.glProgramUniform4fv = missing_glProgramUniform4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4fv == loader_glProgramUniform4fv) {
      rCtx->dsp->emuTbl.glProgramUniform4fv = driverTbl.glProgramUniform4fv;
   }
   driverTbl.glProgramUniform4fv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4i(GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramUniform4i not available." );
}

static void REGAL_CALL loader_glProgramUniform4i(GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4i, "glProgramUniform4i");
   if ( !driverTbl.glProgramUniform4i ) {
      driverTbl.glProgramUniform4i = missing_glProgramUniform4i;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4i == loader_glProgramUniform4i) {
      rCtx->dsp->emuTbl.glProgramUniform4i = driverTbl.glProgramUniform4i;
   }
   driverTbl.glProgramUniform4i(program, location, x, y, z, w);
}

static void REGAL_CALL missing_glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform4iv not available." );
}

static void REGAL_CALL loader_glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4iv, "glProgramUniform4iv");
   if ( !driverTbl.glProgramUniform4iv ) {
      driverTbl.glProgramUniform4iv = missing_glProgramUniform4iv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4iv == loader_glProgramUniform4iv) {
      rCtx->dsp->emuTbl.glProgramUniform4iv = driverTbl.glProgramUniform4iv;
   }
   driverTbl.glProgramUniform4iv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramUniform4ui not available." );
}

static void REGAL_CALL loader_glProgramUniform4ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4ui, "glProgramUniform4ui");
   if ( !driverTbl.glProgramUniform4ui ) {
      driverTbl.glProgramUniform4ui = missing_glProgramUniform4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4ui == loader_glProgramUniform4ui) {
      rCtx->dsp->emuTbl.glProgramUniform4ui = driverTbl.glProgramUniform4ui;
   }
   driverTbl.glProgramUniform4ui(program, location, x, y, z, w);
}

static void REGAL_CALL missing_glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform4uiv not available." );
}

static void REGAL_CALL loader_glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4uiv, "glProgramUniform4uiv");
   if ( !driverTbl.glProgramUniform4uiv ) {
      driverTbl.glProgramUniform4uiv = missing_glProgramUniform4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4uiv == loader_glProgramUniform4uiv) {
      rCtx->dsp->emuTbl.glProgramUniform4uiv = driverTbl.glProgramUniform4uiv;
   }
   driverTbl.glProgramUniform4uiv(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix2dv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix2dv, "glProgramUniformMatrix2dv");
   if ( !driverTbl.glProgramUniformMatrix2dv ) {
      driverTbl.glProgramUniformMatrix2dv = missing_glProgramUniformMatrix2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix2dv == loader_glProgramUniformMatrix2dv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix2dv = driverTbl.glProgramUniformMatrix2dv;
   }
   driverTbl.glProgramUniformMatrix2dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix2fv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix2fv, "glProgramUniformMatrix2fv");
   if ( !driverTbl.glProgramUniformMatrix2fv ) {
      driverTbl.glProgramUniformMatrix2fv = missing_glProgramUniformMatrix2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix2fv == loader_glProgramUniformMatrix2fv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix2fv = driverTbl.glProgramUniformMatrix2fv;
   }
   driverTbl.glProgramUniformMatrix2fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix2x3dv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix2x3dv, "glProgramUniformMatrix2x3dv");
   if ( !driverTbl.glProgramUniformMatrix2x3dv ) {
      driverTbl.glProgramUniformMatrix2x3dv = missing_glProgramUniformMatrix2x3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix2x3dv == loader_glProgramUniformMatrix2x3dv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix2x3dv = driverTbl.glProgramUniformMatrix2x3dv;
   }
   driverTbl.glProgramUniformMatrix2x3dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix2x3fv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix2x3fv, "glProgramUniformMatrix2x3fv");
   if ( !driverTbl.glProgramUniformMatrix2x3fv ) {
      driverTbl.glProgramUniformMatrix2x3fv = missing_glProgramUniformMatrix2x3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix2x3fv == loader_glProgramUniformMatrix2x3fv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix2x3fv = driverTbl.glProgramUniformMatrix2x3fv;
   }
   driverTbl.glProgramUniformMatrix2x3fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix2x4dv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix2x4dv, "glProgramUniformMatrix2x4dv");
   if ( !driverTbl.glProgramUniformMatrix2x4dv ) {
      driverTbl.glProgramUniformMatrix2x4dv = missing_glProgramUniformMatrix2x4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix2x4dv == loader_glProgramUniformMatrix2x4dv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix2x4dv = driverTbl.glProgramUniformMatrix2x4dv;
   }
   driverTbl.glProgramUniformMatrix2x4dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix2x4fv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix2x4fv, "glProgramUniformMatrix2x4fv");
   if ( !driverTbl.glProgramUniformMatrix2x4fv ) {
      driverTbl.glProgramUniformMatrix2x4fv = missing_glProgramUniformMatrix2x4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix2x4fv == loader_glProgramUniformMatrix2x4fv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix2x4fv = driverTbl.glProgramUniformMatrix2x4fv;
   }
   driverTbl.glProgramUniformMatrix2x4fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix3dv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix3dv, "glProgramUniformMatrix3dv");
   if ( !driverTbl.glProgramUniformMatrix3dv ) {
      driverTbl.glProgramUniformMatrix3dv = missing_glProgramUniformMatrix3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix3dv == loader_glProgramUniformMatrix3dv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix3dv = driverTbl.glProgramUniformMatrix3dv;
   }
   driverTbl.glProgramUniformMatrix3dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix3fv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix3fv, "glProgramUniformMatrix3fv");
   if ( !driverTbl.glProgramUniformMatrix3fv ) {
      driverTbl.glProgramUniformMatrix3fv = missing_glProgramUniformMatrix3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix3fv == loader_glProgramUniformMatrix3fv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix3fv = driverTbl.glProgramUniformMatrix3fv;
   }
   driverTbl.glProgramUniformMatrix3fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix3x2dv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix3x2dv, "glProgramUniformMatrix3x2dv");
   if ( !driverTbl.glProgramUniformMatrix3x2dv ) {
      driverTbl.glProgramUniformMatrix3x2dv = missing_glProgramUniformMatrix3x2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix3x2dv == loader_glProgramUniformMatrix3x2dv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix3x2dv = driverTbl.glProgramUniformMatrix3x2dv;
   }
   driverTbl.glProgramUniformMatrix3x2dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix3x2fv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix3x2fv, "glProgramUniformMatrix3x2fv");
   if ( !driverTbl.glProgramUniformMatrix3x2fv ) {
      driverTbl.glProgramUniformMatrix3x2fv = missing_glProgramUniformMatrix3x2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix3x2fv == loader_glProgramUniformMatrix3x2fv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix3x2fv = driverTbl.glProgramUniformMatrix3x2fv;
   }
   driverTbl.glProgramUniformMatrix3x2fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix3x4dv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix3x4dv, "glProgramUniformMatrix3x4dv");
   if ( !driverTbl.glProgramUniformMatrix3x4dv ) {
      driverTbl.glProgramUniformMatrix3x4dv = missing_glProgramUniformMatrix3x4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix3x4dv == loader_glProgramUniformMatrix3x4dv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix3x4dv = driverTbl.glProgramUniformMatrix3x4dv;
   }
   driverTbl.glProgramUniformMatrix3x4dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix3x4fv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix3x4fv, "glProgramUniformMatrix3x4fv");
   if ( !driverTbl.glProgramUniformMatrix3x4fv ) {
      driverTbl.glProgramUniformMatrix3x4fv = missing_glProgramUniformMatrix3x4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix3x4fv == loader_glProgramUniformMatrix3x4fv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix3x4fv = driverTbl.glProgramUniformMatrix3x4fv;
   }
   driverTbl.glProgramUniformMatrix3x4fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix4dv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix4dv, "glProgramUniformMatrix4dv");
   if ( !driverTbl.glProgramUniformMatrix4dv ) {
      driverTbl.glProgramUniformMatrix4dv = missing_glProgramUniformMatrix4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix4dv == loader_glProgramUniformMatrix4dv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix4dv = driverTbl.glProgramUniformMatrix4dv;
   }
   driverTbl.glProgramUniformMatrix4dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix4fv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix4fv, "glProgramUniformMatrix4fv");
   if ( !driverTbl.glProgramUniformMatrix4fv ) {
      driverTbl.glProgramUniformMatrix4fv = missing_glProgramUniformMatrix4fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix4fv == loader_glProgramUniformMatrix4fv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix4fv = driverTbl.glProgramUniformMatrix4fv;
   }
   driverTbl.glProgramUniformMatrix4fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix4x2dv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix4x2dv, "glProgramUniformMatrix4x2dv");
   if ( !driverTbl.glProgramUniformMatrix4x2dv ) {
      driverTbl.glProgramUniformMatrix4x2dv = missing_glProgramUniformMatrix4x2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix4x2dv == loader_glProgramUniformMatrix4x2dv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix4x2dv = driverTbl.glProgramUniformMatrix4x2dv;
   }
   driverTbl.glProgramUniformMatrix4x2dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix4x2fv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix4x2fv, "glProgramUniformMatrix4x2fv");
   if ( !driverTbl.glProgramUniformMatrix4x2fv ) {
      driverTbl.glProgramUniformMatrix4x2fv = missing_glProgramUniformMatrix4x2fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix4x2fv == loader_glProgramUniformMatrix4x2fv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix4x2fv = driverTbl.glProgramUniformMatrix4x2fv;
   }
   driverTbl.glProgramUniformMatrix4x2fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix4x3dv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix4x3dv, "glProgramUniformMatrix4x3dv");
   if ( !driverTbl.glProgramUniformMatrix4x3dv ) {
      driverTbl.glProgramUniformMatrix4x3dv = missing_glProgramUniformMatrix4x3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix4x3dv == loader_glProgramUniformMatrix4x3dv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix4x3dv = driverTbl.glProgramUniformMatrix4x3dv;
   }
   driverTbl.glProgramUniformMatrix4x3dv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix4x3fv not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix4x3fv, "glProgramUniformMatrix4x3fv");
   if ( !driverTbl.glProgramUniformMatrix4x3fv ) {
      driverTbl.glProgramUniformMatrix4x3fv = missing_glProgramUniformMatrix4x3fv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix4x3fv == loader_glProgramUniformMatrix4x3fv) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix4x3fv = driverTbl.glProgramUniformMatrix4x3fv;
   }
   driverTbl.glProgramUniformMatrix4x3fv(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)
{
   UNUSED_PARAMETER(pipeline);
   UNUSED_PARAMETER(stages);
   UNUSED_PARAMETER(program);
   Warning( "glUseProgramStages not available." );
}

static void REGAL_CALL loader_glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUseProgramStages, "glUseProgramStages");
   if ( !driverTbl.glUseProgramStages ) {
      driverTbl.glUseProgramStages = missing_glUseProgramStages;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUseProgramStages == loader_glUseProgramStages) {
      rCtx->dsp->emuTbl.glUseProgramStages = driverTbl.glUseProgramStages;
   }
   driverTbl.glUseProgramStages(pipeline, stages, program);
}

static void REGAL_CALL missing_glValidateProgramPipeline(GLuint pipeline)
{
   UNUSED_PARAMETER(pipeline);
   Warning( "glValidateProgramPipeline not available." );
}

static void REGAL_CALL loader_glValidateProgramPipeline(GLuint pipeline)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glValidateProgramPipeline, "glValidateProgramPipeline");
   if ( !driverTbl.glValidateProgramPipeline ) {
      driverTbl.glValidateProgramPipeline = missing_glValidateProgramPipeline;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glValidateProgramPipeline == loader_glValidateProgramPipeline) {
      rCtx->dsp->emuTbl.glValidateProgramPipeline = driverTbl.glValidateProgramPipeline;
   }
   driverTbl.glValidateProgramPipeline(pipeline);
}

// GL_ARB_shader_atomic_counters

static void REGAL_CALL missing_glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(bufferIndex);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetActiveAtomicCounterBufferiv not available." );
}

static void REGAL_CALL loader_glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetActiveAtomicCounterBufferiv, "glGetActiveAtomicCounterBufferiv");
   if ( !driverTbl.glGetActiveAtomicCounterBufferiv ) {
      driverTbl.glGetActiveAtomicCounterBufferiv = missing_glGetActiveAtomicCounterBufferiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetActiveAtomicCounterBufferiv == loader_glGetActiveAtomicCounterBufferiv) {
      rCtx->dsp->emuTbl.glGetActiveAtomicCounterBufferiv = driverTbl.glGetActiveAtomicCounterBufferiv;
   }
   driverTbl.glGetActiveAtomicCounterBufferiv(program, bufferIndex, pname, params);
}

// GL_ARB_shader_image_load_store

static void REGAL_CALL missing_glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)
{
   UNUSED_PARAMETER(unit);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layered);
   UNUSED_PARAMETER(layer);
   UNUSED_PARAMETER(access);
   UNUSED_PARAMETER(format);
   Warning( "glBindImageTexture not available." );
}

static void REGAL_CALL loader_glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindImageTexture, "glBindImageTexture");
   if ( !driverTbl.glBindImageTexture ) {
      driverTbl.glBindImageTexture = missing_glBindImageTexture;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindImageTexture == loader_glBindImageTexture) {
      rCtx->dsp->emuTbl.glBindImageTexture = driverTbl.glBindImageTexture;
   }
   driverTbl.glBindImageTexture(unit, texture, level, layered, layer, access, format);
}

static void REGAL_CALL missing_glMemoryBarrier(GLbitfield barriers)
{
   UNUSED_PARAMETER(barriers);
   Warning( "glMemoryBarrier not available." );
}

static void REGAL_CALL loader_glMemoryBarrier(GLbitfield barriers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMemoryBarrier, "glMemoryBarrier");
   if ( !driverTbl.glMemoryBarrier ) {
      driverTbl.glMemoryBarrier = missing_glMemoryBarrier;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMemoryBarrier == loader_glMemoryBarrier) {
      rCtx->dsp->emuTbl.glMemoryBarrier = driverTbl.glMemoryBarrier;
   }
   driverTbl.glMemoryBarrier(barriers);
}

// GL_ARB_shader_objects

static void REGAL_CALL missing_glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj)
{
   UNUSED_PARAMETER(containerObj);
   UNUSED_PARAMETER(obj);
   Warning( "glAttachObjectARB not available." );
}

static void REGAL_CALL loader_glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glAttachObjectARB, "glAttachObjectARB");
   if ( !driverTbl.glAttachObjectARB ) {
      driverTbl.glAttachObjectARB = missing_glAttachObjectARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glAttachObjectARB == loader_glAttachObjectARB) {
      rCtx->dsp->emuTbl.glAttachObjectARB = driverTbl.glAttachObjectARB;
   }
   driverTbl.glAttachObjectARB(containerObj, obj);
}

static void REGAL_CALL missing_glCompileShaderARB(GLhandleARB shaderObj)
{
   UNUSED_PARAMETER(shaderObj);
   Warning( "glCompileShaderARB not available." );
}

static void REGAL_CALL loader_glCompileShaderARB(GLhandleARB shaderObj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompileShaderARB, "glCompileShaderARB");
   if ( !driverTbl.glCompileShaderARB ) {
      driverTbl.glCompileShaderARB = missing_glCompileShaderARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompileShaderARB == loader_glCompileShaderARB) {
      rCtx->dsp->emuTbl.glCompileShaderARB = driverTbl.glCompileShaderARB;
   }
   driverTbl.glCompileShaderARB(shaderObj);
}

static GLhandleARB REGAL_CALL missing_glCreateProgramObjectARB(void)
{
   Warning( "glCreateProgramObjectARB not available." );
  GLhandleARB  ret = (GLhandleARB )0;
  return ret;
}

static GLhandleARB REGAL_CALL loader_glCreateProgramObjectARB(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCreateProgramObjectARB, "glCreateProgramObjectARB");
   if ( !driverTbl.glCreateProgramObjectARB ) {
      driverTbl.glCreateProgramObjectARB = missing_glCreateProgramObjectARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCreateProgramObjectARB == loader_glCreateProgramObjectARB) {
      rCtx->dsp->emuTbl.glCreateProgramObjectARB = driverTbl.glCreateProgramObjectARB;
   }
   return driverTbl.glCreateProgramObjectARB();
}

static GLhandleARB REGAL_CALL missing_glCreateShaderObjectARB(GLenum shaderType)
{
   UNUSED_PARAMETER(shaderType);
   Warning( "glCreateShaderObjectARB not available." );
  GLhandleARB  ret = (GLhandleARB )0;
  return ret;
}

static GLhandleARB REGAL_CALL loader_glCreateShaderObjectARB(GLenum shaderType)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCreateShaderObjectARB, "glCreateShaderObjectARB");
   if ( !driverTbl.glCreateShaderObjectARB ) {
      driverTbl.glCreateShaderObjectARB = missing_glCreateShaderObjectARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCreateShaderObjectARB == loader_glCreateShaderObjectARB) {
      rCtx->dsp->emuTbl.glCreateShaderObjectARB = driverTbl.glCreateShaderObjectARB;
   }
   return driverTbl.glCreateShaderObjectARB(shaderType);
}

static void REGAL_CALL missing_glDeleteObjectARB(GLhandleARB obj)
{
   UNUSED_PARAMETER(obj);
   Warning( "glDeleteObjectARB not available." );
}

static void REGAL_CALL loader_glDeleteObjectARB(GLhandleARB obj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteObjectARB, "glDeleteObjectARB");
   if ( !driverTbl.glDeleteObjectARB ) {
      driverTbl.glDeleteObjectARB = missing_glDeleteObjectARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteObjectARB == loader_glDeleteObjectARB) {
      rCtx->dsp->emuTbl.glDeleteObjectARB = driverTbl.glDeleteObjectARB;
   }
   driverTbl.glDeleteObjectARB(obj);
}

static void REGAL_CALL missing_glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj)
{
   UNUSED_PARAMETER(containerObj);
   UNUSED_PARAMETER(attachedObj);
   Warning( "glDetachObjectARB not available." );
}

static void REGAL_CALL loader_glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDetachObjectARB, "glDetachObjectARB");
   if ( !driverTbl.glDetachObjectARB ) {
      driverTbl.glDetachObjectARB = missing_glDetachObjectARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDetachObjectARB == loader_glDetachObjectARB) {
      rCtx->dsp->emuTbl.glDetachObjectARB = driverTbl.glDetachObjectARB;
   }
   driverTbl.glDetachObjectARB(containerObj, attachedObj);
}

static void REGAL_CALL missing_glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
{
   UNUSED_PARAMETER(programObj);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(maxLength);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(name);
   Warning( "glGetActiveUniformARB not available." );
}

static void REGAL_CALL loader_glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetActiveUniformARB, "glGetActiveUniformARB");
   if ( !driverTbl.glGetActiveUniformARB ) {
      driverTbl.glGetActiveUniformARB = missing_glGetActiveUniformARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetActiveUniformARB == loader_glGetActiveUniformARB) {
      rCtx->dsp->emuTbl.glGetActiveUniformARB = driverTbl.glGetActiveUniformARB;
   }
   driverTbl.glGetActiveUniformARB(programObj, index, maxLength, length, size, type, name);
}

static void REGAL_CALL missing_glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj)
{
   UNUSED_PARAMETER(containerObj);
   UNUSED_PARAMETER(maxCount);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(obj);
   Warning( "glGetAttachedObjectsARB not available." );
}

static void REGAL_CALL loader_glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetAttachedObjectsARB, "glGetAttachedObjectsARB");
   if ( !driverTbl.glGetAttachedObjectsARB ) {
      driverTbl.glGetAttachedObjectsARB = missing_glGetAttachedObjectsARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetAttachedObjectsARB == loader_glGetAttachedObjectsARB) {
      rCtx->dsp->emuTbl.glGetAttachedObjectsARB = driverTbl.glGetAttachedObjectsARB;
   }
   driverTbl.glGetAttachedObjectsARB(containerObj, maxCount, count, obj);
}

static GLhandleARB REGAL_CALL missing_glGetHandleARB(GLenum pname)
{
   UNUSED_PARAMETER(pname);
   Warning( "glGetHandleARB not available." );
  GLhandleARB  ret = (GLhandleARB )0;
  return ret;
}

static GLhandleARB REGAL_CALL loader_glGetHandleARB(GLenum pname)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetHandleARB, "glGetHandleARB");
   if ( !driverTbl.glGetHandleARB ) {
      driverTbl.glGetHandleARB = missing_glGetHandleARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetHandleARB == loader_glGetHandleARB) {
      rCtx->dsp->emuTbl.glGetHandleARB = driverTbl.glGetHandleARB;
   }
   return driverTbl.glGetHandleARB(pname);
}

static void REGAL_CALL missing_glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
{
   UNUSED_PARAMETER(obj);
   UNUSED_PARAMETER(maxLength);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(infoLog);
   Warning( "glGetInfoLogARB not available." );
}

static void REGAL_CALL loader_glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetInfoLogARB, "glGetInfoLogARB");
   if ( !driverTbl.glGetInfoLogARB ) {
      driverTbl.glGetInfoLogARB = missing_glGetInfoLogARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetInfoLogARB == loader_glGetInfoLogARB) {
      rCtx->dsp->emuTbl.glGetInfoLogARB = driverTbl.glGetInfoLogARB;
   }
   driverTbl.glGetInfoLogARB(obj, maxLength, length, infoLog);
}

static void REGAL_CALL missing_glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(obj);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetObjectParameterfvARB not available." );
}

static void REGAL_CALL loader_glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetObjectParameterfvARB, "glGetObjectParameterfvARB");
   if ( !driverTbl.glGetObjectParameterfvARB ) {
      driverTbl.glGetObjectParameterfvARB = missing_glGetObjectParameterfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetObjectParameterfvARB == loader_glGetObjectParameterfvARB) {
      rCtx->dsp->emuTbl.glGetObjectParameterfvARB = driverTbl.glGetObjectParameterfvARB;
   }
   driverTbl.glGetObjectParameterfvARB(obj, pname, params);
}

static void REGAL_CALL missing_glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(obj);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetObjectParameterivARB not available." );
}

static void REGAL_CALL loader_glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetObjectParameterivARB, "glGetObjectParameterivARB");
   if ( !driverTbl.glGetObjectParameterivARB ) {
      driverTbl.glGetObjectParameterivARB = missing_glGetObjectParameterivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetObjectParameterivARB == loader_glGetObjectParameterivARB) {
      rCtx->dsp->emuTbl.glGetObjectParameterivARB = driverTbl.glGetObjectParameterivARB;
   }
   driverTbl.glGetObjectParameterivARB(obj, pname, params);
}

static void REGAL_CALL missing_glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source)
{
   UNUSED_PARAMETER(obj);
   UNUSED_PARAMETER(maxLength);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(source);
   Warning( "glGetShaderSourceARB not available." );
}

static void REGAL_CALL loader_glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetShaderSourceARB, "glGetShaderSourceARB");
   if ( !driverTbl.glGetShaderSourceARB ) {
      driverTbl.glGetShaderSourceARB = missing_glGetShaderSourceARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetShaderSourceARB == loader_glGetShaderSourceARB) {
      rCtx->dsp->emuTbl.glGetShaderSourceARB = driverTbl.glGetShaderSourceARB;
   }
   driverTbl.glGetShaderSourceARB(obj, maxLength, length, source);
}

static GLint REGAL_CALL missing_glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
   UNUSED_PARAMETER(programObj);
   UNUSED_PARAMETER(name);
   Warning( "glGetUniformLocationARB not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformLocationARB, "glGetUniformLocationARB");
   if ( !driverTbl.glGetUniformLocationARB ) {
      driverTbl.glGetUniformLocationARB = missing_glGetUniformLocationARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformLocationARB == loader_glGetUniformLocationARB) {
      rCtx->dsp->emuTbl.glGetUniformLocationARB = driverTbl.glGetUniformLocationARB;
   }
   return driverTbl.glGetUniformLocationARB(programObj, name);
}

static void REGAL_CALL missing_glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params)
{
   UNUSED_PARAMETER(programObj);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "glGetUniformfvARB not available." );
}

static void REGAL_CALL loader_glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformfvARB, "glGetUniformfvARB");
   if ( !driverTbl.glGetUniformfvARB ) {
      driverTbl.glGetUniformfvARB = missing_glGetUniformfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformfvARB == loader_glGetUniformfvARB) {
      rCtx->dsp->emuTbl.glGetUniformfvARB = driverTbl.glGetUniformfvARB;
   }
   driverTbl.glGetUniformfvARB(programObj, location, params);
}

static void REGAL_CALL missing_glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params)
{
   UNUSED_PARAMETER(programObj);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "glGetUniformivARB not available." );
}

static void REGAL_CALL loader_glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformivARB, "glGetUniformivARB");
   if ( !driverTbl.glGetUniformivARB ) {
      driverTbl.glGetUniformivARB = missing_glGetUniformivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformivARB == loader_glGetUniformivARB) {
      rCtx->dsp->emuTbl.glGetUniformivARB = driverTbl.glGetUniformivARB;
   }
   driverTbl.glGetUniformivARB(programObj, location, params);
}

static void REGAL_CALL missing_glLinkProgramARB(GLhandleARB programObj)
{
   UNUSED_PARAMETER(programObj);
   Warning( "glLinkProgramARB not available." );
}

static void REGAL_CALL loader_glLinkProgramARB(GLhandleARB programObj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLinkProgramARB, "glLinkProgramARB");
   if ( !driverTbl.glLinkProgramARB ) {
      driverTbl.glLinkProgramARB = missing_glLinkProgramARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLinkProgramARB == loader_glLinkProgramARB) {
      rCtx->dsp->emuTbl.glLinkProgramARB = driverTbl.glLinkProgramARB;
   }
   driverTbl.glLinkProgramARB(programObj);
}

static void REGAL_CALL missing_glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length)
{
   UNUSED_PARAMETER(shaderObj);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(string);
   UNUSED_PARAMETER(length);
   Warning( "glShaderSourceARB not available." );
}

static void REGAL_CALL loader_glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB **string, const GLint *length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glShaderSourceARB, "glShaderSourceARB");
   if ( !driverTbl.glShaderSourceARB ) {
      driverTbl.glShaderSourceARB = missing_glShaderSourceARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glShaderSourceARB == loader_glShaderSourceARB) {
      rCtx->dsp->emuTbl.glShaderSourceARB = driverTbl.glShaderSourceARB;
   }
   driverTbl.glShaderSourceARB(shaderObj, count, string, length);
}

static void REGAL_CALL missing_glUniform1fARB(GLint location, GLfloat v0)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "glUniform1fARB not available." );
}

static void REGAL_CALL loader_glUniform1fARB(GLint location, GLfloat v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1fARB, "glUniform1fARB");
   if ( !driverTbl.glUniform1fARB ) {
      driverTbl.glUniform1fARB = missing_glUniform1fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1fARB == loader_glUniform1fARB) {
      rCtx->dsp->emuTbl.glUniform1fARB = driverTbl.glUniform1fARB;
   }
   driverTbl.glUniform1fARB(location, v0);
}

static void REGAL_CALL missing_glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform1fvARB not available." );
}

static void REGAL_CALL loader_glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1fvARB, "glUniform1fvARB");
   if ( !driverTbl.glUniform1fvARB ) {
      driverTbl.glUniform1fvARB = missing_glUniform1fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1fvARB == loader_glUniform1fvARB) {
      rCtx->dsp->emuTbl.glUniform1fvARB = driverTbl.glUniform1fvARB;
   }
   driverTbl.glUniform1fvARB(location, count, value);
}

static void REGAL_CALL missing_glUniform1iARB(GLint location, GLint v0)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "glUniform1iARB not available." );
}

static void REGAL_CALL loader_glUniform1iARB(GLint location, GLint v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1iARB, "glUniform1iARB");
   if ( !driverTbl.glUniform1iARB ) {
      driverTbl.glUniform1iARB = missing_glUniform1iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1iARB == loader_glUniform1iARB) {
      rCtx->dsp->emuTbl.glUniform1iARB = driverTbl.glUniform1iARB;
   }
   driverTbl.glUniform1iARB(location, v0);
}

static void REGAL_CALL missing_glUniform1ivARB(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform1ivARB not available." );
}

static void REGAL_CALL loader_glUniform1ivARB(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1ivARB, "glUniform1ivARB");
   if ( !driverTbl.glUniform1ivARB ) {
      driverTbl.glUniform1ivARB = missing_glUniform1ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1ivARB == loader_glUniform1ivARB) {
      rCtx->dsp->emuTbl.glUniform1ivARB = driverTbl.glUniform1ivARB;
   }
   driverTbl.glUniform1ivARB(location, count, value);
}

static void REGAL_CALL missing_glUniform2fARB(GLint location, GLfloat v0, GLfloat v1)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "glUniform2fARB not available." );
}

static void REGAL_CALL loader_glUniform2fARB(GLint location, GLfloat v0, GLfloat v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2fARB, "glUniform2fARB");
   if ( !driverTbl.glUniform2fARB ) {
      driverTbl.glUniform2fARB = missing_glUniform2fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2fARB == loader_glUniform2fARB) {
      rCtx->dsp->emuTbl.glUniform2fARB = driverTbl.glUniform2fARB;
   }
   driverTbl.glUniform2fARB(location, v0, v1);
}

static void REGAL_CALL missing_glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform2fvARB not available." );
}

static void REGAL_CALL loader_glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2fvARB, "glUniform2fvARB");
   if ( !driverTbl.glUniform2fvARB ) {
      driverTbl.glUniform2fvARB = missing_glUniform2fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2fvARB == loader_glUniform2fvARB) {
      rCtx->dsp->emuTbl.glUniform2fvARB = driverTbl.glUniform2fvARB;
   }
   driverTbl.glUniform2fvARB(location, count, value);
}

static void REGAL_CALL missing_glUniform2iARB(GLint location, GLint v0, GLint v1)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "glUniform2iARB not available." );
}

static void REGAL_CALL loader_glUniform2iARB(GLint location, GLint v0, GLint v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2iARB, "glUniform2iARB");
   if ( !driverTbl.glUniform2iARB ) {
      driverTbl.glUniform2iARB = missing_glUniform2iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2iARB == loader_glUniform2iARB) {
      rCtx->dsp->emuTbl.glUniform2iARB = driverTbl.glUniform2iARB;
   }
   driverTbl.glUniform2iARB(location, v0, v1);
}

static void REGAL_CALL missing_glUniform2ivARB(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform2ivARB not available." );
}

static void REGAL_CALL loader_glUniform2ivARB(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2ivARB, "glUniform2ivARB");
   if ( !driverTbl.glUniform2ivARB ) {
      driverTbl.glUniform2ivARB = missing_glUniform2ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2ivARB == loader_glUniform2ivARB) {
      rCtx->dsp->emuTbl.glUniform2ivARB = driverTbl.glUniform2ivARB;
   }
   driverTbl.glUniform2ivARB(location, count, value);
}

static void REGAL_CALL missing_glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glUniform3fARB not available." );
}

static void REGAL_CALL loader_glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3fARB, "glUniform3fARB");
   if ( !driverTbl.glUniform3fARB ) {
      driverTbl.glUniform3fARB = missing_glUniform3fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3fARB == loader_glUniform3fARB) {
      rCtx->dsp->emuTbl.glUniform3fARB = driverTbl.glUniform3fARB;
   }
   driverTbl.glUniform3fARB(location, v0, v1, v2);
}

static void REGAL_CALL missing_glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform3fvARB not available." );
}

static void REGAL_CALL loader_glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3fvARB, "glUniform3fvARB");
   if ( !driverTbl.glUniform3fvARB ) {
      driverTbl.glUniform3fvARB = missing_glUniform3fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3fvARB == loader_glUniform3fvARB) {
      rCtx->dsp->emuTbl.glUniform3fvARB = driverTbl.glUniform3fvARB;
   }
   driverTbl.glUniform3fvARB(location, count, value);
}

static void REGAL_CALL missing_glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glUniform3iARB not available." );
}

static void REGAL_CALL loader_glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3iARB, "glUniform3iARB");
   if ( !driverTbl.glUniform3iARB ) {
      driverTbl.glUniform3iARB = missing_glUniform3iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3iARB == loader_glUniform3iARB) {
      rCtx->dsp->emuTbl.glUniform3iARB = driverTbl.glUniform3iARB;
   }
   driverTbl.glUniform3iARB(location, v0, v1, v2);
}

static void REGAL_CALL missing_glUniform3ivARB(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform3ivARB not available." );
}

static void REGAL_CALL loader_glUniform3ivARB(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3ivARB, "glUniform3ivARB");
   if ( !driverTbl.glUniform3ivARB ) {
      driverTbl.glUniform3ivARB = missing_glUniform3ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3ivARB == loader_glUniform3ivARB) {
      rCtx->dsp->emuTbl.glUniform3ivARB = driverTbl.glUniform3ivARB;
   }
   driverTbl.glUniform3ivARB(location, count, value);
}

static void REGAL_CALL missing_glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "glUniform4fARB not available." );
}

static void REGAL_CALL loader_glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4fARB, "glUniform4fARB");
   if ( !driverTbl.glUniform4fARB ) {
      driverTbl.glUniform4fARB = missing_glUniform4fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4fARB == loader_glUniform4fARB) {
      rCtx->dsp->emuTbl.glUniform4fARB = driverTbl.glUniform4fARB;
   }
   driverTbl.glUniform4fARB(location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform4fvARB not available." );
}

static void REGAL_CALL loader_glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4fvARB, "glUniform4fvARB");
   if ( !driverTbl.glUniform4fvARB ) {
      driverTbl.glUniform4fvARB = missing_glUniform4fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4fvARB == loader_glUniform4fvARB) {
      rCtx->dsp->emuTbl.glUniform4fvARB = driverTbl.glUniform4fvARB;
   }
   driverTbl.glUniform4fvARB(location, count, value);
}

static void REGAL_CALL missing_glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "glUniform4iARB not available." );
}

static void REGAL_CALL loader_glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4iARB, "glUniform4iARB");
   if ( !driverTbl.glUniform4iARB ) {
      driverTbl.glUniform4iARB = missing_glUniform4iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4iARB == loader_glUniform4iARB) {
      rCtx->dsp->emuTbl.glUniform4iARB = driverTbl.glUniform4iARB;
   }
   driverTbl.glUniform4iARB(location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glUniform4ivARB(GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform4ivARB not available." );
}

static void REGAL_CALL loader_glUniform4ivARB(GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4ivARB, "glUniform4ivARB");
   if ( !driverTbl.glUniform4ivARB ) {
      driverTbl.glUniform4ivARB = missing_glUniform4ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4ivARB == loader_glUniform4ivARB) {
      rCtx->dsp->emuTbl.glUniform4ivARB = driverTbl.glUniform4ivARB;
   }
   driverTbl.glUniform4ivARB(location, count, value);
}

static void REGAL_CALL missing_glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix2fvARB not available." );
}

static void REGAL_CALL loader_glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix2fvARB, "glUniformMatrix2fvARB");
   if ( !driverTbl.glUniformMatrix2fvARB ) {
      driverTbl.glUniformMatrix2fvARB = missing_glUniformMatrix2fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix2fvARB == loader_glUniformMatrix2fvARB) {
      rCtx->dsp->emuTbl.glUniformMatrix2fvARB = driverTbl.glUniformMatrix2fvARB;
   }
   driverTbl.glUniformMatrix2fvARB(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix3fvARB not available." );
}

static void REGAL_CALL loader_glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix3fvARB, "glUniformMatrix3fvARB");
   if ( !driverTbl.glUniformMatrix3fvARB ) {
      driverTbl.glUniformMatrix3fvARB = missing_glUniformMatrix3fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix3fvARB == loader_glUniformMatrix3fvARB) {
      rCtx->dsp->emuTbl.glUniformMatrix3fvARB = driverTbl.glUniformMatrix3fvARB;
   }
   driverTbl.glUniformMatrix3fvARB(location, count, transpose, value);
}

static void REGAL_CALL missing_glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glUniformMatrix4fvARB not available." );
}

static void REGAL_CALL loader_glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformMatrix4fvARB, "glUniformMatrix4fvARB");
   if ( !driverTbl.glUniformMatrix4fvARB ) {
      driverTbl.glUniformMatrix4fvARB = missing_glUniformMatrix4fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformMatrix4fvARB == loader_glUniformMatrix4fvARB) {
      rCtx->dsp->emuTbl.glUniformMatrix4fvARB = driverTbl.glUniformMatrix4fvARB;
   }
   driverTbl.glUniformMatrix4fvARB(location, count, transpose, value);
}

static void REGAL_CALL missing_glUseProgramObjectARB(GLhandleARB programObj)
{
   UNUSED_PARAMETER(programObj);
   Warning( "glUseProgramObjectARB not available." );
}

static void REGAL_CALL loader_glUseProgramObjectARB(GLhandleARB programObj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUseProgramObjectARB, "glUseProgramObjectARB");
   if ( !driverTbl.glUseProgramObjectARB ) {
      driverTbl.glUseProgramObjectARB = missing_glUseProgramObjectARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUseProgramObjectARB == loader_glUseProgramObjectARB) {
      rCtx->dsp->emuTbl.glUseProgramObjectARB = driverTbl.glUseProgramObjectARB;
   }
   driverTbl.glUseProgramObjectARB(programObj);
}

static void REGAL_CALL missing_glValidateProgramARB(GLhandleARB programObj)
{
   UNUSED_PARAMETER(programObj);
   Warning( "glValidateProgramARB not available." );
}

static void REGAL_CALL loader_glValidateProgramARB(GLhandleARB programObj)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glValidateProgramARB, "glValidateProgramARB");
   if ( !driverTbl.glValidateProgramARB ) {
      driverTbl.glValidateProgramARB = missing_glValidateProgramARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glValidateProgramARB == loader_glValidateProgramARB) {
      rCtx->dsp->emuTbl.glValidateProgramARB = driverTbl.glValidateProgramARB;
   }
   driverTbl.glValidateProgramARB(programObj);
}

// GL_ARB_shader_storage_buffer_object

static void REGAL_CALL missing_glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(storageBlockIndex);
   UNUSED_PARAMETER(storageBlockBinding);
   Warning( "glShaderStorageBlockBinding not available." );
}

static void REGAL_CALL loader_glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glShaderStorageBlockBinding, "glShaderStorageBlockBinding");
   if ( !driverTbl.glShaderStorageBlockBinding ) {
      driverTbl.glShaderStorageBlockBinding = missing_glShaderStorageBlockBinding;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glShaderStorageBlockBinding == loader_glShaderStorageBlockBinding) {
      rCtx->dsp->emuTbl.glShaderStorageBlockBinding = driverTbl.glShaderStorageBlockBinding;
   }
   driverTbl.glShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding);
}

// GL_ARB_shader_subroutine

static void REGAL_CALL missing_glGetActiveSubroutineName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(name);
   Warning( "glGetActiveSubroutineName not available." );
}

static void REGAL_CALL loader_glGetActiveSubroutineName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetActiveSubroutineName, "glGetActiveSubroutineName");
   if ( !driverTbl.glGetActiveSubroutineName ) {
      driverTbl.glGetActiveSubroutineName = missing_glGetActiveSubroutineName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetActiveSubroutineName == loader_glGetActiveSubroutineName) {
      rCtx->dsp->emuTbl.glGetActiveSubroutineName = driverTbl.glGetActiveSubroutineName;
   }
   driverTbl.glGetActiveSubroutineName(program, shaderType, index, bufSize, length, name);
}

static void REGAL_CALL missing_glGetActiveSubroutineUniformName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(name);
   Warning( "glGetActiveSubroutineUniformName not available." );
}

static void REGAL_CALL loader_glGetActiveSubroutineUniformName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetActiveSubroutineUniformName, "glGetActiveSubroutineUniformName");
   if ( !driverTbl.glGetActiveSubroutineUniformName ) {
      driverTbl.glGetActiveSubroutineUniformName = missing_glGetActiveSubroutineUniformName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetActiveSubroutineUniformName == loader_glGetActiveSubroutineUniformName) {
      rCtx->dsp->emuTbl.glGetActiveSubroutineUniformName = driverTbl.glGetActiveSubroutineUniformName;
   }
   driverTbl.glGetActiveSubroutineUniformName(program, shaderType, index, bufSize, length, name);
}

static void REGAL_CALL missing_glGetActiveSubroutineUniformiv(GLuint program, GLenum shaderType, GLuint index, GLenum pname, GLint *values)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(values);
   Warning( "glGetActiveSubroutineUniformiv not available." );
}

static void REGAL_CALL loader_glGetActiveSubroutineUniformiv(GLuint program, GLenum shaderType, GLuint index, GLenum pname, GLint *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetActiveSubroutineUniformiv, "glGetActiveSubroutineUniformiv");
   if ( !driverTbl.glGetActiveSubroutineUniformiv ) {
      driverTbl.glGetActiveSubroutineUniformiv = missing_glGetActiveSubroutineUniformiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetActiveSubroutineUniformiv == loader_glGetActiveSubroutineUniformiv) {
      rCtx->dsp->emuTbl.glGetActiveSubroutineUniformiv = driverTbl.glGetActiveSubroutineUniformiv;
   }
   driverTbl.glGetActiveSubroutineUniformiv(program, shaderType, index, pname, values);
}

static void REGAL_CALL missing_glGetProgramStageiv(GLuint program, GLenum shaderType, GLenum pname, GLint *values)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(values);
   Warning( "glGetProgramStageiv not available." );
}

static void REGAL_CALL loader_glGetProgramStageiv(GLuint program, GLenum shaderType, GLenum pname, GLint *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramStageiv, "glGetProgramStageiv");
   if ( !driverTbl.glGetProgramStageiv ) {
      driverTbl.glGetProgramStageiv = missing_glGetProgramStageiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramStageiv == loader_glGetProgramStageiv) {
      rCtx->dsp->emuTbl.glGetProgramStageiv = driverTbl.glGetProgramStageiv;
   }
   driverTbl.glGetProgramStageiv(program, shaderType, pname, values);
}

static GLuint REGAL_CALL missing_glGetSubroutineIndex(GLuint program, GLenum shaderType, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(name);
   Warning( "glGetSubroutineIndex not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGetSubroutineIndex(GLuint program, GLenum shaderType, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetSubroutineIndex, "glGetSubroutineIndex");
   if ( !driverTbl.glGetSubroutineIndex ) {
      driverTbl.glGetSubroutineIndex = missing_glGetSubroutineIndex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetSubroutineIndex == loader_glGetSubroutineIndex) {
      rCtx->dsp->emuTbl.glGetSubroutineIndex = driverTbl.glGetSubroutineIndex;
   }
   return driverTbl.glGetSubroutineIndex(program, shaderType, name);
}

static GLint REGAL_CALL missing_glGetSubroutineUniformLocation(GLuint program, GLenum shaderType, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(name);
   Warning( "glGetSubroutineUniformLocation not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetSubroutineUniformLocation(GLuint program, GLenum shaderType, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetSubroutineUniformLocation, "glGetSubroutineUniformLocation");
   if ( !driverTbl.glGetSubroutineUniformLocation ) {
      driverTbl.glGetSubroutineUniformLocation = missing_glGetSubroutineUniformLocation;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetSubroutineUniformLocation == loader_glGetSubroutineUniformLocation) {
      rCtx->dsp->emuTbl.glGetSubroutineUniformLocation = driverTbl.glGetSubroutineUniformLocation;
   }
   return driverTbl.glGetSubroutineUniformLocation(program, shaderType, name);
}

static void REGAL_CALL missing_glGetUniformSubroutineuiv(GLenum shaderType, GLint location, GLuint *params)
{
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "glGetUniformSubroutineuiv not available." );
}

static void REGAL_CALL loader_glGetUniformSubroutineuiv(GLenum shaderType, GLint location, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformSubroutineuiv, "glGetUniformSubroutineuiv");
   if ( !driverTbl.glGetUniformSubroutineuiv ) {
      driverTbl.glGetUniformSubroutineuiv = missing_glGetUniformSubroutineuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformSubroutineuiv == loader_glGetUniformSubroutineuiv) {
      rCtx->dsp->emuTbl.glGetUniformSubroutineuiv = driverTbl.glGetUniformSubroutineuiv;
   }
   driverTbl.glGetUniformSubroutineuiv(shaderType, location, params);
}

static void REGAL_CALL missing_glUniformSubroutinesuiv(GLenum shaderType, GLsizei count, const GLuint *indices)
{
   UNUSED_PARAMETER(shaderType);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(indices);
   Warning( "glUniformSubroutinesuiv not available." );
}

static void REGAL_CALL loader_glUniformSubroutinesuiv(GLenum shaderType, GLsizei count, const GLuint *indices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformSubroutinesuiv, "glUniformSubroutinesuiv");
   if ( !driverTbl.glUniformSubroutinesuiv ) {
      driverTbl.glUniformSubroutinesuiv = missing_glUniformSubroutinesuiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformSubroutinesuiv == loader_glUniformSubroutinesuiv) {
      rCtx->dsp->emuTbl.glUniformSubroutinesuiv = driverTbl.glUniformSubroutinesuiv;
   }
   driverTbl.glUniformSubroutinesuiv(shaderType, count, indices);
}

// GL_ARB_shading_language_include

static void REGAL_CALL missing_glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar **path, const GLint *length)
{
   UNUSED_PARAMETER(shader);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(length);
   Warning( "glCompileShaderIncludeARB not available." );
}

static void REGAL_CALL loader_glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar **path, const GLint *length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompileShaderIncludeARB, "glCompileShaderIncludeARB");
   if ( !driverTbl.glCompileShaderIncludeARB ) {
      driverTbl.glCompileShaderIncludeARB = missing_glCompileShaderIncludeARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompileShaderIncludeARB == loader_glCompileShaderIncludeARB) {
      rCtx->dsp->emuTbl.glCompileShaderIncludeARB = driverTbl.glCompileShaderIncludeARB;
   }
   driverTbl.glCompileShaderIncludeARB(shader, count, path, length);
}

static void REGAL_CALL missing_glDeleteNamedStringARB(GLint namelen, const GLchar *name)
{
   UNUSED_PARAMETER(namelen);
   UNUSED_PARAMETER(name);
   Warning( "glDeleteNamedStringARB not available." );
}

static void REGAL_CALL loader_glDeleteNamedStringARB(GLint namelen, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteNamedStringARB, "glDeleteNamedStringARB");
   if ( !driverTbl.glDeleteNamedStringARB ) {
      driverTbl.glDeleteNamedStringARB = missing_glDeleteNamedStringARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteNamedStringARB == loader_glDeleteNamedStringARB) {
      rCtx->dsp->emuTbl.glDeleteNamedStringARB = driverTbl.glDeleteNamedStringARB;
   }
   driverTbl.glDeleteNamedStringARB(namelen, name);
}

static void REGAL_CALL missing_glGetNamedStringARB(GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string)
{
   UNUSED_PARAMETER(namelen);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(stringlen);
   UNUSED_PARAMETER(string);
   Warning( "glGetNamedStringARB not available." );
}

static void REGAL_CALL loader_glGetNamedStringARB(GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedStringARB, "glGetNamedStringARB");
   if ( !driverTbl.glGetNamedStringARB ) {
      driverTbl.glGetNamedStringARB = missing_glGetNamedStringARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedStringARB == loader_glGetNamedStringARB) {
      rCtx->dsp->emuTbl.glGetNamedStringARB = driverTbl.glGetNamedStringARB;
   }
   driverTbl.glGetNamedStringARB(namelen, name, bufSize, stringlen, string);
}

static void REGAL_CALL missing_glGetNamedStringivARB(GLint namelen, const GLchar *name, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(namelen);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetNamedStringivARB not available." );
}

static void REGAL_CALL loader_glGetNamedStringivARB(GLint namelen, const GLchar *name, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedStringivARB, "glGetNamedStringivARB");
   if ( !driverTbl.glGetNamedStringivARB ) {
      driverTbl.glGetNamedStringivARB = missing_glGetNamedStringivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedStringivARB == loader_glGetNamedStringivARB) {
      rCtx->dsp->emuTbl.glGetNamedStringivARB = driverTbl.glGetNamedStringivARB;
   }
   driverTbl.glGetNamedStringivARB(namelen, name, pname, params);
}

static GLboolean REGAL_CALL missing_glIsNamedStringARB(GLint namelen, const GLchar *name)
{
   UNUSED_PARAMETER(namelen);
   UNUSED_PARAMETER(name);
   Warning( "glIsNamedStringARB not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsNamedStringARB(GLint namelen, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsNamedStringARB, "glIsNamedStringARB");
   if ( !driverTbl.glIsNamedStringARB ) {
      driverTbl.glIsNamedStringARB = missing_glIsNamedStringARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsNamedStringARB == loader_glIsNamedStringARB) {
      rCtx->dsp->emuTbl.glIsNamedStringARB = driverTbl.glIsNamedStringARB;
   }
   return driverTbl.glIsNamedStringARB(namelen, name);
}

static void REGAL_CALL missing_glNamedStringARB(GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(namelen);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(stringlen);
   UNUSED_PARAMETER(string);
   Warning( "glNamedStringARB not available." );
}

static void REGAL_CALL loader_glNamedStringARB(GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedStringARB, "glNamedStringARB");
   if ( !driverTbl.glNamedStringARB ) {
      driverTbl.glNamedStringARB = missing_glNamedStringARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedStringARB == loader_glNamedStringARB) {
      rCtx->dsp->emuTbl.glNamedStringARB = driverTbl.glNamedStringARB;
   }
   driverTbl.glNamedStringARB(type, namelen, name, stringlen, string);
}

// GL_ARB_sync

static GLenum REGAL_CALL missing_glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
   UNUSED_PARAMETER(sync);
   UNUSED_PARAMETER(flags);
   UNUSED_PARAMETER(timeout);
   Warning( "glClientWaitSync not available." );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClientWaitSync, "glClientWaitSync");
   if ( !driverTbl.glClientWaitSync ) {
      driverTbl.glClientWaitSync = missing_glClientWaitSync;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClientWaitSync == loader_glClientWaitSync) {
      rCtx->dsp->emuTbl.glClientWaitSync = driverTbl.glClientWaitSync;
   }
   return driverTbl.glClientWaitSync(sync, flags, timeout);
}

static void REGAL_CALL missing_glDeleteSync(GLsync sync)
{
   UNUSED_PARAMETER(sync);
   Warning( "glDeleteSync not available." );
}

static void REGAL_CALL loader_glDeleteSync(GLsync sync)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteSync, "glDeleteSync");
   if ( !driverTbl.glDeleteSync ) {
      driverTbl.glDeleteSync = missing_glDeleteSync;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteSync == loader_glDeleteSync) {
      rCtx->dsp->emuTbl.glDeleteSync = driverTbl.glDeleteSync;
   }
   driverTbl.glDeleteSync(sync);
}

static GLsync REGAL_CALL missing_glFenceSync(GLenum condition, GLbitfield flags)
{
   UNUSED_PARAMETER(condition);
   UNUSED_PARAMETER(flags);
   Warning( "glFenceSync not available." );
  GLsync  ret = (GLsync )0;
  return ret;
}

static GLsync REGAL_CALL loader_glFenceSync(GLenum condition, GLbitfield flags)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFenceSync, "glFenceSync");
   if ( !driverTbl.glFenceSync ) {
      driverTbl.glFenceSync = missing_glFenceSync;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFenceSync == loader_glFenceSync) {
      rCtx->dsp->emuTbl.glFenceSync = driverTbl.glFenceSync;
   }
   return driverTbl.glFenceSync(condition, flags);
}

static void REGAL_CALL missing_glGetInteger64v(GLenum pname, GLint64 *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetInteger64v not available." );
}

static void REGAL_CALL loader_glGetInteger64v(GLenum pname, GLint64 *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetInteger64v, "glGetInteger64v");
   if ( !driverTbl.glGetInteger64v ) {
      driverTbl.glGetInteger64v = missing_glGetInteger64v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetInteger64v == loader_glGetInteger64v) {
      rCtx->dsp->emuTbl.glGetInteger64v = driverTbl.glGetInteger64v;
   }
   driverTbl.glGetInteger64v(pname, params);
}

static void REGAL_CALL missing_glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
   UNUSED_PARAMETER(sync);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(values);
   Warning( "glGetSynciv not available." );
}

static void REGAL_CALL loader_glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetSynciv, "glGetSynciv");
   if ( !driverTbl.glGetSynciv ) {
      driverTbl.glGetSynciv = missing_glGetSynciv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetSynciv == loader_glGetSynciv) {
      rCtx->dsp->emuTbl.glGetSynciv = driverTbl.glGetSynciv;
   }
   driverTbl.glGetSynciv(sync, pname, bufSize, length, values);
}

static GLboolean REGAL_CALL missing_glIsSync(GLsync sync)
{
   UNUSED_PARAMETER(sync);
   Warning( "glIsSync not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsSync(GLsync sync)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsSync, "glIsSync");
   if ( !driverTbl.glIsSync ) {
      driverTbl.glIsSync = missing_glIsSync;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsSync == loader_glIsSync) {
      rCtx->dsp->emuTbl.glIsSync = driverTbl.glIsSync;
   }
   return driverTbl.glIsSync(sync);
}

static void REGAL_CALL missing_glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
   UNUSED_PARAMETER(sync);
   UNUSED_PARAMETER(flags);
   UNUSED_PARAMETER(timeout);
   Warning( "glWaitSync not available." );
}

static void REGAL_CALL loader_glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWaitSync, "glWaitSync");
   if ( !driverTbl.glWaitSync ) {
      driverTbl.glWaitSync = missing_glWaitSync;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWaitSync == loader_glWaitSync) {
      rCtx->dsp->emuTbl.glWaitSync = driverTbl.glWaitSync;
   }
   driverTbl.glWaitSync(sync, flags, timeout);
}

// GL_ARB_tessellation_shader

static void REGAL_CALL missing_glPatchParameterfv(GLenum pname, const GLfloat *values)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(values);
   Warning( "glPatchParameterfv not available." );
}

static void REGAL_CALL loader_glPatchParameterfv(GLenum pname, const GLfloat *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPatchParameterfv, "glPatchParameterfv");
   if ( !driverTbl.glPatchParameterfv ) {
      driverTbl.glPatchParameterfv = missing_glPatchParameterfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPatchParameterfv == loader_glPatchParameterfv) {
      rCtx->dsp->emuTbl.glPatchParameterfv = driverTbl.glPatchParameterfv;
   }
   driverTbl.glPatchParameterfv(pname, values);
}

static void REGAL_CALL missing_glPatchParameteri(GLenum pname, GLint value)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "glPatchParameteri not available." );
}

static void REGAL_CALL loader_glPatchParameteri(GLenum pname, GLint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPatchParameteri, "glPatchParameteri");
   if ( !driverTbl.glPatchParameteri ) {
      driverTbl.glPatchParameteri = missing_glPatchParameteri;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPatchParameteri == loader_glPatchParameteri) {
      rCtx->dsp->emuTbl.glPatchParameteri = driverTbl.glPatchParameteri;
   }
   driverTbl.glPatchParameteri(pname, value);
}

// GL_ARB_texture_buffer_object

static void REGAL_CALL missing_glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(buffer);
   Warning( "glTexBufferARB not available." );
}

static void REGAL_CALL loader_glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexBufferARB, "glTexBufferARB");
   if ( !driverTbl.glTexBufferARB ) {
      driverTbl.glTexBufferARB = missing_glTexBufferARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexBufferARB == loader_glTexBufferARB) {
      rCtx->dsp->emuTbl.glTexBufferARB = driverTbl.glTexBufferARB;
   }
   driverTbl.glTexBufferARB(target, internalformat, buffer);
}

// GL_ARB_texture_buffer_range

static void REGAL_CALL missing_glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   Warning( "glTexBufferRange not available." );
}

static void REGAL_CALL loader_glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexBufferRange, "glTexBufferRange");
   if ( !driverTbl.glTexBufferRange ) {
      driverTbl.glTexBufferRange = missing_glTexBufferRange;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexBufferRange == loader_glTexBufferRange) {
      rCtx->dsp->emuTbl.glTexBufferRange = driverTbl.glTexBufferRange;
   }
   driverTbl.glTexBufferRange(target, internalformat, buffer, offset, size);
}

static void REGAL_CALL missing_glTextureBufferRangeEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   Warning( "glTextureBufferRangeEXT not available." );
}

static void REGAL_CALL loader_glTextureBufferRangeEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureBufferRangeEXT, "glTextureBufferRangeEXT");
   if ( !driverTbl.glTextureBufferRangeEXT ) {
      driverTbl.glTextureBufferRangeEXT = missing_glTextureBufferRangeEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureBufferRangeEXT == loader_glTextureBufferRangeEXT) {
      rCtx->dsp->emuTbl.glTextureBufferRangeEXT = driverTbl.glTextureBufferRangeEXT;
   }
   driverTbl.glTextureBufferRangeEXT(texture, target, internalformat, buffer, offset, size);
}

// GL_ARB_texture_compression

static void REGAL_CALL missing_glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedTexImage1DARB not available." );
}

static void REGAL_CALL loader_glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTexImage1DARB, "glCompressedTexImage1DARB");
   if ( !driverTbl.glCompressedTexImage1DARB ) {
      driverTbl.glCompressedTexImage1DARB = missing_glCompressedTexImage1DARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTexImage1DARB == loader_glCompressedTexImage1DARB) {
      rCtx->dsp->emuTbl.glCompressedTexImage1DARB = driverTbl.glCompressedTexImage1DARB;
   }
   driverTbl.glCompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedTexImage2DARB not available." );
}

static void REGAL_CALL loader_glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTexImage2DARB, "glCompressedTexImage2DARB");
   if ( !driverTbl.glCompressedTexImage2DARB ) {
      driverTbl.glCompressedTexImage2DARB = missing_glCompressedTexImage2DARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTexImage2DARB == loader_glCompressedTexImage2DARB) {
      rCtx->dsp->emuTbl.glCompressedTexImage2DARB = driverTbl.glCompressedTexImage2DARB;
   }
   driverTbl.glCompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedTexImage3DARB not available." );
}

static void REGAL_CALL loader_glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTexImage3DARB, "glCompressedTexImage3DARB");
   if ( !driverTbl.glCompressedTexImage3DARB ) {
      driverTbl.glCompressedTexImage3DARB = missing_glCompressedTexImage3DARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTexImage3DARB == loader_glCompressedTexImage3DARB) {
      rCtx->dsp->emuTbl.glCompressedTexImage3DARB = driverTbl.glCompressedTexImage3DARB;
   }
   driverTbl.glCompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedTexSubImage1DARB not available." );
}

static void REGAL_CALL loader_glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTexSubImage1DARB, "glCompressedTexSubImage1DARB");
   if ( !driverTbl.glCompressedTexSubImage1DARB ) {
      driverTbl.glCompressedTexSubImage1DARB = missing_glCompressedTexSubImage1DARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTexSubImage1DARB == loader_glCompressedTexSubImage1DARB) {
      rCtx->dsp->emuTbl.glCompressedTexSubImage1DARB = driverTbl.glCompressedTexSubImage1DARB;
   }
   driverTbl.glCompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedTexSubImage2DARB not available." );
}

static void REGAL_CALL loader_glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTexSubImage2DARB, "glCompressedTexSubImage2DARB");
   if ( !driverTbl.glCompressedTexSubImage2DARB ) {
      driverTbl.glCompressedTexSubImage2DARB = missing_glCompressedTexSubImage2DARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTexSubImage2DARB == loader_glCompressedTexSubImage2DARB) {
      rCtx->dsp->emuTbl.glCompressedTexSubImage2DARB = driverTbl.glCompressedTexSubImage2DARB;
   }
   driverTbl.glCompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedTexSubImage3DARB not available." );
}

static void REGAL_CALL loader_glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTexSubImage3DARB, "glCompressedTexSubImage3DARB");
   if ( !driverTbl.glCompressedTexSubImage3DARB ) {
      driverTbl.glCompressedTexSubImage3DARB = missing_glCompressedTexSubImage3DARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTexSubImage3DARB == loader_glCompressedTexSubImage3DARB) {
      rCtx->dsp->emuTbl.glCompressedTexSubImage3DARB = driverTbl.glCompressedTexSubImage3DARB;
   }
   driverTbl.glCompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

static void REGAL_CALL missing_glGetCompressedTexImageARB(GLenum target, GLint lod, GLvoid *img)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(lod);
   UNUSED_PARAMETER(img);
   Warning( "glGetCompressedTexImageARB not available." );
}

static void REGAL_CALL loader_glGetCompressedTexImageARB(GLenum target, GLint lod, GLvoid *img)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetCompressedTexImageARB, "glGetCompressedTexImageARB");
   if ( !driverTbl.glGetCompressedTexImageARB ) {
      driverTbl.glGetCompressedTexImageARB = missing_glGetCompressedTexImageARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetCompressedTexImageARB == loader_glGetCompressedTexImageARB) {
      rCtx->dsp->emuTbl.glGetCompressedTexImageARB = driverTbl.glGetCompressedTexImageARB;
   }
   driverTbl.glGetCompressedTexImageARB(target, lod, img);
}

// GL_ARB_texture_multisample

static void REGAL_CALL missing_glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(val);
   Warning( "glGetMultisamplefv not available." );
}

static void REGAL_CALL loader_glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMultisamplefv, "glGetMultisamplefv");
   if ( !driverTbl.glGetMultisamplefv ) {
      driverTbl.glGetMultisamplefv = missing_glGetMultisamplefv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMultisamplefv == loader_glGetMultisamplefv) {
      rCtx->dsp->emuTbl.glGetMultisamplefv = driverTbl.glGetMultisamplefv;
   }
   driverTbl.glGetMultisamplefv(pname, index, val);
}

static void REGAL_CALL missing_glSampleMaski(GLuint index, GLbitfield mask)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(mask);
   Warning( "glSampleMaski not available." );
}

static void REGAL_CALL loader_glSampleMaski(GLuint index, GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSampleMaski, "glSampleMaski");
   if ( !driverTbl.glSampleMaski ) {
      driverTbl.glSampleMaski = missing_glSampleMaski;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSampleMaski == loader_glSampleMaski) {
      rCtx->dsp->emuTbl.glSampleMaski = driverTbl.glSampleMaski;
   }
   driverTbl.glSampleMaski(index, mask);
}

static void REGAL_CALL missing_glTexImage2DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(fixedsamplelocations);
   Warning( "glTexImage2DMultisample not available." );
}

static void REGAL_CALL loader_glTexImage2DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexImage2DMultisample, "glTexImage2DMultisample");
   if ( !driverTbl.glTexImage2DMultisample ) {
      driverTbl.glTexImage2DMultisample = missing_glTexImage2DMultisample;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexImage2DMultisample == loader_glTexImage2DMultisample) {
      rCtx->dsp->emuTbl.glTexImage2DMultisample = driverTbl.glTexImage2DMultisample;
   }
   driverTbl.glTexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
}

static void REGAL_CALL missing_glTexImage3DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(fixedsamplelocations);
   Warning( "glTexImage3DMultisample not available." );
}

static void REGAL_CALL loader_glTexImage3DMultisample(GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexImage3DMultisample, "glTexImage3DMultisample");
   if ( !driverTbl.glTexImage3DMultisample ) {
      driverTbl.glTexImage3DMultisample = missing_glTexImage3DMultisample;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexImage3DMultisample == loader_glTexImage3DMultisample) {
      rCtx->dsp->emuTbl.glTexImage3DMultisample = driverTbl.glTexImage3DMultisample;
   }
   driverTbl.glTexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

// GL_ARB_texture_storage

static void REGAL_CALL missing_glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(levels);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   Warning( "glTexStorage1D not available." );
}

static void REGAL_CALL loader_glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexStorage1D, "glTexStorage1D");
   if ( !driverTbl.glTexStorage1D ) {
      driverTbl.glTexStorage1D = missing_glTexStorage1D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexStorage1D == loader_glTexStorage1D) {
      rCtx->dsp->emuTbl.glTexStorage1D = driverTbl.glTexStorage1D;
   }
   driverTbl.glTexStorage1D(target, levels, internalformat, width);
}

static void REGAL_CALL missing_glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(levels);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glTexStorage2D not available." );
}

static void REGAL_CALL loader_glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexStorage2D, "glTexStorage2D");
   if ( !driverTbl.glTexStorage2D ) {
      driverTbl.glTexStorage2D = missing_glTexStorage2D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexStorage2D == loader_glTexStorage2D) {
      rCtx->dsp->emuTbl.glTexStorage2D = driverTbl.glTexStorage2D;
   }
   driverTbl.glTexStorage2D(target, levels, internalformat, width, height);
}

static void REGAL_CALL missing_glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(levels);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   Warning( "glTexStorage3D not available." );
}

static void REGAL_CALL loader_glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexStorage3D, "glTexStorage3D");
   if ( !driverTbl.glTexStorage3D ) {
      driverTbl.glTexStorage3D = missing_glTexStorage3D;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexStorage3D == loader_glTexStorage3D) {
      rCtx->dsp->emuTbl.glTexStorage3D = driverTbl.glTexStorage3D;
   }
   driverTbl.glTexStorage3D(target, levels, internalformat, width, height, depth);
}

static void REGAL_CALL missing_glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(levels);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   Warning( "glTextureStorage1DEXT not available." );
}

static void REGAL_CALL loader_glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureStorage1DEXT, "glTextureStorage1DEXT");
   if ( !driverTbl.glTextureStorage1DEXT ) {
      driverTbl.glTextureStorage1DEXT = missing_glTextureStorage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureStorage1DEXT == loader_glTextureStorage1DEXT) {
      rCtx->dsp->emuTbl.glTextureStorage1DEXT = driverTbl.glTextureStorage1DEXT;
   }
   driverTbl.glTextureStorage1DEXT(texture, target, levels, internalformat, width);
}

static void REGAL_CALL missing_glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(levels);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glTextureStorage2DEXT not available." );
}

static void REGAL_CALL loader_glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureStorage2DEXT, "glTextureStorage2DEXT");
   if ( !driverTbl.glTextureStorage2DEXT ) {
      driverTbl.glTextureStorage2DEXT = missing_glTextureStorage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureStorage2DEXT == loader_glTextureStorage2DEXT) {
      rCtx->dsp->emuTbl.glTextureStorage2DEXT = driverTbl.glTextureStorage2DEXT;
   }
   driverTbl.glTextureStorage2DEXT(texture, target, levels, internalformat, width, height);
}

static void REGAL_CALL missing_glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(levels);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   Warning( "glTextureStorage3DEXT not available." );
}

static void REGAL_CALL loader_glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureStorage3DEXT, "glTextureStorage3DEXT");
   if ( !driverTbl.glTextureStorage3DEXT ) {
      driverTbl.glTextureStorage3DEXT = missing_glTextureStorage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureStorage3DEXT == loader_glTextureStorage3DEXT) {
      rCtx->dsp->emuTbl.glTextureStorage3DEXT = driverTbl.glTextureStorage3DEXT;
   }
   driverTbl.glTextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);
}

// GL_ARB_texture_storage_multisample

static void REGAL_CALL missing_glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(fixedsamplelocations);
   Warning( "glTexStorage2DMultisample not available." );
}

static void REGAL_CALL loader_glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexStorage2DMultisample, "glTexStorage2DMultisample");
   if ( !driverTbl.glTexStorage2DMultisample ) {
      driverTbl.glTexStorage2DMultisample = missing_glTexStorage2DMultisample;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexStorage2DMultisample == loader_glTexStorage2DMultisample) {
      rCtx->dsp->emuTbl.glTexStorage2DMultisample = driverTbl.glTexStorage2DMultisample;
   }
   driverTbl.glTexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
}

static void REGAL_CALL missing_glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(fixedsamplelocations);
   Warning( "glTexStorage3DMultisample not available." );
}

static void REGAL_CALL loader_glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexStorage3DMultisample, "glTexStorage3DMultisample");
   if ( !driverTbl.glTexStorage3DMultisample ) {
      driverTbl.glTexStorage3DMultisample = missing_glTexStorage3DMultisample;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexStorage3DMultisample == loader_glTexStorage3DMultisample) {
      rCtx->dsp->emuTbl.glTexStorage3DMultisample = driverTbl.glTexStorage3DMultisample;
   }
   driverTbl.glTexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

static void REGAL_CALL missing_glTextureStorage2DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(fixedsamplelocations);
   Warning( "glTextureStorage2DMultisampleEXT not available." );
}

static void REGAL_CALL loader_glTextureStorage2DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureStorage2DMultisampleEXT, "glTextureStorage2DMultisampleEXT");
   if ( !driverTbl.glTextureStorage2DMultisampleEXT ) {
      driverTbl.glTextureStorage2DMultisampleEXT = missing_glTextureStorage2DMultisampleEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureStorage2DMultisampleEXT == loader_glTextureStorage2DMultisampleEXT) {
      rCtx->dsp->emuTbl.glTextureStorage2DMultisampleEXT = driverTbl.glTextureStorage2DMultisampleEXT;
   }
   driverTbl.glTextureStorage2DMultisampleEXT(texture, target, samples, internalformat, width, height, fixedsamplelocations);
}

static void REGAL_CALL missing_glTextureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(fixedsamplelocations);
   Warning( "glTextureStorage3DMultisampleEXT not available." );
}

static void REGAL_CALL loader_glTextureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureStorage3DMultisampleEXT, "glTextureStorage3DMultisampleEXT");
   if ( !driverTbl.glTextureStorage3DMultisampleEXT ) {
      driverTbl.glTextureStorage3DMultisampleEXT = missing_glTextureStorage3DMultisampleEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureStorage3DMultisampleEXT == loader_glTextureStorage3DMultisampleEXT) {
      rCtx->dsp->emuTbl.glTextureStorage3DMultisampleEXT = driverTbl.glTextureStorage3DMultisampleEXT;
   }
   driverTbl.glTextureStorage3DMultisampleEXT(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
}

// GL_ARB_texture_view

static void REGAL_CALL missing_glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(origtexture);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(minlevel);
   UNUSED_PARAMETER(numlevels);
   UNUSED_PARAMETER(minlayer);
   UNUSED_PARAMETER(numlayers);
   Warning( "glTextureView not available." );
}

static void REGAL_CALL loader_glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureView, "glTextureView");
   if ( !driverTbl.glTextureView ) {
      driverTbl.glTextureView = missing_glTextureView;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureView == loader_glTextureView) {
      rCtx->dsp->emuTbl.glTextureView = driverTbl.glTextureView;
   }
   driverTbl.glTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
}

// GL_ARB_timer_query

static void REGAL_CALL missing_glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetQueryObjecti64v not available." );
}

static void REGAL_CALL loader_glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetQueryObjecti64v, "glGetQueryObjecti64v");
   if ( !driverTbl.glGetQueryObjecti64v ) {
      driverTbl.glGetQueryObjecti64v = missing_glGetQueryObjecti64v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetQueryObjecti64v == loader_glGetQueryObjecti64v) {
      rCtx->dsp->emuTbl.glGetQueryObjecti64v = driverTbl.glGetQueryObjecti64v;
   }
   driverTbl.glGetQueryObjecti64v(id, pname, params);
}

static void REGAL_CALL missing_glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetQueryObjectui64v not available." );
}

static void REGAL_CALL loader_glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetQueryObjectui64v, "glGetQueryObjectui64v");
   if ( !driverTbl.glGetQueryObjectui64v ) {
      driverTbl.glGetQueryObjectui64v = missing_glGetQueryObjectui64v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetQueryObjectui64v == loader_glGetQueryObjectui64v) {
      rCtx->dsp->emuTbl.glGetQueryObjectui64v = driverTbl.glGetQueryObjectui64v;
   }
   driverTbl.glGetQueryObjectui64v(id, pname, params);
}

static void REGAL_CALL missing_glQueryCounter(GLuint id, GLenum target)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(target);
   Warning( "glQueryCounter not available." );
}

static void REGAL_CALL loader_glQueryCounter(GLuint id, GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glQueryCounter, "glQueryCounter");
   if ( !driverTbl.glQueryCounter ) {
      driverTbl.glQueryCounter = missing_glQueryCounter;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glQueryCounter == loader_glQueryCounter) {
      rCtx->dsp->emuTbl.glQueryCounter = driverTbl.glQueryCounter;
   }
   driverTbl.glQueryCounter(id, target);
}

// GL_ARB_transform_feedback2

static void REGAL_CALL missing_glBindTransformFeedback(GLenum target, GLuint id)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(id);
   Warning( "glBindTransformFeedback not available." );
}

static void REGAL_CALL loader_glBindTransformFeedback(GLenum target, GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindTransformFeedback, "glBindTransformFeedback");
   if ( !driverTbl.glBindTransformFeedback ) {
      driverTbl.glBindTransformFeedback = missing_glBindTransformFeedback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindTransformFeedback == loader_glBindTransformFeedback) {
      rCtx->dsp->emuTbl.glBindTransformFeedback = driverTbl.glBindTransformFeedback;
   }
   driverTbl.glBindTransformFeedback(target, id);
}

static void REGAL_CALL missing_glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "glDeleteTransformFeedbacks not available." );
}

static void REGAL_CALL loader_glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteTransformFeedbacks, "glDeleteTransformFeedbacks");
   if ( !driverTbl.glDeleteTransformFeedbacks ) {
      driverTbl.glDeleteTransformFeedbacks = missing_glDeleteTransformFeedbacks;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteTransformFeedbacks == loader_glDeleteTransformFeedbacks) {
      rCtx->dsp->emuTbl.glDeleteTransformFeedbacks = driverTbl.glDeleteTransformFeedbacks;
   }
   driverTbl.glDeleteTransformFeedbacks(n, ids);
}

static void REGAL_CALL missing_glDrawTransformFeedback(GLenum mode, GLuint name)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(name);
   Warning( "glDrawTransformFeedback not available." );
}

static void REGAL_CALL loader_glDrawTransformFeedback(GLenum mode, GLuint name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawTransformFeedback, "glDrawTransformFeedback");
   if ( !driverTbl.glDrawTransformFeedback ) {
      driverTbl.glDrawTransformFeedback = missing_glDrawTransformFeedback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawTransformFeedback == loader_glDrawTransformFeedback) {
      rCtx->dsp->emuTbl.glDrawTransformFeedback = driverTbl.glDrawTransformFeedback;
   }
   driverTbl.glDrawTransformFeedback(mode, name);
}

static void REGAL_CALL missing_glGenTransformFeedbacks(GLsizei n, GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "glGenTransformFeedbacks not available." );
}

static void REGAL_CALL loader_glGenTransformFeedbacks(GLsizei n, GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenTransformFeedbacks, "glGenTransformFeedbacks");
   if ( !driverTbl.glGenTransformFeedbacks ) {
      driverTbl.glGenTransformFeedbacks = missing_glGenTransformFeedbacks;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenTransformFeedbacks == loader_glGenTransformFeedbacks) {
      rCtx->dsp->emuTbl.glGenTransformFeedbacks = driverTbl.glGenTransformFeedbacks;
   }
   driverTbl.glGenTransformFeedbacks(n, ids);
}

static GLboolean REGAL_CALL missing_glIsTransformFeedback(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "glIsTransformFeedback not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsTransformFeedback(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsTransformFeedback, "glIsTransformFeedback");
   if ( !driverTbl.glIsTransformFeedback ) {
      driverTbl.glIsTransformFeedback = missing_glIsTransformFeedback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsTransformFeedback == loader_glIsTransformFeedback) {
      rCtx->dsp->emuTbl.glIsTransformFeedback = driverTbl.glIsTransformFeedback;
   }
   return driverTbl.glIsTransformFeedback(id);
}

static void REGAL_CALL missing_glPauseTransformFeedback(void)
{
   Warning( "glPauseTransformFeedback not available." );
}

static void REGAL_CALL loader_glPauseTransformFeedback(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPauseTransformFeedback, "glPauseTransformFeedback");
   if ( !driverTbl.glPauseTransformFeedback ) {
      driverTbl.glPauseTransformFeedback = missing_glPauseTransformFeedback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPauseTransformFeedback == loader_glPauseTransformFeedback) {
      rCtx->dsp->emuTbl.glPauseTransformFeedback = driverTbl.glPauseTransformFeedback;
   }
   driverTbl.glPauseTransformFeedback();
}

static void REGAL_CALL missing_glResumeTransformFeedback(void)
{
   Warning( "glResumeTransformFeedback not available." );
}

static void REGAL_CALL loader_glResumeTransformFeedback(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glResumeTransformFeedback, "glResumeTransformFeedback");
   if ( !driverTbl.glResumeTransformFeedback ) {
      driverTbl.glResumeTransformFeedback = missing_glResumeTransformFeedback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glResumeTransformFeedback == loader_glResumeTransformFeedback) {
      rCtx->dsp->emuTbl.glResumeTransformFeedback = driverTbl.glResumeTransformFeedback;
   }
   driverTbl.glResumeTransformFeedback();
}

// GL_ARB_transform_feedback3

static void REGAL_CALL missing_glBeginQueryIndexed(GLenum target, GLuint index, GLuint id)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(id);
   Warning( "glBeginQueryIndexed not available." );
}

static void REGAL_CALL loader_glBeginQueryIndexed(GLenum target, GLuint index, GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBeginQueryIndexed, "glBeginQueryIndexed");
   if ( !driverTbl.glBeginQueryIndexed ) {
      driverTbl.glBeginQueryIndexed = missing_glBeginQueryIndexed;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBeginQueryIndexed == loader_glBeginQueryIndexed) {
      rCtx->dsp->emuTbl.glBeginQueryIndexed = driverTbl.glBeginQueryIndexed;
   }
   driverTbl.glBeginQueryIndexed(target, index, id);
}

static void REGAL_CALL missing_glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(stream);
   Warning( "glDrawTransformFeedbackStream not available." );
}

static void REGAL_CALL loader_glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawTransformFeedbackStream, "glDrawTransformFeedbackStream");
   if ( !driverTbl.glDrawTransformFeedbackStream ) {
      driverTbl.glDrawTransformFeedbackStream = missing_glDrawTransformFeedbackStream;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawTransformFeedbackStream == loader_glDrawTransformFeedbackStream) {
      rCtx->dsp->emuTbl.glDrawTransformFeedbackStream = driverTbl.glDrawTransformFeedbackStream;
   }
   driverTbl.glDrawTransformFeedbackStream(mode, id, stream);
}

static void REGAL_CALL missing_glEndQueryIndexed(GLenum target, GLuint index)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   Warning( "glEndQueryIndexed not available." );
}

static void REGAL_CALL loader_glEndQueryIndexed(GLenum target, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndQueryIndexed, "glEndQueryIndexed");
   if ( !driverTbl.glEndQueryIndexed ) {
      driverTbl.glEndQueryIndexed = missing_glEndQueryIndexed;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndQueryIndexed == loader_glEndQueryIndexed) {
      rCtx->dsp->emuTbl.glEndQueryIndexed = driverTbl.glEndQueryIndexed;
   }
   driverTbl.glEndQueryIndexed(target, index);
}

static void REGAL_CALL missing_glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetQueryIndexediv not available." );
}

static void REGAL_CALL loader_glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetQueryIndexediv, "glGetQueryIndexediv");
   if ( !driverTbl.glGetQueryIndexediv ) {
      driverTbl.glGetQueryIndexediv = missing_glGetQueryIndexediv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetQueryIndexediv == loader_glGetQueryIndexediv) {
      rCtx->dsp->emuTbl.glGetQueryIndexediv = driverTbl.glGetQueryIndexediv;
   }
   driverTbl.glGetQueryIndexediv(target, index, pname, params);
}

// GL_ARB_transform_feedback_instanced

static void REGAL_CALL missing_glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(primcount);
   Warning( "glDrawTransformFeedbackInstanced not available." );
}

static void REGAL_CALL loader_glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawTransformFeedbackInstanced, "glDrawTransformFeedbackInstanced");
   if ( !driverTbl.glDrawTransformFeedbackInstanced ) {
      driverTbl.glDrawTransformFeedbackInstanced = missing_glDrawTransformFeedbackInstanced;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawTransformFeedbackInstanced == loader_glDrawTransformFeedbackInstanced) {
      rCtx->dsp->emuTbl.glDrawTransformFeedbackInstanced = driverTbl.glDrawTransformFeedbackInstanced;
   }
   driverTbl.glDrawTransformFeedbackInstanced(mode, id, primcount);
}

static void REGAL_CALL missing_glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(primcount);
   Warning( "glDrawTransformFeedbackStreamInstanced not available." );
}

static void REGAL_CALL loader_glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawTransformFeedbackStreamInstanced, "glDrawTransformFeedbackStreamInstanced");
   if ( !driverTbl.glDrawTransformFeedbackStreamInstanced ) {
      driverTbl.glDrawTransformFeedbackStreamInstanced = missing_glDrawTransformFeedbackStreamInstanced;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawTransformFeedbackStreamInstanced == loader_glDrawTransformFeedbackStreamInstanced) {
      rCtx->dsp->emuTbl.glDrawTransformFeedbackStreamInstanced = driverTbl.glDrawTransformFeedbackStreamInstanced;
   }
   driverTbl.glDrawTransformFeedbackStreamInstanced(mode, id, stream, primcount);
}

// GL_ARB_transpose_matrix

static void REGAL_CALL missing_glLoadTransposeMatrixdARB(const GLdouble *m)
{
   UNUSED_PARAMETER(m);
   Warning( "glLoadTransposeMatrixdARB not available." );
}

static void REGAL_CALL loader_glLoadTransposeMatrixdARB(const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLoadTransposeMatrixdARB, "glLoadTransposeMatrixdARB");
   if ( !driverTbl.glLoadTransposeMatrixdARB ) {
      driverTbl.glLoadTransposeMatrixdARB = missing_glLoadTransposeMatrixdARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLoadTransposeMatrixdARB == loader_glLoadTransposeMatrixdARB) {
      rCtx->dsp->emuTbl.glLoadTransposeMatrixdARB = driverTbl.glLoadTransposeMatrixdARB;
   }
   driverTbl.glLoadTransposeMatrixdARB(m);
}

static void REGAL_CALL missing_glLoadTransposeMatrixfARB(const GLfloat *m)
{
   UNUSED_PARAMETER(m);
   Warning( "glLoadTransposeMatrixfARB not available." );
}

static void REGAL_CALL loader_glLoadTransposeMatrixfARB(const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLoadTransposeMatrixfARB, "glLoadTransposeMatrixfARB");
   if ( !driverTbl.glLoadTransposeMatrixfARB ) {
      driverTbl.glLoadTransposeMatrixfARB = missing_glLoadTransposeMatrixfARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLoadTransposeMatrixfARB == loader_glLoadTransposeMatrixfARB) {
      rCtx->dsp->emuTbl.glLoadTransposeMatrixfARB = driverTbl.glLoadTransposeMatrixfARB;
   }
   driverTbl.glLoadTransposeMatrixfARB(m);
}

static void REGAL_CALL missing_glMultTransposeMatrixdARB(const GLdouble *m)
{
   UNUSED_PARAMETER(m);
   Warning( "glMultTransposeMatrixdARB not available." );
}

static void REGAL_CALL loader_glMultTransposeMatrixdARB(const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultTransposeMatrixdARB, "glMultTransposeMatrixdARB");
   if ( !driverTbl.glMultTransposeMatrixdARB ) {
      driverTbl.glMultTransposeMatrixdARB = missing_glMultTransposeMatrixdARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultTransposeMatrixdARB == loader_glMultTransposeMatrixdARB) {
      rCtx->dsp->emuTbl.glMultTransposeMatrixdARB = driverTbl.glMultTransposeMatrixdARB;
   }
   driverTbl.glMultTransposeMatrixdARB(m);
}

static void REGAL_CALL missing_glMultTransposeMatrixfARB(const GLfloat *m)
{
   UNUSED_PARAMETER(m);
   Warning( "glMultTransposeMatrixfARB not available." );
}

static void REGAL_CALL loader_glMultTransposeMatrixfARB(const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultTransposeMatrixfARB, "glMultTransposeMatrixfARB");
   if ( !driverTbl.glMultTransposeMatrixfARB ) {
      driverTbl.glMultTransposeMatrixfARB = missing_glMultTransposeMatrixfARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultTransposeMatrixfARB == loader_glMultTransposeMatrixfARB) {
      rCtx->dsp->emuTbl.glMultTransposeMatrixfARB = driverTbl.glMultTransposeMatrixfARB;
   }
   driverTbl.glMultTransposeMatrixfARB(m);
}

// GL_ARB_uniform_buffer_object

static void REGAL_CALL missing_glBindBufferBase(GLenum target, GLuint index, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   Warning( "glBindBufferBase not available." );
}

static void REGAL_CALL loader_glBindBufferBase(GLenum target, GLuint index, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindBufferBase, "glBindBufferBase");
   if ( !driverTbl.glBindBufferBase ) {
      driverTbl.glBindBufferBase = missing_glBindBufferBase;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindBufferBase == loader_glBindBufferBase) {
      rCtx->dsp->emuTbl.glBindBufferBase = driverTbl.glBindBufferBase;
   }
   driverTbl.glBindBufferBase(target, index, buffer);
}

static void REGAL_CALL missing_glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   Warning( "glBindBufferRange not available." );
}

static void REGAL_CALL loader_glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindBufferRange, "glBindBufferRange");
   if ( !driverTbl.glBindBufferRange ) {
      driverTbl.glBindBufferRange = missing_glBindBufferRange;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindBufferRange == loader_glBindBufferRange) {
      rCtx->dsp->emuTbl.glBindBufferRange = driverTbl.glBindBufferRange;
   }
   driverTbl.glBindBufferRange(target, index, buffer, offset, size);
}

static void REGAL_CALL missing_glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(uniformBlockIndex);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(uniformBlockName);
   Warning( "glGetActiveUniformBlockName not available." );
}

static void REGAL_CALL loader_glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetActiveUniformBlockName, "glGetActiveUniformBlockName");
   if ( !driverTbl.glGetActiveUniformBlockName ) {
      driverTbl.glGetActiveUniformBlockName = missing_glGetActiveUniformBlockName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetActiveUniformBlockName == loader_glGetActiveUniformBlockName) {
      rCtx->dsp->emuTbl.glGetActiveUniformBlockName = driverTbl.glGetActiveUniformBlockName;
   }
   driverTbl.glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);
}

static void REGAL_CALL missing_glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(uniformBlockIndex);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetActiveUniformBlockiv not available." );
}

static void REGAL_CALL loader_glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetActiveUniformBlockiv, "glGetActiveUniformBlockiv");
   if ( !driverTbl.glGetActiveUniformBlockiv ) {
      driverTbl.glGetActiveUniformBlockiv = missing_glGetActiveUniformBlockiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetActiveUniformBlockiv == loader_glGetActiveUniformBlockiv) {
      rCtx->dsp->emuTbl.glGetActiveUniformBlockiv = driverTbl.glGetActiveUniformBlockiv;
   }
   driverTbl.glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
}

static void REGAL_CALL missing_glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(uniformIndex);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(uniformName);
   Warning( "glGetActiveUniformName not available." );
}

static void REGAL_CALL loader_glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetActiveUniformName, "glGetActiveUniformName");
   if ( !driverTbl.glGetActiveUniformName ) {
      driverTbl.glGetActiveUniformName = missing_glGetActiveUniformName;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetActiveUniformName == loader_glGetActiveUniformName) {
      rCtx->dsp->emuTbl.glGetActiveUniformName = driverTbl.glGetActiveUniformName;
   }
   driverTbl.glGetActiveUniformName(program, uniformIndex, bufSize, length, uniformName);
}

static void REGAL_CALL missing_glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(uniformCount);
   UNUSED_PARAMETER(uniformIndices);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetActiveUniformsiv not available." );
}

static void REGAL_CALL loader_glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetActiveUniformsiv, "glGetActiveUniformsiv");
   if ( !driverTbl.glGetActiveUniformsiv ) {
      driverTbl.glGetActiveUniformsiv = missing_glGetActiveUniformsiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetActiveUniformsiv == loader_glGetActiveUniformsiv) {
      rCtx->dsp->emuTbl.glGetActiveUniformsiv = driverTbl.glGetActiveUniformsiv;
   }
   driverTbl.glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);
}

static void REGAL_CALL missing_glGetIntegeri_v(GLenum target, GLuint index, GLint *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "glGetIntegeri_v not available." );
}

static void REGAL_CALL loader_glGetIntegeri_v(GLenum target, GLuint index, GLint *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetIntegeri_v, "glGetIntegeri_v");
   if ( !driverTbl.glGetIntegeri_v ) {
      driverTbl.glGetIntegeri_v = missing_glGetIntegeri_v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetIntegeri_v == loader_glGetIntegeri_v) {
      rCtx->dsp->emuTbl.glGetIntegeri_v = driverTbl.glGetIntegeri_v;
   }
   driverTbl.glGetIntegeri_v(target, index, data);
}

static GLuint REGAL_CALL missing_glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(uniformBlockName);
   Warning( "glGetUniformBlockIndex not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformBlockIndex, "glGetUniformBlockIndex");
   if ( !driverTbl.glGetUniformBlockIndex ) {
      driverTbl.glGetUniformBlockIndex = missing_glGetUniformBlockIndex;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformBlockIndex == loader_glGetUniformBlockIndex) {
      rCtx->dsp->emuTbl.glGetUniformBlockIndex = driverTbl.glGetUniformBlockIndex;
   }
   return driverTbl.glGetUniformBlockIndex(program, uniformBlockName);
}

static void REGAL_CALL missing_glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(uniformCount);
   UNUSED_PARAMETER(uniformNames);
   UNUSED_PARAMETER(uniformIndices);
   Warning( "glGetUniformIndices not available." );
}

static void REGAL_CALL loader_glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformIndices, "glGetUniformIndices");
   if ( !driverTbl.glGetUniformIndices ) {
      driverTbl.glGetUniformIndices = missing_glGetUniformIndices;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformIndices == loader_glGetUniformIndices) {
      rCtx->dsp->emuTbl.glGetUniformIndices = driverTbl.glGetUniformIndices;
   }
   driverTbl.glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices);
}

static void REGAL_CALL missing_glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(uniformBlockIndex);
   UNUSED_PARAMETER(uniformBlockBinding);
   Warning( "glUniformBlockBinding not available." );
}

static void REGAL_CALL loader_glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformBlockBinding, "glUniformBlockBinding");
   if ( !driverTbl.glUniformBlockBinding ) {
      driverTbl.glUniformBlockBinding = missing_glUniformBlockBinding;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformBlockBinding == loader_glUniformBlockBinding) {
      rCtx->dsp->emuTbl.glUniformBlockBinding = driverTbl.glUniformBlockBinding;
   }
   driverTbl.glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
}

// GL_ARB_vertex_array_object

static void REGAL_CALL missing_glBindVertexArray(GLuint array)
{
   UNUSED_PARAMETER(array);
   Warning( "glBindVertexArray not available." );
}

static void REGAL_CALL loader_glBindVertexArray(GLuint array)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindVertexArray, "glBindVertexArray");
   if ( !driverTbl.glBindVertexArray ) {
      driverTbl.glBindVertexArray = missing_glBindVertexArray;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindVertexArray == loader_glBindVertexArray) {
      rCtx->dsp->emuTbl.glBindVertexArray = driverTbl.glBindVertexArray;
   }
   driverTbl.glBindVertexArray(array);
}

static void REGAL_CALL missing_glDeleteVertexArrays(GLsizei n, const GLuint *arrays)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(arrays);
   Warning( "glDeleteVertexArrays not available." );
}

static void REGAL_CALL loader_glDeleteVertexArrays(GLsizei n, const GLuint *arrays)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteVertexArrays, "glDeleteVertexArrays");
   if ( !driverTbl.glDeleteVertexArrays ) {
      driverTbl.glDeleteVertexArrays = missing_glDeleteVertexArrays;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteVertexArrays == loader_glDeleteVertexArrays) {
      rCtx->dsp->emuTbl.glDeleteVertexArrays = driverTbl.glDeleteVertexArrays;
   }
   driverTbl.glDeleteVertexArrays(n, arrays);
}

static void REGAL_CALL missing_glGenVertexArrays(GLsizei n, GLuint *arrays)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(arrays);
   Warning( "glGenVertexArrays not available." );
}

static void REGAL_CALL loader_glGenVertexArrays(GLsizei n, GLuint *arrays)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenVertexArrays, "glGenVertexArrays");
   if ( !driverTbl.glGenVertexArrays ) {
      driverTbl.glGenVertexArrays = missing_glGenVertexArrays;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenVertexArrays == loader_glGenVertexArrays) {
      rCtx->dsp->emuTbl.glGenVertexArrays = driverTbl.glGenVertexArrays;
   }
   driverTbl.glGenVertexArrays(n, arrays);
}

static GLboolean REGAL_CALL missing_glIsVertexArray(GLuint array)
{
   UNUSED_PARAMETER(array);
   Warning( "glIsVertexArray not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsVertexArray(GLuint array)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsVertexArray, "glIsVertexArray");
   if ( !driverTbl.glIsVertexArray ) {
      driverTbl.glIsVertexArray = missing_glIsVertexArray;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsVertexArray == loader_glIsVertexArray) {
      rCtx->dsp->emuTbl.glIsVertexArray = driverTbl.glIsVertexArray;
   }
   return driverTbl.glIsVertexArray(array);
}

// GL_ARB_vertex_attrib_64bit

static void REGAL_CALL missing_glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribLdv not available." );
}

static void REGAL_CALL loader_glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribLdv, "glGetVertexAttribLdv");
   if ( !driverTbl.glGetVertexAttribLdv ) {
      driverTbl.glGetVertexAttribLdv = missing_glGetVertexAttribLdv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribLdv == loader_glGetVertexAttribLdv) {
      rCtx->dsp->emuTbl.glGetVertexAttribLdv = driverTbl.glGetVertexAttribLdv;
   }
   driverTbl.glGetVertexAttribLdv(index, pname, params);
}

static void REGAL_CALL missing_glVertexAttribL1d(GLuint index, GLdouble x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttribL1d not available." );
}

static void REGAL_CALL loader_glVertexAttribL1d(GLuint index, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL1d, "glVertexAttribL1d");
   if ( !driverTbl.glVertexAttribL1d ) {
      driverTbl.glVertexAttribL1d = missing_glVertexAttribL1d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL1d == loader_glVertexAttribL1d) {
      rCtx->dsp->emuTbl.glVertexAttribL1d = driverTbl.glVertexAttribL1d;
   }
   driverTbl.glVertexAttribL1d(index, x);
}

static void REGAL_CALL missing_glVertexAttribL1dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL1dv not available." );
}

static void REGAL_CALL loader_glVertexAttribL1dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL1dv, "glVertexAttribL1dv");
   if ( !driverTbl.glVertexAttribL1dv ) {
      driverTbl.glVertexAttribL1dv = missing_glVertexAttribL1dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL1dv == loader_glVertexAttribL1dv) {
      rCtx->dsp->emuTbl.glVertexAttribL1dv = driverTbl.glVertexAttribL1dv;
   }
   driverTbl.glVertexAttribL1dv(index, v);
}

static void REGAL_CALL missing_glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttribL2d not available." );
}

static void REGAL_CALL loader_glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL2d, "glVertexAttribL2d");
   if ( !driverTbl.glVertexAttribL2d ) {
      driverTbl.glVertexAttribL2d = missing_glVertexAttribL2d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL2d == loader_glVertexAttribL2d) {
      rCtx->dsp->emuTbl.glVertexAttribL2d = driverTbl.glVertexAttribL2d;
   }
   driverTbl.glVertexAttribL2d(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribL2dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL2dv not available." );
}

static void REGAL_CALL loader_glVertexAttribL2dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL2dv, "glVertexAttribL2dv");
   if ( !driverTbl.glVertexAttribL2dv ) {
      driverTbl.glVertexAttribL2dv = missing_glVertexAttribL2dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL2dv == loader_glVertexAttribL2dv) {
      rCtx->dsp->emuTbl.glVertexAttribL2dv = driverTbl.glVertexAttribL2dv;
   }
   driverTbl.glVertexAttribL2dv(index, v);
}

static void REGAL_CALL missing_glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttribL3d not available." );
}

static void REGAL_CALL loader_glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL3d, "glVertexAttribL3d");
   if ( !driverTbl.glVertexAttribL3d ) {
      driverTbl.glVertexAttribL3d = missing_glVertexAttribL3d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL3d == loader_glVertexAttribL3d) {
      rCtx->dsp->emuTbl.glVertexAttribL3d = driverTbl.glVertexAttribL3d;
   }
   driverTbl.glVertexAttribL3d(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribL3dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL3dv not available." );
}

static void REGAL_CALL loader_glVertexAttribL3dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL3dv, "glVertexAttribL3dv");
   if ( !driverTbl.glVertexAttribL3dv ) {
      driverTbl.glVertexAttribL3dv = missing_glVertexAttribL3dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL3dv == loader_glVertexAttribL3dv) {
      rCtx->dsp->emuTbl.glVertexAttribL3dv = driverTbl.glVertexAttribL3dv;
   }
   driverTbl.glVertexAttribL3dv(index, v);
}

static void REGAL_CALL missing_glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttribL4d not available." );
}

static void REGAL_CALL loader_glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL4d, "glVertexAttribL4d");
   if ( !driverTbl.glVertexAttribL4d ) {
      driverTbl.glVertexAttribL4d = missing_glVertexAttribL4d;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL4d == loader_glVertexAttribL4d) {
      rCtx->dsp->emuTbl.glVertexAttribL4d = driverTbl.glVertexAttribL4d;
   }
   driverTbl.glVertexAttribL4d(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribL4dv(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL4dv not available." );
}

static void REGAL_CALL loader_glVertexAttribL4dv(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL4dv, "glVertexAttribL4dv");
   if ( !driverTbl.glVertexAttribL4dv ) {
      driverTbl.glVertexAttribL4dv = missing_glVertexAttribL4dv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL4dv == loader_glVertexAttribL4dv) {
      rCtx->dsp->emuTbl.glVertexAttribL4dv = driverTbl.glVertexAttribL4dv;
   }
   driverTbl.glVertexAttribL4dv(index, v);
}

static void REGAL_CALL missing_glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glVertexAttribLPointer not available." );
}

static void REGAL_CALL loader_glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribLPointer, "glVertexAttribLPointer");
   if ( !driverTbl.glVertexAttribLPointer ) {
      driverTbl.glVertexAttribLPointer = missing_glVertexAttribLPointer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribLPointer == loader_glVertexAttribLPointer) {
      rCtx->dsp->emuTbl.glVertexAttribLPointer = driverTbl.glVertexAttribLPointer;
   }
   driverTbl.glVertexAttribLPointer(index, size, type, stride, pointer);
}

// GL_ARB_vertex_attrib_binding

static void REGAL_CALL missing_glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
{
   UNUSED_PARAMETER(bindingindex);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(stride);
   Warning( "glBindVertexBuffer not available." );
}

static void REGAL_CALL loader_glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindVertexBuffer, "glBindVertexBuffer");
   if ( !driverTbl.glBindVertexBuffer ) {
      driverTbl.glBindVertexBuffer = missing_glBindVertexBuffer;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindVertexBuffer == loader_glBindVertexBuffer) {
      rCtx->dsp->emuTbl.glBindVertexBuffer = driverTbl.glBindVertexBuffer;
   }
   driverTbl.glBindVertexBuffer(bindingindex, buffer, offset, stride);
}

static void REGAL_CALL missing_glVertexAttribBinding(GLuint attribindex, GLuint bindingindex)
{
   UNUSED_PARAMETER(attribindex);
   UNUSED_PARAMETER(bindingindex);
   Warning( "glVertexAttribBinding not available." );
}

static void REGAL_CALL loader_glVertexAttribBinding(GLuint attribindex, GLuint bindingindex)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribBinding, "glVertexAttribBinding");
   if ( !driverTbl.glVertexAttribBinding ) {
      driverTbl.glVertexAttribBinding = missing_glVertexAttribBinding;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribBinding == loader_glVertexAttribBinding) {
      rCtx->dsp->emuTbl.glVertexAttribBinding = driverTbl.glVertexAttribBinding;
   }
   driverTbl.glVertexAttribBinding(attribindex, bindingindex);
}

static void REGAL_CALL missing_glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
   UNUSED_PARAMETER(attribindex);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(relativeoffset);
   Warning( "glVertexAttribFormat not available." );
}

static void REGAL_CALL loader_glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribFormat, "glVertexAttribFormat");
   if ( !driverTbl.glVertexAttribFormat ) {
      driverTbl.glVertexAttribFormat = missing_glVertexAttribFormat;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribFormat == loader_glVertexAttribFormat) {
      rCtx->dsp->emuTbl.glVertexAttribFormat = driverTbl.glVertexAttribFormat;
   }
   driverTbl.glVertexAttribFormat(attribindex, size, type, normalized, relativeoffset);
}

static void REGAL_CALL missing_glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
   UNUSED_PARAMETER(attribindex);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(relativeoffset);
   Warning( "glVertexAttribIFormat not available." );
}

static void REGAL_CALL loader_glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribIFormat, "glVertexAttribIFormat");
   if ( !driverTbl.glVertexAttribIFormat ) {
      driverTbl.glVertexAttribIFormat = missing_glVertexAttribIFormat;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribIFormat == loader_glVertexAttribIFormat) {
      rCtx->dsp->emuTbl.glVertexAttribIFormat = driverTbl.glVertexAttribIFormat;
   }
   driverTbl.glVertexAttribIFormat(attribindex, size, type, relativeoffset);
}

static void REGAL_CALL missing_glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
   UNUSED_PARAMETER(attribindex);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(relativeoffset);
   Warning( "glVertexAttribLFormat not available." );
}

static void REGAL_CALL loader_glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribLFormat, "glVertexAttribLFormat");
   if ( !driverTbl.glVertexAttribLFormat ) {
      driverTbl.glVertexAttribLFormat = missing_glVertexAttribLFormat;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribLFormat == loader_glVertexAttribLFormat) {
      rCtx->dsp->emuTbl.glVertexAttribLFormat = driverTbl.glVertexAttribLFormat;
   }
   driverTbl.glVertexAttribLFormat(attribindex, size, type, relativeoffset);
}

static void REGAL_CALL missing_glVertexBindingDivisor(GLuint bindingindex, GLuint divisor)
{
   UNUSED_PARAMETER(bindingindex);
   UNUSED_PARAMETER(divisor);
   Warning( "glVertexBindingDivisor not available." );
}

static void REGAL_CALL loader_glVertexBindingDivisor(GLuint bindingindex, GLuint divisor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexBindingDivisor, "glVertexBindingDivisor");
   if ( !driverTbl.glVertexBindingDivisor ) {
      driverTbl.glVertexBindingDivisor = missing_glVertexBindingDivisor;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexBindingDivisor == loader_glVertexBindingDivisor) {
      rCtx->dsp->emuTbl.glVertexBindingDivisor = driverTbl.glVertexBindingDivisor;
   }
   driverTbl.glVertexBindingDivisor(bindingindex, divisor);
}

// GL_ARB_vertex_blend

static void REGAL_CALL missing_glVertexBlendARB(GLint count)
{
   UNUSED_PARAMETER(count);
   Warning( "glVertexBlendARB not available." );
}

static void REGAL_CALL loader_glVertexBlendARB(GLint count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexBlendARB, "glVertexBlendARB");
   if ( !driverTbl.glVertexBlendARB ) {
      driverTbl.glVertexBlendARB = missing_glVertexBlendARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexBlendARB == loader_glVertexBlendARB) {
      rCtx->dsp->emuTbl.glVertexBlendARB = driverTbl.glVertexBlendARB;
   }
   driverTbl.glVertexBlendARB(count);
}

static void REGAL_CALL missing_glWeightPointerARB(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glWeightPointerARB not available." );
}

static void REGAL_CALL loader_glWeightPointerARB(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWeightPointerARB, "glWeightPointerARB");
   if ( !driverTbl.glWeightPointerARB ) {
      driverTbl.glWeightPointerARB = missing_glWeightPointerARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWeightPointerARB == loader_glWeightPointerARB) {
      rCtx->dsp->emuTbl.glWeightPointerARB = driverTbl.glWeightPointerARB;
   }
   driverTbl.glWeightPointerARB(size, type, stride, pointer);
}

static void REGAL_CALL missing_glWeightbvARB(GLint size, GLbyte *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "glWeightbvARB not available." );
}

static void REGAL_CALL loader_glWeightbvARB(GLint size, GLbyte *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWeightbvARB, "glWeightbvARB");
   if ( !driverTbl.glWeightbvARB ) {
      driverTbl.glWeightbvARB = missing_glWeightbvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWeightbvARB == loader_glWeightbvARB) {
      rCtx->dsp->emuTbl.glWeightbvARB = driverTbl.glWeightbvARB;
   }
   driverTbl.glWeightbvARB(size, weights);
}

static void REGAL_CALL missing_glWeightdvARB(GLint size, GLdouble *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "glWeightdvARB not available." );
}

static void REGAL_CALL loader_glWeightdvARB(GLint size, GLdouble *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWeightdvARB, "glWeightdvARB");
   if ( !driverTbl.glWeightdvARB ) {
      driverTbl.glWeightdvARB = missing_glWeightdvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWeightdvARB == loader_glWeightdvARB) {
      rCtx->dsp->emuTbl.glWeightdvARB = driverTbl.glWeightdvARB;
   }
   driverTbl.glWeightdvARB(size, weights);
}

static void REGAL_CALL missing_glWeightfvARB(GLint size, GLfloat *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "glWeightfvARB not available." );
}

static void REGAL_CALL loader_glWeightfvARB(GLint size, GLfloat *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWeightfvARB, "glWeightfvARB");
   if ( !driverTbl.glWeightfvARB ) {
      driverTbl.glWeightfvARB = missing_glWeightfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWeightfvARB == loader_glWeightfvARB) {
      rCtx->dsp->emuTbl.glWeightfvARB = driverTbl.glWeightfvARB;
   }
   driverTbl.glWeightfvARB(size, weights);
}

static void REGAL_CALL missing_glWeightivARB(GLint size, GLint *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "glWeightivARB not available." );
}

static void REGAL_CALL loader_glWeightivARB(GLint size, GLint *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWeightivARB, "glWeightivARB");
   if ( !driverTbl.glWeightivARB ) {
      driverTbl.glWeightivARB = missing_glWeightivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWeightivARB == loader_glWeightivARB) {
      rCtx->dsp->emuTbl.glWeightivARB = driverTbl.glWeightivARB;
   }
   driverTbl.glWeightivARB(size, weights);
}

static void REGAL_CALL missing_glWeightsvARB(GLint size, GLshort *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "glWeightsvARB not available." );
}

static void REGAL_CALL loader_glWeightsvARB(GLint size, GLshort *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWeightsvARB, "glWeightsvARB");
   if ( !driverTbl.glWeightsvARB ) {
      driverTbl.glWeightsvARB = missing_glWeightsvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWeightsvARB == loader_glWeightsvARB) {
      rCtx->dsp->emuTbl.glWeightsvARB = driverTbl.glWeightsvARB;
   }
   driverTbl.glWeightsvARB(size, weights);
}

static void REGAL_CALL missing_glWeightubvARB(GLint size, GLubyte *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "glWeightubvARB not available." );
}

static void REGAL_CALL loader_glWeightubvARB(GLint size, GLubyte *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWeightubvARB, "glWeightubvARB");
   if ( !driverTbl.glWeightubvARB ) {
      driverTbl.glWeightubvARB = missing_glWeightubvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWeightubvARB == loader_glWeightubvARB) {
      rCtx->dsp->emuTbl.glWeightubvARB = driverTbl.glWeightubvARB;
   }
   driverTbl.glWeightubvARB(size, weights);
}

static void REGAL_CALL missing_glWeightuivARB(GLint size, GLuint *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "glWeightuivARB not available." );
}

static void REGAL_CALL loader_glWeightuivARB(GLint size, GLuint *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWeightuivARB, "glWeightuivARB");
   if ( !driverTbl.glWeightuivARB ) {
      driverTbl.glWeightuivARB = missing_glWeightuivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWeightuivARB == loader_glWeightuivARB) {
      rCtx->dsp->emuTbl.glWeightuivARB = driverTbl.glWeightuivARB;
   }
   driverTbl.glWeightuivARB(size, weights);
}

static void REGAL_CALL missing_glWeightusvARB(GLint size, GLushort *weights)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(weights);
   Warning( "glWeightusvARB not available." );
}

static void REGAL_CALL loader_glWeightusvARB(GLint size, GLushort *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWeightusvARB, "glWeightusvARB");
   if ( !driverTbl.glWeightusvARB ) {
      driverTbl.glWeightusvARB = missing_glWeightusvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWeightusvARB == loader_glWeightusvARB) {
      rCtx->dsp->emuTbl.glWeightusvARB = driverTbl.glWeightusvARB;
   }
   driverTbl.glWeightusvARB(size, weights);
}

// GL_ARB_vertex_buffer_object

static void REGAL_CALL missing_glBindBufferARB(GLenum target, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(buffer);
   Warning( "glBindBufferARB not available." );
}

static void REGAL_CALL loader_glBindBufferARB(GLenum target, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindBufferARB, "glBindBufferARB");
   if ( !driverTbl.glBindBufferARB ) {
      driverTbl.glBindBufferARB = missing_glBindBufferARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindBufferARB == loader_glBindBufferARB) {
      rCtx->dsp->emuTbl.glBindBufferARB = driverTbl.glBindBufferARB;
   }
   driverTbl.glBindBufferARB(target, buffer);
}

static void REGAL_CALL missing_glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   UNUSED_PARAMETER(usage);
   Warning( "glBufferDataARB not available." );
}

static void REGAL_CALL loader_glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBufferDataARB, "glBufferDataARB");
   if ( !driverTbl.glBufferDataARB ) {
      driverTbl.glBufferDataARB = missing_glBufferDataARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBufferDataARB == loader_glBufferDataARB) {
      rCtx->dsp->emuTbl.glBufferDataARB = driverTbl.glBufferDataARB;
   }
   driverTbl.glBufferDataARB(target, size, data, usage);
}

static void REGAL_CALL missing_glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   Warning( "glBufferSubDataARB not available." );
}

static void REGAL_CALL loader_glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBufferSubDataARB, "glBufferSubDataARB");
   if ( !driverTbl.glBufferSubDataARB ) {
      driverTbl.glBufferSubDataARB = missing_glBufferSubDataARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBufferSubDataARB == loader_glBufferSubDataARB) {
      rCtx->dsp->emuTbl.glBufferSubDataARB = driverTbl.glBufferSubDataARB;
   }
   driverTbl.glBufferSubDataARB(target, offset, size, data);
}

static void REGAL_CALL missing_glDeleteBuffersARB(GLsizei n, const GLuint *buffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(buffers);
   Warning( "glDeleteBuffersARB not available." );
}

static void REGAL_CALL loader_glDeleteBuffersARB(GLsizei n, const GLuint *buffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteBuffersARB, "glDeleteBuffersARB");
   if ( !driverTbl.glDeleteBuffersARB ) {
      driverTbl.glDeleteBuffersARB = missing_glDeleteBuffersARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteBuffersARB == loader_glDeleteBuffersARB) {
      rCtx->dsp->emuTbl.glDeleteBuffersARB = driverTbl.glDeleteBuffersARB;
   }
   driverTbl.glDeleteBuffersARB(n, buffers);
}

static void REGAL_CALL missing_glGenBuffersARB(GLsizei n, GLuint *buffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(buffers);
   Warning( "glGenBuffersARB not available." );
}

static void REGAL_CALL loader_glGenBuffersARB(GLsizei n, GLuint *buffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenBuffersARB, "glGenBuffersARB");
   if ( !driverTbl.glGenBuffersARB ) {
      driverTbl.glGenBuffersARB = missing_glGenBuffersARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenBuffersARB == loader_glGenBuffersARB) {
      rCtx->dsp->emuTbl.glGenBuffersARB = driverTbl.glGenBuffersARB;
   }
   driverTbl.glGenBuffersARB(n, buffers);
}

static void REGAL_CALL missing_glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetBufferParameterivARB not available." );
}

static void REGAL_CALL loader_glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetBufferParameterivARB, "glGetBufferParameterivARB");
   if ( !driverTbl.glGetBufferParameterivARB ) {
      driverTbl.glGetBufferParameterivARB = missing_glGetBufferParameterivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetBufferParameterivARB == loader_glGetBufferParameterivARB) {
      rCtx->dsp->emuTbl.glGetBufferParameterivARB = driverTbl.glGetBufferParameterivARB;
   }
   driverTbl.glGetBufferParameterivARB(target, pname, params);
}

static void REGAL_CALL missing_glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetBufferPointervARB not available." );
}

static void REGAL_CALL loader_glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetBufferPointervARB, "glGetBufferPointervARB");
   if ( !driverTbl.glGetBufferPointervARB ) {
      driverTbl.glGetBufferPointervARB = missing_glGetBufferPointervARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetBufferPointervARB == loader_glGetBufferPointervARB) {
      rCtx->dsp->emuTbl.glGetBufferPointervARB = driverTbl.glGetBufferPointervARB;
   }
   driverTbl.glGetBufferPointervARB(target, pname, params);
}

static void REGAL_CALL missing_glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   Warning( "glGetBufferSubDataARB not available." );
}

static void REGAL_CALL loader_glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetBufferSubDataARB, "glGetBufferSubDataARB");
   if ( !driverTbl.glGetBufferSubDataARB ) {
      driverTbl.glGetBufferSubDataARB = missing_glGetBufferSubDataARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetBufferSubDataARB == loader_glGetBufferSubDataARB) {
      rCtx->dsp->emuTbl.glGetBufferSubDataARB = driverTbl.glGetBufferSubDataARB;
   }
   driverTbl.glGetBufferSubDataARB(target, offset, size, data);
}

static GLboolean REGAL_CALL missing_glIsBufferARB(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "glIsBufferARB not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsBufferARB(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsBufferARB, "glIsBufferARB");
   if ( !driverTbl.glIsBufferARB ) {
      driverTbl.glIsBufferARB = missing_glIsBufferARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsBufferARB == loader_glIsBufferARB) {
      rCtx->dsp->emuTbl.glIsBufferARB = driverTbl.glIsBufferARB;
   }
   return driverTbl.glIsBufferARB(buffer);
}

static GLvoid *REGAL_CALL missing_glMapBufferARB(GLenum target, GLenum access)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(access);
   Warning( "glMapBufferARB not available." );
  GLvoid * ret = NULL;
  return ret;
}

static GLvoid *REGAL_CALL loader_glMapBufferARB(GLenum target, GLenum access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapBufferARB, "glMapBufferARB");
   if ( !driverTbl.glMapBufferARB ) {
      driverTbl.glMapBufferARB = missing_glMapBufferARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapBufferARB == loader_glMapBufferARB) {
      rCtx->dsp->emuTbl.glMapBufferARB = driverTbl.glMapBufferARB;
   }
   return driverTbl.glMapBufferARB(target, access);
}

static GLboolean REGAL_CALL missing_glUnmapBufferARB(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glUnmapBufferARB not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glUnmapBufferARB(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUnmapBufferARB, "glUnmapBufferARB");
   if ( !driverTbl.glUnmapBufferARB ) {
      driverTbl.glUnmapBufferARB = missing_glUnmapBufferARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUnmapBufferARB == loader_glUnmapBufferARB) {
      rCtx->dsp->emuTbl.glUnmapBufferARB = driverTbl.glUnmapBufferARB;
   }
   return driverTbl.glUnmapBufferARB(target);
}

// GL_ARB_vertex_program

static void REGAL_CALL missing_glBindProgramARB(GLenum target, GLuint program)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(program);
   Warning( "glBindProgramARB not available." );
}

static void REGAL_CALL loader_glBindProgramARB(GLenum target, GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindProgramARB, "glBindProgramARB");
   if ( !driverTbl.glBindProgramARB ) {
      driverTbl.glBindProgramARB = missing_glBindProgramARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindProgramARB == loader_glBindProgramARB) {
      rCtx->dsp->emuTbl.glBindProgramARB = driverTbl.glBindProgramARB;
   }
   driverTbl.glBindProgramARB(target, program);
}

static void REGAL_CALL missing_glDeleteProgramsARB(GLsizei n, const GLuint *programs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(programs);
   Warning( "glDeleteProgramsARB not available." );
}

static void REGAL_CALL loader_glDeleteProgramsARB(GLsizei n, const GLuint *programs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteProgramsARB, "glDeleteProgramsARB");
   if ( !driverTbl.glDeleteProgramsARB ) {
      driverTbl.glDeleteProgramsARB = missing_glDeleteProgramsARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteProgramsARB == loader_glDeleteProgramsARB) {
      rCtx->dsp->emuTbl.glDeleteProgramsARB = driverTbl.glDeleteProgramsARB;
   }
   driverTbl.glDeleteProgramsARB(n, programs);
}

static void REGAL_CALL missing_glDisableVertexAttribArrayARB(GLuint index)
{
   UNUSED_PARAMETER(index);
   Warning( "glDisableVertexAttribArrayARB not available." );
}

static void REGAL_CALL loader_glDisableVertexAttribArrayARB(GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDisableVertexAttribArrayARB, "glDisableVertexAttribArrayARB");
   if ( !driverTbl.glDisableVertexAttribArrayARB ) {
      driverTbl.glDisableVertexAttribArrayARB = missing_glDisableVertexAttribArrayARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDisableVertexAttribArrayARB == loader_glDisableVertexAttribArrayARB) {
      rCtx->dsp->emuTbl.glDisableVertexAttribArrayARB = driverTbl.glDisableVertexAttribArrayARB;
   }
   driverTbl.glDisableVertexAttribArrayARB(index);
}

static void REGAL_CALL missing_glEnableVertexAttribArrayARB(GLuint index)
{
   UNUSED_PARAMETER(index);
   Warning( "glEnableVertexAttribArrayARB not available." );
}

static void REGAL_CALL loader_glEnableVertexAttribArrayARB(GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEnableVertexAttribArrayARB, "glEnableVertexAttribArrayARB");
   if ( !driverTbl.glEnableVertexAttribArrayARB ) {
      driverTbl.glEnableVertexAttribArrayARB = missing_glEnableVertexAttribArrayARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEnableVertexAttribArrayARB == loader_glEnableVertexAttribArrayARB) {
      rCtx->dsp->emuTbl.glEnableVertexAttribArrayARB = driverTbl.glEnableVertexAttribArrayARB;
   }
   driverTbl.glEnableVertexAttribArrayARB(index);
}

static void REGAL_CALL missing_glGenProgramsARB(GLsizei n, GLuint *programs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(programs);
   Warning( "glGenProgramsARB not available." );
}

static void REGAL_CALL loader_glGenProgramsARB(GLsizei n, GLuint *programs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenProgramsARB, "glGenProgramsARB");
   if ( !driverTbl.glGenProgramsARB ) {
      driverTbl.glGenProgramsARB = missing_glGenProgramsARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenProgramsARB == loader_glGenProgramsARB) {
      rCtx->dsp->emuTbl.glGenProgramsARB = driverTbl.glGenProgramsARB;
   }
   driverTbl.glGenProgramsARB(n, programs);
}

static void REGAL_CALL missing_glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramEnvParameterdvARB not available." );
}

static void REGAL_CALL loader_glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramEnvParameterdvARB, "glGetProgramEnvParameterdvARB");
   if ( !driverTbl.glGetProgramEnvParameterdvARB ) {
      driverTbl.glGetProgramEnvParameterdvARB = missing_glGetProgramEnvParameterdvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramEnvParameterdvARB == loader_glGetProgramEnvParameterdvARB) {
      rCtx->dsp->emuTbl.glGetProgramEnvParameterdvARB = driverTbl.glGetProgramEnvParameterdvARB;
   }
   driverTbl.glGetProgramEnvParameterdvARB(target, index, params);
}

static void REGAL_CALL missing_glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramEnvParameterfvARB not available." );
}

static void REGAL_CALL loader_glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramEnvParameterfvARB, "glGetProgramEnvParameterfvARB");
   if ( !driverTbl.glGetProgramEnvParameterfvARB ) {
      driverTbl.glGetProgramEnvParameterfvARB = missing_glGetProgramEnvParameterfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramEnvParameterfvARB == loader_glGetProgramEnvParameterfvARB) {
      rCtx->dsp->emuTbl.glGetProgramEnvParameterfvARB = driverTbl.glGetProgramEnvParameterfvARB;
   }
   driverTbl.glGetProgramEnvParameterfvARB(target, index, params);
}

static void REGAL_CALL missing_glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramLocalParameterdvARB not available." );
}

static void REGAL_CALL loader_glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramLocalParameterdvARB, "glGetProgramLocalParameterdvARB");
   if ( !driverTbl.glGetProgramLocalParameterdvARB ) {
      driverTbl.glGetProgramLocalParameterdvARB = missing_glGetProgramLocalParameterdvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramLocalParameterdvARB == loader_glGetProgramLocalParameterdvARB) {
      rCtx->dsp->emuTbl.glGetProgramLocalParameterdvARB = driverTbl.glGetProgramLocalParameterdvARB;
   }
   driverTbl.glGetProgramLocalParameterdvARB(target, index, params);
}

static void REGAL_CALL missing_glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramLocalParameterfvARB not available." );
}

static void REGAL_CALL loader_glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramLocalParameterfvARB, "glGetProgramLocalParameterfvARB");
   if ( !driverTbl.glGetProgramLocalParameterfvARB ) {
      driverTbl.glGetProgramLocalParameterfvARB = missing_glGetProgramLocalParameterfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramLocalParameterfvARB == loader_glGetProgramLocalParameterfvARB) {
      rCtx->dsp->emuTbl.glGetProgramLocalParameterfvARB = driverTbl.glGetProgramLocalParameterfvARB;
   }
   driverTbl.glGetProgramLocalParameterfvARB(target, index, params);
}

static void REGAL_CALL missing_glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(string);
   Warning( "glGetProgramStringARB not available." );
}

static void REGAL_CALL loader_glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramStringARB, "glGetProgramStringARB");
   if ( !driverTbl.glGetProgramStringARB ) {
      driverTbl.glGetProgramStringARB = missing_glGetProgramStringARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramStringARB == loader_glGetProgramStringARB) {
      rCtx->dsp->emuTbl.glGetProgramStringARB = driverTbl.glGetProgramStringARB;
   }
   driverTbl.glGetProgramStringARB(target, pname, string);
}

static void REGAL_CALL missing_glGetProgramivARB(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramivARB not available." );
}

static void REGAL_CALL loader_glGetProgramivARB(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramivARB, "glGetProgramivARB");
   if ( !driverTbl.glGetProgramivARB ) {
      driverTbl.glGetProgramivARB = missing_glGetProgramivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramivARB == loader_glGetProgramivARB) {
      rCtx->dsp->emuTbl.glGetProgramivARB = driverTbl.glGetProgramivARB;
   }
   driverTbl.glGetProgramivARB(target, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(pointer);
   Warning( "glGetVertexAttribPointervARB not available." );
}

static void REGAL_CALL loader_glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribPointervARB, "glGetVertexAttribPointervARB");
   if ( !driverTbl.glGetVertexAttribPointervARB ) {
      driverTbl.glGetVertexAttribPointervARB = missing_glGetVertexAttribPointervARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribPointervARB == loader_glGetVertexAttribPointervARB) {
      rCtx->dsp->emuTbl.glGetVertexAttribPointervARB = driverTbl.glGetVertexAttribPointervARB;
   }
   driverTbl.glGetVertexAttribPointervARB(index, pname, pointer);
}

static void REGAL_CALL missing_glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribdvARB not available." );
}

static void REGAL_CALL loader_glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribdvARB, "glGetVertexAttribdvARB");
   if ( !driverTbl.glGetVertexAttribdvARB ) {
      driverTbl.glGetVertexAttribdvARB = missing_glGetVertexAttribdvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribdvARB == loader_glGetVertexAttribdvARB) {
      rCtx->dsp->emuTbl.glGetVertexAttribdvARB = driverTbl.glGetVertexAttribdvARB;
   }
   driverTbl.glGetVertexAttribdvARB(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribfvARB not available." );
}

static void REGAL_CALL loader_glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribfvARB, "glGetVertexAttribfvARB");
   if ( !driverTbl.glGetVertexAttribfvARB ) {
      driverTbl.glGetVertexAttribfvARB = missing_glGetVertexAttribfvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribfvARB == loader_glGetVertexAttribfvARB) {
      rCtx->dsp->emuTbl.glGetVertexAttribfvARB = driverTbl.glGetVertexAttribfvARB;
   }
   driverTbl.glGetVertexAttribfvARB(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribivARB not available." );
}

static void REGAL_CALL loader_glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribivARB, "glGetVertexAttribivARB");
   if ( !driverTbl.glGetVertexAttribivARB ) {
      driverTbl.glGetVertexAttribivARB = missing_glGetVertexAttribivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribivARB == loader_glGetVertexAttribivARB) {
      rCtx->dsp->emuTbl.glGetVertexAttribivARB = driverTbl.glGetVertexAttribivARB;
   }
   driverTbl.glGetVertexAttribivARB(index, pname, params);
}

static GLboolean REGAL_CALL missing_glIsProgramARB(GLuint program)
{
   UNUSED_PARAMETER(program);
   Warning( "glIsProgramARB not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsProgramARB(GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsProgramARB, "glIsProgramARB");
   if ( !driverTbl.glIsProgramARB ) {
      driverTbl.glIsProgramARB = missing_glIsProgramARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsProgramARB == loader_glIsProgramARB) {
      rCtx->dsp->emuTbl.glIsProgramARB = driverTbl.glIsProgramARB;
   }
   return driverTbl.glIsProgramARB(program);
}

static void REGAL_CALL missing_glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramEnvParameter4dARB not available." );
}

static void REGAL_CALL loader_glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramEnvParameter4dARB, "glProgramEnvParameter4dARB");
   if ( !driverTbl.glProgramEnvParameter4dARB ) {
      driverTbl.glProgramEnvParameter4dARB = missing_glProgramEnvParameter4dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramEnvParameter4dARB == loader_glProgramEnvParameter4dARB) {
      rCtx->dsp->emuTbl.glProgramEnvParameter4dARB = driverTbl.glProgramEnvParameter4dARB;
   }
   driverTbl.glProgramEnvParameter4dARB(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glProgramEnvParameter4dvARB not available." );
}

static void REGAL_CALL loader_glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramEnvParameter4dvARB, "glProgramEnvParameter4dvARB");
   if ( !driverTbl.glProgramEnvParameter4dvARB ) {
      driverTbl.glProgramEnvParameter4dvARB = missing_glProgramEnvParameter4dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramEnvParameter4dvARB == loader_glProgramEnvParameter4dvARB) {
      rCtx->dsp->emuTbl.glProgramEnvParameter4dvARB = driverTbl.glProgramEnvParameter4dvARB;
   }
   driverTbl.glProgramEnvParameter4dvARB(target, index, params);
}

static void REGAL_CALL missing_glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramEnvParameter4fARB not available." );
}

static void REGAL_CALL loader_glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramEnvParameter4fARB, "glProgramEnvParameter4fARB");
   if ( !driverTbl.glProgramEnvParameter4fARB ) {
      driverTbl.glProgramEnvParameter4fARB = missing_glProgramEnvParameter4fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramEnvParameter4fARB == loader_glProgramEnvParameter4fARB) {
      rCtx->dsp->emuTbl.glProgramEnvParameter4fARB = driverTbl.glProgramEnvParameter4fARB;
   }
   driverTbl.glProgramEnvParameter4fARB(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glProgramEnvParameter4fvARB not available." );
}

static void REGAL_CALL loader_glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramEnvParameter4fvARB, "glProgramEnvParameter4fvARB");
   if ( !driverTbl.glProgramEnvParameter4fvARB ) {
      driverTbl.glProgramEnvParameter4fvARB = missing_glProgramEnvParameter4fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramEnvParameter4fvARB == loader_glProgramEnvParameter4fvARB) {
      rCtx->dsp->emuTbl.glProgramEnvParameter4fvARB = driverTbl.glProgramEnvParameter4fvARB;
   }
   driverTbl.glProgramEnvParameter4fvARB(target, index, params);
}

static void REGAL_CALL missing_glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramLocalParameter4dARB not available." );
}

static void REGAL_CALL loader_glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramLocalParameter4dARB, "glProgramLocalParameter4dARB");
   if ( !driverTbl.glProgramLocalParameter4dARB ) {
      driverTbl.glProgramLocalParameter4dARB = missing_glProgramLocalParameter4dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramLocalParameter4dARB == loader_glProgramLocalParameter4dARB) {
      rCtx->dsp->emuTbl.glProgramLocalParameter4dARB = driverTbl.glProgramLocalParameter4dARB;
   }
   driverTbl.glProgramLocalParameter4dARB(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glProgramLocalParameter4dvARB not available." );
}

static void REGAL_CALL loader_glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramLocalParameter4dvARB, "glProgramLocalParameter4dvARB");
   if ( !driverTbl.glProgramLocalParameter4dvARB ) {
      driverTbl.glProgramLocalParameter4dvARB = missing_glProgramLocalParameter4dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramLocalParameter4dvARB == loader_glProgramLocalParameter4dvARB) {
      rCtx->dsp->emuTbl.glProgramLocalParameter4dvARB = driverTbl.glProgramLocalParameter4dvARB;
   }
   driverTbl.glProgramLocalParameter4dvARB(target, index, params);
}

static void REGAL_CALL missing_glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramLocalParameter4fARB not available." );
}

static void REGAL_CALL loader_glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramLocalParameter4fARB, "glProgramLocalParameter4fARB");
   if ( !driverTbl.glProgramLocalParameter4fARB ) {
      driverTbl.glProgramLocalParameter4fARB = missing_glProgramLocalParameter4fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramLocalParameter4fARB == loader_glProgramLocalParameter4fARB) {
      rCtx->dsp->emuTbl.glProgramLocalParameter4fARB = driverTbl.glProgramLocalParameter4fARB;
   }
   driverTbl.glProgramLocalParameter4fARB(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glProgramLocalParameter4fvARB not available." );
}

static void REGAL_CALL loader_glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramLocalParameter4fvARB, "glProgramLocalParameter4fvARB");
   if ( !driverTbl.glProgramLocalParameter4fvARB ) {
      driverTbl.glProgramLocalParameter4fvARB = missing_glProgramLocalParameter4fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramLocalParameter4fvARB == loader_glProgramLocalParameter4fvARB) {
      rCtx->dsp->emuTbl.glProgramLocalParameter4fvARB = driverTbl.glProgramLocalParameter4fvARB;
   }
   driverTbl.glProgramLocalParameter4fvARB(target, index, params);
}

static void REGAL_CALL missing_glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(string);
   Warning( "glProgramStringARB not available." );
}

static void REGAL_CALL loader_glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramStringARB, "glProgramStringARB");
   if ( !driverTbl.glProgramStringARB ) {
      driverTbl.glProgramStringARB = missing_glProgramStringARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramStringARB == loader_glProgramStringARB) {
      rCtx->dsp->emuTbl.glProgramStringARB = driverTbl.glProgramStringARB;
   }
   driverTbl.glProgramStringARB(target, format, len, string);
}

static void REGAL_CALL missing_glVertexAttrib1dARB(GLuint index, GLdouble x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttrib1dARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib1dARB(GLuint index, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1dARB, "glVertexAttrib1dARB");
   if ( !driverTbl.glVertexAttrib1dARB ) {
      driverTbl.glVertexAttrib1dARB = missing_glVertexAttrib1dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1dARB == loader_glVertexAttrib1dARB) {
      rCtx->dsp->emuTbl.glVertexAttrib1dARB = driverTbl.glVertexAttrib1dARB;
   }
   driverTbl.glVertexAttrib1dARB(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1dvARB(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib1dvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib1dvARB(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1dvARB, "glVertexAttrib1dvARB");
   if ( !driverTbl.glVertexAttrib1dvARB ) {
      driverTbl.glVertexAttrib1dvARB = missing_glVertexAttrib1dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1dvARB == loader_glVertexAttrib1dvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib1dvARB = driverTbl.glVertexAttrib1dvARB;
   }
   driverTbl.glVertexAttrib1dvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib1fARB(GLuint index, GLfloat x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttrib1fARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib1fARB(GLuint index, GLfloat x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1fARB, "glVertexAttrib1fARB");
   if ( !driverTbl.glVertexAttrib1fARB ) {
      driverTbl.glVertexAttrib1fARB = missing_glVertexAttrib1fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1fARB == loader_glVertexAttrib1fARB) {
      rCtx->dsp->emuTbl.glVertexAttrib1fARB = driverTbl.glVertexAttrib1fARB;
   }
   driverTbl.glVertexAttrib1fARB(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1fvARB(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib1fvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib1fvARB(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1fvARB, "glVertexAttrib1fvARB");
   if ( !driverTbl.glVertexAttrib1fvARB ) {
      driverTbl.glVertexAttrib1fvARB = missing_glVertexAttrib1fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1fvARB == loader_glVertexAttrib1fvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib1fvARB = driverTbl.glVertexAttrib1fvARB;
   }
   driverTbl.glVertexAttrib1fvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib1sARB(GLuint index, GLshort x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttrib1sARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib1sARB(GLuint index, GLshort x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1sARB, "glVertexAttrib1sARB");
   if ( !driverTbl.glVertexAttrib1sARB ) {
      driverTbl.glVertexAttrib1sARB = missing_glVertexAttrib1sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1sARB == loader_glVertexAttrib1sARB) {
      rCtx->dsp->emuTbl.glVertexAttrib1sARB = driverTbl.glVertexAttrib1sARB;
   }
   driverTbl.glVertexAttrib1sARB(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1svARB(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib1svARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib1svARB(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1svARB, "glVertexAttrib1svARB");
   if ( !driverTbl.glVertexAttrib1svARB ) {
      driverTbl.glVertexAttrib1svARB = missing_glVertexAttrib1svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1svARB == loader_glVertexAttrib1svARB) {
      rCtx->dsp->emuTbl.glVertexAttrib1svARB = driverTbl.glVertexAttrib1svARB;
   }
   driverTbl.glVertexAttrib1svARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttrib2dARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2dARB, "glVertexAttrib2dARB");
   if ( !driverTbl.glVertexAttrib2dARB ) {
      driverTbl.glVertexAttrib2dARB = missing_glVertexAttrib2dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2dARB == loader_glVertexAttrib2dARB) {
      rCtx->dsp->emuTbl.glVertexAttrib2dARB = driverTbl.glVertexAttrib2dARB;
   }
   driverTbl.glVertexAttrib2dARB(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2dvARB(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib2dvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib2dvARB(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2dvARB, "glVertexAttrib2dvARB");
   if ( !driverTbl.glVertexAttrib2dvARB ) {
      driverTbl.glVertexAttrib2dvARB = missing_glVertexAttrib2dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2dvARB == loader_glVertexAttrib2dvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib2dvARB = driverTbl.glVertexAttrib2dvARB;
   }
   driverTbl.glVertexAttrib2dvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttrib2fARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2fARB, "glVertexAttrib2fARB");
   if ( !driverTbl.glVertexAttrib2fARB ) {
      driverTbl.glVertexAttrib2fARB = missing_glVertexAttrib2fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2fARB == loader_glVertexAttrib2fARB) {
      rCtx->dsp->emuTbl.glVertexAttrib2fARB = driverTbl.glVertexAttrib2fARB;
   }
   driverTbl.glVertexAttrib2fARB(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2fvARB(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib2fvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib2fvARB(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2fvARB, "glVertexAttrib2fvARB");
   if ( !driverTbl.glVertexAttrib2fvARB ) {
      driverTbl.glVertexAttrib2fvARB = missing_glVertexAttrib2fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2fvARB == loader_glVertexAttrib2fvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib2fvARB = driverTbl.glVertexAttrib2fvARB;
   }
   driverTbl.glVertexAttrib2fvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttrib2sARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2sARB, "glVertexAttrib2sARB");
   if ( !driverTbl.glVertexAttrib2sARB ) {
      driverTbl.glVertexAttrib2sARB = missing_glVertexAttrib2sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2sARB == loader_glVertexAttrib2sARB) {
      rCtx->dsp->emuTbl.glVertexAttrib2sARB = driverTbl.glVertexAttrib2sARB;
   }
   driverTbl.glVertexAttrib2sARB(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2svARB(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib2svARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib2svARB(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2svARB, "glVertexAttrib2svARB");
   if ( !driverTbl.glVertexAttrib2svARB ) {
      driverTbl.glVertexAttrib2svARB = missing_glVertexAttrib2svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2svARB == loader_glVertexAttrib2svARB) {
      rCtx->dsp->emuTbl.glVertexAttrib2svARB = driverTbl.glVertexAttrib2svARB;
   }
   driverTbl.glVertexAttrib2svARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttrib3dARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3dARB, "glVertexAttrib3dARB");
   if ( !driverTbl.glVertexAttrib3dARB ) {
      driverTbl.glVertexAttrib3dARB = missing_glVertexAttrib3dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3dARB == loader_glVertexAttrib3dARB) {
      rCtx->dsp->emuTbl.glVertexAttrib3dARB = driverTbl.glVertexAttrib3dARB;
   }
   driverTbl.glVertexAttrib3dARB(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3dvARB(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib3dvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib3dvARB(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3dvARB, "glVertexAttrib3dvARB");
   if ( !driverTbl.glVertexAttrib3dvARB ) {
      driverTbl.glVertexAttrib3dvARB = missing_glVertexAttrib3dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3dvARB == loader_glVertexAttrib3dvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib3dvARB = driverTbl.glVertexAttrib3dvARB;
   }
   driverTbl.glVertexAttrib3dvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttrib3fARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3fARB, "glVertexAttrib3fARB");
   if ( !driverTbl.glVertexAttrib3fARB ) {
      driverTbl.glVertexAttrib3fARB = missing_glVertexAttrib3fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3fARB == loader_glVertexAttrib3fARB) {
      rCtx->dsp->emuTbl.glVertexAttrib3fARB = driverTbl.glVertexAttrib3fARB;
   }
   driverTbl.glVertexAttrib3fARB(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3fvARB(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib3fvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib3fvARB(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3fvARB, "glVertexAttrib3fvARB");
   if ( !driverTbl.glVertexAttrib3fvARB ) {
      driverTbl.glVertexAttrib3fvARB = missing_glVertexAttrib3fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3fvARB == loader_glVertexAttrib3fvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib3fvARB = driverTbl.glVertexAttrib3fvARB;
   }
   driverTbl.glVertexAttrib3fvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttrib3sARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3sARB, "glVertexAttrib3sARB");
   if ( !driverTbl.glVertexAttrib3sARB ) {
      driverTbl.glVertexAttrib3sARB = missing_glVertexAttrib3sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3sARB == loader_glVertexAttrib3sARB) {
      rCtx->dsp->emuTbl.glVertexAttrib3sARB = driverTbl.glVertexAttrib3sARB;
   }
   driverTbl.glVertexAttrib3sARB(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3svARB(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib3svARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib3svARB(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3svARB, "glVertexAttrib3svARB");
   if ( !driverTbl.glVertexAttrib3svARB ) {
      driverTbl.glVertexAttrib3svARB = missing_glVertexAttrib3svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3svARB == loader_glVertexAttrib3svARB) {
      rCtx->dsp->emuTbl.glVertexAttrib3svARB = driverTbl.glVertexAttrib3svARB;
   }
   driverTbl.glVertexAttrib3svARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4NbvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4NbvARB, "glVertexAttrib4NbvARB");
   if ( !driverTbl.glVertexAttrib4NbvARB ) {
      driverTbl.glVertexAttrib4NbvARB = missing_glVertexAttrib4NbvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4NbvARB == loader_glVertexAttrib4NbvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4NbvARB = driverTbl.glVertexAttrib4NbvARB;
   }
   driverTbl.glVertexAttrib4NbvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4NivARB(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4NivARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4NivARB(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4NivARB, "glVertexAttrib4NivARB");
   if ( !driverTbl.glVertexAttrib4NivARB ) {
      driverTbl.glVertexAttrib4NivARB = missing_glVertexAttrib4NivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4NivARB == loader_glVertexAttrib4NivARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4NivARB = driverTbl.glVertexAttrib4NivARB;
   }
   driverTbl.glVertexAttrib4NivARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4NsvARB(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4NsvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4NsvARB(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4NsvARB, "glVertexAttrib4NsvARB");
   if ( !driverTbl.glVertexAttrib4NsvARB ) {
      driverTbl.glVertexAttrib4NsvARB = missing_glVertexAttrib4NsvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4NsvARB == loader_glVertexAttrib4NsvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4NsvARB = driverTbl.glVertexAttrib4NsvARB;
   }
   driverTbl.glVertexAttrib4NsvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttrib4NubARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4NubARB, "glVertexAttrib4NubARB");
   if ( !driverTbl.glVertexAttrib4NubARB ) {
      driverTbl.glVertexAttrib4NubARB = missing_glVertexAttrib4NubARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4NubARB == loader_glVertexAttrib4NubARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4NubARB = driverTbl.glVertexAttrib4NubARB;
   }
   driverTbl.glVertexAttrib4NubARB(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4NubvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4NubvARB, "glVertexAttrib4NubvARB");
   if ( !driverTbl.glVertexAttrib4NubvARB ) {
      driverTbl.glVertexAttrib4NubvARB = missing_glVertexAttrib4NubvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4NubvARB == loader_glVertexAttrib4NubvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4NubvARB = driverTbl.glVertexAttrib4NubvARB;
   }
   driverTbl.glVertexAttrib4NubvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4NuivARB(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4NuivARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4NuivARB(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4NuivARB, "glVertexAttrib4NuivARB");
   if ( !driverTbl.glVertexAttrib4NuivARB ) {
      driverTbl.glVertexAttrib4NuivARB = missing_glVertexAttrib4NuivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4NuivARB == loader_glVertexAttrib4NuivARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4NuivARB = driverTbl.glVertexAttrib4NuivARB;
   }
   driverTbl.glVertexAttrib4NuivARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4NusvARB(GLuint index, const GLushort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4NusvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4NusvARB(GLuint index, const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4NusvARB, "glVertexAttrib4NusvARB");
   if ( !driverTbl.glVertexAttrib4NusvARB ) {
      driverTbl.glVertexAttrib4NusvARB = missing_glVertexAttrib4NusvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4NusvARB == loader_glVertexAttrib4NusvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4NusvARB = driverTbl.glVertexAttrib4NusvARB;
   }
   driverTbl.glVertexAttrib4NusvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4bvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4bvARB, "glVertexAttrib4bvARB");
   if ( !driverTbl.glVertexAttrib4bvARB ) {
      driverTbl.glVertexAttrib4bvARB = missing_glVertexAttrib4bvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4bvARB == loader_glVertexAttrib4bvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4bvARB = driverTbl.glVertexAttrib4bvARB;
   }
   driverTbl.glVertexAttrib4bvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttrib4dARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4dARB, "glVertexAttrib4dARB");
   if ( !driverTbl.glVertexAttrib4dARB ) {
      driverTbl.glVertexAttrib4dARB = missing_glVertexAttrib4dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4dARB == loader_glVertexAttrib4dARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4dARB = driverTbl.glVertexAttrib4dARB;
   }
   driverTbl.glVertexAttrib4dARB(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4dvARB(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4dvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4dvARB(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4dvARB, "glVertexAttrib4dvARB");
   if ( !driverTbl.glVertexAttrib4dvARB ) {
      driverTbl.glVertexAttrib4dvARB = missing_glVertexAttrib4dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4dvARB == loader_glVertexAttrib4dvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4dvARB = driverTbl.glVertexAttrib4dvARB;
   }
   driverTbl.glVertexAttrib4dvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttrib4fARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4fARB, "glVertexAttrib4fARB");
   if ( !driverTbl.glVertexAttrib4fARB ) {
      driverTbl.glVertexAttrib4fARB = missing_glVertexAttrib4fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4fARB == loader_glVertexAttrib4fARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4fARB = driverTbl.glVertexAttrib4fARB;
   }
   driverTbl.glVertexAttrib4fARB(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4fvARB(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4fvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4fvARB(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4fvARB, "glVertexAttrib4fvARB");
   if ( !driverTbl.glVertexAttrib4fvARB ) {
      driverTbl.glVertexAttrib4fvARB = missing_glVertexAttrib4fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4fvARB == loader_glVertexAttrib4fvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4fvARB = driverTbl.glVertexAttrib4fvARB;
   }
   driverTbl.glVertexAttrib4fvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4ivARB(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4ivARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4ivARB(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4ivARB, "glVertexAttrib4ivARB");
   if ( !driverTbl.glVertexAttrib4ivARB ) {
      driverTbl.glVertexAttrib4ivARB = missing_glVertexAttrib4ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4ivARB == loader_glVertexAttrib4ivARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4ivARB = driverTbl.glVertexAttrib4ivARB;
   }
   driverTbl.glVertexAttrib4ivARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttrib4sARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4sARB, "glVertexAttrib4sARB");
   if ( !driverTbl.glVertexAttrib4sARB ) {
      driverTbl.glVertexAttrib4sARB = missing_glVertexAttrib4sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4sARB == loader_glVertexAttrib4sARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4sARB = driverTbl.glVertexAttrib4sARB;
   }
   driverTbl.glVertexAttrib4sARB(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4svARB(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4svARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4svARB(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4svARB, "glVertexAttrib4svARB");
   if ( !driverTbl.glVertexAttrib4svARB ) {
      driverTbl.glVertexAttrib4svARB = missing_glVertexAttrib4svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4svARB == loader_glVertexAttrib4svARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4svARB = driverTbl.glVertexAttrib4svARB;
   }
   driverTbl.glVertexAttrib4svARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4ubvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4ubvARB, "glVertexAttrib4ubvARB");
   if ( !driverTbl.glVertexAttrib4ubvARB ) {
      driverTbl.glVertexAttrib4ubvARB = missing_glVertexAttrib4ubvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4ubvARB == loader_glVertexAttrib4ubvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4ubvARB = driverTbl.glVertexAttrib4ubvARB;
   }
   driverTbl.glVertexAttrib4ubvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4uivARB(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4uivARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4uivARB(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4uivARB, "glVertexAttrib4uivARB");
   if ( !driverTbl.glVertexAttrib4uivARB ) {
      driverTbl.glVertexAttrib4uivARB = missing_glVertexAttrib4uivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4uivARB == loader_glVertexAttrib4uivARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4uivARB = driverTbl.glVertexAttrib4uivARB;
   }
   driverTbl.glVertexAttrib4uivARB(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4usvARB(GLuint index, const GLushort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4usvARB not available." );
}

static void REGAL_CALL loader_glVertexAttrib4usvARB(GLuint index, const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4usvARB, "glVertexAttrib4usvARB");
   if ( !driverTbl.glVertexAttrib4usvARB ) {
      driverTbl.glVertexAttrib4usvARB = missing_glVertexAttrib4usvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4usvARB == loader_glVertexAttrib4usvARB) {
      rCtx->dsp->emuTbl.glVertexAttrib4usvARB = driverTbl.glVertexAttrib4usvARB;
   }
   driverTbl.glVertexAttrib4usvARB(index, v);
}

static void REGAL_CALL missing_glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glVertexAttribPointerARB not available." );
}

static void REGAL_CALL loader_glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribPointerARB, "glVertexAttribPointerARB");
   if ( !driverTbl.glVertexAttribPointerARB ) {
      driverTbl.glVertexAttribPointerARB = missing_glVertexAttribPointerARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribPointerARB == loader_glVertexAttribPointerARB) {
      rCtx->dsp->emuTbl.glVertexAttribPointerARB = driverTbl.glVertexAttribPointerARB;
   }
   driverTbl.glVertexAttribPointerARB(index, size, type, normalized, stride, pointer);
}

// GL_ARB_vertex_shader

static void REGAL_CALL missing_glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name)
{
   UNUSED_PARAMETER(programObj);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(name);
   Warning( "glBindAttribLocationARB not available." );
}

static void REGAL_CALL loader_glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindAttribLocationARB, "glBindAttribLocationARB");
   if ( !driverTbl.glBindAttribLocationARB ) {
      driverTbl.glBindAttribLocationARB = missing_glBindAttribLocationARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindAttribLocationARB == loader_glBindAttribLocationARB) {
      rCtx->dsp->emuTbl.glBindAttribLocationARB = driverTbl.glBindAttribLocationARB;
   }
   driverTbl.glBindAttribLocationARB(programObj, index, name);
}

static void REGAL_CALL missing_glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
{
   UNUSED_PARAMETER(programObj);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(maxLength);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(name);
   Warning( "glGetActiveAttribARB not available." );
}

static void REGAL_CALL loader_glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetActiveAttribARB, "glGetActiveAttribARB");
   if ( !driverTbl.glGetActiveAttribARB ) {
      driverTbl.glGetActiveAttribARB = missing_glGetActiveAttribARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetActiveAttribARB == loader_glGetActiveAttribARB) {
      rCtx->dsp->emuTbl.glGetActiveAttribARB = driverTbl.glGetActiveAttribARB;
   }
   driverTbl.glGetActiveAttribARB(programObj, index, maxLength, length, size, type, name);
}

static GLint REGAL_CALL missing_glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
   UNUSED_PARAMETER(programObj);
   UNUSED_PARAMETER(name);
   Warning( "glGetAttribLocationARB not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetAttribLocationARB, "glGetAttribLocationARB");
   if ( !driverTbl.glGetAttribLocationARB ) {
      driverTbl.glGetAttribLocationARB = missing_glGetAttribLocationARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetAttribLocationARB == loader_glGetAttribLocationARB) {
      rCtx->dsp->emuTbl.glGetAttribLocationARB = driverTbl.glGetAttribLocationARB;
   }
   return driverTbl.glGetAttribLocationARB(programObj, name);
}

// GL_ARB_vertex_type_2_10_10_10_rev

static void REGAL_CALL missing_glColorP3ui(GLenum type, GLuint color)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(color);
   Warning( "glColorP3ui not available." );
}

static void REGAL_CALL loader_glColorP3ui(GLenum type, GLuint color)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorP3ui, "glColorP3ui");
   if ( !driverTbl.glColorP3ui ) {
      driverTbl.glColorP3ui = missing_glColorP3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorP3ui == loader_glColorP3ui) {
      rCtx->dsp->emuTbl.glColorP3ui = driverTbl.glColorP3ui;
   }
   driverTbl.glColorP3ui(type, color);
}

static void REGAL_CALL missing_glColorP3uiv(GLenum type, const GLuint *color)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(color);
   Warning( "glColorP3uiv not available." );
}

static void REGAL_CALL loader_glColorP3uiv(GLenum type, const GLuint *color)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorP3uiv, "glColorP3uiv");
   if ( !driverTbl.glColorP3uiv ) {
      driverTbl.glColorP3uiv = missing_glColorP3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorP3uiv == loader_glColorP3uiv) {
      rCtx->dsp->emuTbl.glColorP3uiv = driverTbl.glColorP3uiv;
   }
   driverTbl.glColorP3uiv(type, color);
}

static void REGAL_CALL missing_glColorP4ui(GLenum type, GLuint color)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(color);
   Warning( "glColorP4ui not available." );
}

static void REGAL_CALL loader_glColorP4ui(GLenum type, GLuint color)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorP4ui, "glColorP4ui");
   if ( !driverTbl.glColorP4ui ) {
      driverTbl.glColorP4ui = missing_glColorP4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorP4ui == loader_glColorP4ui) {
      rCtx->dsp->emuTbl.glColorP4ui = driverTbl.glColorP4ui;
   }
   driverTbl.glColorP4ui(type, color);
}

static void REGAL_CALL missing_glColorP4uiv(GLenum type, const GLuint *color)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(color);
   Warning( "glColorP4uiv not available." );
}

static void REGAL_CALL loader_glColorP4uiv(GLenum type, const GLuint *color)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorP4uiv, "glColorP4uiv");
   if ( !driverTbl.glColorP4uiv ) {
      driverTbl.glColorP4uiv = missing_glColorP4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorP4uiv == loader_glColorP4uiv) {
      rCtx->dsp->emuTbl.glColorP4uiv = driverTbl.glColorP4uiv;
   }
   driverTbl.glColorP4uiv(type, color);
}

static void REGAL_CALL missing_glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glMultiTexCoordP1ui not available." );
}

static void REGAL_CALL loader_glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoordP1ui, "glMultiTexCoordP1ui");
   if ( !driverTbl.glMultiTexCoordP1ui ) {
      driverTbl.glMultiTexCoordP1ui = missing_glMultiTexCoordP1ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoordP1ui == loader_glMultiTexCoordP1ui) {
      rCtx->dsp->emuTbl.glMultiTexCoordP1ui = driverTbl.glMultiTexCoordP1ui;
   }
   driverTbl.glMultiTexCoordP1ui(texture, type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glMultiTexCoordP1uiv not available." );
}

static void REGAL_CALL loader_glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoordP1uiv, "glMultiTexCoordP1uiv");
   if ( !driverTbl.glMultiTexCoordP1uiv ) {
      driverTbl.glMultiTexCoordP1uiv = missing_glMultiTexCoordP1uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoordP1uiv == loader_glMultiTexCoordP1uiv) {
      rCtx->dsp->emuTbl.glMultiTexCoordP1uiv = driverTbl.glMultiTexCoordP1uiv;
   }
   driverTbl.glMultiTexCoordP1uiv(texture, type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glMultiTexCoordP2ui not available." );
}

static void REGAL_CALL loader_glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoordP2ui, "glMultiTexCoordP2ui");
   if ( !driverTbl.glMultiTexCoordP2ui ) {
      driverTbl.glMultiTexCoordP2ui = missing_glMultiTexCoordP2ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoordP2ui == loader_glMultiTexCoordP2ui) {
      rCtx->dsp->emuTbl.glMultiTexCoordP2ui = driverTbl.glMultiTexCoordP2ui;
   }
   driverTbl.glMultiTexCoordP2ui(texture, type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glMultiTexCoordP2uiv not available." );
}

static void REGAL_CALL loader_glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoordP2uiv, "glMultiTexCoordP2uiv");
   if ( !driverTbl.glMultiTexCoordP2uiv ) {
      driverTbl.glMultiTexCoordP2uiv = missing_glMultiTexCoordP2uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoordP2uiv == loader_glMultiTexCoordP2uiv) {
      rCtx->dsp->emuTbl.glMultiTexCoordP2uiv = driverTbl.glMultiTexCoordP2uiv;
   }
   driverTbl.glMultiTexCoordP2uiv(texture, type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glMultiTexCoordP3ui not available." );
}

static void REGAL_CALL loader_glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoordP3ui, "glMultiTexCoordP3ui");
   if ( !driverTbl.glMultiTexCoordP3ui ) {
      driverTbl.glMultiTexCoordP3ui = missing_glMultiTexCoordP3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoordP3ui == loader_glMultiTexCoordP3ui) {
      rCtx->dsp->emuTbl.glMultiTexCoordP3ui = driverTbl.glMultiTexCoordP3ui;
   }
   driverTbl.glMultiTexCoordP3ui(texture, type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glMultiTexCoordP3uiv not available." );
}

static void REGAL_CALL loader_glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoordP3uiv, "glMultiTexCoordP3uiv");
   if ( !driverTbl.glMultiTexCoordP3uiv ) {
      driverTbl.glMultiTexCoordP3uiv = missing_glMultiTexCoordP3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoordP3uiv == loader_glMultiTexCoordP3uiv) {
      rCtx->dsp->emuTbl.glMultiTexCoordP3uiv = driverTbl.glMultiTexCoordP3uiv;
   }
   driverTbl.glMultiTexCoordP3uiv(texture, type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glMultiTexCoordP4ui not available." );
}

static void REGAL_CALL loader_glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoordP4ui, "glMultiTexCoordP4ui");
   if ( !driverTbl.glMultiTexCoordP4ui ) {
      driverTbl.glMultiTexCoordP4ui = missing_glMultiTexCoordP4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoordP4ui == loader_glMultiTexCoordP4ui) {
      rCtx->dsp->emuTbl.glMultiTexCoordP4ui = driverTbl.glMultiTexCoordP4ui;
   }
   driverTbl.glMultiTexCoordP4ui(texture, type, coords);
}

static void REGAL_CALL missing_glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glMultiTexCoordP4uiv not available." );
}

static void REGAL_CALL loader_glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoordP4uiv, "glMultiTexCoordP4uiv");
   if ( !driverTbl.glMultiTexCoordP4uiv ) {
      driverTbl.glMultiTexCoordP4uiv = missing_glMultiTexCoordP4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoordP4uiv == loader_glMultiTexCoordP4uiv) {
      rCtx->dsp->emuTbl.glMultiTexCoordP4uiv = driverTbl.glMultiTexCoordP4uiv;
   }
   driverTbl.glMultiTexCoordP4uiv(texture, type, coords);
}

static void REGAL_CALL missing_glNormalP3ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glNormalP3ui not available." );
}

static void REGAL_CALL loader_glNormalP3ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalP3ui, "glNormalP3ui");
   if ( !driverTbl.glNormalP3ui ) {
      driverTbl.glNormalP3ui = missing_glNormalP3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalP3ui == loader_glNormalP3ui) {
      rCtx->dsp->emuTbl.glNormalP3ui = driverTbl.glNormalP3ui;
   }
   driverTbl.glNormalP3ui(type, coords);
}

static void REGAL_CALL missing_glNormalP3uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glNormalP3uiv not available." );
}

static void REGAL_CALL loader_glNormalP3uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalP3uiv, "glNormalP3uiv");
   if ( !driverTbl.glNormalP3uiv ) {
      driverTbl.glNormalP3uiv = missing_glNormalP3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalP3uiv == loader_glNormalP3uiv) {
      rCtx->dsp->emuTbl.glNormalP3uiv = driverTbl.glNormalP3uiv;
   }
   driverTbl.glNormalP3uiv(type, coords);
}

static void REGAL_CALL missing_glSecondaryColorP3ui(GLenum type, GLuint color)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(color);
   Warning( "glSecondaryColorP3ui not available." );
}

static void REGAL_CALL loader_glSecondaryColorP3ui(GLenum type, GLuint color)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColorP3ui, "glSecondaryColorP3ui");
   if ( !driverTbl.glSecondaryColorP3ui ) {
      driverTbl.glSecondaryColorP3ui = missing_glSecondaryColorP3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColorP3ui == loader_glSecondaryColorP3ui) {
      rCtx->dsp->emuTbl.glSecondaryColorP3ui = driverTbl.glSecondaryColorP3ui;
   }
   driverTbl.glSecondaryColorP3ui(type, color);
}

static void REGAL_CALL missing_glSecondaryColorP3uiv(GLenum type, const GLuint *color)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(color);
   Warning( "glSecondaryColorP3uiv not available." );
}

static void REGAL_CALL loader_glSecondaryColorP3uiv(GLenum type, const GLuint *color)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColorP3uiv, "glSecondaryColorP3uiv");
   if ( !driverTbl.glSecondaryColorP3uiv ) {
      driverTbl.glSecondaryColorP3uiv = missing_glSecondaryColorP3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColorP3uiv == loader_glSecondaryColorP3uiv) {
      rCtx->dsp->emuTbl.glSecondaryColorP3uiv = driverTbl.glSecondaryColorP3uiv;
   }
   driverTbl.glSecondaryColorP3uiv(type, color);
}

static void REGAL_CALL missing_glTexCoordP1ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glTexCoordP1ui not available." );
}

static void REGAL_CALL loader_glTexCoordP1ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoordP1ui, "glTexCoordP1ui");
   if ( !driverTbl.glTexCoordP1ui ) {
      driverTbl.glTexCoordP1ui = missing_glTexCoordP1ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoordP1ui == loader_glTexCoordP1ui) {
      rCtx->dsp->emuTbl.glTexCoordP1ui = driverTbl.glTexCoordP1ui;
   }
   driverTbl.glTexCoordP1ui(type, coords);
}

static void REGAL_CALL missing_glTexCoordP1uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glTexCoordP1uiv not available." );
}

static void REGAL_CALL loader_glTexCoordP1uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoordP1uiv, "glTexCoordP1uiv");
   if ( !driverTbl.glTexCoordP1uiv ) {
      driverTbl.glTexCoordP1uiv = missing_glTexCoordP1uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoordP1uiv == loader_glTexCoordP1uiv) {
      rCtx->dsp->emuTbl.glTexCoordP1uiv = driverTbl.glTexCoordP1uiv;
   }
   driverTbl.glTexCoordP1uiv(type, coords);
}

static void REGAL_CALL missing_glTexCoordP2ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glTexCoordP2ui not available." );
}

static void REGAL_CALL loader_glTexCoordP2ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoordP2ui, "glTexCoordP2ui");
   if ( !driverTbl.glTexCoordP2ui ) {
      driverTbl.glTexCoordP2ui = missing_glTexCoordP2ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoordP2ui == loader_glTexCoordP2ui) {
      rCtx->dsp->emuTbl.glTexCoordP2ui = driverTbl.glTexCoordP2ui;
   }
   driverTbl.glTexCoordP2ui(type, coords);
}

static void REGAL_CALL missing_glTexCoordP2uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glTexCoordP2uiv not available." );
}

static void REGAL_CALL loader_glTexCoordP2uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoordP2uiv, "glTexCoordP2uiv");
   if ( !driverTbl.glTexCoordP2uiv ) {
      driverTbl.glTexCoordP2uiv = missing_glTexCoordP2uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoordP2uiv == loader_glTexCoordP2uiv) {
      rCtx->dsp->emuTbl.glTexCoordP2uiv = driverTbl.glTexCoordP2uiv;
   }
   driverTbl.glTexCoordP2uiv(type, coords);
}

static void REGAL_CALL missing_glTexCoordP3ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glTexCoordP3ui not available." );
}

static void REGAL_CALL loader_glTexCoordP3ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoordP3ui, "glTexCoordP3ui");
   if ( !driverTbl.glTexCoordP3ui ) {
      driverTbl.glTexCoordP3ui = missing_glTexCoordP3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoordP3ui == loader_glTexCoordP3ui) {
      rCtx->dsp->emuTbl.glTexCoordP3ui = driverTbl.glTexCoordP3ui;
   }
   driverTbl.glTexCoordP3ui(type, coords);
}

static void REGAL_CALL missing_glTexCoordP3uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glTexCoordP3uiv not available." );
}

static void REGAL_CALL loader_glTexCoordP3uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoordP3uiv, "glTexCoordP3uiv");
   if ( !driverTbl.glTexCoordP3uiv ) {
      driverTbl.glTexCoordP3uiv = missing_glTexCoordP3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoordP3uiv == loader_glTexCoordP3uiv) {
      rCtx->dsp->emuTbl.glTexCoordP3uiv = driverTbl.glTexCoordP3uiv;
   }
   driverTbl.glTexCoordP3uiv(type, coords);
}

static void REGAL_CALL missing_glTexCoordP4ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glTexCoordP4ui not available." );
}

static void REGAL_CALL loader_glTexCoordP4ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoordP4ui, "glTexCoordP4ui");
   if ( !driverTbl.glTexCoordP4ui ) {
      driverTbl.glTexCoordP4ui = missing_glTexCoordP4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoordP4ui == loader_glTexCoordP4ui) {
      rCtx->dsp->emuTbl.glTexCoordP4ui = driverTbl.glTexCoordP4ui;
   }
   driverTbl.glTexCoordP4ui(type, coords);
}

static void REGAL_CALL missing_glTexCoordP4uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glTexCoordP4uiv not available." );
}

static void REGAL_CALL loader_glTexCoordP4uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoordP4uiv, "glTexCoordP4uiv");
   if ( !driverTbl.glTexCoordP4uiv ) {
      driverTbl.glTexCoordP4uiv = missing_glTexCoordP4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoordP4uiv == loader_glTexCoordP4uiv) {
      rCtx->dsp->emuTbl.glTexCoordP4uiv = driverTbl.glTexCoordP4uiv;
   }
   driverTbl.glTexCoordP4uiv(type, coords);
}

static void REGAL_CALL missing_glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "glVertexAttribP1ui not available." );
}

static void REGAL_CALL loader_glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribP1ui, "glVertexAttribP1ui");
   if ( !driverTbl.glVertexAttribP1ui ) {
      driverTbl.glVertexAttribP1ui = missing_glVertexAttribP1ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribP1ui == loader_glVertexAttribP1ui) {
      rCtx->dsp->emuTbl.glVertexAttribP1ui = driverTbl.glVertexAttribP1ui;
   }
   driverTbl.glVertexAttribP1ui(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "glVertexAttribP1uiv not available." );
}

static void REGAL_CALL loader_glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribP1uiv, "glVertexAttribP1uiv");
   if ( !driverTbl.glVertexAttribP1uiv ) {
      driverTbl.glVertexAttribP1uiv = missing_glVertexAttribP1uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribP1uiv == loader_glVertexAttribP1uiv) {
      rCtx->dsp->emuTbl.glVertexAttribP1uiv = driverTbl.glVertexAttribP1uiv;
   }
   driverTbl.glVertexAttribP1uiv(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "glVertexAttribP2ui not available." );
}

static void REGAL_CALL loader_glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribP2ui, "glVertexAttribP2ui");
   if ( !driverTbl.glVertexAttribP2ui ) {
      driverTbl.glVertexAttribP2ui = missing_glVertexAttribP2ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribP2ui == loader_glVertexAttribP2ui) {
      rCtx->dsp->emuTbl.glVertexAttribP2ui = driverTbl.glVertexAttribP2ui;
   }
   driverTbl.glVertexAttribP2ui(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "glVertexAttribP2uiv not available." );
}

static void REGAL_CALL loader_glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribP2uiv, "glVertexAttribP2uiv");
   if ( !driverTbl.glVertexAttribP2uiv ) {
      driverTbl.glVertexAttribP2uiv = missing_glVertexAttribP2uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribP2uiv == loader_glVertexAttribP2uiv) {
      rCtx->dsp->emuTbl.glVertexAttribP2uiv = driverTbl.glVertexAttribP2uiv;
   }
   driverTbl.glVertexAttribP2uiv(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "glVertexAttribP3ui not available." );
}

static void REGAL_CALL loader_glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribP3ui, "glVertexAttribP3ui");
   if ( !driverTbl.glVertexAttribP3ui ) {
      driverTbl.glVertexAttribP3ui = missing_glVertexAttribP3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribP3ui == loader_glVertexAttribP3ui) {
      rCtx->dsp->emuTbl.glVertexAttribP3ui = driverTbl.glVertexAttribP3ui;
   }
   driverTbl.glVertexAttribP3ui(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "glVertexAttribP3uiv not available." );
}

static void REGAL_CALL loader_glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribP3uiv, "glVertexAttribP3uiv");
   if ( !driverTbl.glVertexAttribP3uiv ) {
      driverTbl.glVertexAttribP3uiv = missing_glVertexAttribP3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribP3uiv == loader_glVertexAttribP3uiv) {
      rCtx->dsp->emuTbl.glVertexAttribP3uiv = driverTbl.glVertexAttribP3uiv;
   }
   driverTbl.glVertexAttribP3uiv(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "glVertexAttribP4ui not available." );
}

static void REGAL_CALL loader_glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribP4ui, "glVertexAttribP4ui");
   if ( !driverTbl.glVertexAttribP4ui ) {
      driverTbl.glVertexAttribP4ui = missing_glVertexAttribP4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribP4ui == loader_glVertexAttribP4ui) {
      rCtx->dsp->emuTbl.glVertexAttribP4ui = driverTbl.glVertexAttribP4ui;
   }
   driverTbl.glVertexAttribP4ui(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(value);
   Warning( "glVertexAttribP4uiv not available." );
}

static void REGAL_CALL loader_glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribP4uiv, "glVertexAttribP4uiv");
   if ( !driverTbl.glVertexAttribP4uiv ) {
      driverTbl.glVertexAttribP4uiv = missing_glVertexAttribP4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribP4uiv == loader_glVertexAttribP4uiv) {
      rCtx->dsp->emuTbl.glVertexAttribP4uiv = driverTbl.glVertexAttribP4uiv;
   }
   driverTbl.glVertexAttribP4uiv(index, type, normalized, value);
}

static void REGAL_CALL missing_glVertexP2ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexP2ui not available." );
}

static void REGAL_CALL loader_glVertexP2ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexP2ui, "glVertexP2ui");
   if ( !driverTbl.glVertexP2ui ) {
      driverTbl.glVertexP2ui = missing_glVertexP2ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexP2ui == loader_glVertexP2ui) {
      rCtx->dsp->emuTbl.glVertexP2ui = driverTbl.glVertexP2ui;
   }
   driverTbl.glVertexP2ui(type, coords);
}

static void REGAL_CALL missing_glVertexP2uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexP2uiv not available." );
}

static void REGAL_CALL loader_glVertexP2uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexP2uiv, "glVertexP2uiv");
   if ( !driverTbl.glVertexP2uiv ) {
      driverTbl.glVertexP2uiv = missing_glVertexP2uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexP2uiv == loader_glVertexP2uiv) {
      rCtx->dsp->emuTbl.glVertexP2uiv = driverTbl.glVertexP2uiv;
   }
   driverTbl.glVertexP2uiv(type, coords);
}

static void REGAL_CALL missing_glVertexP3ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexP3ui not available." );
}

static void REGAL_CALL loader_glVertexP3ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexP3ui, "glVertexP3ui");
   if ( !driverTbl.glVertexP3ui ) {
      driverTbl.glVertexP3ui = missing_glVertexP3ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexP3ui == loader_glVertexP3ui) {
      rCtx->dsp->emuTbl.glVertexP3ui = driverTbl.glVertexP3ui;
   }
   driverTbl.glVertexP3ui(type, coords);
}

static void REGAL_CALL missing_glVertexP3uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexP3uiv not available." );
}

static void REGAL_CALL loader_glVertexP3uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexP3uiv, "glVertexP3uiv");
   if ( !driverTbl.glVertexP3uiv ) {
      driverTbl.glVertexP3uiv = missing_glVertexP3uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexP3uiv == loader_glVertexP3uiv) {
      rCtx->dsp->emuTbl.glVertexP3uiv = driverTbl.glVertexP3uiv;
   }
   driverTbl.glVertexP3uiv(type, coords);
}

static void REGAL_CALL missing_glVertexP4ui(GLenum type, GLuint coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexP4ui not available." );
}

static void REGAL_CALL loader_glVertexP4ui(GLenum type, GLuint coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexP4ui, "glVertexP4ui");
   if ( !driverTbl.glVertexP4ui ) {
      driverTbl.glVertexP4ui = missing_glVertexP4ui;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexP4ui == loader_glVertexP4ui) {
      rCtx->dsp->emuTbl.glVertexP4ui = driverTbl.glVertexP4ui;
   }
   driverTbl.glVertexP4ui(type, coords);
}

static void REGAL_CALL missing_glVertexP4uiv(GLenum type, const GLuint *coords)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexP4uiv not available." );
}

static void REGAL_CALL loader_glVertexP4uiv(GLenum type, const GLuint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexP4uiv, "glVertexP4uiv");
   if ( !driverTbl.glVertexP4uiv ) {
      driverTbl.glVertexP4uiv = missing_glVertexP4uiv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexP4uiv == loader_glVertexP4uiv) {
      rCtx->dsp->emuTbl.glVertexP4uiv = driverTbl.glVertexP4uiv;
   }
   driverTbl.glVertexP4uiv(type, coords);
}

// GL_ARB_viewport_array

static void REGAL_CALL missing_glDepthRangeArrayv(GLuint first, GLsizei count, const GLclampd *v)
{
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "glDepthRangeArrayv not available." );
}

static void REGAL_CALL loader_glDepthRangeArrayv(GLuint first, GLsizei count, const GLclampd *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDepthRangeArrayv, "glDepthRangeArrayv");
   if ( !driverTbl.glDepthRangeArrayv ) {
      driverTbl.glDepthRangeArrayv = missing_glDepthRangeArrayv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDepthRangeArrayv == loader_glDepthRangeArrayv) {
      rCtx->dsp->emuTbl.glDepthRangeArrayv = driverTbl.glDepthRangeArrayv;
   }
   driverTbl.glDepthRangeArrayv(first, count, v);
}

static void REGAL_CALL missing_glDepthRangeIndexed(GLuint index, GLclampd n, GLclampd f)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(f);
   Warning( "glDepthRangeIndexed not available." );
}

static void REGAL_CALL loader_glDepthRangeIndexed(GLuint index, GLclampd n, GLclampd f)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDepthRangeIndexed, "glDepthRangeIndexed");
   if ( !driverTbl.glDepthRangeIndexed ) {
      driverTbl.glDepthRangeIndexed = missing_glDepthRangeIndexed;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDepthRangeIndexed == loader_glDepthRangeIndexed) {
      rCtx->dsp->emuTbl.glDepthRangeIndexed = driverTbl.glDepthRangeIndexed;
   }
   driverTbl.glDepthRangeIndexed(index, n, f);
}

static void REGAL_CALL missing_glGetDoublei_v(GLenum target, GLuint index, GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glGetDoublei_v not available." );
}

static void REGAL_CALL loader_glGetDoublei_v(GLenum target, GLuint index, GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetDoublei_v, "glGetDoublei_v");
   if ( !driverTbl.glGetDoublei_v ) {
      driverTbl.glGetDoublei_v = missing_glGetDoublei_v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetDoublei_v == loader_glGetDoublei_v) {
      rCtx->dsp->emuTbl.glGetDoublei_v = driverTbl.glGetDoublei_v;
   }
   driverTbl.glGetDoublei_v(target, index, v);
}

static void REGAL_CALL missing_glGetFloati_v(GLenum target, GLuint index, GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glGetFloati_v not available." );
}

static void REGAL_CALL loader_glGetFloati_v(GLenum target, GLuint index, GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFloati_v, "glGetFloati_v");
   if ( !driverTbl.glGetFloati_v ) {
      driverTbl.glGetFloati_v = missing_glGetFloati_v;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFloati_v == loader_glGetFloati_v) {
      rCtx->dsp->emuTbl.glGetFloati_v = driverTbl.glGetFloati_v;
   }
   driverTbl.glGetFloati_v(target, index, v);
}

static void REGAL_CALL missing_glScissorArrayv(GLuint first, GLsizei count, const GLint *v)
{
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "glScissorArrayv not available." );
}

static void REGAL_CALL loader_glScissorArrayv(GLuint first, GLsizei count, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glScissorArrayv, "glScissorArrayv");
   if ( !driverTbl.glScissorArrayv ) {
      driverTbl.glScissorArrayv = missing_glScissorArrayv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glScissorArrayv == loader_glScissorArrayv) {
      rCtx->dsp->emuTbl.glScissorArrayv = driverTbl.glScissorArrayv;
   }
   driverTbl.glScissorArrayv(first, count, v);
}

static void REGAL_CALL missing_glScissorIndexed(GLuint index, GLint left, GLint bottom, GLint width, GLint height)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(left);
   UNUSED_PARAMETER(bottom);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glScissorIndexed not available." );
}

static void REGAL_CALL loader_glScissorIndexed(GLuint index, GLint left, GLint bottom, GLint width, GLint height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glScissorIndexed, "glScissorIndexed");
   if ( !driverTbl.glScissorIndexed ) {
      driverTbl.glScissorIndexed = missing_glScissorIndexed;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glScissorIndexed == loader_glScissorIndexed) {
      rCtx->dsp->emuTbl.glScissorIndexed = driverTbl.glScissorIndexed;
   }
   driverTbl.glScissorIndexed(index, left, bottom, width, height);
}

static void REGAL_CALL missing_glScissorIndexedv(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glScissorIndexedv not available." );
}

static void REGAL_CALL loader_glScissorIndexedv(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glScissorIndexedv, "glScissorIndexedv");
   if ( !driverTbl.glScissorIndexedv ) {
      driverTbl.glScissorIndexedv = missing_glScissorIndexedv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glScissorIndexedv == loader_glScissorIndexedv) {
      rCtx->dsp->emuTbl.glScissorIndexedv = driverTbl.glScissorIndexedv;
   }
   driverTbl.glScissorIndexedv(index, v);
}

static void REGAL_CALL missing_glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v)
{
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "glViewportArrayv not available." );
}

static void REGAL_CALL loader_glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glViewportArrayv, "glViewportArrayv");
   if ( !driverTbl.glViewportArrayv ) {
      driverTbl.glViewportArrayv = missing_glViewportArrayv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glViewportArrayv == loader_glViewportArrayv) {
      rCtx->dsp->emuTbl.glViewportArrayv = driverTbl.glViewportArrayv;
   }
   driverTbl.glViewportArrayv(first, count, v);
}

static void REGAL_CALL missing_glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(w);
   UNUSED_PARAMETER(h);
   Warning( "glViewportIndexedf not available." );
}

static void REGAL_CALL loader_glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glViewportIndexedf, "glViewportIndexedf");
   if ( !driverTbl.glViewportIndexedf ) {
      driverTbl.glViewportIndexedf = missing_glViewportIndexedf;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glViewportIndexedf == loader_glViewportIndexedf) {
      rCtx->dsp->emuTbl.glViewportIndexedf = driverTbl.glViewportIndexedf;
   }
   driverTbl.glViewportIndexedf(index, x, y, w, h);
}

static void REGAL_CALL missing_glViewportIndexedfv(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glViewportIndexedfv not available." );
}

static void REGAL_CALL loader_glViewportIndexedfv(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glViewportIndexedfv, "glViewportIndexedfv");
   if ( !driverTbl.glViewportIndexedfv ) {
      driverTbl.glViewportIndexedfv = missing_glViewportIndexedfv;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glViewportIndexedfv == loader_glViewportIndexedfv) {
      rCtx->dsp->emuTbl.glViewportIndexedfv = driverTbl.glViewportIndexedfv;
   }
   driverTbl.glViewportIndexedfv(index, v);
}

// GL_ARB_window_pos

static void REGAL_CALL missing_glWindowPos2dARB(GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glWindowPos2dARB not available." );
}

static void REGAL_CALL loader_glWindowPos2dARB(GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2dARB, "glWindowPos2dARB");
   if ( !driverTbl.glWindowPos2dARB ) {
      driverTbl.glWindowPos2dARB = missing_glWindowPos2dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2dARB == loader_glWindowPos2dARB) {
      rCtx->dsp->emuTbl.glWindowPos2dARB = driverTbl.glWindowPos2dARB;
   }
   driverTbl.glWindowPos2dARB(x, y);
}

static void REGAL_CALL missing_glWindowPos2dvARB(const GLdouble *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos2dvARB not available." );
}

static void REGAL_CALL loader_glWindowPos2dvARB(const GLdouble *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2dvARB, "glWindowPos2dvARB");
   if ( !driverTbl.glWindowPos2dvARB ) {
      driverTbl.glWindowPos2dvARB = missing_glWindowPos2dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2dvARB == loader_glWindowPos2dvARB) {
      rCtx->dsp->emuTbl.glWindowPos2dvARB = driverTbl.glWindowPos2dvARB;
   }
   driverTbl.glWindowPos2dvARB(p);
}

static void REGAL_CALL missing_glWindowPos2fARB(GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glWindowPos2fARB not available." );
}

static void REGAL_CALL loader_glWindowPos2fARB(GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2fARB, "glWindowPos2fARB");
   if ( !driverTbl.glWindowPos2fARB ) {
      driverTbl.glWindowPos2fARB = missing_glWindowPos2fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2fARB == loader_glWindowPos2fARB) {
      rCtx->dsp->emuTbl.glWindowPos2fARB = driverTbl.glWindowPos2fARB;
   }
   driverTbl.glWindowPos2fARB(x, y);
}

static void REGAL_CALL missing_glWindowPos2fvARB(const GLfloat *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos2fvARB not available." );
}

static void REGAL_CALL loader_glWindowPos2fvARB(const GLfloat *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2fvARB, "glWindowPos2fvARB");
   if ( !driverTbl.glWindowPos2fvARB ) {
      driverTbl.glWindowPos2fvARB = missing_glWindowPos2fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2fvARB == loader_glWindowPos2fvARB) {
      rCtx->dsp->emuTbl.glWindowPos2fvARB = driverTbl.glWindowPos2fvARB;
   }
   driverTbl.glWindowPos2fvARB(p);
}

static void REGAL_CALL missing_glWindowPos2iARB(GLint x, GLint y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glWindowPos2iARB not available." );
}

static void REGAL_CALL loader_glWindowPos2iARB(GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2iARB, "glWindowPos2iARB");
   if ( !driverTbl.glWindowPos2iARB ) {
      driverTbl.glWindowPos2iARB = missing_glWindowPos2iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2iARB == loader_glWindowPos2iARB) {
      rCtx->dsp->emuTbl.glWindowPos2iARB = driverTbl.glWindowPos2iARB;
   }
   driverTbl.glWindowPos2iARB(x, y);
}

static void REGAL_CALL missing_glWindowPos2ivARB(const GLint *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos2ivARB not available." );
}

static void REGAL_CALL loader_glWindowPos2ivARB(const GLint *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2ivARB, "glWindowPos2ivARB");
   if ( !driverTbl.glWindowPos2ivARB ) {
      driverTbl.glWindowPos2ivARB = missing_glWindowPos2ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2ivARB == loader_glWindowPos2ivARB) {
      rCtx->dsp->emuTbl.glWindowPos2ivARB = driverTbl.glWindowPos2ivARB;
   }
   driverTbl.glWindowPos2ivARB(p);
}

static void REGAL_CALL missing_glWindowPos2sARB(GLshort x, GLshort y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glWindowPos2sARB not available." );
}

static void REGAL_CALL loader_glWindowPos2sARB(GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2sARB, "glWindowPos2sARB");
   if ( !driverTbl.glWindowPos2sARB ) {
      driverTbl.glWindowPos2sARB = missing_glWindowPos2sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2sARB == loader_glWindowPos2sARB) {
      rCtx->dsp->emuTbl.glWindowPos2sARB = driverTbl.glWindowPos2sARB;
   }
   driverTbl.glWindowPos2sARB(x, y);
}

static void REGAL_CALL missing_glWindowPos2svARB(const GLshort *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos2svARB not available." );
}

static void REGAL_CALL loader_glWindowPos2svARB(const GLshort *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2svARB, "glWindowPos2svARB");
   if ( !driverTbl.glWindowPos2svARB ) {
      driverTbl.glWindowPos2svARB = missing_glWindowPos2svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2svARB == loader_glWindowPos2svARB) {
      rCtx->dsp->emuTbl.glWindowPos2svARB = driverTbl.glWindowPos2svARB;
   }
   driverTbl.glWindowPos2svARB(p);
}

static void REGAL_CALL missing_glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glWindowPos3dARB not available." );
}

static void REGAL_CALL loader_glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3dARB, "glWindowPos3dARB");
   if ( !driverTbl.glWindowPos3dARB ) {
      driverTbl.glWindowPos3dARB = missing_glWindowPos3dARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3dARB == loader_glWindowPos3dARB) {
      rCtx->dsp->emuTbl.glWindowPos3dARB = driverTbl.glWindowPos3dARB;
   }
   driverTbl.glWindowPos3dARB(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3dvARB(const GLdouble *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos3dvARB not available." );
}

static void REGAL_CALL loader_glWindowPos3dvARB(const GLdouble *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3dvARB, "glWindowPos3dvARB");
   if ( !driverTbl.glWindowPos3dvARB ) {
      driverTbl.glWindowPos3dvARB = missing_glWindowPos3dvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3dvARB == loader_glWindowPos3dvARB) {
      rCtx->dsp->emuTbl.glWindowPos3dvARB = driverTbl.glWindowPos3dvARB;
   }
   driverTbl.glWindowPos3dvARB(p);
}

static void REGAL_CALL missing_glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glWindowPos3fARB not available." );
}

static void REGAL_CALL loader_glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3fARB, "glWindowPos3fARB");
   if ( !driverTbl.glWindowPos3fARB ) {
      driverTbl.glWindowPos3fARB = missing_glWindowPos3fARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3fARB == loader_glWindowPos3fARB) {
      rCtx->dsp->emuTbl.glWindowPos3fARB = driverTbl.glWindowPos3fARB;
   }
   driverTbl.glWindowPos3fARB(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3fvARB(const GLfloat *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos3fvARB not available." );
}

static void REGAL_CALL loader_glWindowPos3fvARB(const GLfloat *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3fvARB, "glWindowPos3fvARB");
   if ( !driverTbl.glWindowPos3fvARB ) {
      driverTbl.glWindowPos3fvARB = missing_glWindowPos3fvARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3fvARB == loader_glWindowPos3fvARB) {
      rCtx->dsp->emuTbl.glWindowPos3fvARB = driverTbl.glWindowPos3fvARB;
   }
   driverTbl.glWindowPos3fvARB(p);
}

static void REGAL_CALL missing_glWindowPos3iARB(GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glWindowPos3iARB not available." );
}

static void REGAL_CALL loader_glWindowPos3iARB(GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3iARB, "glWindowPos3iARB");
   if ( !driverTbl.glWindowPos3iARB ) {
      driverTbl.glWindowPos3iARB = missing_glWindowPos3iARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3iARB == loader_glWindowPos3iARB) {
      rCtx->dsp->emuTbl.glWindowPos3iARB = driverTbl.glWindowPos3iARB;
   }
   driverTbl.glWindowPos3iARB(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3ivARB(const GLint *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos3ivARB not available." );
}

static void REGAL_CALL loader_glWindowPos3ivARB(const GLint *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3ivARB, "glWindowPos3ivARB");
   if ( !driverTbl.glWindowPos3ivARB ) {
      driverTbl.glWindowPos3ivARB = missing_glWindowPos3ivARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3ivARB == loader_glWindowPos3ivARB) {
      rCtx->dsp->emuTbl.glWindowPos3ivARB = driverTbl.glWindowPos3ivARB;
   }
   driverTbl.glWindowPos3ivARB(p);
}

static void REGAL_CALL missing_glWindowPos3sARB(GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glWindowPos3sARB not available." );
}

static void REGAL_CALL loader_glWindowPos3sARB(GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3sARB, "glWindowPos3sARB");
   if ( !driverTbl.glWindowPos3sARB ) {
      driverTbl.glWindowPos3sARB = missing_glWindowPos3sARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3sARB == loader_glWindowPos3sARB) {
      rCtx->dsp->emuTbl.glWindowPos3sARB = driverTbl.glWindowPos3sARB;
   }
   driverTbl.glWindowPos3sARB(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3svARB(const GLshort *p)
{
   UNUSED_PARAMETER(p);
   Warning( "glWindowPos3svARB not available." );
}

static void REGAL_CALL loader_glWindowPos3svARB(const GLshort *p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3svARB, "glWindowPos3svARB");
   if ( !driverTbl.glWindowPos3svARB ) {
      driverTbl.glWindowPos3svARB = missing_glWindowPos3svARB;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3svARB == loader_glWindowPos3svARB) {
      rCtx->dsp->emuTbl.glWindowPos3svARB = driverTbl.glWindowPos3svARB;
   }
   driverTbl.glWindowPos3svARB(p);
}

// GL_ATI_draw_buffers

static void REGAL_CALL missing_glDrawBuffersATI(GLsizei n, const GLenum *bufs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(bufs);
   Warning( "glDrawBuffersATI not available." );
}

static void REGAL_CALL loader_glDrawBuffersATI(GLsizei n, const GLenum *bufs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawBuffersATI, "glDrawBuffersATI");
   if ( !driverTbl.glDrawBuffersATI ) {
      driverTbl.glDrawBuffersATI = missing_glDrawBuffersATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawBuffersATI == loader_glDrawBuffersATI) {
      rCtx->dsp->emuTbl.glDrawBuffersATI = driverTbl.glDrawBuffersATI;
   }
   driverTbl.glDrawBuffersATI(n, bufs);
}

// GL_ATI_element_array

static void REGAL_CALL missing_glDrawElementArrayATI(GLenum mode, GLsizei count)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   Warning( "glDrawElementArrayATI not available." );
}

static void REGAL_CALL loader_glDrawElementArrayATI(GLenum mode, GLsizei count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawElementArrayATI, "glDrawElementArrayATI");
   if ( !driverTbl.glDrawElementArrayATI ) {
      driverTbl.glDrawElementArrayATI = missing_glDrawElementArrayATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawElementArrayATI == loader_glDrawElementArrayATI) {
      rCtx->dsp->emuTbl.glDrawElementArrayATI = driverTbl.glDrawElementArrayATI;
   }
   driverTbl.glDrawElementArrayATI(mode, count);
}

static void REGAL_CALL missing_glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(end);
   UNUSED_PARAMETER(count);
   Warning( "glDrawRangeElementArrayATI not available." );
}

static void REGAL_CALL loader_glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawRangeElementArrayATI, "glDrawRangeElementArrayATI");
   if ( !driverTbl.glDrawRangeElementArrayATI ) {
      driverTbl.glDrawRangeElementArrayATI = missing_glDrawRangeElementArrayATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawRangeElementArrayATI == loader_glDrawRangeElementArrayATI) {
      rCtx->dsp->emuTbl.glDrawRangeElementArrayATI = driverTbl.glDrawRangeElementArrayATI;
   }
   driverTbl.glDrawRangeElementArrayATI(mode, start, end, count);
}

static void REGAL_CALL missing_glElementPointerATI(GLenum type, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pointer);
   Warning( "glElementPointerATI not available." );
}

static void REGAL_CALL loader_glElementPointerATI(GLenum type, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glElementPointerATI, "glElementPointerATI");
   if ( !driverTbl.glElementPointerATI ) {
      driverTbl.glElementPointerATI = missing_glElementPointerATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glElementPointerATI == loader_glElementPointerATI) {
      rCtx->dsp->emuTbl.glElementPointerATI = driverTbl.glElementPointerATI;
   }
   driverTbl.glElementPointerATI(type, pointer);
}

// GL_ATI_envmap_bumpmap

static void REGAL_CALL missing_glGetTexBumpParameterfvATI(GLenum pname, GLfloat *param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glGetTexBumpParameterfvATI not available." );
}

static void REGAL_CALL loader_glGetTexBumpParameterfvATI(GLenum pname, GLfloat *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexBumpParameterfvATI, "glGetTexBumpParameterfvATI");
   if ( !driverTbl.glGetTexBumpParameterfvATI ) {
      driverTbl.glGetTexBumpParameterfvATI = missing_glGetTexBumpParameterfvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexBumpParameterfvATI == loader_glGetTexBumpParameterfvATI) {
      rCtx->dsp->emuTbl.glGetTexBumpParameterfvATI = driverTbl.glGetTexBumpParameterfvATI;
   }
   driverTbl.glGetTexBumpParameterfvATI(pname, param);
}

static void REGAL_CALL missing_glGetTexBumpParameterivATI(GLenum pname, GLint *param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glGetTexBumpParameterivATI not available." );
}

static void REGAL_CALL loader_glGetTexBumpParameterivATI(GLenum pname, GLint *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexBumpParameterivATI, "glGetTexBumpParameterivATI");
   if ( !driverTbl.glGetTexBumpParameterivATI ) {
      driverTbl.glGetTexBumpParameterivATI = missing_glGetTexBumpParameterivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexBumpParameterivATI == loader_glGetTexBumpParameterivATI) {
      rCtx->dsp->emuTbl.glGetTexBumpParameterivATI = driverTbl.glGetTexBumpParameterivATI;
   }
   driverTbl.glGetTexBumpParameterivATI(pname, param);
}

static void REGAL_CALL missing_glTexBumpParameterfvATI(GLenum pname, GLfloat *param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glTexBumpParameterfvATI not available." );
}

static void REGAL_CALL loader_glTexBumpParameterfvATI(GLenum pname, GLfloat *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexBumpParameterfvATI, "glTexBumpParameterfvATI");
   if ( !driverTbl.glTexBumpParameterfvATI ) {
      driverTbl.glTexBumpParameterfvATI = missing_glTexBumpParameterfvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexBumpParameterfvATI == loader_glTexBumpParameterfvATI) {
      rCtx->dsp->emuTbl.glTexBumpParameterfvATI = driverTbl.glTexBumpParameterfvATI;
   }
   driverTbl.glTexBumpParameterfvATI(pname, param);
}

static void REGAL_CALL missing_glTexBumpParameterivATI(GLenum pname, GLint *param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glTexBumpParameterivATI not available." );
}

static void REGAL_CALL loader_glTexBumpParameterivATI(GLenum pname, GLint *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexBumpParameterivATI, "glTexBumpParameterivATI");
   if ( !driverTbl.glTexBumpParameterivATI ) {
      driverTbl.glTexBumpParameterivATI = missing_glTexBumpParameterivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexBumpParameterivATI == loader_glTexBumpParameterivATI) {
      rCtx->dsp->emuTbl.glTexBumpParameterivATI = driverTbl.glTexBumpParameterivATI;
   }
   driverTbl.glTexBumpParameterivATI(pname, param);
}

// GL_ATI_fragment_shader

static void REGAL_CALL missing_glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(dstMod);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg1Rep);
   UNUSED_PARAMETER(arg1Mod);
   Warning( "glAlphaFragmentOp1ATI not available." );
}

static void REGAL_CALL loader_glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glAlphaFragmentOp1ATI, "glAlphaFragmentOp1ATI");
   if ( !driverTbl.glAlphaFragmentOp1ATI ) {
      driverTbl.glAlphaFragmentOp1ATI = missing_glAlphaFragmentOp1ATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glAlphaFragmentOp1ATI == loader_glAlphaFragmentOp1ATI) {
      rCtx->dsp->emuTbl.glAlphaFragmentOp1ATI = driverTbl.glAlphaFragmentOp1ATI;
   }
   driverTbl.glAlphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
}

static void REGAL_CALL missing_glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(dstMod);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg1Rep);
   UNUSED_PARAMETER(arg1Mod);
   UNUSED_PARAMETER(arg2);
   UNUSED_PARAMETER(arg2Rep);
   UNUSED_PARAMETER(arg2Mod);
   Warning( "glAlphaFragmentOp2ATI not available." );
}

static void REGAL_CALL loader_glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glAlphaFragmentOp2ATI, "glAlphaFragmentOp2ATI");
   if ( !driverTbl.glAlphaFragmentOp2ATI ) {
      driverTbl.glAlphaFragmentOp2ATI = missing_glAlphaFragmentOp2ATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glAlphaFragmentOp2ATI == loader_glAlphaFragmentOp2ATI) {
      rCtx->dsp->emuTbl.glAlphaFragmentOp2ATI = driverTbl.glAlphaFragmentOp2ATI;
   }
   driverTbl.glAlphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
}

static void REGAL_CALL missing_glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(dstMod);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg1Rep);
   UNUSED_PARAMETER(arg1Mod);
   UNUSED_PARAMETER(arg2);
   UNUSED_PARAMETER(arg2Rep);
   UNUSED_PARAMETER(arg2Mod);
   UNUSED_PARAMETER(arg3);
   UNUSED_PARAMETER(arg3Rep);
   UNUSED_PARAMETER(arg3Mod);
   Warning( "glAlphaFragmentOp3ATI not available." );
}

static void REGAL_CALL loader_glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glAlphaFragmentOp3ATI, "glAlphaFragmentOp3ATI");
   if ( !driverTbl.glAlphaFragmentOp3ATI ) {
      driverTbl.glAlphaFragmentOp3ATI = missing_glAlphaFragmentOp3ATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glAlphaFragmentOp3ATI == loader_glAlphaFragmentOp3ATI) {
      rCtx->dsp->emuTbl.glAlphaFragmentOp3ATI = driverTbl.glAlphaFragmentOp3ATI;
   }
   driverTbl.glAlphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
}

static void REGAL_CALL missing_glBeginFragmentShaderATI(void)
{
   Warning( "glBeginFragmentShaderATI not available." );
}

static void REGAL_CALL loader_glBeginFragmentShaderATI(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBeginFragmentShaderATI, "glBeginFragmentShaderATI");
   if ( !driverTbl.glBeginFragmentShaderATI ) {
      driverTbl.glBeginFragmentShaderATI = missing_glBeginFragmentShaderATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBeginFragmentShaderATI == loader_glBeginFragmentShaderATI) {
      rCtx->dsp->emuTbl.glBeginFragmentShaderATI = driverTbl.glBeginFragmentShaderATI;
   }
   driverTbl.glBeginFragmentShaderATI();
}

static void REGAL_CALL missing_glBindFragmentShaderATI(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "glBindFragmentShaderATI not available." );
}

static void REGAL_CALL loader_glBindFragmentShaderATI(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindFragmentShaderATI, "glBindFragmentShaderATI");
   if ( !driverTbl.glBindFragmentShaderATI ) {
      driverTbl.glBindFragmentShaderATI = missing_glBindFragmentShaderATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindFragmentShaderATI == loader_glBindFragmentShaderATI) {
      rCtx->dsp->emuTbl.glBindFragmentShaderATI = driverTbl.glBindFragmentShaderATI;
   }
   driverTbl.glBindFragmentShaderATI(id);
}

static void REGAL_CALL missing_glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(dstMask);
   UNUSED_PARAMETER(dstMod);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg1Rep);
   UNUSED_PARAMETER(arg1Mod);
   Warning( "glColorFragmentOp1ATI not available." );
}

static void REGAL_CALL loader_glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorFragmentOp1ATI, "glColorFragmentOp1ATI");
   if ( !driverTbl.glColorFragmentOp1ATI ) {
      driverTbl.glColorFragmentOp1ATI = missing_glColorFragmentOp1ATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorFragmentOp1ATI == loader_glColorFragmentOp1ATI) {
      rCtx->dsp->emuTbl.glColorFragmentOp1ATI = driverTbl.glColorFragmentOp1ATI;
   }
   driverTbl.glColorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
}

static void REGAL_CALL missing_glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(dstMask);
   UNUSED_PARAMETER(dstMod);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg1Rep);
   UNUSED_PARAMETER(arg1Mod);
   UNUSED_PARAMETER(arg2);
   UNUSED_PARAMETER(arg2Rep);
   UNUSED_PARAMETER(arg2Mod);
   Warning( "glColorFragmentOp2ATI not available." );
}

static void REGAL_CALL loader_glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorFragmentOp2ATI, "glColorFragmentOp2ATI");
   if ( !driverTbl.glColorFragmentOp2ATI ) {
      driverTbl.glColorFragmentOp2ATI = missing_glColorFragmentOp2ATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorFragmentOp2ATI == loader_glColorFragmentOp2ATI) {
      rCtx->dsp->emuTbl.glColorFragmentOp2ATI = driverTbl.glColorFragmentOp2ATI;
   }
   driverTbl.glColorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
}

static void REGAL_CALL missing_glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(dstMask);
   UNUSED_PARAMETER(dstMod);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg1Rep);
   UNUSED_PARAMETER(arg1Mod);
   UNUSED_PARAMETER(arg2);
   UNUSED_PARAMETER(arg2Rep);
   UNUSED_PARAMETER(arg2Mod);
   UNUSED_PARAMETER(arg3);
   UNUSED_PARAMETER(arg3Rep);
   UNUSED_PARAMETER(arg3Mod);
   Warning( "glColorFragmentOp3ATI not available." );
}

static void REGAL_CALL loader_glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorFragmentOp3ATI, "glColorFragmentOp3ATI");
   if ( !driverTbl.glColorFragmentOp3ATI ) {
      driverTbl.glColorFragmentOp3ATI = missing_glColorFragmentOp3ATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorFragmentOp3ATI == loader_glColorFragmentOp3ATI) {
      rCtx->dsp->emuTbl.glColorFragmentOp3ATI = driverTbl.glColorFragmentOp3ATI;
   }
   driverTbl.glColorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
}

static void REGAL_CALL missing_glDeleteFragmentShaderATI(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "glDeleteFragmentShaderATI not available." );
}

static void REGAL_CALL loader_glDeleteFragmentShaderATI(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteFragmentShaderATI, "glDeleteFragmentShaderATI");
   if ( !driverTbl.glDeleteFragmentShaderATI ) {
      driverTbl.glDeleteFragmentShaderATI = missing_glDeleteFragmentShaderATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteFragmentShaderATI == loader_glDeleteFragmentShaderATI) {
      rCtx->dsp->emuTbl.glDeleteFragmentShaderATI = driverTbl.glDeleteFragmentShaderATI;
   }
   driverTbl.glDeleteFragmentShaderATI(id);
}

static void REGAL_CALL missing_glEndFragmentShaderATI(void)
{
   Warning( "glEndFragmentShaderATI not available." );
}

static void REGAL_CALL loader_glEndFragmentShaderATI(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndFragmentShaderATI, "glEndFragmentShaderATI");
   if ( !driverTbl.glEndFragmentShaderATI ) {
      driverTbl.glEndFragmentShaderATI = missing_glEndFragmentShaderATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndFragmentShaderATI == loader_glEndFragmentShaderATI) {
      rCtx->dsp->emuTbl.glEndFragmentShaderATI = driverTbl.glEndFragmentShaderATI;
   }
   driverTbl.glEndFragmentShaderATI();
}

static GLuint REGAL_CALL missing_glGenFragmentShadersATI(GLuint range)
{
   UNUSED_PARAMETER(range);
   Warning( "glGenFragmentShadersATI not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGenFragmentShadersATI(GLuint range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenFragmentShadersATI, "glGenFragmentShadersATI");
   if ( !driverTbl.glGenFragmentShadersATI ) {
      driverTbl.glGenFragmentShadersATI = missing_glGenFragmentShadersATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenFragmentShadersATI == loader_glGenFragmentShadersATI) {
      rCtx->dsp->emuTbl.glGenFragmentShadersATI = driverTbl.glGenFragmentShadersATI;
   }
   return driverTbl.glGenFragmentShadersATI(range);
}

static void REGAL_CALL missing_glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle)
{
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(swizzle);
   Warning( "glPassTexCoordATI not available." );
}

static void REGAL_CALL loader_glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPassTexCoordATI, "glPassTexCoordATI");
   if ( !driverTbl.glPassTexCoordATI ) {
      driverTbl.glPassTexCoordATI = missing_glPassTexCoordATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPassTexCoordATI == loader_glPassTexCoordATI) {
      rCtx->dsp->emuTbl.glPassTexCoordATI = driverTbl.glPassTexCoordATI;
   }
   driverTbl.glPassTexCoordATI(dst, coord, swizzle);
}

static void REGAL_CALL missing_glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle)
{
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(interp);
   UNUSED_PARAMETER(swizzle);
   Warning( "glSampleMapATI not available." );
}

static void REGAL_CALL loader_glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSampleMapATI, "glSampleMapATI");
   if ( !driverTbl.glSampleMapATI ) {
      driverTbl.glSampleMapATI = missing_glSampleMapATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSampleMapATI == loader_glSampleMapATI) {
      rCtx->dsp->emuTbl.glSampleMapATI = driverTbl.glSampleMapATI;
   }
   driverTbl.glSampleMapATI(dst, interp, swizzle);
}

static void REGAL_CALL missing_glSetFragmentShaderConstantATI(GLuint dst, const GLfloat *value)
{
   UNUSED_PARAMETER(dst);
   UNUSED_PARAMETER(value);
   Warning( "glSetFragmentShaderConstantATI not available." );
}

static void REGAL_CALL loader_glSetFragmentShaderConstantATI(GLuint dst, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSetFragmentShaderConstantATI, "glSetFragmentShaderConstantATI");
   if ( !driverTbl.glSetFragmentShaderConstantATI ) {
      driverTbl.glSetFragmentShaderConstantATI = missing_glSetFragmentShaderConstantATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSetFragmentShaderConstantATI == loader_glSetFragmentShaderConstantATI) {
      rCtx->dsp->emuTbl.glSetFragmentShaderConstantATI = driverTbl.glSetFragmentShaderConstantATI;
   }
   driverTbl.glSetFragmentShaderConstantATI(dst, value);
}

// GL_ATI_map_object_buffer

static GLvoid *REGAL_CALL missing_glMapObjectBufferATI(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "glMapObjectBufferATI not available." );
  GLvoid * ret = NULL;
  return ret;
}

static GLvoid *REGAL_CALL loader_glMapObjectBufferATI(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapObjectBufferATI, "glMapObjectBufferATI");
   if ( !driverTbl.glMapObjectBufferATI ) {
      driverTbl.glMapObjectBufferATI = missing_glMapObjectBufferATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapObjectBufferATI == loader_glMapObjectBufferATI) {
      rCtx->dsp->emuTbl.glMapObjectBufferATI = driverTbl.glMapObjectBufferATI;
   }
   return driverTbl.glMapObjectBufferATI(buffer);
}

static void REGAL_CALL missing_glUnmapObjectBufferATI(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "glUnmapObjectBufferATI not available." );
}

static void REGAL_CALL loader_glUnmapObjectBufferATI(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUnmapObjectBufferATI, "glUnmapObjectBufferATI");
   if ( !driverTbl.glUnmapObjectBufferATI ) {
      driverTbl.glUnmapObjectBufferATI = missing_glUnmapObjectBufferATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUnmapObjectBufferATI == loader_glUnmapObjectBufferATI) {
      rCtx->dsp->emuTbl.glUnmapObjectBufferATI = driverTbl.glUnmapObjectBufferATI;
   }
   driverTbl.glUnmapObjectBufferATI(buffer);
}

// GL_ATI_pn_triangles

static void REGAL_CALL missing_glPNTrianglesfATI(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPNTrianglesfATI not available." );
}

static void REGAL_CALL loader_glPNTrianglesfATI(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPNTrianglesfATI, "glPNTrianglesfATI");
   if ( !driverTbl.glPNTrianglesfATI ) {
      driverTbl.glPNTrianglesfATI = missing_glPNTrianglesfATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPNTrianglesfATI == loader_glPNTrianglesfATI) {
      rCtx->dsp->emuTbl.glPNTrianglesfATI = driverTbl.glPNTrianglesfATI;
   }
   driverTbl.glPNTrianglesfATI(pname, param);
}

static void REGAL_CALL missing_glPNTrianglesiATI(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPNTrianglesiATI not available." );
}

static void REGAL_CALL loader_glPNTrianglesiATI(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPNTrianglesiATI, "glPNTrianglesiATI");
   if ( !driverTbl.glPNTrianglesiATI ) {
      driverTbl.glPNTrianglesiATI = missing_glPNTrianglesiATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPNTrianglesiATI == loader_glPNTrianglesiATI) {
      rCtx->dsp->emuTbl.glPNTrianglesiATI = driverTbl.glPNTrianglesiATI;
   }
   driverTbl.glPNTrianglesiATI(pname, param);
}

// GL_ATI_separate_stencil

static void REGAL_CALL missing_glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
{
   UNUSED_PARAMETER(frontfunc);
   UNUSED_PARAMETER(backfunc);
   UNUSED_PARAMETER(ref);
   UNUSED_PARAMETER(mask);
   Warning( "glStencilFuncSeparateATI not available." );
}

static void REGAL_CALL loader_glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStencilFuncSeparateATI, "glStencilFuncSeparateATI");
   if ( !driverTbl.glStencilFuncSeparateATI ) {
      driverTbl.glStencilFuncSeparateATI = missing_glStencilFuncSeparateATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStencilFuncSeparateATI == loader_glStencilFuncSeparateATI) {
      rCtx->dsp->emuTbl.glStencilFuncSeparateATI = driverTbl.glStencilFuncSeparateATI;
   }
   driverTbl.glStencilFuncSeparateATI(frontfunc, backfunc, ref, mask);
}

static void REGAL_CALL missing_glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(sfail);
   UNUSED_PARAMETER(dpfail);
   UNUSED_PARAMETER(dppass);
   Warning( "glStencilOpSeparateATI not available." );
}

static void REGAL_CALL loader_glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStencilOpSeparateATI, "glStencilOpSeparateATI");
   if ( !driverTbl.glStencilOpSeparateATI ) {
      driverTbl.glStencilOpSeparateATI = missing_glStencilOpSeparateATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStencilOpSeparateATI == loader_glStencilOpSeparateATI) {
      rCtx->dsp->emuTbl.glStencilOpSeparateATI = driverTbl.glStencilOpSeparateATI;
   }
   driverTbl.glStencilOpSeparateATI(face, sfail, dpfail, dppass);
}

// GL_ATI_vertex_array_object

static void REGAL_CALL missing_glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
   UNUSED_PARAMETER(array);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   Warning( "glArrayObjectATI not available." );
}

static void REGAL_CALL loader_glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glArrayObjectATI, "glArrayObjectATI");
   if ( !driverTbl.glArrayObjectATI ) {
      driverTbl.glArrayObjectATI = missing_glArrayObjectATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glArrayObjectATI == loader_glArrayObjectATI) {
      rCtx->dsp->emuTbl.glArrayObjectATI = driverTbl.glArrayObjectATI;
   }
   driverTbl.glArrayObjectATI(array, size, type, stride, buffer, offset);
}

static void REGAL_CALL missing_glFreeObjectBufferATI(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "glFreeObjectBufferATI not available." );
}

static void REGAL_CALL loader_glFreeObjectBufferATI(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFreeObjectBufferATI, "glFreeObjectBufferATI");
   if ( !driverTbl.glFreeObjectBufferATI ) {
      driverTbl.glFreeObjectBufferATI = missing_glFreeObjectBufferATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFreeObjectBufferATI == loader_glFreeObjectBufferATI) {
      rCtx->dsp->emuTbl.glFreeObjectBufferATI = driverTbl.glFreeObjectBufferATI;
   }
   driverTbl.glFreeObjectBufferATI(buffer);
}

static void REGAL_CALL missing_glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(array);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetArrayObjectfvATI not available." );
}

static void REGAL_CALL loader_glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetArrayObjectfvATI, "glGetArrayObjectfvATI");
   if ( !driverTbl.glGetArrayObjectfvATI ) {
      driverTbl.glGetArrayObjectfvATI = missing_glGetArrayObjectfvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetArrayObjectfvATI == loader_glGetArrayObjectfvATI) {
      rCtx->dsp->emuTbl.glGetArrayObjectfvATI = driverTbl.glGetArrayObjectfvATI;
   }
   driverTbl.glGetArrayObjectfvATI(array, pname, params);
}

static void REGAL_CALL missing_glGetArrayObjectivATI(GLenum array, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(array);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetArrayObjectivATI not available." );
}

static void REGAL_CALL loader_glGetArrayObjectivATI(GLenum array, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetArrayObjectivATI, "glGetArrayObjectivATI");
   if ( !driverTbl.glGetArrayObjectivATI ) {
      driverTbl.glGetArrayObjectivATI = missing_glGetArrayObjectivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetArrayObjectivATI == loader_glGetArrayObjectivATI) {
      rCtx->dsp->emuTbl.glGetArrayObjectivATI = driverTbl.glGetArrayObjectivATI;
   }
   driverTbl.glGetArrayObjectivATI(array, pname, params);
}

static void REGAL_CALL missing_glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetObjectBufferfvATI not available." );
}

static void REGAL_CALL loader_glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetObjectBufferfvATI, "glGetObjectBufferfvATI");
   if ( !driverTbl.glGetObjectBufferfvATI ) {
      driverTbl.glGetObjectBufferfvATI = missing_glGetObjectBufferfvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetObjectBufferfvATI == loader_glGetObjectBufferfvATI) {
      rCtx->dsp->emuTbl.glGetObjectBufferfvATI = driverTbl.glGetObjectBufferfvATI;
   }
   driverTbl.glGetObjectBufferfvATI(buffer, pname, params);
}

static void REGAL_CALL missing_glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetObjectBufferivATI not available." );
}

static void REGAL_CALL loader_glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetObjectBufferivATI, "glGetObjectBufferivATI");
   if ( !driverTbl.glGetObjectBufferivATI ) {
      driverTbl.glGetObjectBufferivATI = missing_glGetObjectBufferivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetObjectBufferivATI == loader_glGetObjectBufferivATI) {
      rCtx->dsp->emuTbl.glGetObjectBufferivATI = driverTbl.glGetObjectBufferivATI;
   }
   driverTbl.glGetObjectBufferivATI(buffer, pname, params);
}

static void REGAL_CALL missing_glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVariantArrayObjectfvATI not available." );
}

static void REGAL_CALL loader_glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVariantArrayObjectfvATI, "glGetVariantArrayObjectfvATI");
   if ( !driverTbl.glGetVariantArrayObjectfvATI ) {
      driverTbl.glGetVariantArrayObjectfvATI = missing_glGetVariantArrayObjectfvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVariantArrayObjectfvATI == loader_glGetVariantArrayObjectfvATI) {
      rCtx->dsp->emuTbl.glGetVariantArrayObjectfvATI = driverTbl.glGetVariantArrayObjectfvATI;
   }
   driverTbl.glGetVariantArrayObjectfvATI(id, pname, params);
}

static void REGAL_CALL missing_glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVariantArrayObjectivATI not available." );
}

static void REGAL_CALL loader_glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVariantArrayObjectivATI, "glGetVariantArrayObjectivATI");
   if ( !driverTbl.glGetVariantArrayObjectivATI ) {
      driverTbl.glGetVariantArrayObjectivATI = missing_glGetVariantArrayObjectivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVariantArrayObjectivATI == loader_glGetVariantArrayObjectivATI) {
      rCtx->dsp->emuTbl.glGetVariantArrayObjectivATI = driverTbl.glGetVariantArrayObjectivATI;
   }
   driverTbl.glGetVariantArrayObjectivATI(id, pname, params);
}

static GLboolean REGAL_CALL missing_glIsObjectBufferATI(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "glIsObjectBufferATI not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsObjectBufferATI(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsObjectBufferATI, "glIsObjectBufferATI");
   if ( !driverTbl.glIsObjectBufferATI ) {
      driverTbl.glIsObjectBufferATI = missing_glIsObjectBufferATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsObjectBufferATI == loader_glIsObjectBufferATI) {
      rCtx->dsp->emuTbl.glIsObjectBufferATI = driverTbl.glIsObjectBufferATI;
   }
   return driverTbl.glIsObjectBufferATI(buffer);
}

static GLuint REGAL_CALL missing_glNewObjectBufferATI(GLsizei size, const GLvoid *pointer, GLenum usage)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(usage);
   Warning( "glNewObjectBufferATI not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glNewObjectBufferATI(GLsizei size, const GLvoid *pointer, GLenum usage)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNewObjectBufferATI, "glNewObjectBufferATI");
   if ( !driverTbl.glNewObjectBufferATI ) {
      driverTbl.glNewObjectBufferATI = missing_glNewObjectBufferATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNewObjectBufferATI == loader_glNewObjectBufferATI) {
      rCtx->dsp->emuTbl.glNewObjectBufferATI = driverTbl.glNewObjectBufferATI;
   }
   return driverTbl.glNewObjectBufferATI(size, pointer, usage);
}

static void REGAL_CALL missing_glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(preserve);
   Warning( "glUpdateObjectBufferATI not available." );
}

static void REGAL_CALL loader_glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUpdateObjectBufferATI, "glUpdateObjectBufferATI");
   if ( !driverTbl.glUpdateObjectBufferATI ) {
      driverTbl.glUpdateObjectBufferATI = missing_glUpdateObjectBufferATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUpdateObjectBufferATI == loader_glUpdateObjectBufferATI) {
      rCtx->dsp->emuTbl.glUpdateObjectBufferATI = driverTbl.glUpdateObjectBufferATI;
   }
   driverTbl.glUpdateObjectBufferATI(buffer, offset, size, pointer, preserve);
}

static void REGAL_CALL missing_glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   Warning( "glVariantArrayObjectATI not available." );
}

static void REGAL_CALL loader_glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVariantArrayObjectATI, "glVariantArrayObjectATI");
   if ( !driverTbl.glVariantArrayObjectATI ) {
      driverTbl.glVariantArrayObjectATI = missing_glVariantArrayObjectATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVariantArrayObjectATI == loader_glVariantArrayObjectATI) {
      rCtx->dsp->emuTbl.glVariantArrayObjectATI = driverTbl.glVariantArrayObjectATI;
   }
   driverTbl.glVariantArrayObjectATI(id, type, stride, buffer, offset);
}

// GL_ATI_vertex_attrib_array_object

static void REGAL_CALL missing_glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribArrayObjectfvATI not available." );
}

static void REGAL_CALL loader_glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribArrayObjectfvATI, "glGetVertexAttribArrayObjectfvATI");
   if ( !driverTbl.glGetVertexAttribArrayObjectfvATI ) {
      driverTbl.glGetVertexAttribArrayObjectfvATI = missing_glGetVertexAttribArrayObjectfvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribArrayObjectfvATI == loader_glGetVertexAttribArrayObjectfvATI) {
      rCtx->dsp->emuTbl.glGetVertexAttribArrayObjectfvATI = driverTbl.glGetVertexAttribArrayObjectfvATI;
   }
   driverTbl.glGetVertexAttribArrayObjectfvATI(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribArrayObjectivATI not available." );
}

static void REGAL_CALL loader_glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribArrayObjectivATI, "glGetVertexAttribArrayObjectivATI");
   if ( !driverTbl.glGetVertexAttribArrayObjectivATI ) {
      driverTbl.glGetVertexAttribArrayObjectivATI = missing_glGetVertexAttribArrayObjectivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribArrayObjectivATI == loader_glGetVertexAttribArrayObjectivATI) {
      rCtx->dsp->emuTbl.glGetVertexAttribArrayObjectivATI = driverTbl.glGetVertexAttribArrayObjectivATI;
   }
   driverTbl.glGetVertexAttribArrayObjectivATI(index, pname, params);
}

static void REGAL_CALL missing_glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   Warning( "glVertexAttribArrayObjectATI not available." );
}

static void REGAL_CALL loader_glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribArrayObjectATI, "glVertexAttribArrayObjectATI");
   if ( !driverTbl.glVertexAttribArrayObjectATI ) {
      driverTbl.glVertexAttribArrayObjectATI = missing_glVertexAttribArrayObjectATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribArrayObjectATI == loader_glVertexAttribArrayObjectATI) {
      rCtx->dsp->emuTbl.glVertexAttribArrayObjectATI = driverTbl.glVertexAttribArrayObjectATI;
   }
   driverTbl.glVertexAttribArrayObjectATI(index, size, type, normalized, stride, buffer, offset);
}

// GL_ATI_vertex_streams

static void REGAL_CALL missing_glClientActiveVertexStreamATI(GLenum stream)
{
   UNUSED_PARAMETER(stream);
   Warning( "glClientActiveVertexStreamATI not available." );
}

static void REGAL_CALL loader_glClientActiveVertexStreamATI(GLenum stream)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClientActiveVertexStreamATI, "glClientActiveVertexStreamATI");
   if ( !driverTbl.glClientActiveVertexStreamATI ) {
      driverTbl.glClientActiveVertexStreamATI = missing_glClientActiveVertexStreamATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClientActiveVertexStreamATI == loader_glClientActiveVertexStreamATI) {
      rCtx->dsp->emuTbl.glClientActiveVertexStreamATI = driverTbl.glClientActiveVertexStreamATI;
   }
   driverTbl.glClientActiveVertexStreamATI(stream);
}

static void REGAL_CALL missing_glNormalStream3bATI(GLenum stream, GLbyte x, GLbyte y, GLbyte z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glNormalStream3bATI not available." );
}

static void REGAL_CALL loader_glNormalStream3bATI(GLenum stream, GLbyte x, GLbyte y, GLbyte z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalStream3bATI, "glNormalStream3bATI");
   if ( !driverTbl.glNormalStream3bATI ) {
      driverTbl.glNormalStream3bATI = missing_glNormalStream3bATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalStream3bATI == loader_glNormalStream3bATI) {
      rCtx->dsp->emuTbl.glNormalStream3bATI = driverTbl.glNormalStream3bATI;
   }
   driverTbl.glNormalStream3bATI(stream, x, y, z);
}

static void REGAL_CALL missing_glNormalStream3bvATI(GLenum stream, const GLbyte *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glNormalStream3bvATI not available." );
}

static void REGAL_CALL loader_glNormalStream3bvATI(GLenum stream, const GLbyte *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalStream3bvATI, "glNormalStream3bvATI");
   if ( !driverTbl.glNormalStream3bvATI ) {
      driverTbl.glNormalStream3bvATI = missing_glNormalStream3bvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalStream3bvATI == loader_glNormalStream3bvATI) {
      rCtx->dsp->emuTbl.glNormalStream3bvATI = driverTbl.glNormalStream3bvATI;
   }
   driverTbl.glNormalStream3bvATI(stream, coords);
}

static void REGAL_CALL missing_glNormalStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glNormalStream3dATI not available." );
}

static void REGAL_CALL loader_glNormalStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalStream3dATI, "glNormalStream3dATI");
   if ( !driverTbl.glNormalStream3dATI ) {
      driverTbl.glNormalStream3dATI = missing_glNormalStream3dATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalStream3dATI == loader_glNormalStream3dATI) {
      rCtx->dsp->emuTbl.glNormalStream3dATI = driverTbl.glNormalStream3dATI;
   }
   driverTbl.glNormalStream3dATI(stream, x, y, z);
}

static void REGAL_CALL missing_glNormalStream3dvATI(GLenum stream, const GLdouble *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glNormalStream3dvATI not available." );
}

static void REGAL_CALL loader_glNormalStream3dvATI(GLenum stream, const GLdouble *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalStream3dvATI, "glNormalStream3dvATI");
   if ( !driverTbl.glNormalStream3dvATI ) {
      driverTbl.glNormalStream3dvATI = missing_glNormalStream3dvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalStream3dvATI == loader_glNormalStream3dvATI) {
      rCtx->dsp->emuTbl.glNormalStream3dvATI = driverTbl.glNormalStream3dvATI;
   }
   driverTbl.glNormalStream3dvATI(stream, coords);
}

static void REGAL_CALL missing_glNormalStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glNormalStream3fATI not available." );
}

static void REGAL_CALL loader_glNormalStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalStream3fATI, "glNormalStream3fATI");
   if ( !driverTbl.glNormalStream3fATI ) {
      driverTbl.glNormalStream3fATI = missing_glNormalStream3fATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalStream3fATI == loader_glNormalStream3fATI) {
      rCtx->dsp->emuTbl.glNormalStream3fATI = driverTbl.glNormalStream3fATI;
   }
   driverTbl.glNormalStream3fATI(stream, x, y, z);
}

static void REGAL_CALL missing_glNormalStream3fvATI(GLenum stream, const GLfloat *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glNormalStream3fvATI not available." );
}

static void REGAL_CALL loader_glNormalStream3fvATI(GLenum stream, const GLfloat *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalStream3fvATI, "glNormalStream3fvATI");
   if ( !driverTbl.glNormalStream3fvATI ) {
      driverTbl.glNormalStream3fvATI = missing_glNormalStream3fvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalStream3fvATI == loader_glNormalStream3fvATI) {
      rCtx->dsp->emuTbl.glNormalStream3fvATI = driverTbl.glNormalStream3fvATI;
   }
   driverTbl.glNormalStream3fvATI(stream, coords);
}

static void REGAL_CALL missing_glNormalStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glNormalStream3iATI not available." );
}

static void REGAL_CALL loader_glNormalStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalStream3iATI, "glNormalStream3iATI");
   if ( !driverTbl.glNormalStream3iATI ) {
      driverTbl.glNormalStream3iATI = missing_glNormalStream3iATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalStream3iATI == loader_glNormalStream3iATI) {
      rCtx->dsp->emuTbl.glNormalStream3iATI = driverTbl.glNormalStream3iATI;
   }
   driverTbl.glNormalStream3iATI(stream, x, y, z);
}

static void REGAL_CALL missing_glNormalStream3ivATI(GLenum stream, const GLint *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glNormalStream3ivATI not available." );
}

static void REGAL_CALL loader_glNormalStream3ivATI(GLenum stream, const GLint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalStream3ivATI, "glNormalStream3ivATI");
   if ( !driverTbl.glNormalStream3ivATI ) {
      driverTbl.glNormalStream3ivATI = missing_glNormalStream3ivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalStream3ivATI == loader_glNormalStream3ivATI) {
      rCtx->dsp->emuTbl.glNormalStream3ivATI = driverTbl.glNormalStream3ivATI;
   }
   driverTbl.glNormalStream3ivATI(stream, coords);
}

static void REGAL_CALL missing_glNormalStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glNormalStream3sATI not available." );
}

static void REGAL_CALL loader_glNormalStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalStream3sATI, "glNormalStream3sATI");
   if ( !driverTbl.glNormalStream3sATI ) {
      driverTbl.glNormalStream3sATI = missing_glNormalStream3sATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalStream3sATI == loader_glNormalStream3sATI) {
      rCtx->dsp->emuTbl.glNormalStream3sATI = driverTbl.glNormalStream3sATI;
   }
   driverTbl.glNormalStream3sATI(stream, x, y, z);
}

static void REGAL_CALL missing_glNormalStream3svATI(GLenum stream, const GLshort *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glNormalStream3svATI not available." );
}

static void REGAL_CALL loader_glNormalStream3svATI(GLenum stream, const GLshort *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalStream3svATI, "glNormalStream3svATI");
   if ( !driverTbl.glNormalStream3svATI ) {
      driverTbl.glNormalStream3svATI = missing_glNormalStream3svATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalStream3svATI == loader_glNormalStream3svATI) {
      rCtx->dsp->emuTbl.glNormalStream3svATI = driverTbl.glNormalStream3svATI;
   }
   driverTbl.glNormalStream3svATI(stream, coords);
}

static void REGAL_CALL missing_glVertexBlendEnvfATI(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glVertexBlendEnvfATI not available." );
}

static void REGAL_CALL loader_glVertexBlendEnvfATI(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexBlendEnvfATI, "glVertexBlendEnvfATI");
   if ( !driverTbl.glVertexBlendEnvfATI ) {
      driverTbl.glVertexBlendEnvfATI = missing_glVertexBlendEnvfATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexBlendEnvfATI == loader_glVertexBlendEnvfATI) {
      rCtx->dsp->emuTbl.glVertexBlendEnvfATI = driverTbl.glVertexBlendEnvfATI;
   }
   driverTbl.glVertexBlendEnvfATI(pname, param);
}

static void REGAL_CALL missing_glVertexBlendEnviATI(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glVertexBlendEnviATI not available." );
}

static void REGAL_CALL loader_glVertexBlendEnviATI(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexBlendEnviATI, "glVertexBlendEnviATI");
   if ( !driverTbl.glVertexBlendEnviATI ) {
      driverTbl.glVertexBlendEnviATI = missing_glVertexBlendEnviATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexBlendEnviATI == loader_glVertexBlendEnviATI) {
      rCtx->dsp->emuTbl.glVertexBlendEnviATI = driverTbl.glVertexBlendEnviATI;
   }
   driverTbl.glVertexBlendEnviATI(pname, param);
}

static void REGAL_CALL missing_glVertexStream1dATI(GLenum stream, GLdouble x)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   Warning( "glVertexStream1dATI not available." );
}

static void REGAL_CALL loader_glVertexStream1dATI(GLenum stream, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream1dATI, "glVertexStream1dATI");
   if ( !driverTbl.glVertexStream1dATI ) {
      driverTbl.glVertexStream1dATI = missing_glVertexStream1dATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream1dATI == loader_glVertexStream1dATI) {
      rCtx->dsp->emuTbl.glVertexStream1dATI = driverTbl.glVertexStream1dATI;
   }
   driverTbl.glVertexStream1dATI(stream, x);
}

static void REGAL_CALL missing_glVertexStream1dvATI(GLenum stream, const GLdouble *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream1dvATI not available." );
}

static void REGAL_CALL loader_glVertexStream1dvATI(GLenum stream, const GLdouble *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream1dvATI, "glVertexStream1dvATI");
   if ( !driverTbl.glVertexStream1dvATI ) {
      driverTbl.glVertexStream1dvATI = missing_glVertexStream1dvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream1dvATI == loader_glVertexStream1dvATI) {
      rCtx->dsp->emuTbl.glVertexStream1dvATI = driverTbl.glVertexStream1dvATI;
   }
   driverTbl.glVertexStream1dvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream1fATI(GLenum stream, GLfloat x)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   Warning( "glVertexStream1fATI not available." );
}

static void REGAL_CALL loader_glVertexStream1fATI(GLenum stream, GLfloat x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream1fATI, "glVertexStream1fATI");
   if ( !driverTbl.glVertexStream1fATI ) {
      driverTbl.glVertexStream1fATI = missing_glVertexStream1fATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream1fATI == loader_glVertexStream1fATI) {
      rCtx->dsp->emuTbl.glVertexStream1fATI = driverTbl.glVertexStream1fATI;
   }
   driverTbl.glVertexStream1fATI(stream, x);
}

static void REGAL_CALL missing_glVertexStream1fvATI(GLenum stream, const GLfloat *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream1fvATI not available." );
}

static void REGAL_CALL loader_glVertexStream1fvATI(GLenum stream, const GLfloat *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream1fvATI, "glVertexStream1fvATI");
   if ( !driverTbl.glVertexStream1fvATI ) {
      driverTbl.glVertexStream1fvATI = missing_glVertexStream1fvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream1fvATI == loader_glVertexStream1fvATI) {
      rCtx->dsp->emuTbl.glVertexStream1fvATI = driverTbl.glVertexStream1fvATI;
   }
   driverTbl.glVertexStream1fvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream1iATI(GLenum stream, GLint x)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   Warning( "glVertexStream1iATI not available." );
}

static void REGAL_CALL loader_glVertexStream1iATI(GLenum stream, GLint x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream1iATI, "glVertexStream1iATI");
   if ( !driverTbl.glVertexStream1iATI ) {
      driverTbl.glVertexStream1iATI = missing_glVertexStream1iATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream1iATI == loader_glVertexStream1iATI) {
      rCtx->dsp->emuTbl.glVertexStream1iATI = driverTbl.glVertexStream1iATI;
   }
   driverTbl.glVertexStream1iATI(stream, x);
}

static void REGAL_CALL missing_glVertexStream1ivATI(GLenum stream, const GLint *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream1ivATI not available." );
}

static void REGAL_CALL loader_glVertexStream1ivATI(GLenum stream, const GLint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream1ivATI, "glVertexStream1ivATI");
   if ( !driverTbl.glVertexStream1ivATI ) {
      driverTbl.glVertexStream1ivATI = missing_glVertexStream1ivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream1ivATI == loader_glVertexStream1ivATI) {
      rCtx->dsp->emuTbl.glVertexStream1ivATI = driverTbl.glVertexStream1ivATI;
   }
   driverTbl.glVertexStream1ivATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream1sATI(GLenum stream, GLshort x)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   Warning( "glVertexStream1sATI not available." );
}

static void REGAL_CALL loader_glVertexStream1sATI(GLenum stream, GLshort x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream1sATI, "glVertexStream1sATI");
   if ( !driverTbl.glVertexStream1sATI ) {
      driverTbl.glVertexStream1sATI = missing_glVertexStream1sATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream1sATI == loader_glVertexStream1sATI) {
      rCtx->dsp->emuTbl.glVertexStream1sATI = driverTbl.glVertexStream1sATI;
   }
   driverTbl.glVertexStream1sATI(stream, x);
}

static void REGAL_CALL missing_glVertexStream1svATI(GLenum stream, const GLshort *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream1svATI not available." );
}

static void REGAL_CALL loader_glVertexStream1svATI(GLenum stream, const GLshort *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream1svATI, "glVertexStream1svATI");
   if ( !driverTbl.glVertexStream1svATI ) {
      driverTbl.glVertexStream1svATI = missing_glVertexStream1svATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream1svATI == loader_glVertexStream1svATI) {
      rCtx->dsp->emuTbl.glVertexStream1svATI = driverTbl.glVertexStream1svATI;
   }
   driverTbl.glVertexStream1svATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexStream2dATI not available." );
}

static void REGAL_CALL loader_glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream2dATI, "glVertexStream2dATI");
   if ( !driverTbl.glVertexStream2dATI ) {
      driverTbl.glVertexStream2dATI = missing_glVertexStream2dATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream2dATI == loader_glVertexStream2dATI) {
      rCtx->dsp->emuTbl.glVertexStream2dATI = driverTbl.glVertexStream2dATI;
   }
   driverTbl.glVertexStream2dATI(stream, x, y);
}

static void REGAL_CALL missing_glVertexStream2dvATI(GLenum stream, const GLdouble *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream2dvATI not available." );
}

static void REGAL_CALL loader_glVertexStream2dvATI(GLenum stream, const GLdouble *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream2dvATI, "glVertexStream2dvATI");
   if ( !driverTbl.glVertexStream2dvATI ) {
      driverTbl.glVertexStream2dvATI = missing_glVertexStream2dvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream2dvATI == loader_glVertexStream2dvATI) {
      rCtx->dsp->emuTbl.glVertexStream2dvATI = driverTbl.glVertexStream2dvATI;
   }
   driverTbl.glVertexStream2dvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexStream2fATI not available." );
}

static void REGAL_CALL loader_glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream2fATI, "glVertexStream2fATI");
   if ( !driverTbl.glVertexStream2fATI ) {
      driverTbl.glVertexStream2fATI = missing_glVertexStream2fATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream2fATI == loader_glVertexStream2fATI) {
      rCtx->dsp->emuTbl.glVertexStream2fATI = driverTbl.glVertexStream2fATI;
   }
   driverTbl.glVertexStream2fATI(stream, x, y);
}

static void REGAL_CALL missing_glVertexStream2fvATI(GLenum stream, const GLfloat *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream2fvATI not available." );
}

static void REGAL_CALL loader_glVertexStream2fvATI(GLenum stream, const GLfloat *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream2fvATI, "glVertexStream2fvATI");
   if ( !driverTbl.glVertexStream2fvATI ) {
      driverTbl.glVertexStream2fvATI = missing_glVertexStream2fvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream2fvATI == loader_glVertexStream2fvATI) {
      rCtx->dsp->emuTbl.glVertexStream2fvATI = driverTbl.glVertexStream2fvATI;
   }
   driverTbl.glVertexStream2fvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream2iATI(GLenum stream, GLint x, GLint y)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexStream2iATI not available." );
}

static void REGAL_CALL loader_glVertexStream2iATI(GLenum stream, GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream2iATI, "glVertexStream2iATI");
   if ( !driverTbl.glVertexStream2iATI ) {
      driverTbl.glVertexStream2iATI = missing_glVertexStream2iATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream2iATI == loader_glVertexStream2iATI) {
      rCtx->dsp->emuTbl.glVertexStream2iATI = driverTbl.glVertexStream2iATI;
   }
   driverTbl.glVertexStream2iATI(stream, x, y);
}

static void REGAL_CALL missing_glVertexStream2ivATI(GLenum stream, const GLint *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream2ivATI not available." );
}

static void REGAL_CALL loader_glVertexStream2ivATI(GLenum stream, const GLint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream2ivATI, "glVertexStream2ivATI");
   if ( !driverTbl.glVertexStream2ivATI ) {
      driverTbl.glVertexStream2ivATI = missing_glVertexStream2ivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream2ivATI == loader_glVertexStream2ivATI) {
      rCtx->dsp->emuTbl.glVertexStream2ivATI = driverTbl.glVertexStream2ivATI;
   }
   driverTbl.glVertexStream2ivATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream2sATI(GLenum stream, GLshort x, GLshort y)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexStream2sATI not available." );
}

static void REGAL_CALL loader_glVertexStream2sATI(GLenum stream, GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream2sATI, "glVertexStream2sATI");
   if ( !driverTbl.glVertexStream2sATI ) {
      driverTbl.glVertexStream2sATI = missing_glVertexStream2sATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream2sATI == loader_glVertexStream2sATI) {
      rCtx->dsp->emuTbl.glVertexStream2sATI = driverTbl.glVertexStream2sATI;
   }
   driverTbl.glVertexStream2sATI(stream, x, y);
}

static void REGAL_CALL missing_glVertexStream2svATI(GLenum stream, const GLshort *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream2svATI not available." );
}

static void REGAL_CALL loader_glVertexStream2svATI(GLenum stream, const GLshort *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream2svATI, "glVertexStream2svATI");
   if ( !driverTbl.glVertexStream2svATI ) {
      driverTbl.glVertexStream2svATI = missing_glVertexStream2svATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream2svATI == loader_glVertexStream2svATI) {
      rCtx->dsp->emuTbl.glVertexStream2svATI = driverTbl.glVertexStream2svATI;
   }
   driverTbl.glVertexStream2svATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexStream3dATI not available." );
}

static void REGAL_CALL loader_glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream3dATI, "glVertexStream3dATI");
   if ( !driverTbl.glVertexStream3dATI ) {
      driverTbl.glVertexStream3dATI = missing_glVertexStream3dATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream3dATI == loader_glVertexStream3dATI) {
      rCtx->dsp->emuTbl.glVertexStream3dATI = driverTbl.glVertexStream3dATI;
   }
   driverTbl.glVertexStream3dATI(stream, x, y, z);
}

static void REGAL_CALL missing_glVertexStream3dvATI(GLenum stream, const GLdouble *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream3dvATI not available." );
}

static void REGAL_CALL loader_glVertexStream3dvATI(GLenum stream, const GLdouble *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream3dvATI, "glVertexStream3dvATI");
   if ( !driverTbl.glVertexStream3dvATI ) {
      driverTbl.glVertexStream3dvATI = missing_glVertexStream3dvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream3dvATI == loader_glVertexStream3dvATI) {
      rCtx->dsp->emuTbl.glVertexStream3dvATI = driverTbl.glVertexStream3dvATI;
   }
   driverTbl.glVertexStream3dvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexStream3fATI not available." );
}

static void REGAL_CALL loader_glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream3fATI, "glVertexStream3fATI");
   if ( !driverTbl.glVertexStream3fATI ) {
      driverTbl.glVertexStream3fATI = missing_glVertexStream3fATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream3fATI == loader_glVertexStream3fATI) {
      rCtx->dsp->emuTbl.glVertexStream3fATI = driverTbl.glVertexStream3fATI;
   }
   driverTbl.glVertexStream3fATI(stream, x, y, z);
}

static void REGAL_CALL missing_glVertexStream3fvATI(GLenum stream, const GLfloat *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream3fvATI not available." );
}

static void REGAL_CALL loader_glVertexStream3fvATI(GLenum stream, const GLfloat *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream3fvATI, "glVertexStream3fvATI");
   if ( !driverTbl.glVertexStream3fvATI ) {
      driverTbl.glVertexStream3fvATI = missing_glVertexStream3fvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream3fvATI == loader_glVertexStream3fvATI) {
      rCtx->dsp->emuTbl.glVertexStream3fvATI = driverTbl.glVertexStream3fvATI;
   }
   driverTbl.glVertexStream3fvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexStream3iATI not available." );
}

static void REGAL_CALL loader_glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream3iATI, "glVertexStream3iATI");
   if ( !driverTbl.glVertexStream3iATI ) {
      driverTbl.glVertexStream3iATI = missing_glVertexStream3iATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream3iATI == loader_glVertexStream3iATI) {
      rCtx->dsp->emuTbl.glVertexStream3iATI = driverTbl.glVertexStream3iATI;
   }
   driverTbl.glVertexStream3iATI(stream, x, y, z);
}

static void REGAL_CALL missing_glVertexStream3ivATI(GLenum stream, const GLint *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream3ivATI not available." );
}

static void REGAL_CALL loader_glVertexStream3ivATI(GLenum stream, const GLint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream3ivATI, "glVertexStream3ivATI");
   if ( !driverTbl.glVertexStream3ivATI ) {
      driverTbl.glVertexStream3ivATI = missing_glVertexStream3ivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream3ivATI == loader_glVertexStream3ivATI) {
      rCtx->dsp->emuTbl.glVertexStream3ivATI = driverTbl.glVertexStream3ivATI;
   }
   driverTbl.glVertexStream3ivATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexStream3sATI not available." );
}

static void REGAL_CALL loader_glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream3sATI, "glVertexStream3sATI");
   if ( !driverTbl.glVertexStream3sATI ) {
      driverTbl.glVertexStream3sATI = missing_glVertexStream3sATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream3sATI == loader_glVertexStream3sATI) {
      rCtx->dsp->emuTbl.glVertexStream3sATI = driverTbl.glVertexStream3sATI;
   }
   driverTbl.glVertexStream3sATI(stream, x, y, z);
}

static void REGAL_CALL missing_glVertexStream3svATI(GLenum stream, const GLshort *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream3svATI not available." );
}

static void REGAL_CALL loader_glVertexStream3svATI(GLenum stream, const GLshort *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream3svATI, "glVertexStream3svATI");
   if ( !driverTbl.glVertexStream3svATI ) {
      driverTbl.glVertexStream3svATI = missing_glVertexStream3svATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream3svATI == loader_glVertexStream3svATI) {
      rCtx->dsp->emuTbl.glVertexStream3svATI = driverTbl.glVertexStream3svATI;
   }
   driverTbl.glVertexStream3svATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexStream4dATI not available." );
}

static void REGAL_CALL loader_glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream4dATI, "glVertexStream4dATI");
   if ( !driverTbl.glVertexStream4dATI ) {
      driverTbl.glVertexStream4dATI = missing_glVertexStream4dATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream4dATI == loader_glVertexStream4dATI) {
      rCtx->dsp->emuTbl.glVertexStream4dATI = driverTbl.glVertexStream4dATI;
   }
   driverTbl.glVertexStream4dATI(stream, x, y, z, w);
}

static void REGAL_CALL missing_glVertexStream4dvATI(GLenum stream, const GLdouble *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream4dvATI not available." );
}

static void REGAL_CALL loader_glVertexStream4dvATI(GLenum stream, const GLdouble *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream4dvATI, "glVertexStream4dvATI");
   if ( !driverTbl.glVertexStream4dvATI ) {
      driverTbl.glVertexStream4dvATI = missing_glVertexStream4dvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream4dvATI == loader_glVertexStream4dvATI) {
      rCtx->dsp->emuTbl.glVertexStream4dvATI = driverTbl.glVertexStream4dvATI;
   }
   driverTbl.glVertexStream4dvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexStream4fATI not available." );
}

static void REGAL_CALL loader_glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream4fATI, "glVertexStream4fATI");
   if ( !driverTbl.glVertexStream4fATI ) {
      driverTbl.glVertexStream4fATI = missing_glVertexStream4fATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream4fATI == loader_glVertexStream4fATI) {
      rCtx->dsp->emuTbl.glVertexStream4fATI = driverTbl.glVertexStream4fATI;
   }
   driverTbl.glVertexStream4fATI(stream, x, y, z, w);
}

static void REGAL_CALL missing_glVertexStream4fvATI(GLenum stream, const GLfloat *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream4fvATI not available." );
}

static void REGAL_CALL loader_glVertexStream4fvATI(GLenum stream, const GLfloat *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream4fvATI, "glVertexStream4fvATI");
   if ( !driverTbl.glVertexStream4fvATI ) {
      driverTbl.glVertexStream4fvATI = missing_glVertexStream4fvATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream4fvATI == loader_glVertexStream4fvATI) {
      rCtx->dsp->emuTbl.glVertexStream4fvATI = driverTbl.glVertexStream4fvATI;
   }
   driverTbl.glVertexStream4fvATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexStream4iATI not available." );
}

static void REGAL_CALL loader_glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream4iATI, "glVertexStream4iATI");
   if ( !driverTbl.glVertexStream4iATI ) {
      driverTbl.glVertexStream4iATI = missing_glVertexStream4iATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream4iATI == loader_glVertexStream4iATI) {
      rCtx->dsp->emuTbl.glVertexStream4iATI = driverTbl.glVertexStream4iATI;
   }
   driverTbl.glVertexStream4iATI(stream, x, y, z, w);
}

static void REGAL_CALL missing_glVertexStream4ivATI(GLenum stream, const GLint *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream4ivATI not available." );
}

static void REGAL_CALL loader_glVertexStream4ivATI(GLenum stream, const GLint *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream4ivATI, "glVertexStream4ivATI");
   if ( !driverTbl.glVertexStream4ivATI ) {
      driverTbl.glVertexStream4ivATI = missing_glVertexStream4ivATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream4ivATI == loader_glVertexStream4ivATI) {
      rCtx->dsp->emuTbl.glVertexStream4ivATI = driverTbl.glVertexStream4ivATI;
   }
   driverTbl.glVertexStream4ivATI(stream, coords);
}

static void REGAL_CALL missing_glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexStream4sATI not available." );
}

static void REGAL_CALL loader_glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream4sATI, "glVertexStream4sATI");
   if ( !driverTbl.glVertexStream4sATI ) {
      driverTbl.glVertexStream4sATI = missing_glVertexStream4sATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream4sATI == loader_glVertexStream4sATI) {
      rCtx->dsp->emuTbl.glVertexStream4sATI = driverTbl.glVertexStream4sATI;
   }
   driverTbl.glVertexStream4sATI(stream, x, y, z, w);
}

static void REGAL_CALL missing_glVertexStream4svATI(GLenum stream, const GLshort *coords)
{
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(coords);
   Warning( "glVertexStream4svATI not available." );
}

static void REGAL_CALL loader_glVertexStream4svATI(GLenum stream, const GLshort *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexStream4svATI, "glVertexStream4svATI");
   if ( !driverTbl.glVertexStream4svATI ) {
      driverTbl.glVertexStream4svATI = missing_glVertexStream4svATI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexStream4svATI == loader_glVertexStream4svATI) {
      rCtx->dsp->emuTbl.glVertexStream4svATI = driverTbl.glVertexStream4svATI;
   }
   driverTbl.glVertexStream4svATI(stream, coords);
}

// GL_EXT_bindable_uniform

static GLint REGAL_CALL missing_glGetUniformBufferSizeEXT(GLuint program, GLint location)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   Warning( "glGetUniformBufferSizeEXT not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetUniformBufferSizeEXT(GLuint program, GLint location)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformBufferSizeEXT, "glGetUniformBufferSizeEXT");
   if ( !driverTbl.glGetUniformBufferSizeEXT ) {
      driverTbl.glGetUniformBufferSizeEXT = missing_glGetUniformBufferSizeEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformBufferSizeEXT == loader_glGetUniformBufferSizeEXT) {
      rCtx->dsp->emuTbl.glGetUniformBufferSizeEXT = driverTbl.glGetUniformBufferSizeEXT;
   }
   return driverTbl.glGetUniformBufferSizeEXT(program, location);
}

static GLintptr REGAL_CALL missing_glGetUniformOffsetEXT(GLuint program, GLint location)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   Warning( "glGetUniformOffsetEXT not available." );
  GLintptr  ret = (GLintptr )0;
  return ret;
}

static GLintptr REGAL_CALL loader_glGetUniformOffsetEXT(GLuint program, GLint location)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformOffsetEXT, "glGetUniformOffsetEXT");
   if ( !driverTbl.glGetUniformOffsetEXT ) {
      driverTbl.glGetUniformOffsetEXT = missing_glGetUniformOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformOffsetEXT == loader_glGetUniformOffsetEXT) {
      rCtx->dsp->emuTbl.glGetUniformOffsetEXT = driverTbl.glGetUniformOffsetEXT;
   }
   return driverTbl.glGetUniformOffsetEXT(program, location);
}

static void REGAL_CALL missing_glUniformBufferEXT(GLuint program, GLint location, GLuint buffer)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(buffer);
   Warning( "glUniformBufferEXT not available." );
}

static void REGAL_CALL loader_glUniformBufferEXT(GLuint program, GLint location, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformBufferEXT, "glUniformBufferEXT");
   if ( !driverTbl.glUniformBufferEXT ) {
      driverTbl.glUniformBufferEXT = missing_glUniformBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformBufferEXT == loader_glUniformBufferEXT) {
      rCtx->dsp->emuTbl.glUniformBufferEXT = driverTbl.glUniformBufferEXT;
   }
   driverTbl.glUniformBufferEXT(program, location, buffer);
}

// GL_EXT_blend_color

static void REGAL_CALL missing_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glBlendColorEXT not available." );
}

static void REGAL_CALL loader_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendColorEXT, "glBlendColorEXT");
   if ( !driverTbl.glBlendColorEXT ) {
      driverTbl.glBlendColorEXT = missing_glBlendColorEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendColorEXT == loader_glBlendColorEXT) {
      rCtx->dsp->emuTbl.glBlendColorEXT = driverTbl.glBlendColorEXT;
   }
   driverTbl.glBlendColorEXT(red, green, blue, alpha);
}

// GL_EXT_blend_equation_separate

static void REGAL_CALL missing_glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha)
{
   UNUSED_PARAMETER(modeRGB);
   UNUSED_PARAMETER(modeAlpha);
   Warning( "glBlendEquationSeparateEXT not available." );
}

static void REGAL_CALL loader_glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendEquationSeparateEXT, "glBlendEquationSeparateEXT");
   if ( !driverTbl.glBlendEquationSeparateEXT ) {
      driverTbl.glBlendEquationSeparateEXT = missing_glBlendEquationSeparateEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendEquationSeparateEXT == loader_glBlendEquationSeparateEXT) {
      rCtx->dsp->emuTbl.glBlendEquationSeparateEXT = driverTbl.glBlendEquationSeparateEXT;
   }
   driverTbl.glBlendEquationSeparateEXT(modeRGB, modeAlpha);
}

// GL_EXT_blend_func_separate

static void REGAL_CALL missing_glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
   UNUSED_PARAMETER(sfactorRGB);
   UNUSED_PARAMETER(dfactorRGB);
   UNUSED_PARAMETER(sfactorAlpha);
   UNUSED_PARAMETER(dfactorAlpha);
   Warning( "glBlendFuncSeparateEXT not available." );
}

static void REGAL_CALL loader_glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendFuncSeparateEXT, "glBlendFuncSeparateEXT");
   if ( !driverTbl.glBlendFuncSeparateEXT ) {
      driverTbl.glBlendFuncSeparateEXT = missing_glBlendFuncSeparateEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendFuncSeparateEXT == loader_glBlendFuncSeparateEXT) {
      rCtx->dsp->emuTbl.glBlendFuncSeparateEXT = driverTbl.glBlendFuncSeparateEXT;
   }
   driverTbl.glBlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

// GL_EXT_blend_minmax

static void REGAL_CALL missing_glBlendEquationEXT(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glBlendEquationEXT not available." );
}

static void REGAL_CALL loader_glBlendEquationEXT(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendEquationEXT, "glBlendEquationEXT");
   if ( !driverTbl.glBlendEquationEXT ) {
      driverTbl.glBlendEquationEXT = missing_glBlendEquationEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendEquationEXT == loader_glBlendEquationEXT) {
      rCtx->dsp->emuTbl.glBlendEquationEXT = driverTbl.glBlendEquationEXT;
   }
   driverTbl.glBlendEquationEXT(mode);
}

// GL_EXT_color_subtable

static void REGAL_CALL missing_glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *table)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(table);
   Warning( "glColorSubTableEXT not available." );
}

static void REGAL_CALL loader_glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *table)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorSubTableEXT, "glColorSubTableEXT");
   if ( !driverTbl.glColorSubTableEXT ) {
      driverTbl.glColorSubTableEXT = missing_glColorSubTableEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorSubTableEXT == loader_glColorSubTableEXT) {
      rCtx->dsp->emuTbl.glColorSubTableEXT = driverTbl.glColorSubTableEXT;
   }
   driverTbl.glColorSubTableEXT(target, start, count, format, type, table);
}

static void REGAL_CALL missing_glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "glCopyColorSubTableEXT not available." );
}

static void REGAL_CALL loader_glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyColorSubTableEXT, "glCopyColorSubTableEXT");
   if ( !driverTbl.glCopyColorSubTableEXT ) {
      driverTbl.glCopyColorSubTableEXT = missing_glCopyColorSubTableEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyColorSubTableEXT == loader_glCopyColorSubTableEXT) {
      rCtx->dsp->emuTbl.glCopyColorSubTableEXT = driverTbl.glCopyColorSubTableEXT;
   }
   driverTbl.glCopyColorSubTableEXT(target, start, x, y, width);
}

// GL_EXT_compiled_vertex_array

static void REGAL_CALL missing_glLockArraysEXT(GLint first, GLsizei count)
{
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   Warning( "glLockArraysEXT not available." );
}

static void REGAL_CALL loader_glLockArraysEXT(GLint first, GLsizei count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLockArraysEXT, "glLockArraysEXT");
   if ( !driverTbl.glLockArraysEXT ) {
      driverTbl.glLockArraysEXT = missing_glLockArraysEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLockArraysEXT == loader_glLockArraysEXT) {
      rCtx->dsp->emuTbl.glLockArraysEXT = driverTbl.glLockArraysEXT;
   }
   driverTbl.glLockArraysEXT(first, count);
}

static void REGAL_CALL missing_glUnlockArraysEXT(void)
{
   Warning( "glUnlockArraysEXT not available." );
}

static void REGAL_CALL loader_glUnlockArraysEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUnlockArraysEXT, "glUnlockArraysEXT");
   if ( !driverTbl.glUnlockArraysEXT ) {
      driverTbl.glUnlockArraysEXT = missing_glUnlockArraysEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUnlockArraysEXT == loader_glUnlockArraysEXT) {
      rCtx->dsp->emuTbl.glUnlockArraysEXT = driverTbl.glUnlockArraysEXT;
   }
   driverTbl.glUnlockArraysEXT();
}

// GL_EXT_convolution

static void REGAL_CALL missing_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(image);
   Warning( "glConvolutionFilter1DEXT not available." );
}

static void REGAL_CALL loader_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glConvolutionFilter1DEXT, "glConvolutionFilter1DEXT");
   if ( !driverTbl.glConvolutionFilter1DEXT ) {
      driverTbl.glConvolutionFilter1DEXT = missing_glConvolutionFilter1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glConvolutionFilter1DEXT == loader_glConvolutionFilter1DEXT) {
      rCtx->dsp->emuTbl.glConvolutionFilter1DEXT = driverTbl.glConvolutionFilter1DEXT;
   }
   driverTbl.glConvolutionFilter1DEXT(target, internalformat, width, format, type, image);
}

static void REGAL_CALL missing_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(image);
   Warning( "glConvolutionFilter2DEXT not available." );
}

static void REGAL_CALL loader_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glConvolutionFilter2DEXT, "glConvolutionFilter2DEXT");
   if ( !driverTbl.glConvolutionFilter2DEXT ) {
      driverTbl.glConvolutionFilter2DEXT = missing_glConvolutionFilter2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glConvolutionFilter2DEXT == loader_glConvolutionFilter2DEXT) {
      rCtx->dsp->emuTbl.glConvolutionFilter2DEXT = driverTbl.glConvolutionFilter2DEXT;
   }
   driverTbl.glConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image);
}

static void REGAL_CALL missing_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glConvolutionParameterfEXT not available." );
}

static void REGAL_CALL loader_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glConvolutionParameterfEXT, "glConvolutionParameterfEXT");
   if ( !driverTbl.glConvolutionParameterfEXT ) {
      driverTbl.glConvolutionParameterfEXT = missing_glConvolutionParameterfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glConvolutionParameterfEXT == loader_glConvolutionParameterfEXT) {
      rCtx->dsp->emuTbl.glConvolutionParameterfEXT = driverTbl.glConvolutionParameterfEXT;
   }
   driverTbl.glConvolutionParameterfEXT(target, pname, param);
}

static void REGAL_CALL missing_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glConvolutionParameterfvEXT not available." );
}

static void REGAL_CALL loader_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glConvolutionParameterfvEXT, "glConvolutionParameterfvEXT");
   if ( !driverTbl.glConvolutionParameterfvEXT ) {
      driverTbl.glConvolutionParameterfvEXT = missing_glConvolutionParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glConvolutionParameterfvEXT == loader_glConvolutionParameterfvEXT) {
      rCtx->dsp->emuTbl.glConvolutionParameterfvEXT = driverTbl.glConvolutionParameterfvEXT;
   }
   driverTbl.glConvolutionParameterfvEXT(target, pname, params);
}

static void REGAL_CALL missing_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glConvolutionParameteriEXT not available." );
}

static void REGAL_CALL loader_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glConvolutionParameteriEXT, "glConvolutionParameteriEXT");
   if ( !driverTbl.glConvolutionParameteriEXT ) {
      driverTbl.glConvolutionParameteriEXT = missing_glConvolutionParameteriEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glConvolutionParameteriEXT == loader_glConvolutionParameteriEXT) {
      rCtx->dsp->emuTbl.glConvolutionParameteriEXT = driverTbl.glConvolutionParameteriEXT;
   }
   driverTbl.glConvolutionParameteriEXT(target, pname, param);
}

static void REGAL_CALL missing_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glConvolutionParameterivEXT not available." );
}

static void REGAL_CALL loader_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glConvolutionParameterivEXT, "glConvolutionParameterivEXT");
   if ( !driverTbl.glConvolutionParameterivEXT ) {
      driverTbl.glConvolutionParameterivEXT = missing_glConvolutionParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glConvolutionParameterivEXT == loader_glConvolutionParameterivEXT) {
      rCtx->dsp->emuTbl.glConvolutionParameterivEXT = driverTbl.glConvolutionParameterivEXT;
   }
   driverTbl.glConvolutionParameterivEXT(target, pname, params);
}

static void REGAL_CALL missing_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "glCopyConvolutionFilter1DEXT not available." );
}

static void REGAL_CALL loader_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyConvolutionFilter1DEXT, "glCopyConvolutionFilter1DEXT");
   if ( !driverTbl.glCopyConvolutionFilter1DEXT ) {
      driverTbl.glCopyConvolutionFilter1DEXT = missing_glCopyConvolutionFilter1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyConvolutionFilter1DEXT == loader_glCopyConvolutionFilter1DEXT) {
      rCtx->dsp->emuTbl.glCopyConvolutionFilter1DEXT = driverTbl.glCopyConvolutionFilter1DEXT;
   }
   driverTbl.glCopyConvolutionFilter1DEXT(target, internalformat, x, y, width);
}

static void REGAL_CALL missing_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glCopyConvolutionFilter2DEXT not available." );
}

static void REGAL_CALL loader_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyConvolutionFilter2DEXT, "glCopyConvolutionFilter2DEXT");
   if ( !driverTbl.glCopyConvolutionFilter2DEXT ) {
      driverTbl.glCopyConvolutionFilter2DEXT = missing_glCopyConvolutionFilter2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyConvolutionFilter2DEXT == loader_glCopyConvolutionFilter2DEXT) {
      rCtx->dsp->emuTbl.glCopyConvolutionFilter2DEXT = driverTbl.glCopyConvolutionFilter2DEXT;
   }
   driverTbl.glCopyConvolutionFilter2DEXT(target, internalformat, x, y, width, height);
}

static void REGAL_CALL missing_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(image);
   Warning( "glGetConvolutionFilterEXT not available." );
}

static void REGAL_CALL loader_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetConvolutionFilterEXT, "glGetConvolutionFilterEXT");
   if ( !driverTbl.glGetConvolutionFilterEXT ) {
      driverTbl.glGetConvolutionFilterEXT = missing_glGetConvolutionFilterEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetConvolutionFilterEXT == loader_glGetConvolutionFilterEXT) {
      rCtx->dsp->emuTbl.glGetConvolutionFilterEXT = driverTbl.glGetConvolutionFilterEXT;
   }
   driverTbl.glGetConvolutionFilterEXT(target, format, type, image);
}

static void REGAL_CALL missing_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetConvolutionParameterfvEXT not available." );
}

static void REGAL_CALL loader_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetConvolutionParameterfvEXT, "glGetConvolutionParameterfvEXT");
   if ( !driverTbl.glGetConvolutionParameterfvEXT ) {
      driverTbl.glGetConvolutionParameterfvEXT = missing_glGetConvolutionParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetConvolutionParameterfvEXT == loader_glGetConvolutionParameterfvEXT) {
      rCtx->dsp->emuTbl.glGetConvolutionParameterfvEXT = driverTbl.glGetConvolutionParameterfvEXT;
   }
   driverTbl.glGetConvolutionParameterfvEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetConvolutionParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetConvolutionParameterivEXT, "glGetConvolutionParameterivEXT");
   if ( !driverTbl.glGetConvolutionParameterivEXT ) {
      driverTbl.glGetConvolutionParameterivEXT = missing_glGetConvolutionParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetConvolutionParameterivEXT == loader_glGetConvolutionParameterivEXT) {
      rCtx->dsp->emuTbl.glGetConvolutionParameterivEXT = driverTbl.glGetConvolutionParameterivEXT;
   }
   driverTbl.glGetConvolutionParameterivEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(row);
   UNUSED_PARAMETER(column);
   UNUSED_PARAMETER(span);
   Warning( "glGetSeparableFilterEXT not available." );
}

static void REGAL_CALL loader_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetSeparableFilterEXT, "glGetSeparableFilterEXT");
   if ( !driverTbl.glGetSeparableFilterEXT ) {
      driverTbl.glGetSeparableFilterEXT = missing_glGetSeparableFilterEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetSeparableFilterEXT == loader_glGetSeparableFilterEXT) {
      rCtx->dsp->emuTbl.glGetSeparableFilterEXT = driverTbl.glGetSeparableFilterEXT;
   }
   driverTbl.glGetSeparableFilterEXT(target, format, type, row, column, span);
}

static void REGAL_CALL missing_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(row);
   UNUSED_PARAMETER(column);
   Warning( "glSeparableFilter2DEXT not available." );
}

static void REGAL_CALL loader_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSeparableFilter2DEXT, "glSeparableFilter2DEXT");
   if ( !driverTbl.glSeparableFilter2DEXT ) {
      driverTbl.glSeparableFilter2DEXT = missing_glSeparableFilter2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSeparableFilter2DEXT == loader_glSeparableFilter2DEXT) {
      rCtx->dsp->emuTbl.glSeparableFilter2DEXT = driverTbl.glSeparableFilter2DEXT;
   }
   driverTbl.glSeparableFilter2DEXT(target, internalformat, width, height, format, type, row, column);
}

// GL_EXT_coordinate_frame

static void REGAL_CALL missing_glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz)
{
   UNUSED_PARAMETER(bx);
   UNUSED_PARAMETER(by);
   UNUSED_PARAMETER(bz);
   Warning( "glBinormal3bEXT not available." );
}

static void REGAL_CALL loader_glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBinormal3bEXT, "glBinormal3bEXT");
   if ( !driverTbl.glBinormal3bEXT ) {
      driverTbl.glBinormal3bEXT = missing_glBinormal3bEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBinormal3bEXT == loader_glBinormal3bEXT) {
      rCtx->dsp->emuTbl.glBinormal3bEXT = driverTbl.glBinormal3bEXT;
   }
   driverTbl.glBinormal3bEXT(bx, by, bz);
}

static void REGAL_CALL missing_glBinormal3bvEXT(const GLbyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glBinormal3bvEXT not available." );
}

static void REGAL_CALL loader_glBinormal3bvEXT(const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBinormal3bvEXT, "glBinormal3bvEXT");
   if ( !driverTbl.glBinormal3bvEXT ) {
      driverTbl.glBinormal3bvEXT = missing_glBinormal3bvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBinormal3bvEXT == loader_glBinormal3bvEXT) {
      rCtx->dsp->emuTbl.glBinormal3bvEXT = driverTbl.glBinormal3bvEXT;
   }
   driverTbl.glBinormal3bvEXT(v);
}

static void REGAL_CALL missing_glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz)
{
   UNUSED_PARAMETER(bx);
   UNUSED_PARAMETER(by);
   UNUSED_PARAMETER(bz);
   Warning( "glBinormal3dEXT not available." );
}

static void REGAL_CALL loader_glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBinormal3dEXT, "glBinormal3dEXT");
   if ( !driverTbl.glBinormal3dEXT ) {
      driverTbl.glBinormal3dEXT = missing_glBinormal3dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBinormal3dEXT == loader_glBinormal3dEXT) {
      rCtx->dsp->emuTbl.glBinormal3dEXT = driverTbl.glBinormal3dEXT;
   }
   driverTbl.glBinormal3dEXT(bx, by, bz);
}

static void REGAL_CALL missing_glBinormal3dvEXT(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glBinormal3dvEXT not available." );
}

static void REGAL_CALL loader_glBinormal3dvEXT(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBinormal3dvEXT, "glBinormal3dvEXT");
   if ( !driverTbl.glBinormal3dvEXT ) {
      driverTbl.glBinormal3dvEXT = missing_glBinormal3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBinormal3dvEXT == loader_glBinormal3dvEXT) {
      rCtx->dsp->emuTbl.glBinormal3dvEXT = driverTbl.glBinormal3dvEXT;
   }
   driverTbl.glBinormal3dvEXT(v);
}

static void REGAL_CALL missing_glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz)
{
   UNUSED_PARAMETER(bx);
   UNUSED_PARAMETER(by);
   UNUSED_PARAMETER(bz);
   Warning( "glBinormal3fEXT not available." );
}

static void REGAL_CALL loader_glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBinormal3fEXT, "glBinormal3fEXT");
   if ( !driverTbl.glBinormal3fEXT ) {
      driverTbl.glBinormal3fEXT = missing_glBinormal3fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBinormal3fEXT == loader_glBinormal3fEXT) {
      rCtx->dsp->emuTbl.glBinormal3fEXT = driverTbl.glBinormal3fEXT;
   }
   driverTbl.glBinormal3fEXT(bx, by, bz);
}

static void REGAL_CALL missing_glBinormal3fvEXT(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glBinormal3fvEXT not available." );
}

static void REGAL_CALL loader_glBinormal3fvEXT(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBinormal3fvEXT, "glBinormal3fvEXT");
   if ( !driverTbl.glBinormal3fvEXT ) {
      driverTbl.glBinormal3fvEXT = missing_glBinormal3fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBinormal3fvEXT == loader_glBinormal3fvEXT) {
      rCtx->dsp->emuTbl.glBinormal3fvEXT = driverTbl.glBinormal3fvEXT;
   }
   driverTbl.glBinormal3fvEXT(v);
}

static void REGAL_CALL missing_glBinormal3iEXT(GLint bx, GLint by, GLint bz)
{
   UNUSED_PARAMETER(bx);
   UNUSED_PARAMETER(by);
   UNUSED_PARAMETER(bz);
   Warning( "glBinormal3iEXT not available." );
}

static void REGAL_CALL loader_glBinormal3iEXT(GLint bx, GLint by, GLint bz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBinormal3iEXT, "glBinormal3iEXT");
   if ( !driverTbl.glBinormal3iEXT ) {
      driverTbl.glBinormal3iEXT = missing_glBinormal3iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBinormal3iEXT == loader_glBinormal3iEXT) {
      rCtx->dsp->emuTbl.glBinormal3iEXT = driverTbl.glBinormal3iEXT;
   }
   driverTbl.glBinormal3iEXT(bx, by, bz);
}

static void REGAL_CALL missing_glBinormal3ivEXT(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glBinormal3ivEXT not available." );
}

static void REGAL_CALL loader_glBinormal3ivEXT(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBinormal3ivEXT, "glBinormal3ivEXT");
   if ( !driverTbl.glBinormal3ivEXT ) {
      driverTbl.glBinormal3ivEXT = missing_glBinormal3ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBinormal3ivEXT == loader_glBinormal3ivEXT) {
      rCtx->dsp->emuTbl.glBinormal3ivEXT = driverTbl.glBinormal3ivEXT;
   }
   driverTbl.glBinormal3ivEXT(v);
}

static void REGAL_CALL missing_glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz)
{
   UNUSED_PARAMETER(bx);
   UNUSED_PARAMETER(by);
   UNUSED_PARAMETER(bz);
   Warning( "glBinormal3sEXT not available." );
}

static void REGAL_CALL loader_glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBinormal3sEXT, "glBinormal3sEXT");
   if ( !driverTbl.glBinormal3sEXT ) {
      driverTbl.glBinormal3sEXT = missing_glBinormal3sEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBinormal3sEXT == loader_glBinormal3sEXT) {
      rCtx->dsp->emuTbl.glBinormal3sEXT = driverTbl.glBinormal3sEXT;
   }
   driverTbl.glBinormal3sEXT(bx, by, bz);
}

static void REGAL_CALL missing_glBinormal3svEXT(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glBinormal3svEXT not available." );
}

static void REGAL_CALL loader_glBinormal3svEXT(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBinormal3svEXT, "glBinormal3svEXT");
   if ( !driverTbl.glBinormal3svEXT ) {
      driverTbl.glBinormal3svEXT = missing_glBinormal3svEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBinormal3svEXT == loader_glBinormal3svEXT) {
      rCtx->dsp->emuTbl.glBinormal3svEXT = driverTbl.glBinormal3svEXT;
   }
   driverTbl.glBinormal3svEXT(v);
}

static void REGAL_CALL missing_glBinormalPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glBinormalPointerEXT not available." );
}

static void REGAL_CALL loader_glBinormalPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBinormalPointerEXT, "glBinormalPointerEXT");
   if ( !driverTbl.glBinormalPointerEXT ) {
      driverTbl.glBinormalPointerEXT = missing_glBinormalPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBinormalPointerEXT == loader_glBinormalPointerEXT) {
      rCtx->dsp->emuTbl.glBinormalPointerEXT = driverTbl.glBinormalPointerEXT;
   }
   driverTbl.glBinormalPointerEXT(type, stride, pointer);
}

static void REGAL_CALL missing_glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz)
{
   UNUSED_PARAMETER(tx);
   UNUSED_PARAMETER(ty);
   UNUSED_PARAMETER(tz);
   Warning( "glTangent3bEXT not available." );
}

static void REGAL_CALL loader_glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTangent3bEXT, "glTangent3bEXT");
   if ( !driverTbl.glTangent3bEXT ) {
      driverTbl.glTangent3bEXT = missing_glTangent3bEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTangent3bEXT == loader_glTangent3bEXT) {
      rCtx->dsp->emuTbl.glTangent3bEXT = driverTbl.glTangent3bEXT;
   }
   driverTbl.glTangent3bEXT(tx, ty, tz);
}

static void REGAL_CALL missing_glTangent3bvEXT(const GLbyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTangent3bvEXT not available." );
}

static void REGAL_CALL loader_glTangent3bvEXT(const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTangent3bvEXT, "glTangent3bvEXT");
   if ( !driverTbl.glTangent3bvEXT ) {
      driverTbl.glTangent3bvEXT = missing_glTangent3bvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTangent3bvEXT == loader_glTangent3bvEXT) {
      rCtx->dsp->emuTbl.glTangent3bvEXT = driverTbl.glTangent3bvEXT;
   }
   driverTbl.glTangent3bvEXT(v);
}

static void REGAL_CALL missing_glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz)
{
   UNUSED_PARAMETER(tx);
   UNUSED_PARAMETER(ty);
   UNUSED_PARAMETER(tz);
   Warning( "glTangent3dEXT not available." );
}

static void REGAL_CALL loader_glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTangent3dEXT, "glTangent3dEXT");
   if ( !driverTbl.glTangent3dEXT ) {
      driverTbl.glTangent3dEXT = missing_glTangent3dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTangent3dEXT == loader_glTangent3dEXT) {
      rCtx->dsp->emuTbl.glTangent3dEXT = driverTbl.glTangent3dEXT;
   }
   driverTbl.glTangent3dEXT(tx, ty, tz);
}

static void REGAL_CALL missing_glTangent3dvEXT(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTangent3dvEXT not available." );
}

static void REGAL_CALL loader_glTangent3dvEXT(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTangent3dvEXT, "glTangent3dvEXT");
   if ( !driverTbl.glTangent3dvEXT ) {
      driverTbl.glTangent3dvEXT = missing_glTangent3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTangent3dvEXT == loader_glTangent3dvEXT) {
      rCtx->dsp->emuTbl.glTangent3dvEXT = driverTbl.glTangent3dvEXT;
   }
   driverTbl.glTangent3dvEXT(v);
}

static void REGAL_CALL missing_glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz)
{
   UNUSED_PARAMETER(tx);
   UNUSED_PARAMETER(ty);
   UNUSED_PARAMETER(tz);
   Warning( "glTangent3fEXT not available." );
}

static void REGAL_CALL loader_glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTangent3fEXT, "glTangent3fEXT");
   if ( !driverTbl.glTangent3fEXT ) {
      driverTbl.glTangent3fEXT = missing_glTangent3fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTangent3fEXT == loader_glTangent3fEXT) {
      rCtx->dsp->emuTbl.glTangent3fEXT = driverTbl.glTangent3fEXT;
   }
   driverTbl.glTangent3fEXT(tx, ty, tz);
}

static void REGAL_CALL missing_glTangent3fvEXT(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTangent3fvEXT not available." );
}

static void REGAL_CALL loader_glTangent3fvEXT(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTangent3fvEXT, "glTangent3fvEXT");
   if ( !driverTbl.glTangent3fvEXT ) {
      driverTbl.glTangent3fvEXT = missing_glTangent3fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTangent3fvEXT == loader_glTangent3fvEXT) {
      rCtx->dsp->emuTbl.glTangent3fvEXT = driverTbl.glTangent3fvEXT;
   }
   driverTbl.glTangent3fvEXT(v);
}

static void REGAL_CALL missing_glTangent3iEXT(GLint tx, GLint ty, GLint tz)
{
   UNUSED_PARAMETER(tx);
   UNUSED_PARAMETER(ty);
   UNUSED_PARAMETER(tz);
   Warning( "glTangent3iEXT not available." );
}

static void REGAL_CALL loader_glTangent3iEXT(GLint tx, GLint ty, GLint tz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTangent3iEXT, "glTangent3iEXT");
   if ( !driverTbl.glTangent3iEXT ) {
      driverTbl.glTangent3iEXT = missing_glTangent3iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTangent3iEXT == loader_glTangent3iEXT) {
      rCtx->dsp->emuTbl.glTangent3iEXT = driverTbl.glTangent3iEXT;
   }
   driverTbl.glTangent3iEXT(tx, ty, tz);
}

static void REGAL_CALL missing_glTangent3ivEXT(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTangent3ivEXT not available." );
}

static void REGAL_CALL loader_glTangent3ivEXT(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTangent3ivEXT, "glTangent3ivEXT");
   if ( !driverTbl.glTangent3ivEXT ) {
      driverTbl.glTangent3ivEXT = missing_glTangent3ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTangent3ivEXT == loader_glTangent3ivEXT) {
      rCtx->dsp->emuTbl.glTangent3ivEXT = driverTbl.glTangent3ivEXT;
   }
   driverTbl.glTangent3ivEXT(v);
}

static void REGAL_CALL missing_glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz)
{
   UNUSED_PARAMETER(tx);
   UNUSED_PARAMETER(ty);
   UNUSED_PARAMETER(tz);
   Warning( "glTangent3sEXT not available." );
}

static void REGAL_CALL loader_glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTangent3sEXT, "glTangent3sEXT");
   if ( !driverTbl.glTangent3sEXT ) {
      driverTbl.glTangent3sEXT = missing_glTangent3sEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTangent3sEXT == loader_glTangent3sEXT) {
      rCtx->dsp->emuTbl.glTangent3sEXT = driverTbl.glTangent3sEXT;
   }
   driverTbl.glTangent3sEXT(tx, ty, tz);
}

static void REGAL_CALL missing_glTangent3svEXT(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTangent3svEXT not available." );
}

static void REGAL_CALL loader_glTangent3svEXT(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTangent3svEXT, "glTangent3svEXT");
   if ( !driverTbl.glTangent3svEXT ) {
      driverTbl.glTangent3svEXT = missing_glTangent3svEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTangent3svEXT == loader_glTangent3svEXT) {
      rCtx->dsp->emuTbl.glTangent3svEXT = driverTbl.glTangent3svEXT;
   }
   driverTbl.glTangent3svEXT(v);
}

static void REGAL_CALL missing_glTangentPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glTangentPointerEXT not available." );
}

static void REGAL_CALL loader_glTangentPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTangentPointerEXT, "glTangentPointerEXT");
   if ( !driverTbl.glTangentPointerEXT ) {
      driverTbl.glTangentPointerEXT = missing_glTangentPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTangentPointerEXT == loader_glTangentPointerEXT) {
      rCtx->dsp->emuTbl.glTangentPointerEXT = driverTbl.glTangentPointerEXT;
   }
   driverTbl.glTangentPointerEXT(type, stride, pointer);
}

// GL_EXT_copy_texture

static void REGAL_CALL missing_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   Warning( "glCopyTexImage1DEXT not available." );
}

static void REGAL_CALL loader_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTexImage1DEXT, "glCopyTexImage1DEXT");
   if ( !driverTbl.glCopyTexImage1DEXT ) {
      driverTbl.glCopyTexImage1DEXT = missing_glCopyTexImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTexImage1DEXT == loader_glCopyTexImage1DEXT) {
      rCtx->dsp->emuTbl.glCopyTexImage1DEXT = driverTbl.glCopyTexImage1DEXT;
   }
   driverTbl.glCopyTexImage1DEXT(target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL missing_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   Warning( "glCopyTexImage2DEXT not available." );
}

static void REGAL_CALL loader_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTexImage2DEXT, "glCopyTexImage2DEXT");
   if ( !driverTbl.glCopyTexImage2DEXT ) {
      driverTbl.glCopyTexImage2DEXT = missing_glCopyTexImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTexImage2DEXT == loader_glCopyTexImage2DEXT) {
      rCtx->dsp->emuTbl.glCopyTexImage2DEXT = driverTbl.glCopyTexImage2DEXT;
   }
   driverTbl.glCopyTexImage2DEXT(target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL missing_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "glCopyTexSubImage1DEXT not available." );
}

static void REGAL_CALL loader_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTexSubImage1DEXT, "glCopyTexSubImage1DEXT");
   if ( !driverTbl.glCopyTexSubImage1DEXT ) {
      driverTbl.glCopyTexSubImage1DEXT = missing_glCopyTexSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTexSubImage1DEXT == loader_glCopyTexSubImage1DEXT) {
      rCtx->dsp->emuTbl.glCopyTexSubImage1DEXT = driverTbl.glCopyTexSubImage1DEXT;
   }
   driverTbl.glCopyTexSubImage1DEXT(target, level, xoffset, x, y, width);
}

static void REGAL_CALL missing_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glCopyTexSubImage2DEXT not available." );
}

static void REGAL_CALL loader_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTexSubImage2DEXT, "glCopyTexSubImage2DEXT");
   if ( !driverTbl.glCopyTexSubImage2DEXT ) {
      driverTbl.glCopyTexSubImage2DEXT = missing_glCopyTexSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTexSubImage2DEXT == loader_glCopyTexSubImage2DEXT) {
      rCtx->dsp->emuTbl.glCopyTexSubImage2DEXT = driverTbl.glCopyTexSubImage2DEXT;
   }
   driverTbl.glCopyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL missing_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glCopyTexSubImage3DEXT not available." );
}

static void REGAL_CALL loader_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTexSubImage3DEXT, "glCopyTexSubImage3DEXT");
   if ( !driverTbl.glCopyTexSubImage3DEXT ) {
      driverTbl.glCopyTexSubImage3DEXT = missing_glCopyTexSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTexSubImage3DEXT == loader_glCopyTexSubImage3DEXT) {
      rCtx->dsp->emuTbl.glCopyTexSubImage3DEXT = driverTbl.glCopyTexSubImage3DEXT;
   }
   driverTbl.glCopyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

// GL_EXT_cull_vertex

static void REGAL_CALL missing_glCullParameterdvEXT(GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glCullParameterdvEXT not available." );
}

static void REGAL_CALL loader_glCullParameterdvEXT(GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCullParameterdvEXT, "glCullParameterdvEXT");
   if ( !driverTbl.glCullParameterdvEXT ) {
      driverTbl.glCullParameterdvEXT = missing_glCullParameterdvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCullParameterdvEXT == loader_glCullParameterdvEXT) {
      rCtx->dsp->emuTbl.glCullParameterdvEXT = driverTbl.glCullParameterdvEXT;
   }
   driverTbl.glCullParameterdvEXT(pname, params);
}

static void REGAL_CALL missing_glCullParameterfvEXT(GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glCullParameterfvEXT not available." );
}

static void REGAL_CALL loader_glCullParameterfvEXT(GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCullParameterfvEXT, "glCullParameterfvEXT");
   if ( !driverTbl.glCullParameterfvEXT ) {
      driverTbl.glCullParameterfvEXT = missing_glCullParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCullParameterfvEXT == loader_glCullParameterfvEXT) {
      rCtx->dsp->emuTbl.glCullParameterfvEXT = driverTbl.glCullParameterfvEXT;
   }
   driverTbl.glCullParameterfvEXT(pname, params);
}

// GL_EXT_debug_marker

static void REGAL_CALL missing_glInsertEventMarkerEXT(GLsizei length, const GLchar *marker)
{
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(marker);
   Warning( "glInsertEventMarkerEXT not available." );
}

static void REGAL_CALL loader_glInsertEventMarkerEXT(GLsizei length, const GLchar *marker)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glInsertEventMarkerEXT, "glInsertEventMarkerEXT");
   if ( !driverTbl.glInsertEventMarkerEXT ) {
      driverTbl.glInsertEventMarkerEXT = missing_glInsertEventMarkerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glInsertEventMarkerEXT == loader_glInsertEventMarkerEXT) {
      rCtx->dsp->emuTbl.glInsertEventMarkerEXT = driverTbl.glInsertEventMarkerEXT;
   }
   driverTbl.glInsertEventMarkerEXT(length, marker);
}

static void REGAL_CALL missing_glPopGroupMarkerEXT(void)
{
   Warning( "glPopGroupMarkerEXT not available." );
}

static void REGAL_CALL loader_glPopGroupMarkerEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPopGroupMarkerEXT, "glPopGroupMarkerEXT");
   if ( !driverTbl.glPopGroupMarkerEXT ) {
      driverTbl.glPopGroupMarkerEXT = missing_glPopGroupMarkerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPopGroupMarkerEXT == loader_glPopGroupMarkerEXT) {
      rCtx->dsp->emuTbl.glPopGroupMarkerEXT = driverTbl.glPopGroupMarkerEXT;
   }
   driverTbl.glPopGroupMarkerEXT();
}

static void REGAL_CALL missing_glPushGroupMarkerEXT(GLsizei length, const GLchar *marker)
{
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(marker);
   Warning( "glPushGroupMarkerEXT not available." );
}

static void REGAL_CALL loader_glPushGroupMarkerEXT(GLsizei length, const GLchar *marker)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPushGroupMarkerEXT, "glPushGroupMarkerEXT");
   if ( !driverTbl.glPushGroupMarkerEXT ) {
      driverTbl.glPushGroupMarkerEXT = missing_glPushGroupMarkerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPushGroupMarkerEXT == loader_glPushGroupMarkerEXT) {
      rCtx->dsp->emuTbl.glPushGroupMarkerEXT = driverTbl.glPushGroupMarkerEXT;
   }
   driverTbl.glPushGroupMarkerEXT(length, marker);
}

// GL_EXT_depth_bounds_test

static void REGAL_CALL missing_glDepthBoundsEXT(GLclampd zmin, GLclampd zmax)
{
   UNUSED_PARAMETER(zmin);
   UNUSED_PARAMETER(zmax);
   Warning( "glDepthBoundsEXT not available." );
}

static void REGAL_CALL loader_glDepthBoundsEXT(GLclampd zmin, GLclampd zmax)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDepthBoundsEXT, "glDepthBoundsEXT");
   if ( !driverTbl.glDepthBoundsEXT ) {
      driverTbl.glDepthBoundsEXT = missing_glDepthBoundsEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDepthBoundsEXT == loader_glDepthBoundsEXT) {
      rCtx->dsp->emuTbl.glDepthBoundsEXT = driverTbl.glDepthBoundsEXT;
   }
   driverTbl.glDepthBoundsEXT(zmin, zmax);
}

// GL_EXT_direct_state_access

static void REGAL_CALL missing_glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(texture);
   Warning( "glBindMultiTextureEXT not available." );
}

static void REGAL_CALL loader_glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindMultiTextureEXT, "glBindMultiTextureEXT");
   if ( !driverTbl.glBindMultiTextureEXT ) {
      driverTbl.glBindMultiTextureEXT = missing_glBindMultiTextureEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindMultiTextureEXT == loader_glBindMultiTextureEXT) {
      rCtx->dsp->emuTbl.glBindMultiTextureEXT = driverTbl.glBindMultiTextureEXT;
   }
   driverTbl.glBindMultiTextureEXT(texunit, target, texture);
}

static GLenum REGAL_CALL missing_glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(target);
   Warning( "glCheckNamedFramebufferStatusEXT not available." );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCheckNamedFramebufferStatusEXT, "glCheckNamedFramebufferStatusEXT");
   if ( !driverTbl.glCheckNamedFramebufferStatusEXT ) {
      driverTbl.glCheckNamedFramebufferStatusEXT = missing_glCheckNamedFramebufferStatusEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCheckNamedFramebufferStatusEXT == loader_glCheckNamedFramebufferStatusEXT) {
      rCtx->dsp->emuTbl.glCheckNamedFramebufferStatusEXT = driverTbl.glCheckNamedFramebufferStatusEXT;
   }
   return driverTbl.glCheckNamedFramebufferStatusEXT(framebuffer, target);
}

static void REGAL_CALL missing_glClientAttribDefaultEXT(GLbitfield mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "glClientAttribDefaultEXT not available." );
}

static void REGAL_CALL loader_glClientAttribDefaultEXT(GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClientAttribDefaultEXT, "glClientAttribDefaultEXT");
   if ( !driverTbl.glClientAttribDefaultEXT ) {
      driverTbl.glClientAttribDefaultEXT = missing_glClientAttribDefaultEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClientAttribDefaultEXT == loader_glClientAttribDefaultEXT) {
      rCtx->dsp->emuTbl.glClientAttribDefaultEXT = driverTbl.glClientAttribDefaultEXT;
   }
   driverTbl.glClientAttribDefaultEXT(mask);
}

static void REGAL_CALL missing_glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedMultiTexImage1DEXT not available." );
}

static void REGAL_CALL loader_glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedMultiTexImage1DEXT, "glCompressedMultiTexImage1DEXT");
   if ( !driverTbl.glCompressedMultiTexImage1DEXT ) {
      driverTbl.glCompressedMultiTexImage1DEXT = missing_glCompressedMultiTexImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedMultiTexImage1DEXT == loader_glCompressedMultiTexImage1DEXT) {
      rCtx->dsp->emuTbl.glCompressedMultiTexImage1DEXT = driverTbl.glCompressedMultiTexImage1DEXT;
   }
   driverTbl.glCompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, data);
}

static void REGAL_CALL missing_glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "glCompressedMultiTexImage2DEXT not available." );
}

static void REGAL_CALL loader_glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedMultiTexImage2DEXT, "glCompressedMultiTexImage2DEXT");
   if ( !driverTbl.glCompressedMultiTexImage2DEXT ) {
      driverTbl.glCompressedMultiTexImage2DEXT = missing_glCompressedMultiTexImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedMultiTexImage2DEXT == loader_glCompressedMultiTexImage2DEXT) {
      rCtx->dsp->emuTbl.glCompressedMultiTexImage2DEXT = driverTbl.glCompressedMultiTexImage2DEXT;
   }
   driverTbl.glCompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits);
}

static void REGAL_CALL missing_glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "glCompressedMultiTexImage3DEXT not available." );
}

static void REGAL_CALL loader_glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedMultiTexImage3DEXT, "glCompressedMultiTexImage3DEXT");
   if ( !driverTbl.glCompressedMultiTexImage3DEXT ) {
      driverTbl.glCompressedMultiTexImage3DEXT = missing_glCompressedMultiTexImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedMultiTexImage3DEXT == loader_glCompressedMultiTexImage3DEXT) {
      rCtx->dsp->emuTbl.glCompressedMultiTexImage3DEXT = driverTbl.glCompressedMultiTexImage3DEXT;
   }
   driverTbl.glCompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
}

static void REGAL_CALL missing_glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedMultiTexSubImage1DEXT not available." );
}

static void REGAL_CALL loader_glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedMultiTexSubImage1DEXT, "glCompressedMultiTexSubImage1DEXT");
   if ( !driverTbl.glCompressedMultiTexSubImage1DEXT ) {
      driverTbl.glCompressedMultiTexSubImage1DEXT = missing_glCompressedMultiTexSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedMultiTexSubImage1DEXT == loader_glCompressedMultiTexSubImage1DEXT) {
      rCtx->dsp->emuTbl.glCompressedMultiTexSubImage1DEXT = driverTbl.glCompressedMultiTexSubImage1DEXT;
   }
   driverTbl.glCompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, data);
}

static void REGAL_CALL missing_glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedMultiTexSubImage2DEXT not available." );
}

static void REGAL_CALL loader_glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedMultiTexSubImage2DEXT, "glCompressedMultiTexSubImage2DEXT");
   if ( !driverTbl.glCompressedMultiTexSubImage2DEXT ) {
      driverTbl.glCompressedMultiTexSubImage2DEXT = missing_glCompressedMultiTexSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedMultiTexSubImage2DEXT == loader_glCompressedMultiTexSubImage2DEXT) {
      rCtx->dsp->emuTbl.glCompressedMultiTexSubImage2DEXT = driverTbl.glCompressedMultiTexSubImage2DEXT;
   }
   driverTbl.glCompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, data);
}

static void REGAL_CALL missing_glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(data);
   Warning( "glCompressedMultiTexSubImage3DEXT not available." );
}

static void REGAL_CALL loader_glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedMultiTexSubImage3DEXT, "glCompressedMultiTexSubImage3DEXT");
   if ( !driverTbl.glCompressedMultiTexSubImage3DEXT ) {
      driverTbl.glCompressedMultiTexSubImage3DEXT = missing_glCompressedMultiTexSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedMultiTexSubImage3DEXT == loader_glCompressedMultiTexSubImage3DEXT) {
      rCtx->dsp->emuTbl.glCompressedMultiTexSubImage3DEXT = driverTbl.glCompressedMultiTexSubImage3DEXT;
   }
   driverTbl.glCompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

static void REGAL_CALL missing_glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "glCompressedTextureImage1DEXT not available." );
}

static void REGAL_CALL loader_glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTextureImage1DEXT, "glCompressedTextureImage1DEXT");
   if ( !driverTbl.glCompressedTextureImage1DEXT ) {
      driverTbl.glCompressedTextureImage1DEXT = missing_glCompressedTextureImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTextureImage1DEXT == loader_glCompressedTextureImage1DEXT) {
      rCtx->dsp->emuTbl.glCompressedTextureImage1DEXT = driverTbl.glCompressedTextureImage1DEXT;
   }
   driverTbl.glCompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits);
}

static void REGAL_CALL missing_glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "glCompressedTextureImage2DEXT not available." );
}

static void REGAL_CALL loader_glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTextureImage2DEXT, "glCompressedTextureImage2DEXT");
   if ( !driverTbl.glCompressedTextureImage2DEXT ) {
      driverTbl.glCompressedTextureImage2DEXT = missing_glCompressedTextureImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTextureImage2DEXT == loader_glCompressedTextureImage2DEXT) {
      rCtx->dsp->emuTbl.glCompressedTextureImage2DEXT = driverTbl.glCompressedTextureImage2DEXT;
   }
   driverTbl.glCompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits);
}

static void REGAL_CALL missing_glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "glCompressedTextureImage3DEXT not available." );
}

static void REGAL_CALL loader_glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTextureImage3DEXT, "glCompressedTextureImage3DEXT");
   if ( !driverTbl.glCompressedTextureImage3DEXT ) {
      driverTbl.glCompressedTextureImage3DEXT = missing_glCompressedTextureImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTextureImage3DEXT == loader_glCompressedTextureImage3DEXT) {
      rCtx->dsp->emuTbl.glCompressedTextureImage3DEXT = driverTbl.glCompressedTextureImage3DEXT;
   }
   driverTbl.glCompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
}

static void REGAL_CALL missing_glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "glCompressedTextureSubImage1DEXT not available." );
}

static void REGAL_CALL loader_glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTextureSubImage1DEXT, "glCompressedTextureSubImage1DEXT");
   if ( !driverTbl.glCompressedTextureSubImage1DEXT ) {
      driverTbl.glCompressedTextureSubImage1DEXT = missing_glCompressedTextureSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTextureSubImage1DEXT == loader_glCompressedTextureSubImage1DEXT) {
      rCtx->dsp->emuTbl.glCompressedTextureSubImage1DEXT = driverTbl.glCompressedTextureSubImage1DEXT;
   }
   driverTbl.glCompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits);
}

static void REGAL_CALL missing_glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "glCompressedTextureSubImage2DEXT not available." );
}

static void REGAL_CALL loader_glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTextureSubImage2DEXT, "glCompressedTextureSubImage2DEXT");
   if ( !driverTbl.glCompressedTextureSubImage2DEXT ) {
      driverTbl.glCompressedTextureSubImage2DEXT = missing_glCompressedTextureSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTextureSubImage2DEXT == loader_glCompressedTextureSubImage2DEXT) {
      rCtx->dsp->emuTbl.glCompressedTextureSubImage2DEXT = driverTbl.glCompressedTextureSubImage2DEXT;
   }
   driverTbl.glCompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
}

static void REGAL_CALL missing_glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(imageSize);
   UNUSED_PARAMETER(bits);
   Warning( "glCompressedTextureSubImage3DEXT not available." );
}

static void REGAL_CALL loader_glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCompressedTextureSubImage3DEXT, "glCompressedTextureSubImage3DEXT");
   if ( !driverTbl.glCompressedTextureSubImage3DEXT ) {
      driverTbl.glCompressedTextureSubImage3DEXT = missing_glCompressedTextureSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCompressedTextureSubImage3DEXT == loader_glCompressedTextureSubImage3DEXT) {
      rCtx->dsp->emuTbl.glCompressedTextureSubImage3DEXT = driverTbl.glCompressedTextureSubImage3DEXT;
   }
   driverTbl.glCompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
}

static void REGAL_CALL missing_glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   Warning( "glCopyMultiTexImage1DEXT not available." );
}

static void REGAL_CALL loader_glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyMultiTexImage1DEXT, "glCopyMultiTexImage1DEXT");
   if ( !driverTbl.glCopyMultiTexImage1DEXT ) {
      driverTbl.glCopyMultiTexImage1DEXT = missing_glCopyMultiTexImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyMultiTexImage1DEXT == loader_glCopyMultiTexImage1DEXT) {
      rCtx->dsp->emuTbl.glCopyMultiTexImage1DEXT = driverTbl.glCopyMultiTexImage1DEXT;
   }
   driverTbl.glCopyMultiTexImage1DEXT(texunit, target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL missing_glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   Warning( "glCopyMultiTexImage2DEXT not available." );
}

static void REGAL_CALL loader_glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyMultiTexImage2DEXT, "glCopyMultiTexImage2DEXT");
   if ( !driverTbl.glCopyMultiTexImage2DEXT ) {
      driverTbl.glCopyMultiTexImage2DEXT = missing_glCopyMultiTexImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyMultiTexImage2DEXT == loader_glCopyMultiTexImage2DEXT) {
      rCtx->dsp->emuTbl.glCopyMultiTexImage2DEXT = driverTbl.glCopyMultiTexImage2DEXT;
   }
   driverTbl.glCopyMultiTexImage2DEXT(texunit, target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL missing_glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "glCopyMultiTexSubImage1DEXT not available." );
}

static void REGAL_CALL loader_glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyMultiTexSubImage1DEXT, "glCopyMultiTexSubImage1DEXT");
   if ( !driverTbl.glCopyMultiTexSubImage1DEXT ) {
      driverTbl.glCopyMultiTexSubImage1DEXT = missing_glCopyMultiTexSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyMultiTexSubImage1DEXT == loader_glCopyMultiTexSubImage1DEXT) {
      rCtx->dsp->emuTbl.glCopyMultiTexSubImage1DEXT = driverTbl.glCopyMultiTexSubImage1DEXT;
   }
   driverTbl.glCopyMultiTexSubImage1DEXT(texunit, target, level, xoffset, x, y, width);
}

static void REGAL_CALL missing_glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glCopyMultiTexSubImage2DEXT not available." );
}

static void REGAL_CALL loader_glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyMultiTexSubImage2DEXT, "glCopyMultiTexSubImage2DEXT");
   if ( !driverTbl.glCopyMultiTexSubImage2DEXT ) {
      driverTbl.glCopyMultiTexSubImage2DEXT = missing_glCopyMultiTexSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyMultiTexSubImage2DEXT == loader_glCopyMultiTexSubImage2DEXT) {
      rCtx->dsp->emuTbl.glCopyMultiTexSubImage2DEXT = driverTbl.glCopyMultiTexSubImage2DEXT;
   }
   driverTbl.glCopyMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL missing_glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glCopyMultiTexSubImage3DEXT not available." );
}

static void REGAL_CALL loader_glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyMultiTexSubImage3DEXT, "glCopyMultiTexSubImage3DEXT");
   if ( !driverTbl.glCopyMultiTexSubImage3DEXT ) {
      driverTbl.glCopyMultiTexSubImage3DEXT = missing_glCopyMultiTexSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyMultiTexSubImage3DEXT == loader_glCopyMultiTexSubImage3DEXT) {
      rCtx->dsp->emuTbl.glCopyMultiTexSubImage3DEXT = driverTbl.glCopyMultiTexSubImage3DEXT;
   }
   driverTbl.glCopyMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

static void REGAL_CALL missing_glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   Warning( "glCopyTextureImage1DEXT not available." );
}

static void REGAL_CALL loader_glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTextureImage1DEXT, "glCopyTextureImage1DEXT");
   if ( !driverTbl.glCopyTextureImage1DEXT ) {
      driverTbl.glCopyTextureImage1DEXT = missing_glCopyTextureImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTextureImage1DEXT == loader_glCopyTextureImage1DEXT) {
      rCtx->dsp->emuTbl.glCopyTextureImage1DEXT = driverTbl.glCopyTextureImage1DEXT;
   }
   driverTbl.glCopyTextureImage1DEXT(texture, target, level, internalformat, x, y, width, border);
}

static void REGAL_CALL missing_glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   Warning( "glCopyTextureImage2DEXT not available." );
}

static void REGAL_CALL loader_glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTextureImage2DEXT, "glCopyTextureImage2DEXT");
   if ( !driverTbl.glCopyTextureImage2DEXT ) {
      driverTbl.glCopyTextureImage2DEXT = missing_glCopyTextureImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTextureImage2DEXT == loader_glCopyTextureImage2DEXT) {
      rCtx->dsp->emuTbl.glCopyTextureImage2DEXT = driverTbl.glCopyTextureImage2DEXT;
   }
   driverTbl.glCopyTextureImage2DEXT(texture, target, level, internalformat, x, y, width, height, border);
}

static void REGAL_CALL missing_glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "glCopyTextureSubImage1DEXT not available." );
}

static void REGAL_CALL loader_glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTextureSubImage1DEXT, "glCopyTextureSubImage1DEXT");
   if ( !driverTbl.glCopyTextureSubImage1DEXT ) {
      driverTbl.glCopyTextureSubImage1DEXT = missing_glCopyTextureSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTextureSubImage1DEXT == loader_glCopyTextureSubImage1DEXT) {
      rCtx->dsp->emuTbl.glCopyTextureSubImage1DEXT = driverTbl.glCopyTextureSubImage1DEXT;
   }
   driverTbl.glCopyTextureSubImage1DEXT(texture, target, level, xoffset, x, y, width);
}

static void REGAL_CALL missing_glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glCopyTextureSubImage2DEXT not available." );
}

static void REGAL_CALL loader_glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTextureSubImage2DEXT, "glCopyTextureSubImage2DEXT");
   if ( !driverTbl.glCopyTextureSubImage2DEXT ) {
      driverTbl.glCopyTextureSubImage2DEXT = missing_glCopyTextureSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTextureSubImage2DEXT == loader_glCopyTextureSubImage2DEXT) {
      rCtx->dsp->emuTbl.glCopyTextureSubImage2DEXT = driverTbl.glCopyTextureSubImage2DEXT;
   }
   driverTbl.glCopyTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, x, y, width, height);
}

static void REGAL_CALL missing_glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glCopyTextureSubImage3DEXT not available." );
}

static void REGAL_CALL loader_glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyTextureSubImage3DEXT, "glCopyTextureSubImage3DEXT");
   if ( !driverTbl.glCopyTextureSubImage3DEXT ) {
      driverTbl.glCopyTextureSubImage3DEXT = missing_glCopyTextureSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyTextureSubImage3DEXT == loader_glCopyTextureSubImage3DEXT) {
      rCtx->dsp->emuTbl.glCopyTextureSubImage3DEXT = driverTbl.glCopyTextureSubImage3DEXT;
   }
   driverTbl.glCopyTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

static void REGAL_CALL missing_glDisableClientStateIndexedEXT(GLenum array, GLuint index)
{
   UNUSED_PARAMETER(array);
   UNUSED_PARAMETER(index);
   Warning( "glDisableClientStateIndexedEXT not available." );
}

static void REGAL_CALL loader_glDisableClientStateIndexedEXT(GLenum array, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDisableClientStateIndexedEXT, "glDisableClientStateIndexedEXT");
   if ( !driverTbl.glDisableClientStateIndexedEXT ) {
      driverTbl.glDisableClientStateIndexedEXT = missing_glDisableClientStateIndexedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDisableClientStateIndexedEXT == loader_glDisableClientStateIndexedEXT) {
      rCtx->dsp->emuTbl.glDisableClientStateIndexedEXT = driverTbl.glDisableClientStateIndexedEXT;
   }
   driverTbl.glDisableClientStateIndexedEXT(array, index);
}

static void REGAL_CALL missing_glDisableClientStateiEXT(GLenum array, GLuint index)
{
   UNUSED_PARAMETER(array);
   UNUSED_PARAMETER(index);
   Warning( "glDisableClientStateiEXT not available." );
}

static void REGAL_CALL loader_glDisableClientStateiEXT(GLenum array, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDisableClientStateiEXT, "glDisableClientStateiEXT");
   if ( !driverTbl.glDisableClientStateiEXT ) {
      driverTbl.glDisableClientStateiEXT = missing_glDisableClientStateiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDisableClientStateiEXT == loader_glDisableClientStateiEXT) {
      rCtx->dsp->emuTbl.glDisableClientStateiEXT = driverTbl.glDisableClientStateiEXT;
   }
   driverTbl.glDisableClientStateiEXT(array, index);
}

static void REGAL_CALL missing_glDisableVertexArrayAttribEXT(GLuint vaobj, GLenum array)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(array);
   Warning( "glDisableVertexArrayAttribEXT not available." );
}

static void REGAL_CALL loader_glDisableVertexArrayAttribEXT(GLuint vaobj, GLenum array)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDisableVertexArrayAttribEXT, "glDisableVertexArrayAttribEXT");
   if ( !driverTbl.glDisableVertexArrayAttribEXT ) {
      driverTbl.glDisableVertexArrayAttribEXT = missing_glDisableVertexArrayAttribEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDisableVertexArrayAttribEXT == loader_glDisableVertexArrayAttribEXT) {
      rCtx->dsp->emuTbl.glDisableVertexArrayAttribEXT = driverTbl.glDisableVertexArrayAttribEXT;
   }
   driverTbl.glDisableVertexArrayAttribEXT(vaobj, array);
}

static void REGAL_CALL missing_glDisableVertexArrayEXT(GLuint vaobj, GLenum array)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(array);
   Warning( "glDisableVertexArrayEXT not available." );
}

static void REGAL_CALL loader_glDisableVertexArrayEXT(GLuint vaobj, GLenum array)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDisableVertexArrayEXT, "glDisableVertexArrayEXT");
   if ( !driverTbl.glDisableVertexArrayEXT ) {
      driverTbl.glDisableVertexArrayEXT = missing_glDisableVertexArrayEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDisableVertexArrayEXT == loader_glDisableVertexArrayEXT) {
      rCtx->dsp->emuTbl.glDisableVertexArrayEXT = driverTbl.glDisableVertexArrayEXT;
   }
   driverTbl.glDisableVertexArrayEXT(vaobj, array);
}

static void REGAL_CALL missing_glEnableClientStateIndexedEXT(GLenum array, GLuint index)
{
   UNUSED_PARAMETER(array);
   UNUSED_PARAMETER(index);
   Warning( "glEnableClientStateIndexedEXT not available." );
}

static void REGAL_CALL loader_glEnableClientStateIndexedEXT(GLenum array, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEnableClientStateIndexedEXT, "glEnableClientStateIndexedEXT");
   if ( !driverTbl.glEnableClientStateIndexedEXT ) {
      driverTbl.glEnableClientStateIndexedEXT = missing_glEnableClientStateIndexedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEnableClientStateIndexedEXT == loader_glEnableClientStateIndexedEXT) {
      rCtx->dsp->emuTbl.glEnableClientStateIndexedEXT = driverTbl.glEnableClientStateIndexedEXT;
   }
   driverTbl.glEnableClientStateIndexedEXT(array, index);
}

static void REGAL_CALL missing_glEnableClientStateiEXT(GLenum array, GLuint index)
{
   UNUSED_PARAMETER(array);
   UNUSED_PARAMETER(index);
   Warning( "glEnableClientStateiEXT not available." );
}

static void REGAL_CALL loader_glEnableClientStateiEXT(GLenum array, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEnableClientStateiEXT, "glEnableClientStateiEXT");
   if ( !driverTbl.glEnableClientStateiEXT ) {
      driverTbl.glEnableClientStateiEXT = missing_glEnableClientStateiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEnableClientStateiEXT == loader_glEnableClientStateiEXT) {
      rCtx->dsp->emuTbl.glEnableClientStateiEXT = driverTbl.glEnableClientStateiEXT;
   }
   driverTbl.glEnableClientStateiEXT(array, index);
}

static void REGAL_CALL missing_glEnableVertexArrayAttribEXT(GLuint vaobj, GLenum array)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(array);
   Warning( "glEnableVertexArrayAttribEXT not available." );
}

static void REGAL_CALL loader_glEnableVertexArrayAttribEXT(GLuint vaobj, GLenum array)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEnableVertexArrayAttribEXT, "glEnableVertexArrayAttribEXT");
   if ( !driverTbl.glEnableVertexArrayAttribEXT ) {
      driverTbl.glEnableVertexArrayAttribEXT = missing_glEnableVertexArrayAttribEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEnableVertexArrayAttribEXT == loader_glEnableVertexArrayAttribEXT) {
      rCtx->dsp->emuTbl.glEnableVertexArrayAttribEXT = driverTbl.glEnableVertexArrayAttribEXT;
   }
   driverTbl.glEnableVertexArrayAttribEXT(vaobj, array);
}

static void REGAL_CALL missing_glEnableVertexArrayEXT(GLuint vaobj, GLenum array)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(array);
   Warning( "glEnableVertexArrayEXT not available." );
}

static void REGAL_CALL loader_glEnableVertexArrayEXT(GLuint vaobj, GLenum array)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEnableVertexArrayEXT, "glEnableVertexArrayEXT");
   if ( !driverTbl.glEnableVertexArrayEXT ) {
      driverTbl.glEnableVertexArrayEXT = missing_glEnableVertexArrayEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEnableVertexArrayEXT == loader_glEnableVertexArrayEXT) {
      rCtx->dsp->emuTbl.glEnableVertexArrayEXT = driverTbl.glEnableVertexArrayEXT;
   }
   driverTbl.glEnableVertexArrayEXT(vaobj, array);
}

static void REGAL_CALL missing_glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(length);
   Warning( "glFlushMappedNamedBufferRangeEXT not available." );
}

static void REGAL_CALL loader_glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFlushMappedNamedBufferRangeEXT, "glFlushMappedNamedBufferRangeEXT");
   if ( !driverTbl.glFlushMappedNamedBufferRangeEXT ) {
      driverTbl.glFlushMappedNamedBufferRangeEXT = missing_glFlushMappedNamedBufferRangeEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFlushMappedNamedBufferRangeEXT == loader_glFlushMappedNamedBufferRangeEXT) {
      rCtx->dsp->emuTbl.glFlushMappedNamedBufferRangeEXT = driverTbl.glFlushMappedNamedBufferRangeEXT;
   }
   driverTbl.glFlushMappedNamedBufferRangeEXT(buffer, offset, length);
}

static void REGAL_CALL missing_glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(mode);
   Warning( "glFramebufferDrawBufferEXT not available." );
}

static void REGAL_CALL loader_glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferDrawBufferEXT, "glFramebufferDrawBufferEXT");
   if ( !driverTbl.glFramebufferDrawBufferEXT ) {
      driverTbl.glFramebufferDrawBufferEXT = missing_glFramebufferDrawBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferDrawBufferEXT == loader_glFramebufferDrawBufferEXT) {
      rCtx->dsp->emuTbl.glFramebufferDrawBufferEXT = driverTbl.glFramebufferDrawBufferEXT;
   }
   driverTbl.glFramebufferDrawBufferEXT(framebuffer, mode);
}

static void REGAL_CALL missing_glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum *bufs)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(bufs);
   Warning( "glFramebufferDrawBuffersEXT not available." );
}

static void REGAL_CALL loader_glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum *bufs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferDrawBuffersEXT, "glFramebufferDrawBuffersEXT");
   if ( !driverTbl.glFramebufferDrawBuffersEXT ) {
      driverTbl.glFramebufferDrawBuffersEXT = missing_glFramebufferDrawBuffersEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferDrawBuffersEXT == loader_glFramebufferDrawBuffersEXT) {
      rCtx->dsp->emuTbl.glFramebufferDrawBuffersEXT = driverTbl.glFramebufferDrawBuffersEXT;
   }
   driverTbl.glFramebufferDrawBuffersEXT(framebuffer, n, bufs);
}

static void REGAL_CALL missing_glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(mode);
   Warning( "glFramebufferReadBufferEXT not available." );
}

static void REGAL_CALL loader_glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferReadBufferEXT, "glFramebufferReadBufferEXT");
   if ( !driverTbl.glFramebufferReadBufferEXT ) {
      driverTbl.glFramebufferReadBufferEXT = missing_glFramebufferReadBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferReadBufferEXT == loader_glFramebufferReadBufferEXT) {
      rCtx->dsp->emuTbl.glFramebufferReadBufferEXT = driverTbl.glFramebufferReadBufferEXT;
   }
   driverTbl.glFramebufferReadBufferEXT(framebuffer, mode);
}

static void REGAL_CALL missing_glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   Warning( "glGenerateMultiTexMipmapEXT not available." );
}

static void REGAL_CALL loader_glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenerateMultiTexMipmapEXT, "glGenerateMultiTexMipmapEXT");
   if ( !driverTbl.glGenerateMultiTexMipmapEXT ) {
      driverTbl.glGenerateMultiTexMipmapEXT = missing_glGenerateMultiTexMipmapEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenerateMultiTexMipmapEXT == loader_glGenerateMultiTexMipmapEXT) {
      rCtx->dsp->emuTbl.glGenerateMultiTexMipmapEXT = driverTbl.glGenerateMultiTexMipmapEXT;
   }
   driverTbl.glGenerateMultiTexMipmapEXT(texunit, target);
}

static void REGAL_CALL missing_glGenerateTextureMipmapEXT(GLuint texture, GLenum target)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   Warning( "glGenerateTextureMipmapEXT not available." );
}

static void REGAL_CALL loader_glGenerateTextureMipmapEXT(GLuint texture, GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenerateTextureMipmapEXT, "glGenerateTextureMipmapEXT");
   if ( !driverTbl.glGenerateTextureMipmapEXT ) {
      driverTbl.glGenerateTextureMipmapEXT = missing_glGenerateTextureMipmapEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenerateTextureMipmapEXT == loader_glGenerateTextureMipmapEXT) {
      rCtx->dsp->emuTbl.glGenerateTextureMipmapEXT = driverTbl.glGenerateTextureMipmapEXT;
   }
   driverTbl.glGenerateTextureMipmapEXT(texture, target);
}

static void REGAL_CALL missing_glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, GLvoid *img)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(lod);
   UNUSED_PARAMETER(img);
   Warning( "glGetCompressedMultiTexImageEXT not available." );
}

static void REGAL_CALL loader_glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, GLvoid *img)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetCompressedMultiTexImageEXT, "glGetCompressedMultiTexImageEXT");
   if ( !driverTbl.glGetCompressedMultiTexImageEXT ) {
      driverTbl.glGetCompressedMultiTexImageEXT = missing_glGetCompressedMultiTexImageEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetCompressedMultiTexImageEXT == loader_glGetCompressedMultiTexImageEXT) {
      rCtx->dsp->emuTbl.glGetCompressedMultiTexImageEXT = driverTbl.glGetCompressedMultiTexImageEXT;
   }
   driverTbl.glGetCompressedMultiTexImageEXT(texunit, target, lod, img);
}

static void REGAL_CALL missing_glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, GLvoid *img)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(lod);
   UNUSED_PARAMETER(img);
   Warning( "glGetCompressedTextureImageEXT not available." );
}

static void REGAL_CALL loader_glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, GLvoid *img)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetCompressedTextureImageEXT, "glGetCompressedTextureImageEXT");
   if ( !driverTbl.glGetCompressedTextureImageEXT ) {
      driverTbl.glGetCompressedTextureImageEXT = missing_glGetCompressedTextureImageEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetCompressedTextureImageEXT == loader_glGetCompressedTextureImageEXT) {
      rCtx->dsp->emuTbl.glGetCompressedTextureImageEXT = driverTbl.glGetCompressedTextureImageEXT;
   }
   driverTbl.glGetCompressedTextureImageEXT(texture, target, lod, img);
}

static void REGAL_CALL missing_glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "glGetDoubleIndexedvEXT not available." );
}

static void REGAL_CALL loader_glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetDoubleIndexedvEXT, "glGetDoubleIndexedvEXT");
   if ( !driverTbl.glGetDoubleIndexedvEXT ) {
      driverTbl.glGetDoubleIndexedvEXT = missing_glGetDoubleIndexedvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetDoubleIndexedvEXT == loader_glGetDoubleIndexedvEXT) {
      rCtx->dsp->emuTbl.glGetDoubleIndexedvEXT = driverTbl.glGetDoubleIndexedvEXT;
   }
   driverTbl.glGetDoubleIndexedvEXT(target, index, data);
}

static void REGAL_CALL missing_glGetDoublei_vEXT(GLenum target, GLuint index, GLdouble *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "glGetDoublei_vEXT not available." );
}

static void REGAL_CALL loader_glGetDoublei_vEXT(GLenum target, GLuint index, GLdouble *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetDoublei_vEXT, "glGetDoublei_vEXT");
   if ( !driverTbl.glGetDoublei_vEXT ) {
      driverTbl.glGetDoublei_vEXT = missing_glGetDoublei_vEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetDoublei_vEXT == loader_glGetDoublei_vEXT) {
      rCtx->dsp->emuTbl.glGetDoublei_vEXT = driverTbl.glGetDoublei_vEXT;
   }
   driverTbl.glGetDoublei_vEXT(target, index, data);
}

static void REGAL_CALL missing_glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "glGetFloatIndexedvEXT not available." );
}

static void REGAL_CALL loader_glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFloatIndexedvEXT, "glGetFloatIndexedvEXT");
   if ( !driverTbl.glGetFloatIndexedvEXT ) {
      driverTbl.glGetFloatIndexedvEXT = missing_glGetFloatIndexedvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFloatIndexedvEXT == loader_glGetFloatIndexedvEXT) {
      rCtx->dsp->emuTbl.glGetFloatIndexedvEXT = driverTbl.glGetFloatIndexedvEXT;
   }
   driverTbl.glGetFloatIndexedvEXT(target, index, data);
}

static void REGAL_CALL missing_glGetFloati_vEXT(GLenum target, GLuint index, GLfloat *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "glGetFloati_vEXT not available." );
}

static void REGAL_CALL loader_glGetFloati_vEXT(GLenum target, GLuint index, GLfloat *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFloati_vEXT, "glGetFloati_vEXT");
   if ( !driverTbl.glGetFloati_vEXT ) {
      driverTbl.glGetFloati_vEXT = missing_glGetFloati_vEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFloati_vEXT == loader_glGetFloati_vEXT) {
      rCtx->dsp->emuTbl.glGetFloati_vEXT = driverTbl.glGetFloati_vEXT;
   }
   driverTbl.glGetFloati_vEXT(target, index, data);
}

static void REGAL_CALL missing_glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFramebufferParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFramebufferParameterivEXT, "glGetFramebufferParameterivEXT");
   if ( !driverTbl.glGetFramebufferParameterivEXT ) {
      driverTbl.glGetFramebufferParameterivEXT = missing_glGetFramebufferParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFramebufferParameterivEXT == loader_glGetFramebufferParameterivEXT) {
      rCtx->dsp->emuTbl.glGetFramebufferParameterivEXT = driverTbl.glGetFramebufferParameterivEXT;
   }
   driverTbl.glGetFramebufferParameterivEXT(framebuffer, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMultiTexEnvfvEXT not available." );
}

static void REGAL_CALL loader_glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMultiTexEnvfvEXT, "glGetMultiTexEnvfvEXT");
   if ( !driverTbl.glGetMultiTexEnvfvEXT ) {
      driverTbl.glGetMultiTexEnvfvEXT = missing_glGetMultiTexEnvfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMultiTexEnvfvEXT == loader_glGetMultiTexEnvfvEXT) {
      rCtx->dsp->emuTbl.glGetMultiTexEnvfvEXT = driverTbl.glGetMultiTexEnvfvEXT;
   }
   driverTbl.glGetMultiTexEnvfvEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMultiTexEnvivEXT not available." );
}

static void REGAL_CALL loader_glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMultiTexEnvivEXT, "glGetMultiTexEnvivEXT");
   if ( !driverTbl.glGetMultiTexEnvivEXT ) {
      driverTbl.glGetMultiTexEnvivEXT = missing_glGetMultiTexEnvivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMultiTexEnvivEXT == loader_glGetMultiTexEnvivEXT) {
      rCtx->dsp->emuTbl.glGetMultiTexEnvivEXT = driverTbl.glGetMultiTexEnvivEXT;
   }
   driverTbl.glGetMultiTexEnvivEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMultiTexGendvEXT not available." );
}

static void REGAL_CALL loader_glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMultiTexGendvEXT, "glGetMultiTexGendvEXT");
   if ( !driverTbl.glGetMultiTexGendvEXT ) {
      driverTbl.glGetMultiTexGendvEXT = missing_glGetMultiTexGendvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMultiTexGendvEXT == loader_glGetMultiTexGendvEXT) {
      rCtx->dsp->emuTbl.glGetMultiTexGendvEXT = driverTbl.glGetMultiTexGendvEXT;
   }
   driverTbl.glGetMultiTexGendvEXT(texunit, coord, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMultiTexGenfvEXT not available." );
}

static void REGAL_CALL loader_glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMultiTexGenfvEXT, "glGetMultiTexGenfvEXT");
   if ( !driverTbl.glGetMultiTexGenfvEXT ) {
      driverTbl.glGetMultiTexGenfvEXT = missing_glGetMultiTexGenfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMultiTexGenfvEXT == loader_glGetMultiTexGenfvEXT) {
      rCtx->dsp->emuTbl.glGetMultiTexGenfvEXT = driverTbl.glGetMultiTexGenfvEXT;
   }
   driverTbl.glGetMultiTexGenfvEXT(texunit, coord, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMultiTexGenivEXT not available." );
}

static void REGAL_CALL loader_glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMultiTexGenivEXT, "glGetMultiTexGenivEXT");
   if ( !driverTbl.glGetMultiTexGenivEXT ) {
      driverTbl.glGetMultiTexGenivEXT = missing_glGetMultiTexGenivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMultiTexGenivEXT == loader_glGetMultiTexGenivEXT) {
      rCtx->dsp->emuTbl.glGetMultiTexGenivEXT = driverTbl.glGetMultiTexGenivEXT;
   }
   driverTbl.glGetMultiTexGenivEXT(texunit, coord, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glGetMultiTexImageEXT not available." );
}

static void REGAL_CALL loader_glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMultiTexImageEXT, "glGetMultiTexImageEXT");
   if ( !driverTbl.glGetMultiTexImageEXT ) {
      driverTbl.glGetMultiTexImageEXT = missing_glGetMultiTexImageEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMultiTexImageEXT == loader_glGetMultiTexImageEXT) {
      rCtx->dsp->emuTbl.glGetMultiTexImageEXT = driverTbl.glGetMultiTexImageEXT;
   }
   driverTbl.glGetMultiTexImageEXT(texunit, target, level, format, type, pixels);
}

static void REGAL_CALL missing_glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMultiTexLevelParameterfvEXT not available." );
}

static void REGAL_CALL loader_glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMultiTexLevelParameterfvEXT, "glGetMultiTexLevelParameterfvEXT");
   if ( !driverTbl.glGetMultiTexLevelParameterfvEXT ) {
      driverTbl.glGetMultiTexLevelParameterfvEXT = missing_glGetMultiTexLevelParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMultiTexLevelParameterfvEXT == loader_glGetMultiTexLevelParameterfvEXT) {
      rCtx->dsp->emuTbl.glGetMultiTexLevelParameterfvEXT = driverTbl.glGetMultiTexLevelParameterfvEXT;
   }
   driverTbl.glGetMultiTexLevelParameterfvEXT(texunit, target, level, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMultiTexLevelParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMultiTexLevelParameterivEXT, "glGetMultiTexLevelParameterivEXT");
   if ( !driverTbl.glGetMultiTexLevelParameterivEXT ) {
      driverTbl.glGetMultiTexLevelParameterivEXT = missing_glGetMultiTexLevelParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMultiTexLevelParameterivEXT == loader_glGetMultiTexLevelParameterivEXT) {
      rCtx->dsp->emuTbl.glGetMultiTexLevelParameterivEXT = driverTbl.glGetMultiTexLevelParameterivEXT;
   }
   driverTbl.glGetMultiTexLevelParameterivEXT(texunit, target, level, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMultiTexParameterIivEXT not available." );
}

static void REGAL_CALL loader_glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMultiTexParameterIivEXT, "glGetMultiTexParameterIivEXT");
   if ( !driverTbl.glGetMultiTexParameterIivEXT ) {
      driverTbl.glGetMultiTexParameterIivEXT = missing_glGetMultiTexParameterIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMultiTexParameterIivEXT == loader_glGetMultiTexParameterIivEXT) {
      rCtx->dsp->emuTbl.glGetMultiTexParameterIivEXT = driverTbl.glGetMultiTexParameterIivEXT;
   }
   driverTbl.glGetMultiTexParameterIivEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMultiTexParameterIuivEXT not available." );
}

static void REGAL_CALL loader_glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMultiTexParameterIuivEXT, "glGetMultiTexParameterIuivEXT");
   if ( !driverTbl.glGetMultiTexParameterIuivEXT ) {
      driverTbl.glGetMultiTexParameterIuivEXT = missing_glGetMultiTexParameterIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMultiTexParameterIuivEXT == loader_glGetMultiTexParameterIuivEXT) {
      rCtx->dsp->emuTbl.glGetMultiTexParameterIuivEXT = driverTbl.glGetMultiTexParameterIuivEXT;
   }
   driverTbl.glGetMultiTexParameterIuivEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMultiTexParameterfvEXT not available." );
}

static void REGAL_CALL loader_glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMultiTexParameterfvEXT, "glGetMultiTexParameterfvEXT");
   if ( !driverTbl.glGetMultiTexParameterfvEXT ) {
      driverTbl.glGetMultiTexParameterfvEXT = missing_glGetMultiTexParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMultiTexParameterfvEXT == loader_glGetMultiTexParameterfvEXT) {
      rCtx->dsp->emuTbl.glGetMultiTexParameterfvEXT = driverTbl.glGetMultiTexParameterfvEXT;
   }
   driverTbl.glGetMultiTexParameterfvEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMultiTexParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMultiTexParameterivEXT, "glGetMultiTexParameterivEXT");
   if ( !driverTbl.glGetMultiTexParameterivEXT ) {
      driverTbl.glGetMultiTexParameterivEXT = missing_glGetMultiTexParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMultiTexParameterivEXT == loader_glGetMultiTexParameterivEXT) {
      rCtx->dsp->emuTbl.glGetMultiTexParameterivEXT = driverTbl.glGetMultiTexParameterivEXT;
   }
   driverTbl.glGetMultiTexParameterivEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetNamedBufferParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedBufferParameterivEXT, "glGetNamedBufferParameterivEXT");
   if ( !driverTbl.glGetNamedBufferParameterivEXT ) {
      driverTbl.glGetNamedBufferParameterivEXT = missing_glGetNamedBufferParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedBufferParameterivEXT == loader_glGetNamedBufferParameterivEXT) {
      rCtx->dsp->emuTbl.glGetNamedBufferParameterivEXT = driverTbl.glGetNamedBufferParameterivEXT;
   }
   driverTbl.glGetNamedBufferParameterivEXT(buffer, pname, params);
}

static void REGAL_CALL missing_glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, GLvoid **params)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetNamedBufferPointervEXT not available." );
}

static void REGAL_CALL loader_glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, GLvoid **params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedBufferPointervEXT, "glGetNamedBufferPointervEXT");
   if ( !driverTbl.glGetNamedBufferPointervEXT ) {
      driverTbl.glGetNamedBufferPointervEXT = missing_glGetNamedBufferPointervEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedBufferPointervEXT == loader_glGetNamedBufferPointervEXT) {
      rCtx->dsp->emuTbl.glGetNamedBufferPointervEXT = driverTbl.glGetNamedBufferPointervEXT;
   }
   driverTbl.glGetNamedBufferPointervEXT(buffer, pname, params);
}

static void REGAL_CALL missing_glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   Warning( "glGetNamedBufferSubDataEXT not available." );
}

static void REGAL_CALL loader_glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedBufferSubDataEXT, "glGetNamedBufferSubDataEXT");
   if ( !driverTbl.glGetNamedBufferSubDataEXT ) {
      driverTbl.glGetNamedBufferSubDataEXT = missing_glGetNamedBufferSubDataEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedBufferSubDataEXT == loader_glGetNamedBufferSubDataEXT) {
      rCtx->dsp->emuTbl.glGetNamedBufferSubDataEXT = driverTbl.glGetNamedBufferSubDataEXT;
   }
   driverTbl.glGetNamedBufferSubDataEXT(buffer, offset, size, data);
}

static void REGAL_CALL missing_glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetNamedFramebufferAttachmentParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedFramebufferAttachmentParameterivEXT, "glGetNamedFramebufferAttachmentParameterivEXT");
   if ( !driverTbl.glGetNamedFramebufferAttachmentParameterivEXT ) {
      driverTbl.glGetNamedFramebufferAttachmentParameterivEXT = missing_glGetNamedFramebufferAttachmentParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedFramebufferAttachmentParameterivEXT == loader_glGetNamedFramebufferAttachmentParameterivEXT) {
      rCtx->dsp->emuTbl.glGetNamedFramebufferAttachmentParameterivEXT = driverTbl.glGetNamedFramebufferAttachmentParameterivEXT;
   }
   driverTbl.glGetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, params);
}

static void REGAL_CALL missing_glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glGetNamedProgramLocalParameterIivEXT not available." );
}

static void REGAL_CALL loader_glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedProgramLocalParameterIivEXT, "glGetNamedProgramLocalParameterIivEXT");
   if ( !driverTbl.glGetNamedProgramLocalParameterIivEXT ) {
      driverTbl.glGetNamedProgramLocalParameterIivEXT = missing_glGetNamedProgramLocalParameterIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedProgramLocalParameterIivEXT == loader_glGetNamedProgramLocalParameterIivEXT) {
      rCtx->dsp->emuTbl.glGetNamedProgramLocalParameterIivEXT = driverTbl.glGetNamedProgramLocalParameterIivEXT;
   }
   driverTbl.glGetNamedProgramLocalParameterIivEXT(program, target, index, params);
}

static void REGAL_CALL missing_glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glGetNamedProgramLocalParameterIuivEXT not available." );
}

static void REGAL_CALL loader_glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedProgramLocalParameterIuivEXT, "glGetNamedProgramLocalParameterIuivEXT");
   if ( !driverTbl.glGetNamedProgramLocalParameterIuivEXT ) {
      driverTbl.glGetNamedProgramLocalParameterIuivEXT = missing_glGetNamedProgramLocalParameterIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedProgramLocalParameterIuivEXT == loader_glGetNamedProgramLocalParameterIuivEXT) {
      rCtx->dsp->emuTbl.glGetNamedProgramLocalParameterIuivEXT = driverTbl.glGetNamedProgramLocalParameterIuivEXT;
   }
   driverTbl.glGetNamedProgramLocalParameterIuivEXT(program, target, index, params);
}

static void REGAL_CALL missing_glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glGetNamedProgramLocalParameterdvEXT not available." );
}

static void REGAL_CALL loader_glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedProgramLocalParameterdvEXT, "glGetNamedProgramLocalParameterdvEXT");
   if ( !driverTbl.glGetNamedProgramLocalParameterdvEXT ) {
      driverTbl.glGetNamedProgramLocalParameterdvEXT = missing_glGetNamedProgramLocalParameterdvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedProgramLocalParameterdvEXT == loader_glGetNamedProgramLocalParameterdvEXT) {
      rCtx->dsp->emuTbl.glGetNamedProgramLocalParameterdvEXT = driverTbl.glGetNamedProgramLocalParameterdvEXT;
   }
   driverTbl.glGetNamedProgramLocalParameterdvEXT(program, target, index, params);
}

static void REGAL_CALL missing_glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glGetNamedProgramLocalParameterfvEXT not available." );
}

static void REGAL_CALL loader_glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedProgramLocalParameterfvEXT, "glGetNamedProgramLocalParameterfvEXT");
   if ( !driverTbl.glGetNamedProgramLocalParameterfvEXT ) {
      driverTbl.glGetNamedProgramLocalParameterfvEXT = missing_glGetNamedProgramLocalParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedProgramLocalParameterfvEXT == loader_glGetNamedProgramLocalParameterfvEXT) {
      rCtx->dsp->emuTbl.glGetNamedProgramLocalParameterfvEXT = driverTbl.glGetNamedProgramLocalParameterfvEXT;
   }
   driverTbl.glGetNamedProgramLocalParameterfvEXT(program, target, index, params);
}

static void REGAL_CALL missing_glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, GLvoid *string)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(string);
   Warning( "glGetNamedProgramStringEXT not available." );
}

static void REGAL_CALL loader_glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, GLvoid *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedProgramStringEXT, "glGetNamedProgramStringEXT");
   if ( !driverTbl.glGetNamedProgramStringEXT ) {
      driverTbl.glGetNamedProgramStringEXT = missing_glGetNamedProgramStringEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedProgramStringEXT == loader_glGetNamedProgramStringEXT) {
      rCtx->dsp->emuTbl.glGetNamedProgramStringEXT = driverTbl.glGetNamedProgramStringEXT;
   }
   driverTbl.glGetNamedProgramStringEXT(program, target, pname, string);
}

static void REGAL_CALL missing_glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetNamedProgramivEXT not available." );
}

static void REGAL_CALL loader_glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedProgramivEXT, "glGetNamedProgramivEXT");
   if ( !driverTbl.glGetNamedProgramivEXT ) {
      driverTbl.glGetNamedProgramivEXT = missing_glGetNamedProgramivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedProgramivEXT == loader_glGetNamedProgramivEXT) {
      rCtx->dsp->emuTbl.glGetNamedProgramivEXT = driverTbl.glGetNamedProgramivEXT;
   }
   driverTbl.glGetNamedProgramivEXT(program, target, pname, params);
}

static void REGAL_CALL missing_glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(renderbuffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetNamedRenderbufferParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedRenderbufferParameterivEXT, "glGetNamedRenderbufferParameterivEXT");
   if ( !driverTbl.glGetNamedRenderbufferParameterivEXT ) {
      driverTbl.glGetNamedRenderbufferParameterivEXT = missing_glGetNamedRenderbufferParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedRenderbufferParameterivEXT == loader_glGetNamedRenderbufferParameterivEXT) {
      rCtx->dsp->emuTbl.glGetNamedRenderbufferParameterivEXT = driverTbl.glGetNamedRenderbufferParameterivEXT;
   }
   driverTbl.glGetNamedRenderbufferParameterivEXT(renderbuffer, pname, params);
}

static void REGAL_CALL missing_glGetPointerIndexedvEXT(GLenum target, GLuint index, GLvoid **data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "glGetPointerIndexedvEXT not available." );
}

static void REGAL_CALL loader_glGetPointerIndexedvEXT(GLenum target, GLuint index, GLvoid **data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPointerIndexedvEXT, "glGetPointerIndexedvEXT");
   if ( !driverTbl.glGetPointerIndexedvEXT ) {
      driverTbl.glGetPointerIndexedvEXT = missing_glGetPointerIndexedvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPointerIndexedvEXT == loader_glGetPointerIndexedvEXT) {
      rCtx->dsp->emuTbl.glGetPointerIndexedvEXT = driverTbl.glGetPointerIndexedvEXT;
   }
   driverTbl.glGetPointerIndexedvEXT(target, index, data);
}

static void REGAL_CALL missing_glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glGetTextureImageEXT not available." );
}

static void REGAL_CALL loader_glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTextureImageEXT, "glGetTextureImageEXT");
   if ( !driverTbl.glGetTextureImageEXT ) {
      driverTbl.glGetTextureImageEXT = missing_glGetTextureImageEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTextureImageEXT == loader_glGetTextureImageEXT) {
      rCtx->dsp->emuTbl.glGetTextureImageEXT = driverTbl.glGetTextureImageEXT;
   }
   driverTbl.glGetTextureImageEXT(texture, target, level, format, type, pixels);
}

static void REGAL_CALL missing_glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTextureLevelParameterfvEXT not available." );
}

static void REGAL_CALL loader_glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTextureLevelParameterfvEXT, "glGetTextureLevelParameterfvEXT");
   if ( !driverTbl.glGetTextureLevelParameterfvEXT ) {
      driverTbl.glGetTextureLevelParameterfvEXT = missing_glGetTextureLevelParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTextureLevelParameterfvEXT == loader_glGetTextureLevelParameterfvEXT) {
      rCtx->dsp->emuTbl.glGetTextureLevelParameterfvEXT = driverTbl.glGetTextureLevelParameterfvEXT;
   }
   driverTbl.glGetTextureLevelParameterfvEXT(texture, target, level, pname, params);
}

static void REGAL_CALL missing_glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTextureLevelParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTextureLevelParameterivEXT, "glGetTextureLevelParameterivEXT");
   if ( !driverTbl.glGetTextureLevelParameterivEXT ) {
      driverTbl.glGetTextureLevelParameterivEXT = missing_glGetTextureLevelParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTextureLevelParameterivEXT == loader_glGetTextureLevelParameterivEXT) {
      rCtx->dsp->emuTbl.glGetTextureLevelParameterivEXT = driverTbl.glGetTextureLevelParameterivEXT;
   }
   driverTbl.glGetTextureLevelParameterivEXT(texture, target, level, pname, params);
}

static void REGAL_CALL missing_glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTextureParameterIivEXT not available." );
}

static void REGAL_CALL loader_glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTextureParameterIivEXT, "glGetTextureParameterIivEXT");
   if ( !driverTbl.glGetTextureParameterIivEXT ) {
      driverTbl.glGetTextureParameterIivEXT = missing_glGetTextureParameterIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTextureParameterIivEXT == loader_glGetTextureParameterIivEXT) {
      rCtx->dsp->emuTbl.glGetTextureParameterIivEXT = driverTbl.glGetTextureParameterIivEXT;
   }
   driverTbl.glGetTextureParameterIivEXT(texture, target, pname, params);
}

static void REGAL_CALL missing_glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTextureParameterIuivEXT not available." );
}

static void REGAL_CALL loader_glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTextureParameterIuivEXT, "glGetTextureParameterIuivEXT");
   if ( !driverTbl.glGetTextureParameterIuivEXT ) {
      driverTbl.glGetTextureParameterIuivEXT = missing_glGetTextureParameterIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTextureParameterIuivEXT == loader_glGetTextureParameterIuivEXT) {
      rCtx->dsp->emuTbl.glGetTextureParameterIuivEXT = driverTbl.glGetTextureParameterIuivEXT;
   }
   driverTbl.glGetTextureParameterIuivEXT(texture, target, pname, params);
}

static void REGAL_CALL missing_glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTextureParameterfvEXT not available." );
}

static void REGAL_CALL loader_glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTextureParameterfvEXT, "glGetTextureParameterfvEXT");
   if ( !driverTbl.glGetTextureParameterfvEXT ) {
      driverTbl.glGetTextureParameterfvEXT = missing_glGetTextureParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTextureParameterfvEXT == loader_glGetTextureParameterfvEXT) {
      rCtx->dsp->emuTbl.glGetTextureParameterfvEXT = driverTbl.glGetTextureParameterfvEXT;
   }
   driverTbl.glGetTextureParameterfvEXT(texture, target, pname, params);
}

static void REGAL_CALL missing_glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTextureParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTextureParameterivEXT, "glGetTextureParameterivEXT");
   if ( !driverTbl.glGetTextureParameterivEXT ) {
      driverTbl.glGetTextureParameterivEXT = missing_glGetTextureParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTextureParameterivEXT == loader_glGetTextureParameterivEXT) {
      rCtx->dsp->emuTbl.glGetTextureParameterivEXT = driverTbl.glGetTextureParameterivEXT;
   }
   driverTbl.glGetTextureParameterivEXT(texture, target, pname, params);
}

static void REGAL_CALL missing_glGetVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLint *param)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glGetVertexArrayIntegeri_vEXT not available." );
}

static void REGAL_CALL loader_glGetVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLint *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexArrayIntegeri_vEXT, "glGetVertexArrayIntegeri_vEXT");
   if ( !driverTbl.glGetVertexArrayIntegeri_vEXT ) {
      driverTbl.glGetVertexArrayIntegeri_vEXT = missing_glGetVertexArrayIntegeri_vEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexArrayIntegeri_vEXT == loader_glGetVertexArrayIntegeri_vEXT) {
      rCtx->dsp->emuTbl.glGetVertexArrayIntegeri_vEXT = driverTbl.glGetVertexArrayIntegeri_vEXT;
   }
   driverTbl.glGetVertexArrayIntegeri_vEXT(vaobj, index, pname, param);
}

static void REGAL_CALL missing_glGetVertexArrayIntegervEXT(GLuint vaobj, GLenum pname, GLint *param)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glGetVertexArrayIntegervEXT not available." );
}

static void REGAL_CALL loader_glGetVertexArrayIntegervEXT(GLuint vaobj, GLenum pname, GLint *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexArrayIntegervEXT, "glGetVertexArrayIntegervEXT");
   if ( !driverTbl.glGetVertexArrayIntegervEXT ) {
      driverTbl.glGetVertexArrayIntegervEXT = missing_glGetVertexArrayIntegervEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexArrayIntegervEXT == loader_glGetVertexArrayIntegervEXT) {
      rCtx->dsp->emuTbl.glGetVertexArrayIntegervEXT = driverTbl.glGetVertexArrayIntegervEXT;
   }
   driverTbl.glGetVertexArrayIntegervEXT(vaobj, pname, param);
}

static void REGAL_CALL missing_glGetVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLvoid **param)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glGetVertexArrayPointeri_vEXT not available." );
}

static void REGAL_CALL loader_glGetVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLvoid **param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexArrayPointeri_vEXT, "glGetVertexArrayPointeri_vEXT");
   if ( !driverTbl.glGetVertexArrayPointeri_vEXT ) {
      driverTbl.glGetVertexArrayPointeri_vEXT = missing_glGetVertexArrayPointeri_vEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexArrayPointeri_vEXT == loader_glGetVertexArrayPointeri_vEXT) {
      rCtx->dsp->emuTbl.glGetVertexArrayPointeri_vEXT = driverTbl.glGetVertexArrayPointeri_vEXT;
   }
   driverTbl.glGetVertexArrayPointeri_vEXT(vaobj, index, pname, param);
}

static void REGAL_CALL missing_glGetVertexArrayPointervEXT(GLuint vaobj, GLenum pname, GLvoid **param)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glGetVertexArrayPointervEXT not available." );
}

static void REGAL_CALL loader_glGetVertexArrayPointervEXT(GLuint vaobj, GLenum pname, GLvoid **param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexArrayPointervEXT, "glGetVertexArrayPointervEXT");
   if ( !driverTbl.glGetVertexArrayPointervEXT ) {
      driverTbl.glGetVertexArrayPointervEXT = missing_glGetVertexArrayPointervEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexArrayPointervEXT == loader_glGetVertexArrayPointervEXT) {
      rCtx->dsp->emuTbl.glGetVertexArrayPointervEXT = driverTbl.glGetVertexArrayPointervEXT;
   }
   driverTbl.glGetVertexArrayPointervEXT(vaobj, pname, param);
}

static GLvoid *REGAL_CALL missing_glMapNamedBufferEXT(GLuint buffer, GLenum access)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(access);
   Warning( "glMapNamedBufferEXT not available." );
  GLvoid * ret = NULL;
  return ret;
}

static GLvoid *REGAL_CALL loader_glMapNamedBufferEXT(GLuint buffer, GLenum access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapNamedBufferEXT, "glMapNamedBufferEXT");
   if ( !driverTbl.glMapNamedBufferEXT ) {
      driverTbl.glMapNamedBufferEXT = missing_glMapNamedBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapNamedBufferEXT == loader_glMapNamedBufferEXT) {
      rCtx->dsp->emuTbl.glMapNamedBufferEXT = driverTbl.glMapNamedBufferEXT;
   }
   return driverTbl.glMapNamedBufferEXT(buffer, access);
}

static GLvoid *REGAL_CALL missing_glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(access);
   Warning( "glMapNamedBufferRangeEXT not available." );
  GLvoid * ret = NULL;
  return ret;
}

static GLvoid *REGAL_CALL loader_glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapNamedBufferRangeEXT, "glMapNamedBufferRangeEXT");
   if ( !driverTbl.glMapNamedBufferRangeEXT ) {
      driverTbl.glMapNamedBufferRangeEXT = missing_glMapNamedBufferRangeEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapNamedBufferRangeEXT == loader_glMapNamedBufferRangeEXT) {
      rCtx->dsp->emuTbl.glMapNamedBufferRangeEXT = driverTbl.glMapNamedBufferRangeEXT;
   }
   return driverTbl.glMapNamedBufferRangeEXT(buffer, offset, length, access);
}

static void REGAL_CALL missing_glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(left);
   UNUSED_PARAMETER(right);
   UNUSED_PARAMETER(bottom);
   UNUSED_PARAMETER(top);
   UNUSED_PARAMETER(zNear);
   UNUSED_PARAMETER(zFar);
   Warning( "glMatrixFrustumEXT not available." );
}

static void REGAL_CALL loader_glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixFrustumEXT, "glMatrixFrustumEXT");
   if ( !driverTbl.glMatrixFrustumEXT ) {
      driverTbl.glMatrixFrustumEXT = missing_glMatrixFrustumEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixFrustumEXT == loader_glMatrixFrustumEXT) {
      rCtx->dsp->emuTbl.glMatrixFrustumEXT = driverTbl.glMatrixFrustumEXT;
   }
   driverTbl.glMatrixFrustumEXT(mode, left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL missing_glMatrixLoadIdentityEXT(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glMatrixLoadIdentityEXT not available." );
}

static void REGAL_CALL loader_glMatrixLoadIdentityEXT(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixLoadIdentityEXT, "glMatrixLoadIdentityEXT");
   if ( !driverTbl.glMatrixLoadIdentityEXT ) {
      driverTbl.glMatrixLoadIdentityEXT = missing_glMatrixLoadIdentityEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixLoadIdentityEXT == loader_glMatrixLoadIdentityEXT) {
      rCtx->dsp->emuTbl.glMatrixLoadIdentityEXT = driverTbl.glMatrixLoadIdentityEXT;
   }
   driverTbl.glMatrixLoadIdentityEXT(mode);
}

static void REGAL_CALL missing_glMatrixLoadTransposedEXT(GLenum mode, const GLdouble *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "glMatrixLoadTransposedEXT not available." );
}

static void REGAL_CALL loader_glMatrixLoadTransposedEXT(GLenum mode, const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixLoadTransposedEXT, "glMatrixLoadTransposedEXT");
   if ( !driverTbl.glMatrixLoadTransposedEXT ) {
      driverTbl.glMatrixLoadTransposedEXT = missing_glMatrixLoadTransposedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixLoadTransposedEXT == loader_glMatrixLoadTransposedEXT) {
      rCtx->dsp->emuTbl.glMatrixLoadTransposedEXT = driverTbl.glMatrixLoadTransposedEXT;
   }
   driverTbl.glMatrixLoadTransposedEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixLoadTransposefEXT(GLenum mode, const GLfloat *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "glMatrixLoadTransposefEXT not available." );
}

static void REGAL_CALL loader_glMatrixLoadTransposefEXT(GLenum mode, const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixLoadTransposefEXT, "glMatrixLoadTransposefEXT");
   if ( !driverTbl.glMatrixLoadTransposefEXT ) {
      driverTbl.glMatrixLoadTransposefEXT = missing_glMatrixLoadTransposefEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixLoadTransposefEXT == loader_glMatrixLoadTransposefEXT) {
      rCtx->dsp->emuTbl.glMatrixLoadTransposefEXT = driverTbl.glMatrixLoadTransposefEXT;
   }
   driverTbl.glMatrixLoadTransposefEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixLoaddEXT(GLenum mode, const GLdouble *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "glMatrixLoaddEXT not available." );
}

static void REGAL_CALL loader_glMatrixLoaddEXT(GLenum mode, const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixLoaddEXT, "glMatrixLoaddEXT");
   if ( !driverTbl.glMatrixLoaddEXT ) {
      driverTbl.glMatrixLoaddEXT = missing_glMatrixLoaddEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixLoaddEXT == loader_glMatrixLoaddEXT) {
      rCtx->dsp->emuTbl.glMatrixLoaddEXT = driverTbl.glMatrixLoaddEXT;
   }
   driverTbl.glMatrixLoaddEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixLoadfEXT(GLenum mode, const GLfloat *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "glMatrixLoadfEXT not available." );
}

static void REGAL_CALL loader_glMatrixLoadfEXT(GLenum mode, const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixLoadfEXT, "glMatrixLoadfEXT");
   if ( !driverTbl.glMatrixLoadfEXT ) {
      driverTbl.glMatrixLoadfEXT = missing_glMatrixLoadfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixLoadfEXT == loader_glMatrixLoadfEXT) {
      rCtx->dsp->emuTbl.glMatrixLoadfEXT = driverTbl.glMatrixLoadfEXT;
   }
   driverTbl.glMatrixLoadfEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixMultTransposedEXT(GLenum mode, const GLdouble *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "glMatrixMultTransposedEXT not available." );
}

static void REGAL_CALL loader_glMatrixMultTransposedEXT(GLenum mode, const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixMultTransposedEXT, "glMatrixMultTransposedEXT");
   if ( !driverTbl.glMatrixMultTransposedEXT ) {
      driverTbl.glMatrixMultTransposedEXT = missing_glMatrixMultTransposedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixMultTransposedEXT == loader_glMatrixMultTransposedEXT) {
      rCtx->dsp->emuTbl.glMatrixMultTransposedEXT = driverTbl.glMatrixMultTransposedEXT;
   }
   driverTbl.glMatrixMultTransposedEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixMultTransposefEXT(GLenum mode, const GLfloat *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "glMatrixMultTransposefEXT not available." );
}

static void REGAL_CALL loader_glMatrixMultTransposefEXT(GLenum mode, const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixMultTransposefEXT, "glMatrixMultTransposefEXT");
   if ( !driverTbl.glMatrixMultTransposefEXT ) {
      driverTbl.glMatrixMultTransposefEXT = missing_glMatrixMultTransposefEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixMultTransposefEXT == loader_glMatrixMultTransposefEXT) {
      rCtx->dsp->emuTbl.glMatrixMultTransposefEXT = driverTbl.glMatrixMultTransposefEXT;
   }
   driverTbl.glMatrixMultTransposefEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixMultdEXT(GLenum mode, const GLdouble *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "glMatrixMultdEXT not available." );
}

static void REGAL_CALL loader_glMatrixMultdEXT(GLenum mode, const GLdouble *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixMultdEXT, "glMatrixMultdEXT");
   if ( !driverTbl.glMatrixMultdEXT ) {
      driverTbl.glMatrixMultdEXT = missing_glMatrixMultdEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixMultdEXT == loader_glMatrixMultdEXT) {
      rCtx->dsp->emuTbl.glMatrixMultdEXT = driverTbl.glMatrixMultdEXT;
   }
   driverTbl.glMatrixMultdEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixMultfEXT(GLenum mode, const GLfloat *m)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(m);
   Warning( "glMatrixMultfEXT not available." );
}

static void REGAL_CALL loader_glMatrixMultfEXT(GLenum mode, const GLfloat *m)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixMultfEXT, "glMatrixMultfEXT");
   if ( !driverTbl.glMatrixMultfEXT ) {
      driverTbl.glMatrixMultfEXT = missing_glMatrixMultfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixMultfEXT == loader_glMatrixMultfEXT) {
      rCtx->dsp->emuTbl.glMatrixMultfEXT = driverTbl.glMatrixMultfEXT;
   }
   driverTbl.glMatrixMultfEXT(mode, m);
}

static void REGAL_CALL missing_glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(left);
   UNUSED_PARAMETER(right);
   UNUSED_PARAMETER(bottom);
   UNUSED_PARAMETER(top);
   UNUSED_PARAMETER(zNear);
   UNUSED_PARAMETER(zFar);
   Warning( "glMatrixOrthoEXT not available." );
}

static void REGAL_CALL loader_glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixOrthoEXT, "glMatrixOrthoEXT");
   if ( !driverTbl.glMatrixOrthoEXT ) {
      driverTbl.glMatrixOrthoEXT = missing_glMatrixOrthoEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixOrthoEXT == loader_glMatrixOrthoEXT) {
      rCtx->dsp->emuTbl.glMatrixOrthoEXT = driverTbl.glMatrixOrthoEXT;
   }
   driverTbl.glMatrixOrthoEXT(mode, left, right, bottom, top, zNear, zFar);
}

static void REGAL_CALL missing_glMatrixPopEXT(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glMatrixPopEXT not available." );
}

static void REGAL_CALL loader_glMatrixPopEXT(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixPopEXT, "glMatrixPopEXT");
   if ( !driverTbl.glMatrixPopEXT ) {
      driverTbl.glMatrixPopEXT = missing_glMatrixPopEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixPopEXT == loader_glMatrixPopEXT) {
      rCtx->dsp->emuTbl.glMatrixPopEXT = driverTbl.glMatrixPopEXT;
   }
   driverTbl.glMatrixPopEXT(mode);
}

static void REGAL_CALL missing_glMatrixPushEXT(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glMatrixPushEXT not available." );
}

static void REGAL_CALL loader_glMatrixPushEXT(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixPushEXT, "glMatrixPushEXT");
   if ( !driverTbl.glMatrixPushEXT ) {
      driverTbl.glMatrixPushEXT = missing_glMatrixPushEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixPushEXT == loader_glMatrixPushEXT) {
      rCtx->dsp->emuTbl.glMatrixPushEXT = driverTbl.glMatrixPushEXT;
   }
   driverTbl.glMatrixPushEXT(mode);
}

static void REGAL_CALL missing_glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(angle);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glMatrixRotatedEXT not available." );
}

static void REGAL_CALL loader_glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixRotatedEXT, "glMatrixRotatedEXT");
   if ( !driverTbl.glMatrixRotatedEXT ) {
      driverTbl.glMatrixRotatedEXT = missing_glMatrixRotatedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixRotatedEXT == loader_glMatrixRotatedEXT) {
      rCtx->dsp->emuTbl.glMatrixRotatedEXT = driverTbl.glMatrixRotatedEXT;
   }
   driverTbl.glMatrixRotatedEXT(mode, angle, x, y, z);
}

static void REGAL_CALL missing_glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(angle);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glMatrixRotatefEXT not available." );
}

static void REGAL_CALL loader_glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixRotatefEXT, "glMatrixRotatefEXT");
   if ( !driverTbl.glMatrixRotatefEXT ) {
      driverTbl.glMatrixRotatefEXT = missing_glMatrixRotatefEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixRotatefEXT == loader_glMatrixRotatefEXT) {
      rCtx->dsp->emuTbl.glMatrixRotatefEXT = driverTbl.glMatrixRotatefEXT;
   }
   driverTbl.glMatrixRotatefEXT(mode, angle, x, y, z);
}

static void REGAL_CALL missing_glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glMatrixScaledEXT not available." );
}

static void REGAL_CALL loader_glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixScaledEXT, "glMatrixScaledEXT");
   if ( !driverTbl.glMatrixScaledEXT ) {
      driverTbl.glMatrixScaledEXT = missing_glMatrixScaledEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixScaledEXT == loader_glMatrixScaledEXT) {
      rCtx->dsp->emuTbl.glMatrixScaledEXT = driverTbl.glMatrixScaledEXT;
   }
   driverTbl.glMatrixScaledEXT(mode, x, y, z);
}

static void REGAL_CALL missing_glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glMatrixScalefEXT not available." );
}

static void REGAL_CALL loader_glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixScalefEXT, "glMatrixScalefEXT");
   if ( !driverTbl.glMatrixScalefEXT ) {
      driverTbl.glMatrixScalefEXT = missing_glMatrixScalefEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixScalefEXT == loader_glMatrixScalefEXT) {
      rCtx->dsp->emuTbl.glMatrixScalefEXT = driverTbl.glMatrixScalefEXT;
   }
   driverTbl.glMatrixScalefEXT(mode, x, y, z);
}

static void REGAL_CALL missing_glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glMatrixTranslatedEXT not available." );
}

static void REGAL_CALL loader_glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixTranslatedEXT, "glMatrixTranslatedEXT");
   if ( !driverTbl.glMatrixTranslatedEXT ) {
      driverTbl.glMatrixTranslatedEXT = missing_glMatrixTranslatedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixTranslatedEXT == loader_glMatrixTranslatedEXT) {
      rCtx->dsp->emuTbl.glMatrixTranslatedEXT = driverTbl.glMatrixTranslatedEXT;
   }
   driverTbl.glMatrixTranslatedEXT(mode, x, y, z);
}

static void REGAL_CALL missing_glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glMatrixTranslatefEXT not available." );
}

static void REGAL_CALL loader_glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMatrixTranslatefEXT, "glMatrixTranslatefEXT");
   if ( !driverTbl.glMatrixTranslatefEXT ) {
      driverTbl.glMatrixTranslatefEXT = missing_glMatrixTranslatefEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMatrixTranslatefEXT == loader_glMatrixTranslatefEXT) {
      rCtx->dsp->emuTbl.glMatrixTranslatefEXT = driverTbl.glMatrixTranslatefEXT;
   }
   driverTbl.glMatrixTranslatefEXT(mode, x, y, z);
}

static void REGAL_CALL missing_glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(buffer);
   Warning( "glMultiTexBufferEXT not available." );
}

static void REGAL_CALL loader_glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexBufferEXT, "glMultiTexBufferEXT");
   if ( !driverTbl.glMultiTexBufferEXT ) {
      driverTbl.glMultiTexBufferEXT = missing_glMultiTexBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexBufferEXT == loader_glMultiTexBufferEXT) {
      rCtx->dsp->emuTbl.glMultiTexBufferEXT = driverTbl.glMultiTexBufferEXT;
   }
   driverTbl.glMultiTexBufferEXT(texunit, target, internalformat, buffer);
}

static void REGAL_CALL missing_glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glMultiTexCoordPointerEXT not available." );
}

static void REGAL_CALL loader_glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoordPointerEXT, "glMultiTexCoordPointerEXT");
   if ( !driverTbl.glMultiTexCoordPointerEXT ) {
      driverTbl.glMultiTexCoordPointerEXT = missing_glMultiTexCoordPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoordPointerEXT == loader_glMultiTexCoordPointerEXT) {
      rCtx->dsp->emuTbl.glMultiTexCoordPointerEXT = driverTbl.glMultiTexCoordPointerEXT;
   }
   driverTbl.glMultiTexCoordPointerEXT(texunit, size, type, stride, pointer);
}

static void REGAL_CALL missing_glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glMultiTexEnvfEXT not available." );
}

static void REGAL_CALL loader_glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexEnvfEXT, "glMultiTexEnvfEXT");
   if ( !driverTbl.glMultiTexEnvfEXT ) {
      driverTbl.glMultiTexEnvfEXT = missing_glMultiTexEnvfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexEnvfEXT == loader_glMultiTexEnvfEXT) {
      rCtx->dsp->emuTbl.glMultiTexEnvfEXT = driverTbl.glMultiTexEnvfEXT;
   }
   driverTbl.glMultiTexEnvfEXT(texunit, target, pname, param);
}

static void REGAL_CALL missing_glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glMultiTexEnvfvEXT not available." );
}

static void REGAL_CALL loader_glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexEnvfvEXT, "glMultiTexEnvfvEXT");
   if ( !driverTbl.glMultiTexEnvfvEXT ) {
      driverTbl.glMultiTexEnvfvEXT = missing_glMultiTexEnvfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexEnvfvEXT == loader_glMultiTexEnvfvEXT) {
      rCtx->dsp->emuTbl.glMultiTexEnvfvEXT = driverTbl.glMultiTexEnvfvEXT;
   }
   driverTbl.glMultiTexEnvfvEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glMultiTexEnviEXT not available." );
}

static void REGAL_CALL loader_glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexEnviEXT, "glMultiTexEnviEXT");
   if ( !driverTbl.glMultiTexEnviEXT ) {
      driverTbl.glMultiTexEnviEXT = missing_glMultiTexEnviEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexEnviEXT == loader_glMultiTexEnviEXT) {
      rCtx->dsp->emuTbl.glMultiTexEnviEXT = driverTbl.glMultiTexEnviEXT;
   }
   driverTbl.glMultiTexEnviEXT(texunit, target, pname, param);
}

static void REGAL_CALL missing_glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glMultiTexEnvivEXT not available." );
}

static void REGAL_CALL loader_glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexEnvivEXT, "glMultiTexEnvivEXT");
   if ( !driverTbl.glMultiTexEnvivEXT ) {
      driverTbl.glMultiTexEnvivEXT = missing_glMultiTexEnvivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexEnvivEXT == loader_glMultiTexEnvivEXT) {
      rCtx->dsp->emuTbl.glMultiTexEnvivEXT = driverTbl.glMultiTexEnvivEXT;
   }
   driverTbl.glMultiTexEnvivEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glMultiTexGendEXT not available." );
}

static void REGAL_CALL loader_glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexGendEXT, "glMultiTexGendEXT");
   if ( !driverTbl.glMultiTexGendEXT ) {
      driverTbl.glMultiTexGendEXT = missing_glMultiTexGendEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexGendEXT == loader_glMultiTexGendEXT) {
      rCtx->dsp->emuTbl.glMultiTexGendEXT = driverTbl.glMultiTexGendEXT;
   }
   driverTbl.glMultiTexGendEXT(texunit, coord, pname, param);
}

static void REGAL_CALL missing_glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glMultiTexGendvEXT not available." );
}

static void REGAL_CALL loader_glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexGendvEXT, "glMultiTexGendvEXT");
   if ( !driverTbl.glMultiTexGendvEXT ) {
      driverTbl.glMultiTexGendvEXT = missing_glMultiTexGendvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexGendvEXT == loader_glMultiTexGendvEXT) {
      rCtx->dsp->emuTbl.glMultiTexGendvEXT = driverTbl.glMultiTexGendvEXT;
   }
   driverTbl.glMultiTexGendvEXT(texunit, coord, pname, params);
}

static void REGAL_CALL missing_glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glMultiTexGenfEXT not available." );
}

static void REGAL_CALL loader_glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexGenfEXT, "glMultiTexGenfEXT");
   if ( !driverTbl.glMultiTexGenfEXT ) {
      driverTbl.glMultiTexGenfEXT = missing_glMultiTexGenfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexGenfEXT == loader_glMultiTexGenfEXT) {
      rCtx->dsp->emuTbl.glMultiTexGenfEXT = driverTbl.glMultiTexGenfEXT;
   }
   driverTbl.glMultiTexGenfEXT(texunit, coord, pname, param);
}

static void REGAL_CALL missing_glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glMultiTexGenfvEXT not available." );
}

static void REGAL_CALL loader_glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexGenfvEXT, "glMultiTexGenfvEXT");
   if ( !driverTbl.glMultiTexGenfvEXT ) {
      driverTbl.glMultiTexGenfvEXT = missing_glMultiTexGenfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexGenfvEXT == loader_glMultiTexGenfvEXT) {
      rCtx->dsp->emuTbl.glMultiTexGenfvEXT = driverTbl.glMultiTexGenfvEXT;
   }
   driverTbl.glMultiTexGenfvEXT(texunit, coord, pname, params);
}

static void REGAL_CALL missing_glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glMultiTexGeniEXT not available." );
}

static void REGAL_CALL loader_glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexGeniEXT, "glMultiTexGeniEXT");
   if ( !driverTbl.glMultiTexGeniEXT ) {
      driverTbl.glMultiTexGeniEXT = missing_glMultiTexGeniEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexGeniEXT == loader_glMultiTexGeniEXT) {
      rCtx->dsp->emuTbl.glMultiTexGeniEXT = driverTbl.glMultiTexGeniEXT;
   }
   driverTbl.glMultiTexGeniEXT(texunit, coord, pname, param);
}

static void REGAL_CALL missing_glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glMultiTexGenivEXT not available." );
}

static void REGAL_CALL loader_glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexGenivEXT, "glMultiTexGenivEXT");
   if ( !driverTbl.glMultiTexGenivEXT ) {
      driverTbl.glMultiTexGenivEXT = missing_glMultiTexGenivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexGenivEXT == loader_glMultiTexGenivEXT) {
      rCtx->dsp->emuTbl.glMultiTexGenivEXT = driverTbl.glMultiTexGenivEXT;
   }
   driverTbl.glMultiTexGenivEXT(texunit, coord, pname, params);
}

static void REGAL_CALL missing_glMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glMultiTexImage1DEXT not available." );
}

static void REGAL_CALL loader_glMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexImage1DEXT, "glMultiTexImage1DEXT");
   if ( !driverTbl.glMultiTexImage1DEXT ) {
      driverTbl.glMultiTexImage1DEXT = missing_glMultiTexImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexImage1DEXT == loader_glMultiTexImage1DEXT) {
      rCtx->dsp->emuTbl.glMultiTexImage1DEXT = driverTbl.glMultiTexImage1DEXT;
   }
   driverTbl.glMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, type, pixels);
}

static void REGAL_CALL missing_glMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glMultiTexImage2DEXT not available." );
}

static void REGAL_CALL loader_glMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexImage2DEXT, "glMultiTexImage2DEXT");
   if ( !driverTbl.glMultiTexImage2DEXT ) {
      driverTbl.glMultiTexImage2DEXT = missing_glMultiTexImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexImage2DEXT == loader_glMultiTexImage2DEXT) {
      rCtx->dsp->emuTbl.glMultiTexImage2DEXT = driverTbl.glMultiTexImage2DEXT;
   }
   driverTbl.glMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, type, pixels);
}

static void REGAL_CALL missing_glMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glMultiTexImage3DEXT not available." );
}

static void REGAL_CALL loader_glMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexImage3DEXT, "glMultiTexImage3DEXT");
   if ( !driverTbl.glMultiTexImage3DEXT ) {
      driverTbl.glMultiTexImage3DEXT = missing_glMultiTexImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexImage3DEXT == loader_glMultiTexImage3DEXT) {
      rCtx->dsp->emuTbl.glMultiTexImage3DEXT = driverTbl.glMultiTexImage3DEXT;
   }
   driverTbl.glMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
}

static void REGAL_CALL missing_glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glMultiTexParameterIivEXT not available." );
}

static void REGAL_CALL loader_glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexParameterIivEXT, "glMultiTexParameterIivEXT");
   if ( !driverTbl.glMultiTexParameterIivEXT ) {
      driverTbl.glMultiTexParameterIivEXT = missing_glMultiTexParameterIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexParameterIivEXT == loader_glMultiTexParameterIivEXT) {
      rCtx->dsp->emuTbl.glMultiTexParameterIivEXT = driverTbl.glMultiTexParameterIivEXT;
   }
   driverTbl.glMultiTexParameterIivEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint *params)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glMultiTexParameterIuivEXT not available." );
}

static void REGAL_CALL loader_glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexParameterIuivEXT, "glMultiTexParameterIuivEXT");
   if ( !driverTbl.glMultiTexParameterIuivEXT ) {
      driverTbl.glMultiTexParameterIuivEXT = missing_glMultiTexParameterIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexParameterIuivEXT == loader_glMultiTexParameterIuivEXT) {
      rCtx->dsp->emuTbl.glMultiTexParameterIuivEXT = driverTbl.glMultiTexParameterIuivEXT;
   }
   driverTbl.glMultiTexParameterIuivEXT(texunit, target, pname, params);
}

static void REGAL_CALL missing_glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glMultiTexParameterfEXT not available." );
}

static void REGAL_CALL loader_glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexParameterfEXT, "glMultiTexParameterfEXT");
   if ( !driverTbl.glMultiTexParameterfEXT ) {
      driverTbl.glMultiTexParameterfEXT = missing_glMultiTexParameterfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexParameterfEXT == loader_glMultiTexParameterfEXT) {
      rCtx->dsp->emuTbl.glMultiTexParameterfEXT = driverTbl.glMultiTexParameterfEXT;
   }
   driverTbl.glMultiTexParameterfEXT(texunit, target, pname, param);
}

static void REGAL_CALL missing_glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glMultiTexParameterfvEXT not available." );
}

static void REGAL_CALL loader_glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexParameterfvEXT, "glMultiTexParameterfvEXT");
   if ( !driverTbl.glMultiTexParameterfvEXT ) {
      driverTbl.glMultiTexParameterfvEXT = missing_glMultiTexParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexParameterfvEXT == loader_glMultiTexParameterfvEXT) {
      rCtx->dsp->emuTbl.glMultiTexParameterfvEXT = driverTbl.glMultiTexParameterfvEXT;
   }
   driverTbl.glMultiTexParameterfvEXT(texunit, target, pname, param);
}

static void REGAL_CALL missing_glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glMultiTexParameteriEXT not available." );
}

static void REGAL_CALL loader_glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexParameteriEXT, "glMultiTexParameteriEXT");
   if ( !driverTbl.glMultiTexParameteriEXT ) {
      driverTbl.glMultiTexParameteriEXT = missing_glMultiTexParameteriEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexParameteriEXT == loader_glMultiTexParameteriEXT) {
      rCtx->dsp->emuTbl.glMultiTexParameteriEXT = driverTbl.glMultiTexParameteriEXT;
   }
   driverTbl.glMultiTexParameteriEXT(texunit, target, pname, param);
}

static void REGAL_CALL missing_glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *param)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glMultiTexParameterivEXT not available." );
}

static void REGAL_CALL loader_glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexParameterivEXT, "glMultiTexParameterivEXT");
   if ( !driverTbl.glMultiTexParameterivEXT ) {
      driverTbl.glMultiTexParameterivEXT = missing_glMultiTexParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexParameterivEXT == loader_glMultiTexParameterivEXT) {
      rCtx->dsp->emuTbl.glMultiTexParameterivEXT = driverTbl.glMultiTexParameterivEXT;
   }
   driverTbl.glMultiTexParameterivEXT(texunit, target, pname, param);
}

static void REGAL_CALL missing_glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "glMultiTexRenderbufferEXT not available." );
}

static void REGAL_CALL loader_glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexRenderbufferEXT, "glMultiTexRenderbufferEXT");
   if ( !driverTbl.glMultiTexRenderbufferEXT ) {
      driverTbl.glMultiTexRenderbufferEXT = missing_glMultiTexRenderbufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexRenderbufferEXT == loader_glMultiTexRenderbufferEXT) {
      rCtx->dsp->emuTbl.glMultiTexRenderbufferEXT = driverTbl.glMultiTexRenderbufferEXT;
   }
   driverTbl.glMultiTexRenderbufferEXT(texunit, target, renderbuffer);
}

static void REGAL_CALL missing_glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glMultiTexSubImage1DEXT not available." );
}

static void REGAL_CALL loader_glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexSubImage1DEXT, "glMultiTexSubImage1DEXT");
   if ( !driverTbl.glMultiTexSubImage1DEXT ) {
      driverTbl.glMultiTexSubImage1DEXT = missing_glMultiTexSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexSubImage1DEXT == loader_glMultiTexSubImage1DEXT) {
      rCtx->dsp->emuTbl.glMultiTexSubImage1DEXT = driverTbl.glMultiTexSubImage1DEXT;
   }
   driverTbl.glMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL missing_glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glMultiTexSubImage2DEXT not available." );
}

static void REGAL_CALL loader_glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexSubImage2DEXT, "glMultiTexSubImage2DEXT");
   if ( !driverTbl.glMultiTexSubImage2DEXT ) {
      driverTbl.glMultiTexSubImage2DEXT = missing_glMultiTexSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexSubImage2DEXT == loader_glMultiTexSubImage2DEXT) {
      rCtx->dsp->emuTbl.glMultiTexSubImage2DEXT = driverTbl.glMultiTexSubImage2DEXT;
   }
   driverTbl.glMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL missing_glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glMultiTexSubImage3DEXT not available." );
}

static void REGAL_CALL loader_glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexSubImage3DEXT, "glMultiTexSubImage3DEXT");
   if ( !driverTbl.glMultiTexSubImage3DEXT ) {
      driverTbl.glMultiTexSubImage3DEXT = missing_glMultiTexSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexSubImage3DEXT == loader_glMultiTexSubImage3DEXT) {
      rCtx->dsp->emuTbl.glMultiTexSubImage3DEXT = driverTbl.glMultiTexSubImage3DEXT;
   }
   driverTbl.glMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

static void REGAL_CALL missing_glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   UNUSED_PARAMETER(usage);
   Warning( "glNamedBufferDataEXT not available." );
}

static void REGAL_CALL loader_glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedBufferDataEXT, "glNamedBufferDataEXT");
   if ( !driverTbl.glNamedBufferDataEXT ) {
      driverTbl.glNamedBufferDataEXT = missing_glNamedBufferDataEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedBufferDataEXT == loader_glNamedBufferDataEXT) {
      rCtx->dsp->emuTbl.glNamedBufferDataEXT = driverTbl.glNamedBufferDataEXT;
   }
   driverTbl.glNamedBufferDataEXT(buffer, size, data, usage);
}

static void REGAL_CALL missing_glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(data);
   Warning( "glNamedBufferSubDataEXT not available." );
}

static void REGAL_CALL loader_glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedBufferSubDataEXT, "glNamedBufferSubDataEXT");
   if ( !driverTbl.glNamedBufferSubDataEXT ) {
      driverTbl.glNamedBufferSubDataEXT = missing_glNamedBufferSubDataEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedBufferSubDataEXT == loader_glNamedBufferSubDataEXT) {
      rCtx->dsp->emuTbl.glNamedBufferSubDataEXT = driverTbl.glNamedBufferSubDataEXT;
   }
   driverTbl.glNamedBufferSubDataEXT(buffer, offset, size, data);
}

static void REGAL_CALL missing_glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
   UNUSED_PARAMETER(readBuffer);
   UNUSED_PARAMETER(writeBuffer);
   UNUSED_PARAMETER(readOffset);
   UNUSED_PARAMETER(writeOffset);
   UNUSED_PARAMETER(size);
   Warning( "glNamedCopyBufferSubDataEXT not available." );
}

static void REGAL_CALL loader_glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedCopyBufferSubDataEXT, "glNamedCopyBufferSubDataEXT");
   if ( !driverTbl.glNamedCopyBufferSubDataEXT ) {
      driverTbl.glNamedCopyBufferSubDataEXT = missing_glNamedCopyBufferSubDataEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedCopyBufferSubDataEXT == loader_glNamedCopyBufferSubDataEXT) {
      rCtx->dsp->emuTbl.glNamedCopyBufferSubDataEXT = driverTbl.glNamedCopyBufferSubDataEXT;
   }
   driverTbl.glNamedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size);
}

static void REGAL_CALL missing_glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(renderbuffertarget);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "glNamedFramebufferRenderbufferEXT not available." );
}

static void REGAL_CALL loader_glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedFramebufferRenderbufferEXT, "glNamedFramebufferRenderbufferEXT");
   if ( !driverTbl.glNamedFramebufferRenderbufferEXT ) {
      driverTbl.glNamedFramebufferRenderbufferEXT = missing_glNamedFramebufferRenderbufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedFramebufferRenderbufferEXT == loader_glNamedFramebufferRenderbufferEXT) {
      rCtx->dsp->emuTbl.glNamedFramebufferRenderbufferEXT = driverTbl.glNamedFramebufferRenderbufferEXT;
   }
   driverTbl.glNamedFramebufferRenderbufferEXT(framebuffer, attachment, renderbuffertarget, renderbuffer);
}

static void REGAL_CALL missing_glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "glNamedFramebufferTexture1DEXT not available." );
}

static void REGAL_CALL loader_glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedFramebufferTexture1DEXT, "glNamedFramebufferTexture1DEXT");
   if ( !driverTbl.glNamedFramebufferTexture1DEXT ) {
      driverTbl.glNamedFramebufferTexture1DEXT = missing_glNamedFramebufferTexture1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedFramebufferTexture1DEXT == loader_glNamedFramebufferTexture1DEXT) {
      rCtx->dsp->emuTbl.glNamedFramebufferTexture1DEXT = driverTbl.glNamedFramebufferTexture1DEXT;
   }
   driverTbl.glNamedFramebufferTexture1DEXT(framebuffer, attachment, textarget, texture, level);
}

static void REGAL_CALL missing_glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "glNamedFramebufferTexture2DEXT not available." );
}

static void REGAL_CALL loader_glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedFramebufferTexture2DEXT, "glNamedFramebufferTexture2DEXT");
   if ( !driverTbl.glNamedFramebufferTexture2DEXT ) {
      driverTbl.glNamedFramebufferTexture2DEXT = missing_glNamedFramebufferTexture2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedFramebufferTexture2DEXT == loader_glNamedFramebufferTexture2DEXT) {
      rCtx->dsp->emuTbl.glNamedFramebufferTexture2DEXT = driverTbl.glNamedFramebufferTexture2DEXT;
   }
   driverTbl.glNamedFramebufferTexture2DEXT(framebuffer, attachment, textarget, texture, level);
}

static void REGAL_CALL missing_glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(zoffset);
   Warning( "glNamedFramebufferTexture3DEXT not available." );
}

static void REGAL_CALL loader_glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedFramebufferTexture3DEXT, "glNamedFramebufferTexture3DEXT");
   if ( !driverTbl.glNamedFramebufferTexture3DEXT ) {
      driverTbl.glNamedFramebufferTexture3DEXT = missing_glNamedFramebufferTexture3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedFramebufferTexture3DEXT == loader_glNamedFramebufferTexture3DEXT) {
      rCtx->dsp->emuTbl.glNamedFramebufferTexture3DEXT = driverTbl.glNamedFramebufferTexture3DEXT;
   }
   driverTbl.glNamedFramebufferTexture3DEXT(framebuffer, attachment, textarget, texture, level, zoffset);
}

static void REGAL_CALL missing_glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "glNamedFramebufferTextureEXT not available." );
}

static void REGAL_CALL loader_glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedFramebufferTextureEXT, "glNamedFramebufferTextureEXT");
   if ( !driverTbl.glNamedFramebufferTextureEXT ) {
      driverTbl.glNamedFramebufferTextureEXT = missing_glNamedFramebufferTextureEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedFramebufferTextureEXT == loader_glNamedFramebufferTextureEXT) {
      rCtx->dsp->emuTbl.glNamedFramebufferTextureEXT = driverTbl.glNamedFramebufferTextureEXT;
   }
   driverTbl.glNamedFramebufferTextureEXT(framebuffer, attachment, texture, level);
}

static void REGAL_CALL missing_glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(face);
   Warning( "glNamedFramebufferTextureFaceEXT not available." );
}

static void REGAL_CALL loader_glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedFramebufferTextureFaceEXT, "glNamedFramebufferTextureFaceEXT");
   if ( !driverTbl.glNamedFramebufferTextureFaceEXT ) {
      driverTbl.glNamedFramebufferTextureFaceEXT = missing_glNamedFramebufferTextureFaceEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedFramebufferTextureFaceEXT == loader_glNamedFramebufferTextureFaceEXT) {
      rCtx->dsp->emuTbl.glNamedFramebufferTextureFaceEXT = driverTbl.glNamedFramebufferTextureFaceEXT;
   }
   driverTbl.glNamedFramebufferTextureFaceEXT(framebuffer, attachment, texture, level, face);
}

static void REGAL_CALL missing_glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   UNUSED_PARAMETER(framebuffer);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layer);
   Warning( "glNamedFramebufferTextureLayerEXT not available." );
}

static void REGAL_CALL loader_glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedFramebufferTextureLayerEXT, "glNamedFramebufferTextureLayerEXT");
   if ( !driverTbl.glNamedFramebufferTextureLayerEXT ) {
      driverTbl.glNamedFramebufferTextureLayerEXT = missing_glNamedFramebufferTextureLayerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedFramebufferTextureLayerEXT == loader_glNamedFramebufferTextureLayerEXT) {
      rCtx->dsp->emuTbl.glNamedFramebufferTextureLayerEXT = driverTbl.glNamedFramebufferTextureLayerEXT;
   }
   driverTbl.glNamedFramebufferTextureLayerEXT(framebuffer, attachment, texture, level, layer);
}

static void REGAL_CALL missing_glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glNamedProgramLocalParameter4dEXT not available." );
}

static void REGAL_CALL loader_glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedProgramLocalParameter4dEXT, "glNamedProgramLocalParameter4dEXT");
   if ( !driverTbl.glNamedProgramLocalParameter4dEXT ) {
      driverTbl.glNamedProgramLocalParameter4dEXT = missing_glNamedProgramLocalParameter4dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedProgramLocalParameter4dEXT == loader_glNamedProgramLocalParameter4dEXT) {
      rCtx->dsp->emuTbl.glNamedProgramLocalParameter4dEXT = driverTbl.glNamedProgramLocalParameter4dEXT;
   }
   driverTbl.glNamedProgramLocalParameter4dEXT(program, target, index, x, y, z, w);
}

static void REGAL_CALL missing_glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glNamedProgramLocalParameter4dvEXT not available." );
}

static void REGAL_CALL loader_glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedProgramLocalParameter4dvEXT, "glNamedProgramLocalParameter4dvEXT");
   if ( !driverTbl.glNamedProgramLocalParameter4dvEXT ) {
      driverTbl.glNamedProgramLocalParameter4dvEXT = missing_glNamedProgramLocalParameter4dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedProgramLocalParameter4dvEXT == loader_glNamedProgramLocalParameter4dvEXT) {
      rCtx->dsp->emuTbl.glNamedProgramLocalParameter4dvEXT = driverTbl.glNamedProgramLocalParameter4dvEXT;
   }
   driverTbl.glNamedProgramLocalParameter4dvEXT(program, target, index, params);
}

static void REGAL_CALL missing_glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glNamedProgramLocalParameter4fEXT not available." );
}

static void REGAL_CALL loader_glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedProgramLocalParameter4fEXT, "glNamedProgramLocalParameter4fEXT");
   if ( !driverTbl.glNamedProgramLocalParameter4fEXT ) {
      driverTbl.glNamedProgramLocalParameter4fEXT = missing_glNamedProgramLocalParameter4fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedProgramLocalParameter4fEXT == loader_glNamedProgramLocalParameter4fEXT) {
      rCtx->dsp->emuTbl.glNamedProgramLocalParameter4fEXT = driverTbl.glNamedProgramLocalParameter4fEXT;
   }
   driverTbl.glNamedProgramLocalParameter4fEXT(program, target, index, x, y, z, w);
}

static void REGAL_CALL missing_glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glNamedProgramLocalParameter4fvEXT not available." );
}

static void REGAL_CALL loader_glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedProgramLocalParameter4fvEXT, "glNamedProgramLocalParameter4fvEXT");
   if ( !driverTbl.glNamedProgramLocalParameter4fvEXT ) {
      driverTbl.glNamedProgramLocalParameter4fvEXT = missing_glNamedProgramLocalParameter4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedProgramLocalParameter4fvEXT == loader_glNamedProgramLocalParameter4fvEXT) {
      rCtx->dsp->emuTbl.glNamedProgramLocalParameter4fvEXT = driverTbl.glNamedProgramLocalParameter4fvEXT;
   }
   driverTbl.glNamedProgramLocalParameter4fvEXT(program, target, index, params);
}

static void REGAL_CALL missing_glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glNamedProgramLocalParameterI4iEXT not available." );
}

static void REGAL_CALL loader_glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedProgramLocalParameterI4iEXT, "glNamedProgramLocalParameterI4iEXT");
   if ( !driverTbl.glNamedProgramLocalParameterI4iEXT ) {
      driverTbl.glNamedProgramLocalParameterI4iEXT = missing_glNamedProgramLocalParameterI4iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedProgramLocalParameterI4iEXT == loader_glNamedProgramLocalParameterI4iEXT) {
      rCtx->dsp->emuTbl.glNamedProgramLocalParameterI4iEXT = driverTbl.glNamedProgramLocalParameterI4iEXT;
   }
   driverTbl.glNamedProgramLocalParameterI4iEXT(program, target, index, x, y, z, w);
}

static void REGAL_CALL missing_glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glNamedProgramLocalParameterI4ivEXT not available." );
}

static void REGAL_CALL loader_glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedProgramLocalParameterI4ivEXT, "glNamedProgramLocalParameterI4ivEXT");
   if ( !driverTbl.glNamedProgramLocalParameterI4ivEXT ) {
      driverTbl.glNamedProgramLocalParameterI4ivEXT = missing_glNamedProgramLocalParameterI4ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedProgramLocalParameterI4ivEXT == loader_glNamedProgramLocalParameterI4ivEXT) {
      rCtx->dsp->emuTbl.glNamedProgramLocalParameterI4ivEXT = driverTbl.glNamedProgramLocalParameterI4ivEXT;
   }
   driverTbl.glNamedProgramLocalParameterI4ivEXT(program, target, index, params);
}

static void REGAL_CALL missing_glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glNamedProgramLocalParameterI4uiEXT not available." );
}

static void REGAL_CALL loader_glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedProgramLocalParameterI4uiEXT, "glNamedProgramLocalParameterI4uiEXT");
   if ( !driverTbl.glNamedProgramLocalParameterI4uiEXT ) {
      driverTbl.glNamedProgramLocalParameterI4uiEXT = missing_glNamedProgramLocalParameterI4uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedProgramLocalParameterI4uiEXT == loader_glNamedProgramLocalParameterI4uiEXT) {
      rCtx->dsp->emuTbl.glNamedProgramLocalParameterI4uiEXT = driverTbl.glNamedProgramLocalParameterI4uiEXT;
   }
   driverTbl.glNamedProgramLocalParameterI4uiEXT(program, target, index, x, y, z, w);
}

static void REGAL_CALL missing_glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glNamedProgramLocalParameterI4uivEXT not available." );
}

static void REGAL_CALL loader_glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedProgramLocalParameterI4uivEXT, "glNamedProgramLocalParameterI4uivEXT");
   if ( !driverTbl.glNamedProgramLocalParameterI4uivEXT ) {
      driverTbl.glNamedProgramLocalParameterI4uivEXT = missing_glNamedProgramLocalParameterI4uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedProgramLocalParameterI4uivEXT == loader_glNamedProgramLocalParameterI4uivEXT) {
      rCtx->dsp->emuTbl.glNamedProgramLocalParameterI4uivEXT = driverTbl.glNamedProgramLocalParameterI4uivEXT;
   }
   driverTbl.glNamedProgramLocalParameterI4uivEXT(program, target, index, params);
}

static void REGAL_CALL missing_glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "glNamedProgramLocalParameters4fvEXT not available." );
}

static void REGAL_CALL loader_glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedProgramLocalParameters4fvEXT, "glNamedProgramLocalParameters4fvEXT");
   if ( !driverTbl.glNamedProgramLocalParameters4fvEXT ) {
      driverTbl.glNamedProgramLocalParameters4fvEXT = missing_glNamedProgramLocalParameters4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedProgramLocalParameters4fvEXT == loader_glNamedProgramLocalParameters4fvEXT) {
      rCtx->dsp->emuTbl.glNamedProgramLocalParameters4fvEXT = driverTbl.glNamedProgramLocalParameters4fvEXT;
   }
   driverTbl.glNamedProgramLocalParameters4fvEXT(program, target, index, count, params);
}

static void REGAL_CALL missing_glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "glNamedProgramLocalParametersI4ivEXT not available." );
}

static void REGAL_CALL loader_glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedProgramLocalParametersI4ivEXT, "glNamedProgramLocalParametersI4ivEXT");
   if ( !driverTbl.glNamedProgramLocalParametersI4ivEXT ) {
      driverTbl.glNamedProgramLocalParametersI4ivEXT = missing_glNamedProgramLocalParametersI4ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedProgramLocalParametersI4ivEXT == loader_glNamedProgramLocalParametersI4ivEXT) {
      rCtx->dsp->emuTbl.glNamedProgramLocalParametersI4ivEXT = driverTbl.glNamedProgramLocalParametersI4ivEXT;
   }
   driverTbl.glNamedProgramLocalParametersI4ivEXT(program, target, index, count, params);
}

static void REGAL_CALL missing_glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "glNamedProgramLocalParametersI4uivEXT not available." );
}

static void REGAL_CALL loader_glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedProgramLocalParametersI4uivEXT, "glNamedProgramLocalParametersI4uivEXT");
   if ( !driverTbl.glNamedProgramLocalParametersI4uivEXT ) {
      driverTbl.glNamedProgramLocalParametersI4uivEXT = missing_glNamedProgramLocalParametersI4uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedProgramLocalParametersI4uivEXT == loader_glNamedProgramLocalParametersI4uivEXT) {
      rCtx->dsp->emuTbl.glNamedProgramLocalParametersI4uivEXT = driverTbl.glNamedProgramLocalParametersI4uivEXT;
   }
   driverTbl.glNamedProgramLocalParametersI4uivEXT(program, target, index, count, params);
}

static void REGAL_CALL missing_glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(string);
   Warning( "glNamedProgramStringEXT not available." );
}

static void REGAL_CALL loader_glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedProgramStringEXT, "glNamedProgramStringEXT");
   if ( !driverTbl.glNamedProgramStringEXT ) {
      driverTbl.glNamedProgramStringEXT = missing_glNamedProgramStringEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedProgramStringEXT == loader_glNamedProgramStringEXT) {
      rCtx->dsp->emuTbl.glNamedProgramStringEXT = driverTbl.glNamedProgramStringEXT;
   }
   driverTbl.glNamedProgramStringEXT(program, target, format, len, string);
}

static void REGAL_CALL missing_glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(renderbuffer);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glNamedRenderbufferStorageEXT not available." );
}

static void REGAL_CALL loader_glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedRenderbufferStorageEXT, "glNamedRenderbufferStorageEXT");
   if ( !driverTbl.glNamedRenderbufferStorageEXT ) {
      driverTbl.glNamedRenderbufferStorageEXT = missing_glNamedRenderbufferStorageEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedRenderbufferStorageEXT == loader_glNamedRenderbufferStorageEXT) {
      rCtx->dsp->emuTbl.glNamedRenderbufferStorageEXT = driverTbl.glNamedRenderbufferStorageEXT;
   }
   driverTbl.glNamedRenderbufferStorageEXT(renderbuffer, internalformat, width, height);
}

static void REGAL_CALL missing_glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(renderbuffer);
   UNUSED_PARAMETER(coverageSamples);
   UNUSED_PARAMETER(colorSamples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glNamedRenderbufferStorageMultisampleCoverageEXT not available." );
}

static void REGAL_CALL loader_glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedRenderbufferStorageMultisampleCoverageEXT, "glNamedRenderbufferStorageMultisampleCoverageEXT");
   if ( !driverTbl.glNamedRenderbufferStorageMultisampleCoverageEXT ) {
      driverTbl.glNamedRenderbufferStorageMultisampleCoverageEXT = missing_glNamedRenderbufferStorageMultisampleCoverageEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedRenderbufferStorageMultisampleCoverageEXT == loader_glNamedRenderbufferStorageMultisampleCoverageEXT) {
      rCtx->dsp->emuTbl.glNamedRenderbufferStorageMultisampleCoverageEXT = driverTbl.glNamedRenderbufferStorageMultisampleCoverageEXT;
   }
   driverTbl.glNamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
}

static void REGAL_CALL missing_glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(renderbuffer);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glNamedRenderbufferStorageMultisampleEXT not available." );
}

static void REGAL_CALL loader_glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNamedRenderbufferStorageMultisampleEXT, "glNamedRenderbufferStorageMultisampleEXT");
   if ( !driverTbl.glNamedRenderbufferStorageMultisampleEXT ) {
      driverTbl.glNamedRenderbufferStorageMultisampleEXT = missing_glNamedRenderbufferStorageMultisampleEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNamedRenderbufferStorageMultisampleEXT == loader_glNamedRenderbufferStorageMultisampleEXT) {
      rCtx->dsp->emuTbl.glNamedRenderbufferStorageMultisampleEXT = driverTbl.glNamedRenderbufferStorageMultisampleEXT;
   }
   driverTbl.glNamedRenderbufferStorageMultisampleEXT(renderbuffer, samples, internalformat, width, height);
}

static void REGAL_CALL missing_glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "glProgramUniform1dEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1dEXT, "glProgramUniform1dEXT");
   if ( !driverTbl.glProgramUniform1dEXT ) {
      driverTbl.glProgramUniform1dEXT = missing_glProgramUniform1dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1dEXT == loader_glProgramUniform1dEXT) {
      rCtx->dsp->emuTbl.glProgramUniform1dEXT = driverTbl.glProgramUniform1dEXT;
   }
   driverTbl.glProgramUniform1dEXT(program, location, x);
}

static void REGAL_CALL missing_glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform1dvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1dvEXT, "glProgramUniform1dvEXT");
   if ( !driverTbl.glProgramUniform1dvEXT ) {
      driverTbl.glProgramUniform1dvEXT = missing_glProgramUniform1dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1dvEXT == loader_glProgramUniform1dvEXT) {
      rCtx->dsp->emuTbl.glProgramUniform1dvEXT = driverTbl.glProgramUniform1dvEXT;
   }
   driverTbl.glProgramUniform1dvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "glProgramUniform1fEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1fEXT, "glProgramUniform1fEXT");
   if ( !driverTbl.glProgramUniform1fEXT ) {
      driverTbl.glProgramUniform1fEXT = missing_glProgramUniform1fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1fEXT == loader_glProgramUniform1fEXT) {
      rCtx->dsp->emuTbl.glProgramUniform1fEXT = driverTbl.glProgramUniform1fEXT;
   }
   driverTbl.glProgramUniform1fEXT(program, location, v0);
}

static void REGAL_CALL missing_glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform1fvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1fvEXT, "glProgramUniform1fvEXT");
   if ( !driverTbl.glProgramUniform1fvEXT ) {
      driverTbl.glProgramUniform1fvEXT = missing_glProgramUniform1fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1fvEXT == loader_glProgramUniform1fvEXT) {
      rCtx->dsp->emuTbl.glProgramUniform1fvEXT = driverTbl.glProgramUniform1fvEXT;
   }
   driverTbl.glProgramUniform1fvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform1iEXT(GLuint program, GLint location, GLint v0)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "glProgramUniform1iEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform1iEXT(GLuint program, GLint location, GLint v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1iEXT, "glProgramUniform1iEXT");
   if ( !driverTbl.glProgramUniform1iEXT ) {
      driverTbl.glProgramUniform1iEXT = missing_glProgramUniform1iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1iEXT == loader_glProgramUniform1iEXT) {
      rCtx->dsp->emuTbl.glProgramUniform1iEXT = driverTbl.glProgramUniform1iEXT;
   }
   driverTbl.glProgramUniform1iEXT(program, location, v0);
}

static void REGAL_CALL missing_glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform1ivEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1ivEXT, "glProgramUniform1ivEXT");
   if ( !driverTbl.glProgramUniform1ivEXT ) {
      driverTbl.glProgramUniform1ivEXT = missing_glProgramUniform1ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1ivEXT == loader_glProgramUniform1ivEXT) {
      rCtx->dsp->emuTbl.glProgramUniform1ivEXT = driverTbl.glProgramUniform1ivEXT;
   }
   driverTbl.glProgramUniform1ivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "glProgramUniform1uiEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1uiEXT, "glProgramUniform1uiEXT");
   if ( !driverTbl.glProgramUniform1uiEXT ) {
      driverTbl.glProgramUniform1uiEXT = missing_glProgramUniform1uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1uiEXT == loader_glProgramUniform1uiEXT) {
      rCtx->dsp->emuTbl.glProgramUniform1uiEXT = driverTbl.glProgramUniform1uiEXT;
   }
   driverTbl.glProgramUniform1uiEXT(program, location, v0);
}

static void REGAL_CALL missing_glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform1uivEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1uivEXT, "glProgramUniform1uivEXT");
   if ( !driverTbl.glProgramUniform1uivEXT ) {
      driverTbl.glProgramUniform1uivEXT = missing_glProgramUniform1uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1uivEXT == loader_glProgramUniform1uivEXT) {
      rCtx->dsp->emuTbl.glProgramUniform1uivEXT = driverTbl.glProgramUniform1uivEXT;
   }
   driverTbl.glProgramUniform1uivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glProgramUniform2dEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2dEXT, "glProgramUniform2dEXT");
   if ( !driverTbl.glProgramUniform2dEXT ) {
      driverTbl.glProgramUniform2dEXT = missing_glProgramUniform2dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2dEXT == loader_glProgramUniform2dEXT) {
      rCtx->dsp->emuTbl.glProgramUniform2dEXT = driverTbl.glProgramUniform2dEXT;
   }
   driverTbl.glProgramUniform2dEXT(program, location, x, y);
}

static void REGAL_CALL missing_glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform2dvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2dvEXT, "glProgramUniform2dvEXT");
   if ( !driverTbl.glProgramUniform2dvEXT ) {
      driverTbl.glProgramUniform2dvEXT = missing_glProgramUniform2dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2dvEXT == loader_glProgramUniform2dvEXT) {
      rCtx->dsp->emuTbl.glProgramUniform2dvEXT = driverTbl.glProgramUniform2dvEXT;
   }
   driverTbl.glProgramUniform2dvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "glProgramUniform2fEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2fEXT, "glProgramUniform2fEXT");
   if ( !driverTbl.glProgramUniform2fEXT ) {
      driverTbl.glProgramUniform2fEXT = missing_glProgramUniform2fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2fEXT == loader_glProgramUniform2fEXT) {
      rCtx->dsp->emuTbl.glProgramUniform2fEXT = driverTbl.glProgramUniform2fEXT;
   }
   driverTbl.glProgramUniform2fEXT(program, location, v0, v1);
}

static void REGAL_CALL missing_glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform2fvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2fvEXT, "glProgramUniform2fvEXT");
   if ( !driverTbl.glProgramUniform2fvEXT ) {
      driverTbl.glProgramUniform2fvEXT = missing_glProgramUniform2fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2fvEXT == loader_glProgramUniform2fvEXT) {
      rCtx->dsp->emuTbl.glProgramUniform2fvEXT = driverTbl.glProgramUniform2fvEXT;
   }
   driverTbl.glProgramUniform2fvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "glProgramUniform2iEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2iEXT, "glProgramUniform2iEXT");
   if ( !driverTbl.glProgramUniform2iEXT ) {
      driverTbl.glProgramUniform2iEXT = missing_glProgramUniform2iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2iEXT == loader_glProgramUniform2iEXT) {
      rCtx->dsp->emuTbl.glProgramUniform2iEXT = driverTbl.glProgramUniform2iEXT;
   }
   driverTbl.glProgramUniform2iEXT(program, location, v0, v1);
}

static void REGAL_CALL missing_glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform2ivEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2ivEXT, "glProgramUniform2ivEXT");
   if ( !driverTbl.glProgramUniform2ivEXT ) {
      driverTbl.glProgramUniform2ivEXT = missing_glProgramUniform2ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2ivEXT == loader_glProgramUniform2ivEXT) {
      rCtx->dsp->emuTbl.glProgramUniform2ivEXT = driverTbl.glProgramUniform2ivEXT;
   }
   driverTbl.glProgramUniform2ivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "glProgramUniform2uiEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2uiEXT, "glProgramUniform2uiEXT");
   if ( !driverTbl.glProgramUniform2uiEXT ) {
      driverTbl.glProgramUniform2uiEXT = missing_glProgramUniform2uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2uiEXT == loader_glProgramUniform2uiEXT) {
      rCtx->dsp->emuTbl.glProgramUniform2uiEXT = driverTbl.glProgramUniform2uiEXT;
   }
   driverTbl.glProgramUniform2uiEXT(program, location, v0, v1);
}

static void REGAL_CALL missing_glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform2uivEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2uivEXT, "glProgramUniform2uivEXT");
   if ( !driverTbl.glProgramUniform2uivEXT ) {
      driverTbl.glProgramUniform2uivEXT = missing_glProgramUniform2uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2uivEXT == loader_glProgramUniform2uivEXT) {
      rCtx->dsp->emuTbl.glProgramUniform2uivEXT = driverTbl.glProgramUniform2uivEXT;
   }
   driverTbl.glProgramUniform2uivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glProgramUniform3dEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3dEXT, "glProgramUniform3dEXT");
   if ( !driverTbl.glProgramUniform3dEXT ) {
      driverTbl.glProgramUniform3dEXT = missing_glProgramUniform3dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3dEXT == loader_glProgramUniform3dEXT) {
      rCtx->dsp->emuTbl.glProgramUniform3dEXT = driverTbl.glProgramUniform3dEXT;
   }
   driverTbl.glProgramUniform3dEXT(program, location, x, y, z);
}

static void REGAL_CALL missing_glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform3dvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3dvEXT, "glProgramUniform3dvEXT");
   if ( !driverTbl.glProgramUniform3dvEXT ) {
      driverTbl.glProgramUniform3dvEXT = missing_glProgramUniform3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3dvEXT == loader_glProgramUniform3dvEXT) {
      rCtx->dsp->emuTbl.glProgramUniform3dvEXT = driverTbl.glProgramUniform3dvEXT;
   }
   driverTbl.glProgramUniform3dvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glProgramUniform3fEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3fEXT, "glProgramUniform3fEXT");
   if ( !driverTbl.glProgramUniform3fEXT ) {
      driverTbl.glProgramUniform3fEXT = missing_glProgramUniform3fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3fEXT == loader_glProgramUniform3fEXT) {
      rCtx->dsp->emuTbl.glProgramUniform3fEXT = driverTbl.glProgramUniform3fEXT;
   }
   driverTbl.glProgramUniform3fEXT(program, location, v0, v1, v2);
}

static void REGAL_CALL missing_glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform3fvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3fvEXT, "glProgramUniform3fvEXT");
   if ( !driverTbl.glProgramUniform3fvEXT ) {
      driverTbl.glProgramUniform3fvEXT = missing_glProgramUniform3fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3fvEXT == loader_glProgramUniform3fvEXT) {
      rCtx->dsp->emuTbl.glProgramUniform3fvEXT = driverTbl.glProgramUniform3fvEXT;
   }
   driverTbl.glProgramUniform3fvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glProgramUniform3iEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3iEXT, "glProgramUniform3iEXT");
   if ( !driverTbl.glProgramUniform3iEXT ) {
      driverTbl.glProgramUniform3iEXT = missing_glProgramUniform3iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3iEXT == loader_glProgramUniform3iEXT) {
      rCtx->dsp->emuTbl.glProgramUniform3iEXT = driverTbl.glProgramUniform3iEXT;
   }
   driverTbl.glProgramUniform3iEXT(program, location, v0, v1, v2);
}

static void REGAL_CALL missing_glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform3ivEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3ivEXT, "glProgramUniform3ivEXT");
   if ( !driverTbl.glProgramUniform3ivEXT ) {
      driverTbl.glProgramUniform3ivEXT = missing_glProgramUniform3ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3ivEXT == loader_glProgramUniform3ivEXT) {
      rCtx->dsp->emuTbl.glProgramUniform3ivEXT = driverTbl.glProgramUniform3ivEXT;
   }
   driverTbl.glProgramUniform3ivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glProgramUniform3uiEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3uiEXT, "glProgramUniform3uiEXT");
   if ( !driverTbl.glProgramUniform3uiEXT ) {
      driverTbl.glProgramUniform3uiEXT = missing_glProgramUniform3uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3uiEXT == loader_glProgramUniform3uiEXT) {
      rCtx->dsp->emuTbl.glProgramUniform3uiEXT = driverTbl.glProgramUniform3uiEXT;
   }
   driverTbl.glProgramUniform3uiEXT(program, location, v0, v1, v2);
}

static void REGAL_CALL missing_glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform3uivEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3uivEXT, "glProgramUniform3uivEXT");
   if ( !driverTbl.glProgramUniform3uivEXT ) {
      driverTbl.glProgramUniform3uivEXT = missing_glProgramUniform3uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3uivEXT == loader_glProgramUniform3uivEXT) {
      rCtx->dsp->emuTbl.glProgramUniform3uivEXT = driverTbl.glProgramUniform3uivEXT;
   }
   driverTbl.glProgramUniform3uivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramUniform4dEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4dEXT, "glProgramUniform4dEXT");
   if ( !driverTbl.glProgramUniform4dEXT ) {
      driverTbl.glProgramUniform4dEXT = missing_glProgramUniform4dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4dEXT == loader_glProgramUniform4dEXT) {
      rCtx->dsp->emuTbl.glProgramUniform4dEXT = driverTbl.glProgramUniform4dEXT;
   }
   driverTbl.glProgramUniform4dEXT(program, location, x, y, z, w);
}

static void REGAL_CALL missing_glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform4dvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4dvEXT, "glProgramUniform4dvEXT");
   if ( !driverTbl.glProgramUniform4dvEXT ) {
      driverTbl.glProgramUniform4dvEXT = missing_glProgramUniform4dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4dvEXT == loader_glProgramUniform4dvEXT) {
      rCtx->dsp->emuTbl.glProgramUniform4dvEXT = driverTbl.glProgramUniform4dvEXT;
   }
   driverTbl.glProgramUniform4dvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "glProgramUniform4fEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4fEXT, "glProgramUniform4fEXT");
   if ( !driverTbl.glProgramUniform4fEXT ) {
      driverTbl.glProgramUniform4fEXT = missing_glProgramUniform4fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4fEXT == loader_glProgramUniform4fEXT) {
      rCtx->dsp->emuTbl.glProgramUniform4fEXT = driverTbl.glProgramUniform4fEXT;
   }
   driverTbl.glProgramUniform4fEXT(program, location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform4fvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4fvEXT, "glProgramUniform4fvEXT");
   if ( !driverTbl.glProgramUniform4fvEXT ) {
      driverTbl.glProgramUniform4fvEXT = missing_glProgramUniform4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4fvEXT == loader_glProgramUniform4fvEXT) {
      rCtx->dsp->emuTbl.glProgramUniform4fvEXT = driverTbl.glProgramUniform4fvEXT;
   }
   driverTbl.glProgramUniform4fvEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "glProgramUniform4iEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4iEXT, "glProgramUniform4iEXT");
   if ( !driverTbl.glProgramUniform4iEXT ) {
      driverTbl.glProgramUniform4iEXT = missing_glProgramUniform4iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4iEXT == loader_glProgramUniform4iEXT) {
      rCtx->dsp->emuTbl.glProgramUniform4iEXT = driverTbl.glProgramUniform4iEXT;
   }
   driverTbl.glProgramUniform4iEXT(program, location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform4ivEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4ivEXT, "glProgramUniform4ivEXT");
   if ( !driverTbl.glProgramUniform4ivEXT ) {
      driverTbl.glProgramUniform4ivEXT = missing_glProgramUniform4ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4ivEXT == loader_glProgramUniform4ivEXT) {
      rCtx->dsp->emuTbl.glProgramUniform4ivEXT = driverTbl.glProgramUniform4ivEXT;
   }
   driverTbl.glProgramUniform4ivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "glProgramUniform4uiEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4uiEXT, "glProgramUniform4uiEXT");
   if ( !driverTbl.glProgramUniform4uiEXT ) {
      driverTbl.glProgramUniform4uiEXT = missing_glProgramUniform4uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4uiEXT == loader_glProgramUniform4uiEXT) {
      rCtx->dsp->emuTbl.glProgramUniform4uiEXT = driverTbl.glProgramUniform4uiEXT;
   }
   driverTbl.glProgramUniform4uiEXT(program, location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform4uivEXT not available." );
}

static void REGAL_CALL loader_glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4uivEXT, "glProgramUniform4uivEXT");
   if ( !driverTbl.glProgramUniform4uivEXT ) {
      driverTbl.glProgramUniform4uivEXT = missing_glProgramUniform4uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4uivEXT == loader_glProgramUniform4uivEXT) {
      rCtx->dsp->emuTbl.glProgramUniform4uivEXT = driverTbl.glProgramUniform4uivEXT;
   }
   driverTbl.glProgramUniform4uivEXT(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix2dvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix2dvEXT, "glProgramUniformMatrix2dvEXT");
   if ( !driverTbl.glProgramUniformMatrix2dvEXT ) {
      driverTbl.glProgramUniformMatrix2dvEXT = missing_glProgramUniformMatrix2dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix2dvEXT == loader_glProgramUniformMatrix2dvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix2dvEXT = driverTbl.glProgramUniformMatrix2dvEXT;
   }
   driverTbl.glProgramUniformMatrix2dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix2fvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix2fvEXT, "glProgramUniformMatrix2fvEXT");
   if ( !driverTbl.glProgramUniformMatrix2fvEXT ) {
      driverTbl.glProgramUniformMatrix2fvEXT = missing_glProgramUniformMatrix2fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix2fvEXT == loader_glProgramUniformMatrix2fvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix2fvEXT = driverTbl.glProgramUniformMatrix2fvEXT;
   }
   driverTbl.glProgramUniformMatrix2fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix2x3dvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix2x3dvEXT, "glProgramUniformMatrix2x3dvEXT");
   if ( !driverTbl.glProgramUniformMatrix2x3dvEXT ) {
      driverTbl.glProgramUniformMatrix2x3dvEXT = missing_glProgramUniformMatrix2x3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix2x3dvEXT == loader_glProgramUniformMatrix2x3dvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix2x3dvEXT = driverTbl.glProgramUniformMatrix2x3dvEXT;
   }
   driverTbl.glProgramUniformMatrix2x3dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix2x3fvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix2x3fvEXT, "glProgramUniformMatrix2x3fvEXT");
   if ( !driverTbl.glProgramUniformMatrix2x3fvEXT ) {
      driverTbl.glProgramUniformMatrix2x3fvEXT = missing_glProgramUniformMatrix2x3fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix2x3fvEXT == loader_glProgramUniformMatrix2x3fvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix2x3fvEXT = driverTbl.glProgramUniformMatrix2x3fvEXT;
   }
   driverTbl.glProgramUniformMatrix2x3fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix2x4dvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix2x4dvEXT, "glProgramUniformMatrix2x4dvEXT");
   if ( !driverTbl.glProgramUniformMatrix2x4dvEXT ) {
      driverTbl.glProgramUniformMatrix2x4dvEXT = missing_glProgramUniformMatrix2x4dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix2x4dvEXT == loader_glProgramUniformMatrix2x4dvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix2x4dvEXT = driverTbl.glProgramUniformMatrix2x4dvEXT;
   }
   driverTbl.glProgramUniformMatrix2x4dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix2x4fvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix2x4fvEXT, "glProgramUniformMatrix2x4fvEXT");
   if ( !driverTbl.glProgramUniformMatrix2x4fvEXT ) {
      driverTbl.glProgramUniformMatrix2x4fvEXT = missing_glProgramUniformMatrix2x4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix2x4fvEXT == loader_glProgramUniformMatrix2x4fvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix2x4fvEXT = driverTbl.glProgramUniformMatrix2x4fvEXT;
   }
   driverTbl.glProgramUniformMatrix2x4fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix3dvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix3dvEXT, "glProgramUniformMatrix3dvEXT");
   if ( !driverTbl.glProgramUniformMatrix3dvEXT ) {
      driverTbl.glProgramUniformMatrix3dvEXT = missing_glProgramUniformMatrix3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix3dvEXT == loader_glProgramUniformMatrix3dvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix3dvEXT = driverTbl.glProgramUniformMatrix3dvEXT;
   }
   driverTbl.glProgramUniformMatrix3dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix3fvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix3fvEXT, "glProgramUniformMatrix3fvEXT");
   if ( !driverTbl.glProgramUniformMatrix3fvEXT ) {
      driverTbl.glProgramUniformMatrix3fvEXT = missing_glProgramUniformMatrix3fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix3fvEXT == loader_glProgramUniformMatrix3fvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix3fvEXT = driverTbl.glProgramUniformMatrix3fvEXT;
   }
   driverTbl.glProgramUniformMatrix3fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix3x2dvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix3x2dvEXT, "glProgramUniformMatrix3x2dvEXT");
   if ( !driverTbl.glProgramUniformMatrix3x2dvEXT ) {
      driverTbl.glProgramUniformMatrix3x2dvEXT = missing_glProgramUniformMatrix3x2dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix3x2dvEXT == loader_glProgramUniformMatrix3x2dvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix3x2dvEXT = driverTbl.glProgramUniformMatrix3x2dvEXT;
   }
   driverTbl.glProgramUniformMatrix3x2dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix3x2fvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix3x2fvEXT, "glProgramUniformMatrix3x2fvEXT");
   if ( !driverTbl.glProgramUniformMatrix3x2fvEXT ) {
      driverTbl.glProgramUniformMatrix3x2fvEXT = missing_glProgramUniformMatrix3x2fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix3x2fvEXT == loader_glProgramUniformMatrix3x2fvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix3x2fvEXT = driverTbl.glProgramUniformMatrix3x2fvEXT;
   }
   driverTbl.glProgramUniformMatrix3x2fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix3x4dvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix3x4dvEXT, "glProgramUniformMatrix3x4dvEXT");
   if ( !driverTbl.glProgramUniformMatrix3x4dvEXT ) {
      driverTbl.glProgramUniformMatrix3x4dvEXT = missing_glProgramUniformMatrix3x4dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix3x4dvEXT == loader_glProgramUniformMatrix3x4dvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix3x4dvEXT = driverTbl.glProgramUniformMatrix3x4dvEXT;
   }
   driverTbl.glProgramUniformMatrix3x4dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix3x4fvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix3x4fvEXT, "glProgramUniformMatrix3x4fvEXT");
   if ( !driverTbl.glProgramUniformMatrix3x4fvEXT ) {
      driverTbl.glProgramUniformMatrix3x4fvEXT = missing_glProgramUniformMatrix3x4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix3x4fvEXT == loader_glProgramUniformMatrix3x4fvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix3x4fvEXT = driverTbl.glProgramUniformMatrix3x4fvEXT;
   }
   driverTbl.glProgramUniformMatrix3x4fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix4dvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix4dvEXT, "glProgramUniformMatrix4dvEXT");
   if ( !driverTbl.glProgramUniformMatrix4dvEXT ) {
      driverTbl.glProgramUniformMatrix4dvEXT = missing_glProgramUniformMatrix4dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix4dvEXT == loader_glProgramUniformMatrix4dvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix4dvEXT = driverTbl.glProgramUniformMatrix4dvEXT;
   }
   driverTbl.glProgramUniformMatrix4dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix4fvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix4fvEXT, "glProgramUniformMatrix4fvEXT");
   if ( !driverTbl.glProgramUniformMatrix4fvEXT ) {
      driverTbl.glProgramUniformMatrix4fvEXT = missing_glProgramUniformMatrix4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix4fvEXT == loader_glProgramUniformMatrix4fvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix4fvEXT = driverTbl.glProgramUniformMatrix4fvEXT;
   }
   driverTbl.glProgramUniformMatrix4fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix4x2dvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix4x2dvEXT, "glProgramUniformMatrix4x2dvEXT");
   if ( !driverTbl.glProgramUniformMatrix4x2dvEXT ) {
      driverTbl.glProgramUniformMatrix4x2dvEXT = missing_glProgramUniformMatrix4x2dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix4x2dvEXT == loader_glProgramUniformMatrix4x2dvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix4x2dvEXT = driverTbl.glProgramUniformMatrix4x2dvEXT;
   }
   driverTbl.glProgramUniformMatrix4x2dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix4x2fvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix4x2fvEXT, "glProgramUniformMatrix4x2fvEXT");
   if ( !driverTbl.glProgramUniformMatrix4x2fvEXT ) {
      driverTbl.glProgramUniformMatrix4x2fvEXT = missing_glProgramUniformMatrix4x2fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix4x2fvEXT == loader_glProgramUniformMatrix4x2fvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix4x2fvEXT = driverTbl.glProgramUniformMatrix4x2fvEXT;
   }
   driverTbl.glProgramUniformMatrix4x2fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix4x3dvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix4x3dvEXT, "glProgramUniformMatrix4x3dvEXT");
   if ( !driverTbl.glProgramUniformMatrix4x3dvEXT ) {
      driverTbl.glProgramUniformMatrix4x3dvEXT = missing_glProgramUniformMatrix4x3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix4x3dvEXT == loader_glProgramUniformMatrix4x3dvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix4x3dvEXT = driverTbl.glProgramUniformMatrix4x3dvEXT;
   }
   driverTbl.glProgramUniformMatrix4x3dvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(transpose);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformMatrix4x3fvEXT not available." );
}

static void REGAL_CALL loader_glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformMatrix4x3fvEXT, "glProgramUniformMatrix4x3fvEXT");
   if ( !driverTbl.glProgramUniformMatrix4x3fvEXT ) {
      driverTbl.glProgramUniformMatrix4x3fvEXT = missing_glProgramUniformMatrix4x3fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformMatrix4x3fvEXT == loader_glProgramUniformMatrix4x3fvEXT) {
      rCtx->dsp->emuTbl.glProgramUniformMatrix4x3fvEXT = driverTbl.glProgramUniformMatrix4x3fvEXT;
   }
   driverTbl.glProgramUniformMatrix4x3fvEXT(program, location, count, transpose, value);
}

static void REGAL_CALL missing_glPushClientAttribDefaultEXT(GLbitfield mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "glPushClientAttribDefaultEXT not available." );
}

static void REGAL_CALL loader_glPushClientAttribDefaultEXT(GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPushClientAttribDefaultEXT, "glPushClientAttribDefaultEXT");
   if ( !driverTbl.glPushClientAttribDefaultEXT ) {
      driverTbl.glPushClientAttribDefaultEXT = missing_glPushClientAttribDefaultEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPushClientAttribDefaultEXT == loader_glPushClientAttribDefaultEXT) {
      rCtx->dsp->emuTbl.glPushClientAttribDefaultEXT = driverTbl.glPushClientAttribDefaultEXT;
   }
   driverTbl.glPushClientAttribDefaultEXT(mask);
}

static void REGAL_CALL missing_glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(buffer);
   Warning( "glTextureBufferEXT not available." );
}

static void REGAL_CALL loader_glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureBufferEXT, "glTextureBufferEXT");
   if ( !driverTbl.glTextureBufferEXT ) {
      driverTbl.glTextureBufferEXT = missing_glTextureBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureBufferEXT == loader_glTextureBufferEXT) {
      rCtx->dsp->emuTbl.glTextureBufferEXT = driverTbl.glTextureBufferEXT;
   }
   driverTbl.glTextureBufferEXT(texture, target, internalformat, buffer);
}

static void REGAL_CALL missing_glTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTextureImage1DEXT not available." );
}

static void REGAL_CALL loader_glTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureImage1DEXT, "glTextureImage1DEXT");
   if ( !driverTbl.glTextureImage1DEXT ) {
      driverTbl.glTextureImage1DEXT = missing_glTextureImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureImage1DEXT == loader_glTextureImage1DEXT) {
      rCtx->dsp->emuTbl.glTextureImage1DEXT = driverTbl.glTextureImage1DEXT;
   }
   driverTbl.glTextureImage1DEXT(texture, target, level, internalformat, width, border, format, type, pixels);
}

static void REGAL_CALL missing_glTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTextureImage2DEXT not available." );
}

static void REGAL_CALL loader_glTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureImage2DEXT, "glTextureImage2DEXT");
   if ( !driverTbl.glTextureImage2DEXT ) {
      driverTbl.glTextureImage2DEXT = missing_glTextureImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureImage2DEXT == loader_glTextureImage2DEXT) {
      rCtx->dsp->emuTbl.glTextureImage2DEXT = driverTbl.glTextureImage2DEXT;
   }
   driverTbl.glTextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, type, pixels);
}

static void REGAL_CALL missing_glTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTextureImage3DEXT not available." );
}

static void REGAL_CALL loader_glTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureImage3DEXT, "glTextureImage3DEXT");
   if ( !driverTbl.glTextureImage3DEXT ) {
      driverTbl.glTextureImage3DEXT = missing_glTextureImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureImage3DEXT == loader_glTextureImage3DEXT) {
      rCtx->dsp->emuTbl.glTextureImage3DEXT = driverTbl.glTextureImage3DEXT;
   }
   driverTbl.glTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
}

static void REGAL_CALL missing_glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glTextureParameterIivEXT not available." );
}

static void REGAL_CALL loader_glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureParameterIivEXT, "glTextureParameterIivEXT");
   if ( !driverTbl.glTextureParameterIivEXT ) {
      driverTbl.glTextureParameterIivEXT = missing_glTextureParameterIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureParameterIivEXT == loader_glTextureParameterIivEXT) {
      rCtx->dsp->emuTbl.glTextureParameterIivEXT = driverTbl.glTextureParameterIivEXT;
   }
   driverTbl.glTextureParameterIivEXT(texture, target, pname, params);
}

static void REGAL_CALL missing_glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint *params)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glTextureParameterIuivEXT not available." );
}

static void REGAL_CALL loader_glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureParameterIuivEXT, "glTextureParameterIuivEXT");
   if ( !driverTbl.glTextureParameterIuivEXT ) {
      driverTbl.glTextureParameterIuivEXT = missing_glTextureParameterIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureParameterIuivEXT == loader_glTextureParameterIuivEXT) {
      rCtx->dsp->emuTbl.glTextureParameterIuivEXT = driverTbl.glTextureParameterIuivEXT;
   }
   driverTbl.glTextureParameterIuivEXT(texture, target, pname, params);
}

static void REGAL_CALL missing_glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glTextureParameterfEXT not available." );
}

static void REGAL_CALL loader_glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureParameterfEXT, "glTextureParameterfEXT");
   if ( !driverTbl.glTextureParameterfEXT ) {
      driverTbl.glTextureParameterfEXT = missing_glTextureParameterfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureParameterfEXT == loader_glTextureParameterfEXT) {
      rCtx->dsp->emuTbl.glTextureParameterfEXT = driverTbl.glTextureParameterfEXT;
   }
   driverTbl.glTextureParameterfEXT(texture, target, pname, param);
}

static void REGAL_CALL missing_glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat *param)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glTextureParameterfvEXT not available." );
}

static void REGAL_CALL loader_glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureParameterfvEXT, "glTextureParameterfvEXT");
   if ( !driverTbl.glTextureParameterfvEXT ) {
      driverTbl.glTextureParameterfvEXT = missing_glTextureParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureParameterfvEXT == loader_glTextureParameterfvEXT) {
      rCtx->dsp->emuTbl.glTextureParameterfvEXT = driverTbl.glTextureParameterfvEXT;
   }
   driverTbl.glTextureParameterfvEXT(texture, target, pname, param);
}

static void REGAL_CALL missing_glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glTextureParameteriEXT not available." );
}

static void REGAL_CALL loader_glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureParameteriEXT, "glTextureParameteriEXT");
   if ( !driverTbl.glTextureParameteriEXT ) {
      driverTbl.glTextureParameteriEXT = missing_glTextureParameteriEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureParameteriEXT == loader_glTextureParameteriEXT) {
      rCtx->dsp->emuTbl.glTextureParameteriEXT = driverTbl.glTextureParameteriEXT;
   }
   driverTbl.glTextureParameteriEXT(texture, target, pname, param);
}

static void REGAL_CALL missing_glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *param)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glTextureParameterivEXT not available." );
}

static void REGAL_CALL loader_glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureParameterivEXT, "glTextureParameterivEXT");
   if ( !driverTbl.glTextureParameterivEXT ) {
      driverTbl.glTextureParameterivEXT = missing_glTextureParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureParameterivEXT == loader_glTextureParameterivEXT) {
      rCtx->dsp->emuTbl.glTextureParameterivEXT = driverTbl.glTextureParameterivEXT;
   }
   driverTbl.glTextureParameterivEXT(texture, target, pname, param);
}

static void REGAL_CALL missing_glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "glTextureRenderbufferEXT not available." );
}

static void REGAL_CALL loader_glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureRenderbufferEXT, "glTextureRenderbufferEXT");
   if ( !driverTbl.glTextureRenderbufferEXT ) {
      driverTbl.glTextureRenderbufferEXT = missing_glTextureRenderbufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureRenderbufferEXT == loader_glTextureRenderbufferEXT) {
      rCtx->dsp->emuTbl.glTextureRenderbufferEXT = driverTbl.glTextureRenderbufferEXT;
   }
   driverTbl.glTextureRenderbufferEXT(texture, target, renderbuffer);
}

static void REGAL_CALL missing_glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTextureSubImage1DEXT not available." );
}

static void REGAL_CALL loader_glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureSubImage1DEXT, "glTextureSubImage1DEXT");
   if ( !driverTbl.glTextureSubImage1DEXT ) {
      driverTbl.glTextureSubImage1DEXT = missing_glTextureSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureSubImage1DEXT == loader_glTextureSubImage1DEXT) {
      rCtx->dsp->emuTbl.glTextureSubImage1DEXT = driverTbl.glTextureSubImage1DEXT;
   }
   driverTbl.glTextureSubImage1DEXT(texture, target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL missing_glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTextureSubImage2DEXT not available." );
}

static void REGAL_CALL loader_glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureSubImage2DEXT, "glTextureSubImage2DEXT");
   if ( !driverTbl.glTextureSubImage2DEXT ) {
      driverTbl.glTextureSubImage2DEXT = missing_glTextureSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureSubImage2DEXT == loader_glTextureSubImage2DEXT) {
      rCtx->dsp->emuTbl.glTextureSubImage2DEXT = driverTbl.glTextureSubImage2DEXT;
   }
   driverTbl.glTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL missing_glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTextureSubImage3DEXT not available." );
}

static void REGAL_CALL loader_glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureSubImage3DEXT, "glTextureSubImage3DEXT");
   if ( !driverTbl.glTextureSubImage3DEXT ) {
      driverTbl.glTextureSubImage3DEXT = missing_glTextureSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureSubImage3DEXT == loader_glTextureSubImage3DEXT) {
      rCtx->dsp->emuTbl.glTextureSubImage3DEXT = driverTbl.glTextureSubImage3DEXT;
   }
   driverTbl.glTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

static GLboolean REGAL_CALL missing_glUnmapNamedBufferEXT(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "glUnmapNamedBufferEXT not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glUnmapNamedBufferEXT(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUnmapNamedBufferEXT, "glUnmapNamedBufferEXT");
   if ( !driverTbl.glUnmapNamedBufferEXT ) {
      driverTbl.glUnmapNamedBufferEXT = missing_glUnmapNamedBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUnmapNamedBufferEXT == loader_glUnmapNamedBufferEXT) {
      rCtx->dsp->emuTbl.glUnmapNamedBufferEXT = driverTbl.glUnmapNamedBufferEXT;
   }
   return driverTbl.glUnmapNamedBufferEXT(buffer);
}

static void REGAL_CALL missing_glVertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(offset);
   Warning( "glVertexArrayColorOffsetEXT not available." );
}

static void REGAL_CALL loader_glVertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArrayColorOffsetEXT, "glVertexArrayColorOffsetEXT");
   if ( !driverTbl.glVertexArrayColorOffsetEXT ) {
      driverTbl.glVertexArrayColorOffsetEXT = missing_glVertexArrayColorOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArrayColorOffsetEXT == loader_glVertexArrayColorOffsetEXT) {
      rCtx->dsp->emuTbl.glVertexArrayColorOffsetEXT = driverTbl.glVertexArrayColorOffsetEXT;
   }
   driverTbl.glVertexArrayColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
}

static void REGAL_CALL missing_glVertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, const GLintptr offset)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(offset);
   Warning( "glVertexArrayEdgeFlagOffsetEXT not available." );
}

static void REGAL_CALL loader_glVertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, const GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArrayEdgeFlagOffsetEXT, "glVertexArrayEdgeFlagOffsetEXT");
   if ( !driverTbl.glVertexArrayEdgeFlagOffsetEXT ) {
      driverTbl.glVertexArrayEdgeFlagOffsetEXT = missing_glVertexArrayEdgeFlagOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArrayEdgeFlagOffsetEXT == loader_glVertexArrayEdgeFlagOffsetEXT) {
      rCtx->dsp->emuTbl.glVertexArrayEdgeFlagOffsetEXT = driverTbl.glVertexArrayEdgeFlagOffsetEXT;
   }
   driverTbl.glVertexArrayEdgeFlagOffsetEXT(vaobj, buffer, stride, offset);
}

static void REGAL_CALL missing_glVertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(offset);
   Warning( "glVertexArrayFogCoordOffsetEXT not available." );
}

static void REGAL_CALL loader_glVertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArrayFogCoordOffsetEXT, "glVertexArrayFogCoordOffsetEXT");
   if ( !driverTbl.glVertexArrayFogCoordOffsetEXT ) {
      driverTbl.glVertexArrayFogCoordOffsetEXT = missing_glVertexArrayFogCoordOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArrayFogCoordOffsetEXT == loader_glVertexArrayFogCoordOffsetEXT) {
      rCtx->dsp->emuTbl.glVertexArrayFogCoordOffsetEXT = driverTbl.glVertexArrayFogCoordOffsetEXT;
   }
   driverTbl.glVertexArrayFogCoordOffsetEXT(vaobj, buffer, type, stride, offset);
}

static void REGAL_CALL missing_glVertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(offset);
   Warning( "glVertexArrayIndexOffsetEXT not available." );
}

static void REGAL_CALL loader_glVertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArrayIndexOffsetEXT, "glVertexArrayIndexOffsetEXT");
   if ( !driverTbl.glVertexArrayIndexOffsetEXT ) {
      driverTbl.glVertexArrayIndexOffsetEXT = missing_glVertexArrayIndexOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArrayIndexOffsetEXT == loader_glVertexArrayIndexOffsetEXT) {
      rCtx->dsp->emuTbl.glVertexArrayIndexOffsetEXT = driverTbl.glVertexArrayIndexOffsetEXT;
   }
   driverTbl.glVertexArrayIndexOffsetEXT(vaobj, buffer, type, stride, offset);
}

static void REGAL_CALL missing_glVertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(texunit);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(offset);
   Warning( "glVertexArrayMultiTexCoordOffsetEXT not available." );
}

static void REGAL_CALL loader_glVertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArrayMultiTexCoordOffsetEXT, "glVertexArrayMultiTexCoordOffsetEXT");
   if ( !driverTbl.glVertexArrayMultiTexCoordOffsetEXT ) {
      driverTbl.glVertexArrayMultiTexCoordOffsetEXT = missing_glVertexArrayMultiTexCoordOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArrayMultiTexCoordOffsetEXT == loader_glVertexArrayMultiTexCoordOffsetEXT) {
      rCtx->dsp->emuTbl.glVertexArrayMultiTexCoordOffsetEXT = driverTbl.glVertexArrayMultiTexCoordOffsetEXT;
   }
   driverTbl.glVertexArrayMultiTexCoordOffsetEXT(vaobj, buffer, texunit, size, type, stride, offset);
}

static void REGAL_CALL missing_glVertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(offset);
   Warning( "glVertexArrayNormalOffsetEXT not available." );
}

static void REGAL_CALL loader_glVertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArrayNormalOffsetEXT, "glVertexArrayNormalOffsetEXT");
   if ( !driverTbl.glVertexArrayNormalOffsetEXT ) {
      driverTbl.glVertexArrayNormalOffsetEXT = missing_glVertexArrayNormalOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArrayNormalOffsetEXT == loader_glVertexArrayNormalOffsetEXT) {
      rCtx->dsp->emuTbl.glVertexArrayNormalOffsetEXT = driverTbl.glVertexArrayNormalOffsetEXT;
   }
   driverTbl.glVertexArrayNormalOffsetEXT(vaobj, buffer, type, stride, offset);
}

static void REGAL_CALL missing_glVertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(offset);
   Warning( "glVertexArraySecondaryColorOffsetEXT not available." );
}

static void REGAL_CALL loader_glVertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArraySecondaryColorOffsetEXT, "glVertexArraySecondaryColorOffsetEXT");
   if ( !driverTbl.glVertexArraySecondaryColorOffsetEXT ) {
      driverTbl.glVertexArraySecondaryColorOffsetEXT = missing_glVertexArraySecondaryColorOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArraySecondaryColorOffsetEXT == loader_glVertexArraySecondaryColorOffsetEXT) {
      rCtx->dsp->emuTbl.glVertexArraySecondaryColorOffsetEXT = driverTbl.glVertexArraySecondaryColorOffsetEXT;
   }
   driverTbl.glVertexArraySecondaryColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
}

static void REGAL_CALL missing_glVertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(offset);
   Warning( "glVertexArrayTexCoordOffsetEXT not available." );
}

static void REGAL_CALL loader_glVertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArrayTexCoordOffsetEXT, "glVertexArrayTexCoordOffsetEXT");
   if ( !driverTbl.glVertexArrayTexCoordOffsetEXT ) {
      driverTbl.glVertexArrayTexCoordOffsetEXT = missing_glVertexArrayTexCoordOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArrayTexCoordOffsetEXT == loader_glVertexArrayTexCoordOffsetEXT) {
      rCtx->dsp->emuTbl.glVertexArrayTexCoordOffsetEXT = driverTbl.glVertexArrayTexCoordOffsetEXT;
   }
   driverTbl.glVertexArrayTexCoordOffsetEXT(vaobj, buffer, size, type, stride, offset);
}

static void REGAL_CALL missing_glVertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(offset);
   Warning( "glVertexArrayVertexAttribIOffsetEXT not available." );
}

static void REGAL_CALL loader_glVertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArrayVertexAttribIOffsetEXT, "glVertexArrayVertexAttribIOffsetEXT");
   if ( !driverTbl.glVertexArrayVertexAttribIOffsetEXT ) {
      driverTbl.glVertexArrayVertexAttribIOffsetEXT = missing_glVertexArrayVertexAttribIOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArrayVertexAttribIOffsetEXT == loader_glVertexArrayVertexAttribIOffsetEXT) {
      rCtx->dsp->emuTbl.glVertexArrayVertexAttribIOffsetEXT = driverTbl.glVertexArrayVertexAttribIOffsetEXT;
   }
   driverTbl.glVertexArrayVertexAttribIOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
}

static void REGAL_CALL missing_glVertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLintptr offset)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(offset);
   Warning( "glVertexArrayVertexAttribOffsetEXT not available." );
}

static void REGAL_CALL loader_glVertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArrayVertexAttribOffsetEXT, "glVertexArrayVertexAttribOffsetEXT");
   if ( !driverTbl.glVertexArrayVertexAttribOffsetEXT ) {
      driverTbl.glVertexArrayVertexAttribOffsetEXT = missing_glVertexArrayVertexAttribOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArrayVertexAttribOffsetEXT == loader_glVertexArrayVertexAttribOffsetEXT) {
      rCtx->dsp->emuTbl.glVertexArrayVertexAttribOffsetEXT = driverTbl.glVertexArrayVertexAttribOffsetEXT;
   }
   driverTbl.glVertexArrayVertexAttribOffsetEXT(vaobj, buffer, index, size, type, normalized, stride, offset);
}

static void REGAL_CALL missing_glVertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(offset);
   Warning( "glVertexArrayVertexOffsetEXT not available." );
}

static void REGAL_CALL loader_glVertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArrayVertexOffsetEXT, "glVertexArrayVertexOffsetEXT");
   if ( !driverTbl.glVertexArrayVertexOffsetEXT ) {
      driverTbl.glVertexArrayVertexOffsetEXT = missing_glVertexArrayVertexOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArrayVertexOffsetEXT == loader_glVertexArrayVertexOffsetEXT) {
      rCtx->dsp->emuTbl.glVertexArrayVertexOffsetEXT = driverTbl.glVertexArrayVertexOffsetEXT;
   }
   driverTbl.glVertexArrayVertexOffsetEXT(vaobj, buffer, size, type, stride, offset);
}

// GL_EXT_draw_buffers2

static void REGAL_CALL missing_glColorMaskIndexedEXT(GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
   UNUSED_PARAMETER(buf);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   Warning( "glColorMaskIndexedEXT not available." );
}

static void REGAL_CALL loader_glColorMaskIndexedEXT(GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorMaskIndexedEXT, "glColorMaskIndexedEXT");
   if ( !driverTbl.glColorMaskIndexedEXT ) {
      driverTbl.glColorMaskIndexedEXT = missing_glColorMaskIndexedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorMaskIndexedEXT == loader_glColorMaskIndexedEXT) {
      rCtx->dsp->emuTbl.glColorMaskIndexedEXT = driverTbl.glColorMaskIndexedEXT;
   }
   driverTbl.glColorMaskIndexedEXT(buf, r, g, b, a);
}

static void REGAL_CALL missing_glDisableIndexedEXT(GLenum target, GLuint index)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   Warning( "glDisableIndexedEXT not available." );
}

static void REGAL_CALL loader_glDisableIndexedEXT(GLenum target, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDisableIndexedEXT, "glDisableIndexedEXT");
   if ( !driverTbl.glDisableIndexedEXT ) {
      driverTbl.glDisableIndexedEXT = missing_glDisableIndexedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDisableIndexedEXT == loader_glDisableIndexedEXT) {
      rCtx->dsp->emuTbl.glDisableIndexedEXT = driverTbl.glDisableIndexedEXT;
   }
   driverTbl.glDisableIndexedEXT(target, index);
}

static void REGAL_CALL missing_glEnableIndexedEXT(GLenum target, GLuint index)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   Warning( "glEnableIndexedEXT not available." );
}

static void REGAL_CALL loader_glEnableIndexedEXT(GLenum target, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEnableIndexedEXT, "glEnableIndexedEXT");
   if ( !driverTbl.glEnableIndexedEXT ) {
      driverTbl.glEnableIndexedEXT = missing_glEnableIndexedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEnableIndexedEXT == loader_glEnableIndexedEXT) {
      rCtx->dsp->emuTbl.glEnableIndexedEXT = driverTbl.glEnableIndexedEXT;
   }
   driverTbl.glEnableIndexedEXT(target, index);
}

static void REGAL_CALL missing_glGetBooleanIndexedvEXT(GLenum value, GLuint index, GLboolean *data)
{
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "glGetBooleanIndexedvEXT not available." );
}

static void REGAL_CALL loader_glGetBooleanIndexedvEXT(GLenum value, GLuint index, GLboolean *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetBooleanIndexedvEXT, "glGetBooleanIndexedvEXT");
   if ( !driverTbl.glGetBooleanIndexedvEXT ) {
      driverTbl.glGetBooleanIndexedvEXT = missing_glGetBooleanIndexedvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetBooleanIndexedvEXT == loader_glGetBooleanIndexedvEXT) {
      rCtx->dsp->emuTbl.glGetBooleanIndexedvEXT = driverTbl.glGetBooleanIndexedvEXT;
   }
   driverTbl.glGetBooleanIndexedvEXT(value, index, data);
}

static void REGAL_CALL missing_glGetIntegerIndexedvEXT(GLenum value, GLuint index, GLint *data)
{
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "glGetIntegerIndexedvEXT not available." );
}

static void REGAL_CALL loader_glGetIntegerIndexedvEXT(GLenum value, GLuint index, GLint *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetIntegerIndexedvEXT, "glGetIntegerIndexedvEXT");
   if ( !driverTbl.glGetIntegerIndexedvEXT ) {
      driverTbl.glGetIntegerIndexedvEXT = missing_glGetIntegerIndexedvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetIntegerIndexedvEXT == loader_glGetIntegerIndexedvEXT) {
      rCtx->dsp->emuTbl.glGetIntegerIndexedvEXT = driverTbl.glGetIntegerIndexedvEXT;
   }
   driverTbl.glGetIntegerIndexedvEXT(value, index, data);
}

static GLboolean REGAL_CALL missing_glIsEnabledIndexedEXT(GLenum target, GLuint index)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   Warning( "glIsEnabledIndexedEXT not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsEnabledIndexedEXT(GLenum target, GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsEnabledIndexedEXT, "glIsEnabledIndexedEXT");
   if ( !driverTbl.glIsEnabledIndexedEXT ) {
      driverTbl.glIsEnabledIndexedEXT = missing_glIsEnabledIndexedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsEnabledIndexedEXT == loader_glIsEnabledIndexedEXT) {
      rCtx->dsp->emuTbl.glIsEnabledIndexedEXT = driverTbl.glIsEnabledIndexedEXT;
   }
   return driverTbl.glIsEnabledIndexedEXT(target, index);
}

// GL_EXT_draw_instanced

static void REGAL_CALL missing_glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   Warning( "glDrawArraysInstancedEXT not available." );
}

static void REGAL_CALL loader_glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawArraysInstancedEXT, "glDrawArraysInstancedEXT");
   if ( !driverTbl.glDrawArraysInstancedEXT ) {
      driverTbl.glDrawArraysInstancedEXT = missing_glDrawArraysInstancedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawArraysInstancedEXT == loader_glDrawArraysInstancedEXT) {
      rCtx->dsp->emuTbl.glDrawArraysInstancedEXT = driverTbl.glDrawArraysInstancedEXT;
   }
   driverTbl.glDrawArraysInstancedEXT(mode, start, count, primcount);
}

static void REGAL_CALL missing_glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   Warning( "glDrawElementsInstancedEXT not available." );
}

static void REGAL_CALL loader_glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawElementsInstancedEXT, "glDrawElementsInstancedEXT");
   if ( !driverTbl.glDrawElementsInstancedEXT ) {
      driverTbl.glDrawElementsInstancedEXT = missing_glDrawElementsInstancedEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawElementsInstancedEXT == loader_glDrawElementsInstancedEXT) {
      rCtx->dsp->emuTbl.glDrawElementsInstancedEXT = driverTbl.glDrawElementsInstancedEXT;
   }
   driverTbl.glDrawElementsInstancedEXT(mode, count, type, indices, primcount);
}

// GL_EXT_draw_range_elements

static void REGAL_CALL missing_glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(start);
   UNUSED_PARAMETER(end);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   Warning( "glDrawRangeElementsEXT not available." );
}

static void REGAL_CALL loader_glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawRangeElementsEXT, "glDrawRangeElementsEXT");
   if ( !driverTbl.glDrawRangeElementsEXT ) {
      driverTbl.glDrawRangeElementsEXT = missing_glDrawRangeElementsEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawRangeElementsEXT == loader_glDrawRangeElementsEXT) {
      rCtx->dsp->emuTbl.glDrawRangeElementsEXT = driverTbl.glDrawRangeElementsEXT;
   }
   driverTbl.glDrawRangeElementsEXT(mode, start, end, count, type, indices);
}

// GL_EXT_fog_coord

static void REGAL_CALL missing_glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glFogCoordPointerEXT not available." );
}

static void REGAL_CALL loader_glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogCoordPointerEXT, "glFogCoordPointerEXT");
   if ( !driverTbl.glFogCoordPointerEXT ) {
      driverTbl.glFogCoordPointerEXT = missing_glFogCoordPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogCoordPointerEXT == loader_glFogCoordPointerEXT) {
      rCtx->dsp->emuTbl.glFogCoordPointerEXT = driverTbl.glFogCoordPointerEXT;
   }
   driverTbl.glFogCoordPointerEXT(type, stride, pointer);
}

static void REGAL_CALL missing_glFogCoorddEXT(GLdouble coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "glFogCoorddEXT not available." );
}

static void REGAL_CALL loader_glFogCoorddEXT(GLdouble coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogCoorddEXT, "glFogCoorddEXT");
   if ( !driverTbl.glFogCoorddEXT ) {
      driverTbl.glFogCoorddEXT = missing_glFogCoorddEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogCoorddEXT == loader_glFogCoorddEXT) {
      rCtx->dsp->emuTbl.glFogCoorddEXT = driverTbl.glFogCoorddEXT;
   }
   driverTbl.glFogCoorddEXT(coord);
}

static void REGAL_CALL missing_glFogCoorddvEXT(const GLdouble *coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "glFogCoorddvEXT not available." );
}

static void REGAL_CALL loader_glFogCoorddvEXT(const GLdouble *coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogCoorddvEXT, "glFogCoorddvEXT");
   if ( !driverTbl.glFogCoorddvEXT ) {
      driverTbl.glFogCoorddvEXT = missing_glFogCoorddvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogCoorddvEXT == loader_glFogCoorddvEXT) {
      rCtx->dsp->emuTbl.glFogCoorddvEXT = driverTbl.glFogCoorddvEXT;
   }
   driverTbl.glFogCoorddvEXT(coord);
}

static void REGAL_CALL missing_glFogCoordfEXT(GLfloat coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "glFogCoordfEXT not available." );
}

static void REGAL_CALL loader_glFogCoordfEXT(GLfloat coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogCoordfEXT, "glFogCoordfEXT");
   if ( !driverTbl.glFogCoordfEXT ) {
      driverTbl.glFogCoordfEXT = missing_glFogCoordfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogCoordfEXT == loader_glFogCoordfEXT) {
      rCtx->dsp->emuTbl.glFogCoordfEXT = driverTbl.glFogCoordfEXT;
   }
   driverTbl.glFogCoordfEXT(coord);
}

static void REGAL_CALL missing_glFogCoordfvEXT(const GLfloat *coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "glFogCoordfvEXT not available." );
}

static void REGAL_CALL loader_glFogCoordfvEXT(const GLfloat *coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogCoordfvEXT, "glFogCoordfvEXT");
   if ( !driverTbl.glFogCoordfvEXT ) {
      driverTbl.glFogCoordfvEXT = missing_glFogCoordfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogCoordfvEXT == loader_glFogCoordfvEXT) {
      rCtx->dsp->emuTbl.glFogCoordfvEXT = driverTbl.glFogCoordfvEXT;
   }
   driverTbl.glFogCoordfvEXT(coord);
}

// GL_EXT_fragment_lighting

static void REGAL_CALL missing_glFragmentColorMaterialEXT(GLenum face, GLenum mode)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(mode);
   Warning( "glFragmentColorMaterialEXT not available." );
}

static void REGAL_CALL loader_glFragmentColorMaterialEXT(GLenum face, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentColorMaterialEXT, "glFragmentColorMaterialEXT");
   if ( !driverTbl.glFragmentColorMaterialEXT ) {
      driverTbl.glFragmentColorMaterialEXT = missing_glFragmentColorMaterialEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentColorMaterialEXT == loader_glFragmentColorMaterialEXT) {
      rCtx->dsp->emuTbl.glFragmentColorMaterialEXT = driverTbl.glFragmentColorMaterialEXT;
   }
   driverTbl.glFragmentColorMaterialEXT(face, mode);
}

static void REGAL_CALL missing_glFragmentLightModelfEXT(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFragmentLightModelfEXT not available." );
}

static void REGAL_CALL loader_glFragmentLightModelfEXT(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightModelfEXT, "glFragmentLightModelfEXT");
   if ( !driverTbl.glFragmentLightModelfEXT ) {
      driverTbl.glFragmentLightModelfEXT = missing_glFragmentLightModelfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightModelfEXT == loader_glFragmentLightModelfEXT) {
      rCtx->dsp->emuTbl.glFragmentLightModelfEXT = driverTbl.glFragmentLightModelfEXT;
   }
   driverTbl.glFragmentLightModelfEXT(pname, param);
}

static void REGAL_CALL missing_glFragmentLightModelfvEXT(GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glFragmentLightModelfvEXT not available." );
}

static void REGAL_CALL loader_glFragmentLightModelfvEXT(GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightModelfvEXT, "glFragmentLightModelfvEXT");
   if ( !driverTbl.glFragmentLightModelfvEXT ) {
      driverTbl.glFragmentLightModelfvEXT = missing_glFragmentLightModelfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightModelfvEXT == loader_glFragmentLightModelfvEXT) {
      rCtx->dsp->emuTbl.glFragmentLightModelfvEXT = driverTbl.glFragmentLightModelfvEXT;
   }
   driverTbl.glFragmentLightModelfvEXT(pname, params);
}

static void REGAL_CALL missing_glFragmentLightModeliEXT(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFragmentLightModeliEXT not available." );
}

static void REGAL_CALL loader_glFragmentLightModeliEXT(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightModeliEXT, "glFragmentLightModeliEXT");
   if ( !driverTbl.glFragmentLightModeliEXT ) {
      driverTbl.glFragmentLightModeliEXT = missing_glFragmentLightModeliEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightModeliEXT == loader_glFragmentLightModeliEXT) {
      rCtx->dsp->emuTbl.glFragmentLightModeliEXT = driverTbl.glFragmentLightModeliEXT;
   }
   driverTbl.glFragmentLightModeliEXT(pname, param);
}

static void REGAL_CALL missing_glFragmentLightModelivEXT(GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glFragmentLightModelivEXT not available." );
}

static void REGAL_CALL loader_glFragmentLightModelivEXT(GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightModelivEXT, "glFragmentLightModelivEXT");
   if ( !driverTbl.glFragmentLightModelivEXT ) {
      driverTbl.glFragmentLightModelivEXT = missing_glFragmentLightModelivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightModelivEXT == loader_glFragmentLightModelivEXT) {
      rCtx->dsp->emuTbl.glFragmentLightModelivEXT = driverTbl.glFragmentLightModelivEXT;
   }
   driverTbl.glFragmentLightModelivEXT(pname, params);
}

static void REGAL_CALL missing_glFragmentLightfEXT(GLenum light, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFragmentLightfEXT not available." );
}

static void REGAL_CALL loader_glFragmentLightfEXT(GLenum light, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightfEXT, "glFragmentLightfEXT");
   if ( !driverTbl.glFragmentLightfEXT ) {
      driverTbl.glFragmentLightfEXT = missing_glFragmentLightfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightfEXT == loader_glFragmentLightfEXT) {
      rCtx->dsp->emuTbl.glFragmentLightfEXT = driverTbl.glFragmentLightfEXT;
   }
   driverTbl.glFragmentLightfEXT(light, pname, param);
}

static void REGAL_CALL missing_glFragmentLightfvEXT(GLenum light, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glFragmentLightfvEXT not available." );
}

static void REGAL_CALL loader_glFragmentLightfvEXT(GLenum light, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightfvEXT, "glFragmentLightfvEXT");
   if ( !driverTbl.glFragmentLightfvEXT ) {
      driverTbl.glFragmentLightfvEXT = missing_glFragmentLightfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightfvEXT == loader_glFragmentLightfvEXT) {
      rCtx->dsp->emuTbl.glFragmentLightfvEXT = driverTbl.glFragmentLightfvEXT;
   }
   driverTbl.glFragmentLightfvEXT(light, pname, params);
}

static void REGAL_CALL missing_glFragmentLightiEXT(GLenum light, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFragmentLightiEXT not available." );
}

static void REGAL_CALL loader_glFragmentLightiEXT(GLenum light, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightiEXT, "glFragmentLightiEXT");
   if ( !driverTbl.glFragmentLightiEXT ) {
      driverTbl.glFragmentLightiEXT = missing_glFragmentLightiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightiEXT == loader_glFragmentLightiEXT) {
      rCtx->dsp->emuTbl.glFragmentLightiEXT = driverTbl.glFragmentLightiEXT;
   }
   driverTbl.glFragmentLightiEXT(light, pname, param);
}

static void REGAL_CALL missing_glFragmentLightivEXT(GLenum light, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glFragmentLightivEXT not available." );
}

static void REGAL_CALL loader_glFragmentLightivEXT(GLenum light, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightivEXT, "glFragmentLightivEXT");
   if ( !driverTbl.glFragmentLightivEXT ) {
      driverTbl.glFragmentLightivEXT = missing_glFragmentLightivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightivEXT == loader_glFragmentLightivEXT) {
      rCtx->dsp->emuTbl.glFragmentLightivEXT = driverTbl.glFragmentLightivEXT;
   }
   driverTbl.glFragmentLightivEXT(light, pname, params);
}

static void REGAL_CALL missing_glFragmentMaterialfEXT(GLenum face, GLenum pname, const GLfloat param)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFragmentMaterialfEXT not available." );
}

static void REGAL_CALL loader_glFragmentMaterialfEXT(GLenum face, GLenum pname, const GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentMaterialfEXT, "glFragmentMaterialfEXT");
   if ( !driverTbl.glFragmentMaterialfEXT ) {
      driverTbl.glFragmentMaterialfEXT = missing_glFragmentMaterialfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentMaterialfEXT == loader_glFragmentMaterialfEXT) {
      rCtx->dsp->emuTbl.glFragmentMaterialfEXT = driverTbl.glFragmentMaterialfEXT;
   }
   driverTbl.glFragmentMaterialfEXT(face, pname, param);
}

static void REGAL_CALL missing_glFragmentMaterialfvEXT(GLenum face, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glFragmentMaterialfvEXT not available." );
}

static void REGAL_CALL loader_glFragmentMaterialfvEXT(GLenum face, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentMaterialfvEXT, "glFragmentMaterialfvEXT");
   if ( !driverTbl.glFragmentMaterialfvEXT ) {
      driverTbl.glFragmentMaterialfvEXT = missing_glFragmentMaterialfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentMaterialfvEXT == loader_glFragmentMaterialfvEXT) {
      rCtx->dsp->emuTbl.glFragmentMaterialfvEXT = driverTbl.glFragmentMaterialfvEXT;
   }
   driverTbl.glFragmentMaterialfvEXT(face, pname, params);
}

static void REGAL_CALL missing_glFragmentMaterialiEXT(GLenum face, GLenum pname, const GLint param)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFragmentMaterialiEXT not available." );
}

static void REGAL_CALL loader_glFragmentMaterialiEXT(GLenum face, GLenum pname, const GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentMaterialiEXT, "glFragmentMaterialiEXT");
   if ( !driverTbl.glFragmentMaterialiEXT ) {
      driverTbl.glFragmentMaterialiEXT = missing_glFragmentMaterialiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentMaterialiEXT == loader_glFragmentMaterialiEXT) {
      rCtx->dsp->emuTbl.glFragmentMaterialiEXT = driverTbl.glFragmentMaterialiEXT;
   }
   driverTbl.glFragmentMaterialiEXT(face, pname, param);
}

static void REGAL_CALL missing_glFragmentMaterialivEXT(GLenum face, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glFragmentMaterialivEXT not available." );
}

static void REGAL_CALL loader_glFragmentMaterialivEXT(GLenum face, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentMaterialivEXT, "glFragmentMaterialivEXT");
   if ( !driverTbl.glFragmentMaterialivEXT ) {
      driverTbl.glFragmentMaterialivEXT = missing_glFragmentMaterialivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentMaterialivEXT == loader_glFragmentMaterialivEXT) {
      rCtx->dsp->emuTbl.glFragmentMaterialivEXT = driverTbl.glFragmentMaterialivEXT;
   }
   driverTbl.glFragmentMaterialivEXT(face, pname, params);
}

static void REGAL_CALL missing_glGetFragmentLightfvEXT(GLenum light, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFragmentLightfvEXT not available." );
}

static void REGAL_CALL loader_glGetFragmentLightfvEXT(GLenum light, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFragmentLightfvEXT, "glGetFragmentLightfvEXT");
   if ( !driverTbl.glGetFragmentLightfvEXT ) {
      driverTbl.glGetFragmentLightfvEXT = missing_glGetFragmentLightfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFragmentLightfvEXT == loader_glGetFragmentLightfvEXT) {
      rCtx->dsp->emuTbl.glGetFragmentLightfvEXT = driverTbl.glGetFragmentLightfvEXT;
   }
   driverTbl.glGetFragmentLightfvEXT(light, pname, params);
}

static void REGAL_CALL missing_glGetFragmentLightivEXT(GLenum light, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFragmentLightivEXT not available." );
}

static void REGAL_CALL loader_glGetFragmentLightivEXT(GLenum light, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFragmentLightivEXT, "glGetFragmentLightivEXT");
   if ( !driverTbl.glGetFragmentLightivEXT ) {
      driverTbl.glGetFragmentLightivEXT = missing_glGetFragmentLightivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFragmentLightivEXT == loader_glGetFragmentLightivEXT) {
      rCtx->dsp->emuTbl.glGetFragmentLightivEXT = driverTbl.glGetFragmentLightivEXT;
   }
   driverTbl.glGetFragmentLightivEXT(light, pname, params);
}

static void REGAL_CALL missing_glGetFragmentMaterialfvEXT(GLenum face, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFragmentMaterialfvEXT not available." );
}

static void REGAL_CALL loader_glGetFragmentMaterialfvEXT(GLenum face, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFragmentMaterialfvEXT, "glGetFragmentMaterialfvEXT");
   if ( !driverTbl.glGetFragmentMaterialfvEXT ) {
      driverTbl.glGetFragmentMaterialfvEXT = missing_glGetFragmentMaterialfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFragmentMaterialfvEXT == loader_glGetFragmentMaterialfvEXT) {
      rCtx->dsp->emuTbl.glGetFragmentMaterialfvEXT = driverTbl.glGetFragmentMaterialfvEXT;
   }
   driverTbl.glGetFragmentMaterialfvEXT(face, pname, params);
}

static void REGAL_CALL missing_glGetFragmentMaterialivEXT(GLenum face, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFragmentMaterialivEXT not available." );
}

static void REGAL_CALL loader_glGetFragmentMaterialivEXT(GLenum face, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFragmentMaterialivEXT, "glGetFragmentMaterialivEXT");
   if ( !driverTbl.glGetFragmentMaterialivEXT ) {
      driverTbl.glGetFragmentMaterialivEXT = missing_glGetFragmentMaterialivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFragmentMaterialivEXT == loader_glGetFragmentMaterialivEXT) {
      rCtx->dsp->emuTbl.glGetFragmentMaterialivEXT = driverTbl.glGetFragmentMaterialivEXT;
   }
   driverTbl.glGetFragmentMaterialivEXT(face, pname, params);
}

static void REGAL_CALL missing_glLightEnviEXT(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glLightEnviEXT not available." );
}

static void REGAL_CALL loader_glLightEnviEXT(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLightEnviEXT, "glLightEnviEXT");
   if ( !driverTbl.glLightEnviEXT ) {
      driverTbl.glLightEnviEXT = missing_glLightEnviEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLightEnviEXT == loader_glLightEnviEXT) {
      rCtx->dsp->emuTbl.glLightEnviEXT = driverTbl.glLightEnviEXT;
   }
   driverTbl.glLightEnviEXT(pname, param);
}

// GL_EXT_framebuffer_blit

static void REGAL_CALL missing_glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
   UNUSED_PARAMETER(srcX0);
   UNUSED_PARAMETER(srcY0);
   UNUSED_PARAMETER(srcX1);
   UNUSED_PARAMETER(srcY1);
   UNUSED_PARAMETER(dstX0);
   UNUSED_PARAMETER(dstY0);
   UNUSED_PARAMETER(dstX1);
   UNUSED_PARAMETER(dstY1);
   UNUSED_PARAMETER(mask);
   UNUSED_PARAMETER(filter);
   Warning( "glBlitFramebufferEXT not available." );
}

static void REGAL_CALL loader_glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlitFramebufferEXT, "glBlitFramebufferEXT");
   if ( !driverTbl.glBlitFramebufferEXT ) {
      driverTbl.glBlitFramebufferEXT = missing_glBlitFramebufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlitFramebufferEXT == loader_glBlitFramebufferEXT) {
      rCtx->dsp->emuTbl.glBlitFramebufferEXT = driverTbl.glBlitFramebufferEXT;
   }
   driverTbl.glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

// GL_EXT_framebuffer_multisample

static void REGAL_CALL missing_glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glRenderbufferStorageMultisampleEXT not available." );
}

static void REGAL_CALL loader_glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRenderbufferStorageMultisampleEXT, "glRenderbufferStorageMultisampleEXT");
   if ( !driverTbl.glRenderbufferStorageMultisampleEXT ) {
      driverTbl.glRenderbufferStorageMultisampleEXT = missing_glRenderbufferStorageMultisampleEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRenderbufferStorageMultisampleEXT == loader_glRenderbufferStorageMultisampleEXT) {
      rCtx->dsp->emuTbl.glRenderbufferStorageMultisampleEXT = driverTbl.glRenderbufferStorageMultisampleEXT;
   }
   driverTbl.glRenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height);
}

// GL_EXT_framebuffer_object

static void REGAL_CALL missing_glBindFramebufferEXT(GLenum target, GLuint framebuffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(framebuffer);
   Warning( "glBindFramebufferEXT not available." );
}

static void REGAL_CALL loader_glBindFramebufferEXT(GLenum target, GLuint framebuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindFramebufferEXT, "glBindFramebufferEXT");
   if ( !driverTbl.glBindFramebufferEXT ) {
      driverTbl.glBindFramebufferEXT = missing_glBindFramebufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindFramebufferEXT == loader_glBindFramebufferEXT) {
      rCtx->dsp->emuTbl.glBindFramebufferEXT = driverTbl.glBindFramebufferEXT;
   }
   driverTbl.glBindFramebufferEXT(target, framebuffer);
}

static void REGAL_CALL missing_glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "glBindRenderbufferEXT not available." );
}

static void REGAL_CALL loader_glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindRenderbufferEXT, "glBindRenderbufferEXT");
   if ( !driverTbl.glBindRenderbufferEXT ) {
      driverTbl.glBindRenderbufferEXT = missing_glBindRenderbufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindRenderbufferEXT == loader_glBindRenderbufferEXT) {
      rCtx->dsp->emuTbl.glBindRenderbufferEXT = driverTbl.glBindRenderbufferEXT;
   }
   driverTbl.glBindRenderbufferEXT(target, renderbuffer);
}

static GLenum REGAL_CALL missing_glCheckFramebufferStatusEXT(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glCheckFramebufferStatusEXT not available." );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glCheckFramebufferStatusEXT(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCheckFramebufferStatusEXT, "glCheckFramebufferStatusEXT");
   if ( !driverTbl.glCheckFramebufferStatusEXT ) {
      driverTbl.glCheckFramebufferStatusEXT = missing_glCheckFramebufferStatusEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCheckFramebufferStatusEXT == loader_glCheckFramebufferStatusEXT) {
      rCtx->dsp->emuTbl.glCheckFramebufferStatusEXT = driverTbl.glCheckFramebufferStatusEXT;
   }
   return driverTbl.glCheckFramebufferStatusEXT(target);
}

static void REGAL_CALL missing_glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(framebuffers);
   Warning( "glDeleteFramebuffersEXT not available." );
}

static void REGAL_CALL loader_glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteFramebuffersEXT, "glDeleteFramebuffersEXT");
   if ( !driverTbl.glDeleteFramebuffersEXT ) {
      driverTbl.glDeleteFramebuffersEXT = missing_glDeleteFramebuffersEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteFramebuffersEXT == loader_glDeleteFramebuffersEXT) {
      rCtx->dsp->emuTbl.glDeleteFramebuffersEXT = driverTbl.glDeleteFramebuffersEXT;
   }
   driverTbl.glDeleteFramebuffersEXT(n, framebuffers);
}

static void REGAL_CALL missing_glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(renderbuffers);
   Warning( "glDeleteRenderbuffersEXT not available." );
}

static void REGAL_CALL loader_glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteRenderbuffersEXT, "glDeleteRenderbuffersEXT");
   if ( !driverTbl.glDeleteRenderbuffersEXT ) {
      driverTbl.glDeleteRenderbuffersEXT = missing_glDeleteRenderbuffersEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteRenderbuffersEXT == loader_glDeleteRenderbuffersEXT) {
      rCtx->dsp->emuTbl.glDeleteRenderbuffersEXT = driverTbl.glDeleteRenderbuffersEXT;
   }
   driverTbl.glDeleteRenderbuffersEXT(n, renderbuffers);
}

static void REGAL_CALL missing_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(renderbuffertarget);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "glFramebufferRenderbufferEXT not available." );
}

static void REGAL_CALL loader_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferRenderbufferEXT, "glFramebufferRenderbufferEXT");
   if ( !driverTbl.glFramebufferRenderbufferEXT ) {
      driverTbl.glFramebufferRenderbufferEXT = missing_glFramebufferRenderbufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferRenderbufferEXT == loader_glFramebufferRenderbufferEXT) {
      rCtx->dsp->emuTbl.glFramebufferRenderbufferEXT = driverTbl.glFramebufferRenderbufferEXT;
   }
   driverTbl.glFramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);
}

static void REGAL_CALL missing_glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "glFramebufferTexture1DEXT not available." );
}

static void REGAL_CALL loader_glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTexture1DEXT, "glFramebufferTexture1DEXT");
   if ( !driverTbl.glFramebufferTexture1DEXT ) {
      driverTbl.glFramebufferTexture1DEXT = missing_glFramebufferTexture1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTexture1DEXT == loader_glFramebufferTexture1DEXT) {
      rCtx->dsp->emuTbl.glFramebufferTexture1DEXT = driverTbl.glFramebufferTexture1DEXT;
   }
   driverTbl.glFramebufferTexture1DEXT(target, attachment, textarget, texture, level);
}

static void REGAL_CALL missing_glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "glFramebufferTexture2DEXT not available." );
}

static void REGAL_CALL loader_glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTexture2DEXT, "glFramebufferTexture2DEXT");
   if ( !driverTbl.glFramebufferTexture2DEXT ) {
      driverTbl.glFramebufferTexture2DEXT = missing_glFramebufferTexture2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTexture2DEXT == loader_glFramebufferTexture2DEXT) {
      rCtx->dsp->emuTbl.glFramebufferTexture2DEXT = driverTbl.glFramebufferTexture2DEXT;
   }
   driverTbl.glFramebufferTexture2DEXT(target, attachment, textarget, texture, level);
}

static void REGAL_CALL missing_glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(textarget);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(zoffset);
   Warning( "glFramebufferTexture3DEXT not available." );
}

static void REGAL_CALL loader_glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTexture3DEXT, "glFramebufferTexture3DEXT");
   if ( !driverTbl.glFramebufferTexture3DEXT ) {
      driverTbl.glFramebufferTexture3DEXT = missing_glFramebufferTexture3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTexture3DEXT == loader_glFramebufferTexture3DEXT) {
      rCtx->dsp->emuTbl.glFramebufferTexture3DEXT = driverTbl.glFramebufferTexture3DEXT;
   }
   driverTbl.glFramebufferTexture3DEXT(target, attachment, textarget, texture, level, zoffset);
}

static void REGAL_CALL missing_glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(framebuffers);
   Warning( "glGenFramebuffersEXT not available." );
}

static void REGAL_CALL loader_glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenFramebuffersEXT, "glGenFramebuffersEXT");
   if ( !driverTbl.glGenFramebuffersEXT ) {
      driverTbl.glGenFramebuffersEXT = missing_glGenFramebuffersEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenFramebuffersEXT == loader_glGenFramebuffersEXT) {
      rCtx->dsp->emuTbl.glGenFramebuffersEXT = driverTbl.glGenFramebuffersEXT;
   }
   driverTbl.glGenFramebuffersEXT(n, framebuffers);
}

static void REGAL_CALL missing_glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(renderbuffers);
   Warning( "glGenRenderbuffersEXT not available." );
}

static void REGAL_CALL loader_glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenRenderbuffersEXT, "glGenRenderbuffersEXT");
   if ( !driverTbl.glGenRenderbuffersEXT ) {
      driverTbl.glGenRenderbuffersEXT = missing_glGenRenderbuffersEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenRenderbuffersEXT == loader_glGenRenderbuffersEXT) {
      rCtx->dsp->emuTbl.glGenRenderbuffersEXT = driverTbl.glGenRenderbuffersEXT;
   }
   driverTbl.glGenRenderbuffersEXT(n, renderbuffers);
}

static void REGAL_CALL missing_glGenerateMipmapEXT(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glGenerateMipmapEXT not available." );
}

static void REGAL_CALL loader_glGenerateMipmapEXT(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenerateMipmapEXT, "glGenerateMipmapEXT");
   if ( !driverTbl.glGenerateMipmapEXT ) {
      driverTbl.glGenerateMipmapEXT = missing_glGenerateMipmapEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenerateMipmapEXT == loader_glGenerateMipmapEXT) {
      rCtx->dsp->emuTbl.glGenerateMipmapEXT = driverTbl.glGenerateMipmapEXT;
   }
   driverTbl.glGenerateMipmapEXT(target);
}

static void REGAL_CALL missing_glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFramebufferAttachmentParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFramebufferAttachmentParameterivEXT, "glGetFramebufferAttachmentParameterivEXT");
   if ( !driverTbl.glGetFramebufferAttachmentParameterivEXT ) {
      driverTbl.glGetFramebufferAttachmentParameterivEXT = missing_glGetFramebufferAttachmentParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFramebufferAttachmentParameterivEXT == loader_glGetFramebufferAttachmentParameterivEXT) {
      rCtx->dsp->emuTbl.glGetFramebufferAttachmentParameterivEXT = driverTbl.glGetFramebufferAttachmentParameterivEXT;
   }
   driverTbl.glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, params);
}

static void REGAL_CALL missing_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetRenderbufferParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetRenderbufferParameterivEXT, "glGetRenderbufferParameterivEXT");
   if ( !driverTbl.glGetRenderbufferParameterivEXT ) {
      driverTbl.glGetRenderbufferParameterivEXT = missing_glGetRenderbufferParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetRenderbufferParameterivEXT == loader_glGetRenderbufferParameterivEXT) {
      rCtx->dsp->emuTbl.glGetRenderbufferParameterivEXT = driverTbl.glGetRenderbufferParameterivEXT;
   }
   driverTbl.glGetRenderbufferParameterivEXT(target, pname, params);
}

static GLboolean REGAL_CALL missing_glIsFramebufferEXT(GLuint framebuffer)
{
   UNUSED_PARAMETER(framebuffer);
   Warning( "glIsFramebufferEXT not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsFramebufferEXT(GLuint framebuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsFramebufferEXT, "glIsFramebufferEXT");
   if ( !driverTbl.glIsFramebufferEXT ) {
      driverTbl.glIsFramebufferEXT = missing_glIsFramebufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsFramebufferEXT == loader_glIsFramebufferEXT) {
      rCtx->dsp->emuTbl.glIsFramebufferEXT = driverTbl.glIsFramebufferEXT;
   }
   return driverTbl.glIsFramebufferEXT(framebuffer);
}

static GLboolean REGAL_CALL missing_glIsRenderbufferEXT(GLuint renderbuffer)
{
   UNUSED_PARAMETER(renderbuffer);
   Warning( "glIsRenderbufferEXT not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsRenderbufferEXT(GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsRenderbufferEXT, "glIsRenderbufferEXT");
   if ( !driverTbl.glIsRenderbufferEXT ) {
      driverTbl.glIsRenderbufferEXT = missing_glIsRenderbufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsRenderbufferEXT == loader_glIsRenderbufferEXT) {
      rCtx->dsp->emuTbl.glIsRenderbufferEXT = driverTbl.glIsRenderbufferEXT;
   }
   return driverTbl.glIsRenderbufferEXT(renderbuffer);
}

static void REGAL_CALL missing_glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glRenderbufferStorageEXT not available." );
}

static void REGAL_CALL loader_glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRenderbufferStorageEXT, "glRenderbufferStorageEXT");
   if ( !driverTbl.glRenderbufferStorageEXT ) {
      driverTbl.glRenderbufferStorageEXT = missing_glRenderbufferStorageEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRenderbufferStorageEXT == loader_glRenderbufferStorageEXT) {
      rCtx->dsp->emuTbl.glRenderbufferStorageEXT = driverTbl.glRenderbufferStorageEXT;
   }
   driverTbl.glRenderbufferStorageEXT(target, internalformat, width, height);
}

// GL_EXT_geometry_shader4

static void REGAL_CALL missing_glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   Warning( "glFramebufferTextureEXT not available." );
}

static void REGAL_CALL loader_glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTextureEXT, "glFramebufferTextureEXT");
   if ( !driverTbl.glFramebufferTextureEXT ) {
      driverTbl.glFramebufferTextureEXT = missing_glFramebufferTextureEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTextureEXT == loader_glFramebufferTextureEXT) {
      rCtx->dsp->emuTbl.glFramebufferTextureEXT = driverTbl.glFramebufferTextureEXT;
   }
   driverTbl.glFramebufferTextureEXT(target, attachment, texture, level);
}

static void REGAL_CALL missing_glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(face);
   Warning( "glFramebufferTextureFaceEXT not available." );
}

static void REGAL_CALL loader_glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTextureFaceEXT, "glFramebufferTextureFaceEXT");
   if ( !driverTbl.glFramebufferTextureFaceEXT ) {
      driverTbl.glFramebufferTextureFaceEXT = missing_glFramebufferTextureFaceEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTextureFaceEXT == loader_glFramebufferTextureFaceEXT) {
      rCtx->dsp->emuTbl.glFramebufferTextureFaceEXT = driverTbl.glFramebufferTextureFaceEXT;
   }
   driverTbl.glFramebufferTextureFaceEXT(target, attachment, texture, level, face);
}

static void REGAL_CALL missing_glProgramParameteriEXT(GLuint program, GLenum pname, GLint value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "glProgramParameteriEXT not available." );
}

static void REGAL_CALL loader_glProgramParameteriEXT(GLuint program, GLenum pname, GLint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramParameteriEXT, "glProgramParameteriEXT");
   if ( !driverTbl.glProgramParameteriEXT ) {
      driverTbl.glProgramParameteriEXT = missing_glProgramParameteriEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramParameteriEXT == loader_glProgramParameteriEXT) {
      rCtx->dsp->emuTbl.glProgramParameteriEXT = driverTbl.glProgramParameteriEXT;
   }
   driverTbl.glProgramParameteriEXT(program, pname, value);
}

// GL_EXT_gpu_program_parameters

static void REGAL_CALL missing_glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "glProgramEnvParameters4fvEXT not available." );
}

static void REGAL_CALL loader_glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramEnvParameters4fvEXT, "glProgramEnvParameters4fvEXT");
   if ( !driverTbl.glProgramEnvParameters4fvEXT ) {
      driverTbl.glProgramEnvParameters4fvEXT = missing_glProgramEnvParameters4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramEnvParameters4fvEXT == loader_glProgramEnvParameters4fvEXT) {
      rCtx->dsp->emuTbl.glProgramEnvParameters4fvEXT = driverTbl.glProgramEnvParameters4fvEXT;
   }
   driverTbl.glProgramEnvParameters4fvEXT(target, index, count, params);
}

static void REGAL_CALL missing_glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "glProgramLocalParameters4fvEXT not available." );
}

static void REGAL_CALL loader_glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramLocalParameters4fvEXT, "glProgramLocalParameters4fvEXT");
   if ( !driverTbl.glProgramLocalParameters4fvEXT ) {
      driverTbl.glProgramLocalParameters4fvEXT = missing_glProgramLocalParameters4fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramLocalParameters4fvEXT == loader_glProgramLocalParameters4fvEXT) {
      rCtx->dsp->emuTbl.glProgramLocalParameters4fvEXT = driverTbl.glProgramLocalParameters4fvEXT;
   }
   driverTbl.glProgramLocalParameters4fvEXT(target, index, count, params);
}

// GL_EXT_gpu_shader4

static void REGAL_CALL missing_glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(color);
   UNUSED_PARAMETER(name);
   Warning( "glBindFragDataLocationEXT not available." );
}

static void REGAL_CALL loader_glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindFragDataLocationEXT, "glBindFragDataLocationEXT");
   if ( !driverTbl.glBindFragDataLocationEXT ) {
      driverTbl.glBindFragDataLocationEXT = missing_glBindFragDataLocationEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindFragDataLocationEXT == loader_glBindFragDataLocationEXT) {
      rCtx->dsp->emuTbl.glBindFragDataLocationEXT = driverTbl.glBindFragDataLocationEXT;
   }
   driverTbl.glBindFragDataLocationEXT(program, color, name);
}

static GLint REGAL_CALL missing_glGetFragDataLocationEXT(GLuint program, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(name);
   Warning( "glGetFragDataLocationEXT not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetFragDataLocationEXT(GLuint program, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFragDataLocationEXT, "glGetFragDataLocationEXT");
   if ( !driverTbl.glGetFragDataLocationEXT ) {
      driverTbl.glGetFragDataLocationEXT = missing_glGetFragDataLocationEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFragDataLocationEXT == loader_glGetFragDataLocationEXT) {
      rCtx->dsp->emuTbl.glGetFragDataLocationEXT = driverTbl.glGetFragDataLocationEXT;
   }
   return driverTbl.glGetFragDataLocationEXT(program, name);
}

static void REGAL_CALL missing_glGetUniformuivEXT(GLuint program, GLint location, GLuint *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "glGetUniformuivEXT not available." );
}

static void REGAL_CALL loader_glGetUniformuivEXT(GLuint program, GLint location, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformuivEXT, "glGetUniformuivEXT");
   if ( !driverTbl.glGetUniformuivEXT ) {
      driverTbl.glGetUniformuivEXT = missing_glGetUniformuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformuivEXT == loader_glGetUniformuivEXT) {
      rCtx->dsp->emuTbl.glGetUniformuivEXT = driverTbl.glGetUniformuivEXT;
   }
   driverTbl.glGetUniformuivEXT(program, location, params);
}

static void REGAL_CALL missing_glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribIivEXT not available." );
}

static void REGAL_CALL loader_glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribIivEXT, "glGetVertexAttribIivEXT");
   if ( !driverTbl.glGetVertexAttribIivEXT ) {
      driverTbl.glGetVertexAttribIivEXT = missing_glGetVertexAttribIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribIivEXT == loader_glGetVertexAttribIivEXT) {
      rCtx->dsp->emuTbl.glGetVertexAttribIivEXT = driverTbl.glGetVertexAttribIivEXT;
   }
   driverTbl.glGetVertexAttribIivEXT(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribIuivEXT not available." );
}

static void REGAL_CALL loader_glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribIuivEXT, "glGetVertexAttribIuivEXT");
   if ( !driverTbl.glGetVertexAttribIuivEXT ) {
      driverTbl.glGetVertexAttribIuivEXT = missing_glGetVertexAttribIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribIuivEXT == loader_glGetVertexAttribIuivEXT) {
      rCtx->dsp->emuTbl.glGetVertexAttribIuivEXT = driverTbl.glGetVertexAttribIuivEXT;
   }
   driverTbl.glGetVertexAttribIuivEXT(index, pname, params);
}

static void REGAL_CALL missing_glUniform1uiEXT(GLint location, GLuint v0)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "glUniform1uiEXT not available." );
}

static void REGAL_CALL loader_glUniform1uiEXT(GLint location, GLuint v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1uiEXT, "glUniform1uiEXT");
   if ( !driverTbl.glUniform1uiEXT ) {
      driverTbl.glUniform1uiEXT = missing_glUniform1uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1uiEXT == loader_glUniform1uiEXT) {
      rCtx->dsp->emuTbl.glUniform1uiEXT = driverTbl.glUniform1uiEXT;
   }
   driverTbl.glUniform1uiEXT(location, v0);
}

static void REGAL_CALL missing_glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform1uivEXT not available." );
}

static void REGAL_CALL loader_glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1uivEXT, "glUniform1uivEXT");
   if ( !driverTbl.glUniform1uivEXT ) {
      driverTbl.glUniform1uivEXT = missing_glUniform1uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1uivEXT == loader_glUniform1uivEXT) {
      rCtx->dsp->emuTbl.glUniform1uivEXT = driverTbl.glUniform1uivEXT;
   }
   driverTbl.glUniform1uivEXT(location, count, value);
}

static void REGAL_CALL missing_glUniform2uiEXT(GLint location, GLuint v0, GLuint v1)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   Warning( "glUniform2uiEXT not available." );
}

static void REGAL_CALL loader_glUniform2uiEXT(GLint location, GLuint v0, GLuint v1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2uiEXT, "glUniform2uiEXT");
   if ( !driverTbl.glUniform2uiEXT ) {
      driverTbl.glUniform2uiEXT = missing_glUniform2uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2uiEXT == loader_glUniform2uiEXT) {
      rCtx->dsp->emuTbl.glUniform2uiEXT = driverTbl.glUniform2uiEXT;
   }
   driverTbl.glUniform2uiEXT(location, v0, v1);
}

static void REGAL_CALL missing_glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform2uivEXT not available." );
}

static void REGAL_CALL loader_glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2uivEXT, "glUniform2uivEXT");
   if ( !driverTbl.glUniform2uivEXT ) {
      driverTbl.glUniform2uivEXT = missing_glUniform2uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2uivEXT == loader_glUniform2uivEXT) {
      rCtx->dsp->emuTbl.glUniform2uivEXT = driverTbl.glUniform2uivEXT;
   }
   driverTbl.glUniform2uivEXT(location, count, value);
}

static void REGAL_CALL missing_glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   Warning( "glUniform3uiEXT not available." );
}

static void REGAL_CALL loader_glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3uiEXT, "glUniform3uiEXT");
   if ( !driverTbl.glUniform3uiEXT ) {
      driverTbl.glUniform3uiEXT = missing_glUniform3uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3uiEXT == loader_glUniform3uiEXT) {
      rCtx->dsp->emuTbl.glUniform3uiEXT = driverTbl.glUniform3uiEXT;
   }
   driverTbl.glUniform3uiEXT(location, v0, v1, v2);
}

static void REGAL_CALL missing_glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform3uivEXT not available." );
}

static void REGAL_CALL loader_glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3uivEXT, "glUniform3uivEXT");
   if ( !driverTbl.glUniform3uivEXT ) {
      driverTbl.glUniform3uivEXT = missing_glUniform3uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3uivEXT == loader_glUniform3uivEXT) {
      rCtx->dsp->emuTbl.glUniform3uivEXT = driverTbl.glUniform3uivEXT;
   }
   driverTbl.glUniform3uivEXT(location, count, value);
}

static void REGAL_CALL missing_glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(v3);
   Warning( "glUniform4uiEXT not available." );
}

static void REGAL_CALL loader_glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4uiEXT, "glUniform4uiEXT");
   if ( !driverTbl.glUniform4uiEXT ) {
      driverTbl.glUniform4uiEXT = missing_glUniform4uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4uiEXT == loader_glUniform4uiEXT) {
      rCtx->dsp->emuTbl.glUniform4uiEXT = driverTbl.glUniform4uiEXT;
   }
   driverTbl.glUniform4uiEXT(location, v0, v1, v2, v3);
}

static void REGAL_CALL missing_glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform4uivEXT not available." );
}

static void REGAL_CALL loader_glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4uivEXT, "glUniform4uivEXT");
   if ( !driverTbl.glUniform4uivEXT ) {
      driverTbl.glUniform4uivEXT = missing_glUniform4uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4uivEXT == loader_glUniform4uivEXT) {
      rCtx->dsp->emuTbl.glUniform4uivEXT = driverTbl.glUniform4uivEXT;
   }
   driverTbl.glUniform4uivEXT(location, count, value);
}

static void REGAL_CALL missing_glVertexAttribI1iEXT(GLuint index, GLint x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttribI1iEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI1iEXT(GLuint index, GLint x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI1iEXT, "glVertexAttribI1iEXT");
   if ( !driverTbl.glVertexAttribI1iEXT ) {
      driverTbl.glVertexAttribI1iEXT = missing_glVertexAttribI1iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI1iEXT == loader_glVertexAttribI1iEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI1iEXT = driverTbl.glVertexAttribI1iEXT;
   }
   driverTbl.glVertexAttribI1iEXT(index, x);
}

static void REGAL_CALL missing_glVertexAttribI1ivEXT(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI1ivEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI1ivEXT(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI1ivEXT, "glVertexAttribI1ivEXT");
   if ( !driverTbl.glVertexAttribI1ivEXT ) {
      driverTbl.glVertexAttribI1ivEXT = missing_glVertexAttribI1ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI1ivEXT == loader_glVertexAttribI1ivEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI1ivEXT = driverTbl.glVertexAttribI1ivEXT;
   }
   driverTbl.glVertexAttribI1ivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI1uiEXT(GLuint index, GLuint x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttribI1uiEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI1uiEXT(GLuint index, GLuint x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI1uiEXT, "glVertexAttribI1uiEXT");
   if ( !driverTbl.glVertexAttribI1uiEXT ) {
      driverTbl.glVertexAttribI1uiEXT = missing_glVertexAttribI1uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI1uiEXT == loader_glVertexAttribI1uiEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI1uiEXT = driverTbl.glVertexAttribI1uiEXT;
   }
   driverTbl.glVertexAttribI1uiEXT(index, x);
}

static void REGAL_CALL missing_glVertexAttribI1uivEXT(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI1uivEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI1uivEXT(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI1uivEXT, "glVertexAttribI1uivEXT");
   if ( !driverTbl.glVertexAttribI1uivEXT ) {
      driverTbl.glVertexAttribI1uivEXT = missing_glVertexAttribI1uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI1uivEXT == loader_glVertexAttribI1uivEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI1uivEXT = driverTbl.glVertexAttribI1uivEXT;
   }
   driverTbl.glVertexAttribI1uivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI2iEXT(GLuint index, GLint x, GLint y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttribI2iEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI2iEXT(GLuint index, GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI2iEXT, "glVertexAttribI2iEXT");
   if ( !driverTbl.glVertexAttribI2iEXT ) {
      driverTbl.glVertexAttribI2iEXT = missing_glVertexAttribI2iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI2iEXT == loader_glVertexAttribI2iEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI2iEXT = driverTbl.glVertexAttribI2iEXT;
   }
   driverTbl.glVertexAttribI2iEXT(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribI2ivEXT(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI2ivEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI2ivEXT(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI2ivEXT, "glVertexAttribI2ivEXT");
   if ( !driverTbl.glVertexAttribI2ivEXT ) {
      driverTbl.glVertexAttribI2ivEXT = missing_glVertexAttribI2ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI2ivEXT == loader_glVertexAttribI2ivEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI2ivEXT = driverTbl.glVertexAttribI2ivEXT;
   }
   driverTbl.glVertexAttribI2ivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttribI2uiEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI2uiEXT, "glVertexAttribI2uiEXT");
   if ( !driverTbl.glVertexAttribI2uiEXT ) {
      driverTbl.glVertexAttribI2uiEXT = missing_glVertexAttribI2uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI2uiEXT == loader_glVertexAttribI2uiEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI2uiEXT = driverTbl.glVertexAttribI2uiEXT;
   }
   driverTbl.glVertexAttribI2uiEXT(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribI2uivEXT(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI2uivEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI2uivEXT(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI2uivEXT, "glVertexAttribI2uivEXT");
   if ( !driverTbl.glVertexAttribI2uivEXT ) {
      driverTbl.glVertexAttribI2uivEXT = missing_glVertexAttribI2uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI2uivEXT == loader_glVertexAttribI2uivEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI2uivEXT = driverTbl.glVertexAttribI2uivEXT;
   }
   driverTbl.glVertexAttribI2uivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttribI3iEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI3iEXT, "glVertexAttribI3iEXT");
   if ( !driverTbl.glVertexAttribI3iEXT ) {
      driverTbl.glVertexAttribI3iEXT = missing_glVertexAttribI3iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI3iEXT == loader_glVertexAttribI3iEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI3iEXT = driverTbl.glVertexAttribI3iEXT;
   }
   driverTbl.glVertexAttribI3iEXT(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribI3ivEXT(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI3ivEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI3ivEXT(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI3ivEXT, "glVertexAttribI3ivEXT");
   if ( !driverTbl.glVertexAttribI3ivEXT ) {
      driverTbl.glVertexAttribI3ivEXT = missing_glVertexAttribI3ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI3ivEXT == loader_glVertexAttribI3ivEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI3ivEXT = driverTbl.glVertexAttribI3ivEXT;
   }
   driverTbl.glVertexAttribI3ivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttribI3uiEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI3uiEXT, "glVertexAttribI3uiEXT");
   if ( !driverTbl.glVertexAttribI3uiEXT ) {
      driverTbl.glVertexAttribI3uiEXT = missing_glVertexAttribI3uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI3uiEXT == loader_glVertexAttribI3uiEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI3uiEXT = driverTbl.glVertexAttribI3uiEXT;
   }
   driverTbl.glVertexAttribI3uiEXT(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribI3uivEXT(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI3uivEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI3uivEXT(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI3uivEXT, "glVertexAttribI3uivEXT");
   if ( !driverTbl.glVertexAttribI3uivEXT ) {
      driverTbl.glVertexAttribI3uivEXT = missing_glVertexAttribI3uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI3uivEXT == loader_glVertexAttribI3uivEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI3uivEXT = driverTbl.glVertexAttribI3uivEXT;
   }
   driverTbl.glVertexAttribI3uivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4bvEXT(GLuint index, const GLbyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI4bvEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI4bvEXT(GLuint index, const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4bvEXT, "glVertexAttribI4bvEXT");
   if ( !driverTbl.glVertexAttribI4bvEXT ) {
      driverTbl.glVertexAttribI4bvEXT = missing_glVertexAttribI4bvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4bvEXT == loader_glVertexAttribI4bvEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI4bvEXT = driverTbl.glVertexAttribI4bvEXT;
   }
   driverTbl.glVertexAttribI4bvEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttribI4iEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4iEXT, "glVertexAttribI4iEXT");
   if ( !driverTbl.glVertexAttribI4iEXT ) {
      driverTbl.glVertexAttribI4iEXT = missing_glVertexAttribI4iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4iEXT == loader_glVertexAttribI4iEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI4iEXT = driverTbl.glVertexAttribI4iEXT;
   }
   driverTbl.glVertexAttribI4iEXT(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribI4ivEXT(GLuint index, const GLint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI4ivEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI4ivEXT(GLuint index, const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4ivEXT, "glVertexAttribI4ivEXT");
   if ( !driverTbl.glVertexAttribI4ivEXT ) {
      driverTbl.glVertexAttribI4ivEXT = missing_glVertexAttribI4ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4ivEXT == loader_glVertexAttribI4ivEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI4ivEXT = driverTbl.glVertexAttribI4ivEXT;
   }
   driverTbl.glVertexAttribI4ivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4svEXT(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI4svEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI4svEXT(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4svEXT, "glVertexAttribI4svEXT");
   if ( !driverTbl.glVertexAttribI4svEXT ) {
      driverTbl.glVertexAttribI4svEXT = missing_glVertexAttribI4svEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4svEXT == loader_glVertexAttribI4svEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI4svEXT = driverTbl.glVertexAttribI4svEXT;
   }
   driverTbl.glVertexAttribI4svEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI4ubvEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4ubvEXT, "glVertexAttribI4ubvEXT");
   if ( !driverTbl.glVertexAttribI4ubvEXT ) {
      driverTbl.glVertexAttribI4ubvEXT = missing_glVertexAttribI4ubvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4ubvEXT == loader_glVertexAttribI4ubvEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI4ubvEXT = driverTbl.glVertexAttribI4ubvEXT;
   }
   driverTbl.glVertexAttribI4ubvEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttribI4uiEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4uiEXT, "glVertexAttribI4uiEXT");
   if ( !driverTbl.glVertexAttribI4uiEXT ) {
      driverTbl.glVertexAttribI4uiEXT = missing_glVertexAttribI4uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4uiEXT == loader_glVertexAttribI4uiEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI4uiEXT = driverTbl.glVertexAttribI4uiEXT;
   }
   driverTbl.glVertexAttribI4uiEXT(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribI4uivEXT(GLuint index, const GLuint *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI4uivEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI4uivEXT(GLuint index, const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4uivEXT, "glVertexAttribI4uivEXT");
   if ( !driverTbl.glVertexAttribI4uivEXT ) {
      driverTbl.glVertexAttribI4uivEXT = missing_glVertexAttribI4uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4uivEXT == loader_glVertexAttribI4uivEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI4uivEXT = driverTbl.glVertexAttribI4uivEXT;
   }
   driverTbl.glVertexAttribI4uivEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribI4usvEXT(GLuint index, const GLushort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribI4usvEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribI4usvEXT(GLuint index, const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribI4usvEXT, "glVertexAttribI4usvEXT");
   if ( !driverTbl.glVertexAttribI4usvEXT ) {
      driverTbl.glVertexAttribI4usvEXT = missing_glVertexAttribI4usvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribI4usvEXT == loader_glVertexAttribI4usvEXT) {
      rCtx->dsp->emuTbl.glVertexAttribI4usvEXT = driverTbl.glVertexAttribI4usvEXT;
   }
   driverTbl.glVertexAttribI4usvEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glVertexAttribIPointerEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribIPointerEXT, "glVertexAttribIPointerEXT");
   if ( !driverTbl.glVertexAttribIPointerEXT ) {
      driverTbl.glVertexAttribIPointerEXT = missing_glVertexAttribIPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribIPointerEXT == loader_glVertexAttribIPointerEXT) {
      rCtx->dsp->emuTbl.glVertexAttribIPointerEXT = driverTbl.glVertexAttribIPointerEXT;
   }
   driverTbl.glVertexAttribIPointerEXT(index, size, type, stride, pointer);
}

// GL_EXT_histogram

static void REGAL_CALL missing_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(reset);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(values);
   Warning( "glGetHistogramEXT not available." );
}

static void REGAL_CALL loader_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetHistogramEXT, "glGetHistogramEXT");
   if ( !driverTbl.glGetHistogramEXT ) {
      driverTbl.glGetHistogramEXT = missing_glGetHistogramEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetHistogramEXT == loader_glGetHistogramEXT) {
      rCtx->dsp->emuTbl.glGetHistogramEXT = driverTbl.glGetHistogramEXT;
   }
   driverTbl.glGetHistogramEXT(target, reset, format, type, values);
}

static void REGAL_CALL missing_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetHistogramParameterfvEXT not available." );
}

static void REGAL_CALL loader_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetHistogramParameterfvEXT, "glGetHistogramParameterfvEXT");
   if ( !driverTbl.glGetHistogramParameterfvEXT ) {
      driverTbl.glGetHistogramParameterfvEXT = missing_glGetHistogramParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetHistogramParameterfvEXT == loader_glGetHistogramParameterfvEXT) {
      rCtx->dsp->emuTbl.glGetHistogramParameterfvEXT = driverTbl.glGetHistogramParameterfvEXT;
   }
   driverTbl.glGetHistogramParameterfvEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetHistogramParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetHistogramParameterivEXT, "glGetHistogramParameterivEXT");
   if ( !driverTbl.glGetHistogramParameterivEXT ) {
      driverTbl.glGetHistogramParameterivEXT = missing_glGetHistogramParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetHistogramParameterivEXT == loader_glGetHistogramParameterivEXT) {
      rCtx->dsp->emuTbl.glGetHistogramParameterivEXT = driverTbl.glGetHistogramParameterivEXT;
   }
   driverTbl.glGetHistogramParameterivEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(reset);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(values);
   Warning( "glGetMinmaxEXT not available." );
}

static void REGAL_CALL loader_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMinmaxEXT, "glGetMinmaxEXT");
   if ( !driverTbl.glGetMinmaxEXT ) {
      driverTbl.glGetMinmaxEXT = missing_glGetMinmaxEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMinmaxEXT == loader_glGetMinmaxEXT) {
      rCtx->dsp->emuTbl.glGetMinmaxEXT = driverTbl.glGetMinmaxEXT;
   }
   driverTbl.glGetMinmaxEXT(target, reset, format, type, values);
}

static void REGAL_CALL missing_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMinmaxParameterfvEXT not available." );
}

static void REGAL_CALL loader_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMinmaxParameterfvEXT, "glGetMinmaxParameterfvEXT");
   if ( !driverTbl.glGetMinmaxParameterfvEXT ) {
      driverTbl.glGetMinmaxParameterfvEXT = missing_glGetMinmaxParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMinmaxParameterfvEXT == loader_glGetMinmaxParameterfvEXT) {
      rCtx->dsp->emuTbl.glGetMinmaxParameterfvEXT = driverTbl.glGetMinmaxParameterfvEXT;
   }
   driverTbl.glGetMinmaxParameterfvEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMinmaxParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMinmaxParameterivEXT, "glGetMinmaxParameterivEXT");
   if ( !driverTbl.glGetMinmaxParameterivEXT ) {
      driverTbl.glGetMinmaxParameterivEXT = missing_glGetMinmaxParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMinmaxParameterivEXT == loader_glGetMinmaxParameterivEXT) {
      rCtx->dsp->emuTbl.glGetMinmaxParameterivEXT = driverTbl.glGetMinmaxParameterivEXT;
   }
   driverTbl.glGetMinmaxParameterivEXT(target, pname, params);
}

static void REGAL_CALL missing_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(sink);
   Warning( "glHistogramEXT not available." );
}

static void REGAL_CALL loader_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glHistogramEXT, "glHistogramEXT");
   if ( !driverTbl.glHistogramEXT ) {
      driverTbl.glHistogramEXT = missing_glHistogramEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glHistogramEXT == loader_glHistogramEXT) {
      rCtx->dsp->emuTbl.glHistogramEXT = driverTbl.glHistogramEXT;
   }
   driverTbl.glHistogramEXT(target, width, internalformat, sink);
}

static void REGAL_CALL missing_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(sink);
   Warning( "glMinmaxEXT not available." );
}

static void REGAL_CALL loader_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMinmaxEXT, "glMinmaxEXT");
   if ( !driverTbl.glMinmaxEXT ) {
      driverTbl.glMinmaxEXT = missing_glMinmaxEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMinmaxEXT == loader_glMinmaxEXT) {
      rCtx->dsp->emuTbl.glMinmaxEXT = driverTbl.glMinmaxEXT;
   }
   driverTbl.glMinmaxEXT(target, internalformat, sink);
}

static void REGAL_CALL missing_glResetHistogramEXT(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glResetHistogramEXT not available." );
}

static void REGAL_CALL loader_glResetHistogramEXT(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glResetHistogramEXT, "glResetHistogramEXT");
   if ( !driverTbl.glResetHistogramEXT ) {
      driverTbl.glResetHistogramEXT = missing_glResetHistogramEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glResetHistogramEXT == loader_glResetHistogramEXT) {
      rCtx->dsp->emuTbl.glResetHistogramEXT = driverTbl.glResetHistogramEXT;
   }
   driverTbl.glResetHistogramEXT(target);
}

static void REGAL_CALL missing_glResetMinmaxEXT(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glResetMinmaxEXT not available." );
}

static void REGAL_CALL loader_glResetMinmaxEXT(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glResetMinmaxEXT, "glResetMinmaxEXT");
   if ( !driverTbl.glResetMinmaxEXT ) {
      driverTbl.glResetMinmaxEXT = missing_glResetMinmaxEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glResetMinmaxEXT == loader_glResetMinmaxEXT) {
      rCtx->dsp->emuTbl.glResetMinmaxEXT = driverTbl.glResetMinmaxEXT;
   }
   driverTbl.glResetMinmaxEXT(target);
}

// GL_EXT_index_func

static void REGAL_CALL missing_glIndexFuncEXT(GLenum func, GLfloat ref)
{
   UNUSED_PARAMETER(func);
   UNUSED_PARAMETER(ref);
   Warning( "glIndexFuncEXT not available." );
}

static void REGAL_CALL loader_glIndexFuncEXT(GLenum func, GLfloat ref)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexFuncEXT, "glIndexFuncEXT");
   if ( !driverTbl.glIndexFuncEXT ) {
      driverTbl.glIndexFuncEXT = missing_glIndexFuncEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexFuncEXT == loader_glIndexFuncEXT) {
      rCtx->dsp->emuTbl.glIndexFuncEXT = driverTbl.glIndexFuncEXT;
   }
   driverTbl.glIndexFuncEXT(func, ref);
}

// GL_EXT_index_material

static void REGAL_CALL missing_glIndexMaterialEXT(GLenum face, GLenum mode)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(mode);
   Warning( "glIndexMaterialEXT not available." );
}

static void REGAL_CALL loader_glIndexMaterialEXT(GLenum face, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexMaterialEXT, "glIndexMaterialEXT");
   if ( !driverTbl.glIndexMaterialEXT ) {
      driverTbl.glIndexMaterialEXT = missing_glIndexMaterialEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexMaterialEXT == loader_glIndexMaterialEXT) {
      rCtx->dsp->emuTbl.glIndexMaterialEXT = driverTbl.glIndexMaterialEXT;
   }
   driverTbl.glIndexMaterialEXT(face, mode);
}

// GL_EXT_light_texture

static void REGAL_CALL missing_glApplyTextureEXT(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glApplyTextureEXT not available." );
}

static void REGAL_CALL loader_glApplyTextureEXT(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glApplyTextureEXT, "glApplyTextureEXT");
   if ( !driverTbl.glApplyTextureEXT ) {
      driverTbl.glApplyTextureEXT = missing_glApplyTextureEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glApplyTextureEXT == loader_glApplyTextureEXT) {
      rCtx->dsp->emuTbl.glApplyTextureEXT = driverTbl.glApplyTextureEXT;
   }
   driverTbl.glApplyTextureEXT(mode);
}

static void REGAL_CALL missing_glTextureLightEXT(GLenum pname)
{
   UNUSED_PARAMETER(pname);
   Warning( "glTextureLightEXT not available." );
}

static void REGAL_CALL loader_glTextureLightEXT(GLenum pname)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureLightEXT, "glTextureLightEXT");
   if ( !driverTbl.glTextureLightEXT ) {
      driverTbl.glTextureLightEXT = missing_glTextureLightEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureLightEXT == loader_glTextureLightEXT) {
      rCtx->dsp->emuTbl.glTextureLightEXT = driverTbl.glTextureLightEXT;
   }
   driverTbl.glTextureLightEXT(pname);
}

static void REGAL_CALL missing_glTextureMaterialEXT(GLenum face, GLenum mode)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(mode);
   Warning( "glTextureMaterialEXT not available." );
}

static void REGAL_CALL loader_glTextureMaterialEXT(GLenum face, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureMaterialEXT, "glTextureMaterialEXT");
   if ( !driverTbl.glTextureMaterialEXT ) {
      driverTbl.glTextureMaterialEXT = missing_glTextureMaterialEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureMaterialEXT == loader_glTextureMaterialEXT) {
      rCtx->dsp->emuTbl.glTextureMaterialEXT = driverTbl.glTextureMaterialEXT;
   }
   driverTbl.glTextureMaterialEXT(face, mode);
}

// GL_EXT_multi_draw_arrays

static void REGAL_CALL missing_glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   Warning( "glMultiDrawArraysEXT not available." );
}

static void REGAL_CALL loader_glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiDrawArraysEXT, "glMultiDrawArraysEXT");
   if ( !driverTbl.glMultiDrawArraysEXT ) {
      driverTbl.glMultiDrawArraysEXT = missing_glMultiDrawArraysEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiDrawArraysEXT == loader_glMultiDrawArraysEXT) {
      rCtx->dsp->emuTbl.glMultiDrawArraysEXT = driverTbl.glMultiDrawArraysEXT;
   }
   driverTbl.glMultiDrawArraysEXT(mode, first, count, primcount);
}

static void REGAL_CALL missing_glMultiDrawElementsEXT(GLenum mode, GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   Warning( "glMultiDrawElementsEXT not available." );
}

static void REGAL_CALL loader_glMultiDrawElementsEXT(GLenum mode, GLsizei *count, GLenum type, const GLvoid **indices, GLsizei primcount)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiDrawElementsEXT, "glMultiDrawElementsEXT");
   if ( !driverTbl.glMultiDrawElementsEXT ) {
      driverTbl.glMultiDrawElementsEXT = missing_glMultiDrawElementsEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiDrawElementsEXT == loader_glMultiDrawElementsEXT) {
      rCtx->dsp->emuTbl.glMultiDrawElementsEXT = driverTbl.glMultiDrawElementsEXT;
   }
   driverTbl.glMultiDrawElementsEXT(mode, count, type, indices, primcount);
}

// GL_EXT_multisample

static void REGAL_CALL missing_glSampleMaskEXT(GLclampf value, GLboolean invert)
{
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(invert);
   Warning( "glSampleMaskEXT not available." );
}

static void REGAL_CALL loader_glSampleMaskEXT(GLclampf value, GLboolean invert)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSampleMaskEXT, "glSampleMaskEXT");
   if ( !driverTbl.glSampleMaskEXT ) {
      driverTbl.glSampleMaskEXT = missing_glSampleMaskEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSampleMaskEXT == loader_glSampleMaskEXT) {
      rCtx->dsp->emuTbl.glSampleMaskEXT = driverTbl.glSampleMaskEXT;
   }
   driverTbl.glSampleMaskEXT(value, invert);
}

static void REGAL_CALL missing_glSamplePatternEXT(GLenum pattern)
{
   UNUSED_PARAMETER(pattern);
   Warning( "glSamplePatternEXT not available." );
}

static void REGAL_CALL loader_glSamplePatternEXT(GLenum pattern)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSamplePatternEXT, "glSamplePatternEXT");
   if ( !driverTbl.glSamplePatternEXT ) {
      driverTbl.glSamplePatternEXT = missing_glSamplePatternEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSamplePatternEXT == loader_glSamplePatternEXT) {
      rCtx->dsp->emuTbl.glSamplePatternEXT = driverTbl.glSamplePatternEXT;
   }
   driverTbl.glSamplePatternEXT(pattern);
}

// GL_EXT_paletted_texture

static void REGAL_CALL missing_glColorTableEXT(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalFormat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(table);
   Warning( "glColorTableEXT not available." );
}

static void REGAL_CALL loader_glColorTableEXT(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorTableEXT, "glColorTableEXT");
   if ( !driverTbl.glColorTableEXT ) {
      driverTbl.glColorTableEXT = missing_glColorTableEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorTableEXT == loader_glColorTableEXT) {
      rCtx->dsp->emuTbl.glColorTableEXT = driverTbl.glColorTableEXT;
   }
   driverTbl.glColorTableEXT(target, internalFormat, width, format, type, table);
}

static void REGAL_CALL missing_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(data);
   Warning( "glGetColorTableEXT not available." );
}

static void REGAL_CALL loader_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetColorTableEXT, "glGetColorTableEXT");
   if ( !driverTbl.glGetColorTableEXT ) {
      driverTbl.glGetColorTableEXT = missing_glGetColorTableEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetColorTableEXT == loader_glGetColorTableEXT) {
      rCtx->dsp->emuTbl.glGetColorTableEXT = driverTbl.glGetColorTableEXT;
   }
   driverTbl.glGetColorTableEXT(target, format, type, data);
}

static void REGAL_CALL missing_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetColorTableParameterfvEXT not available." );
}

static void REGAL_CALL loader_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetColorTableParameterfvEXT, "glGetColorTableParameterfvEXT");
   if ( !driverTbl.glGetColorTableParameterfvEXT ) {
      driverTbl.glGetColorTableParameterfvEXT = missing_glGetColorTableParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetColorTableParameterfvEXT == loader_glGetColorTableParameterfvEXT) {
      rCtx->dsp->emuTbl.glGetColorTableParameterfvEXT = driverTbl.glGetColorTableParameterfvEXT;
   }
   driverTbl.glGetColorTableParameterfvEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetColorTableParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetColorTableParameterivEXT, "glGetColorTableParameterivEXT");
   if ( !driverTbl.glGetColorTableParameterivEXT ) {
      driverTbl.glGetColorTableParameterivEXT = missing_glGetColorTableParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetColorTableParameterivEXT == loader_glGetColorTableParameterivEXT) {
      rCtx->dsp->emuTbl.glGetColorTableParameterivEXT = driverTbl.glGetColorTableParameterivEXT;
   }
   driverTbl.glGetColorTableParameterivEXT(target, pname, params);
}

// GL_EXT_pixel_transform

static void REGAL_CALL missing_glGetPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetPixelTransformParameterfvEXT not available." );
}

static void REGAL_CALL loader_glGetPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPixelTransformParameterfvEXT, "glGetPixelTransformParameterfvEXT");
   if ( !driverTbl.glGetPixelTransformParameterfvEXT ) {
      driverTbl.glGetPixelTransformParameterfvEXT = missing_glGetPixelTransformParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPixelTransformParameterfvEXT == loader_glGetPixelTransformParameterfvEXT) {
      rCtx->dsp->emuTbl.glGetPixelTransformParameterfvEXT = driverTbl.glGetPixelTransformParameterfvEXT;
   }
   driverTbl.glGetPixelTransformParameterfvEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetPixelTransformParameterivEXT not available." );
}

static void REGAL_CALL loader_glGetPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPixelTransformParameterivEXT, "glGetPixelTransformParameterivEXT");
   if ( !driverTbl.glGetPixelTransformParameterivEXT ) {
      driverTbl.glGetPixelTransformParameterivEXT = missing_glGetPixelTransformParameterivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPixelTransformParameterivEXT == loader_glGetPixelTransformParameterivEXT) {
      rCtx->dsp->emuTbl.glGetPixelTransformParameterivEXT = driverTbl.glGetPixelTransformParameterivEXT;
   }
   driverTbl.glGetPixelTransformParameterivEXT(target, pname, params);
}

static void REGAL_CALL missing_glPixelTransformParameterfEXT(GLenum target, GLenum pname, const GLfloat param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPixelTransformParameterfEXT not available." );
}

static void REGAL_CALL loader_glPixelTransformParameterfEXT(GLenum target, GLenum pname, const GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelTransformParameterfEXT, "glPixelTransformParameterfEXT");
   if ( !driverTbl.glPixelTransformParameterfEXT ) {
      driverTbl.glPixelTransformParameterfEXT = missing_glPixelTransformParameterfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelTransformParameterfEXT == loader_glPixelTransformParameterfEXT) {
      rCtx->dsp->emuTbl.glPixelTransformParameterfEXT = driverTbl.glPixelTransformParameterfEXT;
   }
   driverTbl.glPixelTransformParameterfEXT(target, pname, param);
}

static void REGAL_CALL missing_glPixelTransformParameteriEXT(GLenum target, GLenum pname, const GLint param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPixelTransformParameteriEXT not available." );
}

static void REGAL_CALL loader_glPixelTransformParameteriEXT(GLenum target, GLenum pname, const GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelTransformParameteriEXT, "glPixelTransformParameteriEXT");
   if ( !driverTbl.glPixelTransformParameteriEXT ) {
      driverTbl.glPixelTransformParameteriEXT = missing_glPixelTransformParameteriEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelTransformParameteriEXT == loader_glPixelTransformParameteriEXT) {
      rCtx->dsp->emuTbl.glPixelTransformParameteriEXT = driverTbl.glPixelTransformParameteriEXT;
   }
   driverTbl.glPixelTransformParameteriEXT(target, pname, param);
}

// GL_EXT_point_parameters

static void REGAL_CALL missing_glPointParameterfEXT(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPointParameterfEXT not available." );
}

static void REGAL_CALL loader_glPointParameterfEXT(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPointParameterfEXT, "glPointParameterfEXT");
   if ( !driverTbl.glPointParameterfEXT ) {
      driverTbl.glPointParameterfEXT = missing_glPointParameterfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPointParameterfEXT == loader_glPointParameterfEXT) {
      rCtx->dsp->emuTbl.glPointParameterfEXT = driverTbl.glPointParameterfEXT;
   }
   driverTbl.glPointParameterfEXT(pname, param);
}

static void REGAL_CALL missing_glPointParameterfvEXT(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glPointParameterfvEXT not available." );
}

static void REGAL_CALL loader_glPointParameterfvEXT(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPointParameterfvEXT, "glPointParameterfvEXT");
   if ( !driverTbl.glPointParameterfvEXT ) {
      driverTbl.glPointParameterfvEXT = missing_glPointParameterfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPointParameterfvEXT == loader_glPointParameterfvEXT) {
      rCtx->dsp->emuTbl.glPointParameterfvEXT = driverTbl.glPointParameterfvEXT;
   }
   driverTbl.glPointParameterfvEXT(pname, params);
}

// GL_EXT_polygon_offset

static void REGAL_CALL missing_glPolygonOffsetEXT(GLfloat factor, GLfloat bias)
{
   UNUSED_PARAMETER(factor);
   UNUSED_PARAMETER(bias);
   Warning( "glPolygonOffsetEXT not available." );
}

static void REGAL_CALL loader_glPolygonOffsetEXT(GLfloat factor, GLfloat bias)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPolygonOffsetEXT, "glPolygonOffsetEXT");
   if ( !driverTbl.glPolygonOffsetEXT ) {
      driverTbl.glPolygonOffsetEXT = missing_glPolygonOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPolygonOffsetEXT == loader_glPolygonOffsetEXT) {
      rCtx->dsp->emuTbl.glPolygonOffsetEXT = driverTbl.glPolygonOffsetEXT;
   }
   driverTbl.glPolygonOffsetEXT(factor, bias);
}

// GL_EXT_provoking_vertex

static void REGAL_CALL missing_glProvokingVertexEXT(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glProvokingVertexEXT not available." );
}

static void REGAL_CALL loader_glProvokingVertexEXT(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProvokingVertexEXT, "glProvokingVertexEXT");
   if ( !driverTbl.glProvokingVertexEXT ) {
      driverTbl.glProvokingVertexEXT = missing_glProvokingVertexEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProvokingVertexEXT == loader_glProvokingVertexEXT) {
      rCtx->dsp->emuTbl.glProvokingVertexEXT = driverTbl.glProvokingVertexEXT;
   }
   driverTbl.glProvokingVertexEXT(mode);
}

// GL_EXT_scene_marker

static void REGAL_CALL missing_glBeginSceneEXT(void)
{
   Warning( "glBeginSceneEXT not available." );
}

static void REGAL_CALL loader_glBeginSceneEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBeginSceneEXT, "glBeginSceneEXT");
   if ( !driverTbl.glBeginSceneEXT ) {
      driverTbl.glBeginSceneEXT = missing_glBeginSceneEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBeginSceneEXT == loader_glBeginSceneEXT) {
      rCtx->dsp->emuTbl.glBeginSceneEXT = driverTbl.glBeginSceneEXT;
   }
   driverTbl.glBeginSceneEXT();
}

static void REGAL_CALL missing_glEndSceneEXT(void)
{
   Warning( "glEndSceneEXT not available." );
}

static void REGAL_CALL loader_glEndSceneEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndSceneEXT, "glEndSceneEXT");
   if ( !driverTbl.glEndSceneEXT ) {
      driverTbl.glEndSceneEXT = missing_glEndSceneEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndSceneEXT == loader_glEndSceneEXT) {
      rCtx->dsp->emuTbl.glEndSceneEXT = driverTbl.glEndSceneEXT;
   }
   driverTbl.glEndSceneEXT();
}

// GL_EXT_secondary_color

static void REGAL_CALL missing_glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3bEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3bEXT, "glSecondaryColor3bEXT");
   if ( !driverTbl.glSecondaryColor3bEXT ) {
      driverTbl.glSecondaryColor3bEXT = missing_glSecondaryColor3bEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3bEXT == loader_glSecondaryColor3bEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3bEXT = driverTbl.glSecondaryColor3bEXT;
   }
   driverTbl.glSecondaryColor3bEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3bvEXT(const GLbyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3bvEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3bvEXT(const GLbyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3bvEXT, "glSecondaryColor3bvEXT");
   if ( !driverTbl.glSecondaryColor3bvEXT ) {
      driverTbl.glSecondaryColor3bvEXT = missing_glSecondaryColor3bvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3bvEXT == loader_glSecondaryColor3bvEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3bvEXT = driverTbl.glSecondaryColor3bvEXT;
   }
   driverTbl.glSecondaryColor3bvEXT(v);
}

static void REGAL_CALL missing_glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3dEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3dEXT, "glSecondaryColor3dEXT");
   if ( !driverTbl.glSecondaryColor3dEXT ) {
      driverTbl.glSecondaryColor3dEXT = missing_glSecondaryColor3dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3dEXT == loader_glSecondaryColor3dEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3dEXT = driverTbl.glSecondaryColor3dEXT;
   }
   driverTbl.glSecondaryColor3dEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3dvEXT(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3dvEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3dvEXT(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3dvEXT, "glSecondaryColor3dvEXT");
   if ( !driverTbl.glSecondaryColor3dvEXT ) {
      driverTbl.glSecondaryColor3dvEXT = missing_glSecondaryColor3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3dvEXT == loader_glSecondaryColor3dvEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3dvEXT = driverTbl.glSecondaryColor3dvEXT;
   }
   driverTbl.glSecondaryColor3dvEXT(v);
}

static void REGAL_CALL missing_glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3fEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3fEXT, "glSecondaryColor3fEXT");
   if ( !driverTbl.glSecondaryColor3fEXT ) {
      driverTbl.glSecondaryColor3fEXT = missing_glSecondaryColor3fEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3fEXT == loader_glSecondaryColor3fEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3fEXT = driverTbl.glSecondaryColor3fEXT;
   }
   driverTbl.glSecondaryColor3fEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3fvEXT(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3fvEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3fvEXT(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3fvEXT, "glSecondaryColor3fvEXT");
   if ( !driverTbl.glSecondaryColor3fvEXT ) {
      driverTbl.glSecondaryColor3fvEXT = missing_glSecondaryColor3fvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3fvEXT == loader_glSecondaryColor3fvEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3fvEXT = driverTbl.glSecondaryColor3fvEXT;
   }
   driverTbl.glSecondaryColor3fvEXT(v);
}

static void REGAL_CALL missing_glSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3iEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3iEXT, "glSecondaryColor3iEXT");
   if ( !driverTbl.glSecondaryColor3iEXT ) {
      driverTbl.glSecondaryColor3iEXT = missing_glSecondaryColor3iEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3iEXT == loader_glSecondaryColor3iEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3iEXT = driverTbl.glSecondaryColor3iEXT;
   }
   driverTbl.glSecondaryColor3iEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3ivEXT(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3ivEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3ivEXT(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3ivEXT, "glSecondaryColor3ivEXT");
   if ( !driverTbl.glSecondaryColor3ivEXT ) {
      driverTbl.glSecondaryColor3ivEXT = missing_glSecondaryColor3ivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3ivEXT == loader_glSecondaryColor3ivEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3ivEXT = driverTbl.glSecondaryColor3ivEXT;
   }
   driverTbl.glSecondaryColor3ivEXT(v);
}

static void REGAL_CALL missing_glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3sEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3sEXT, "glSecondaryColor3sEXT");
   if ( !driverTbl.glSecondaryColor3sEXT ) {
      driverTbl.glSecondaryColor3sEXT = missing_glSecondaryColor3sEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3sEXT == loader_glSecondaryColor3sEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3sEXT = driverTbl.glSecondaryColor3sEXT;
   }
   driverTbl.glSecondaryColor3sEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3svEXT(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3svEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3svEXT(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3svEXT, "glSecondaryColor3svEXT");
   if ( !driverTbl.glSecondaryColor3svEXT ) {
      driverTbl.glSecondaryColor3svEXT = missing_glSecondaryColor3svEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3svEXT == loader_glSecondaryColor3svEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3svEXT = driverTbl.glSecondaryColor3svEXT;
   }
   driverTbl.glSecondaryColor3svEXT(v);
}

static void REGAL_CALL missing_glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3ubEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3ubEXT, "glSecondaryColor3ubEXT");
   if ( !driverTbl.glSecondaryColor3ubEXT ) {
      driverTbl.glSecondaryColor3ubEXT = missing_glSecondaryColor3ubEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3ubEXT == loader_glSecondaryColor3ubEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3ubEXT = driverTbl.glSecondaryColor3ubEXT;
   }
   driverTbl.glSecondaryColor3ubEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3ubvEXT(const GLubyte *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3ubvEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3ubvEXT(const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3ubvEXT, "glSecondaryColor3ubvEXT");
   if ( !driverTbl.glSecondaryColor3ubvEXT ) {
      driverTbl.glSecondaryColor3ubvEXT = missing_glSecondaryColor3ubvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3ubvEXT == loader_glSecondaryColor3ubvEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3ubvEXT = driverTbl.glSecondaryColor3ubvEXT;
   }
   driverTbl.glSecondaryColor3ubvEXT(v);
}

static void REGAL_CALL missing_glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3uiEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3uiEXT, "glSecondaryColor3uiEXT");
   if ( !driverTbl.glSecondaryColor3uiEXT ) {
      driverTbl.glSecondaryColor3uiEXT = missing_glSecondaryColor3uiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3uiEXT == loader_glSecondaryColor3uiEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3uiEXT = driverTbl.glSecondaryColor3uiEXT;
   }
   driverTbl.glSecondaryColor3uiEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3uivEXT(const GLuint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3uivEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3uivEXT(const GLuint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3uivEXT, "glSecondaryColor3uivEXT");
   if ( !driverTbl.glSecondaryColor3uivEXT ) {
      driverTbl.glSecondaryColor3uivEXT = missing_glSecondaryColor3uivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3uivEXT == loader_glSecondaryColor3uivEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3uivEXT = driverTbl.glSecondaryColor3uivEXT;
   }
   driverTbl.glSecondaryColor3uivEXT(v);
}

static void REGAL_CALL missing_glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3usEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3usEXT, "glSecondaryColor3usEXT");
   if ( !driverTbl.glSecondaryColor3usEXT ) {
      driverTbl.glSecondaryColor3usEXT = missing_glSecondaryColor3usEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3usEXT == loader_glSecondaryColor3usEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3usEXT = driverTbl.glSecondaryColor3usEXT;
   }
   driverTbl.glSecondaryColor3usEXT(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3usvEXT(const GLushort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3usvEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColor3usvEXT(const GLushort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3usvEXT, "glSecondaryColor3usvEXT");
   if ( !driverTbl.glSecondaryColor3usvEXT ) {
      driverTbl.glSecondaryColor3usvEXT = missing_glSecondaryColor3usvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3usvEXT == loader_glSecondaryColor3usvEXT) {
      rCtx->dsp->emuTbl.glSecondaryColor3usvEXT = driverTbl.glSecondaryColor3usvEXT;
   }
   driverTbl.glSecondaryColor3usvEXT(v);
}

static void REGAL_CALL missing_glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glSecondaryColorPointerEXT not available." );
}

static void REGAL_CALL loader_glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColorPointerEXT, "glSecondaryColorPointerEXT");
   if ( !driverTbl.glSecondaryColorPointerEXT ) {
      driverTbl.glSecondaryColorPointerEXT = missing_glSecondaryColorPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColorPointerEXT == loader_glSecondaryColorPointerEXT) {
      rCtx->dsp->emuTbl.glSecondaryColorPointerEXT = driverTbl.glSecondaryColorPointerEXT;
   }
   driverTbl.glSecondaryColorPointerEXT(size, type, stride, pointer);
}

// GL_EXT_separate_shader_objects

static void REGAL_CALL missing_glActiveProgramEXT(GLuint program)
{
   UNUSED_PARAMETER(program);
   Warning( "glActiveProgramEXT not available." );
}

static void REGAL_CALL loader_glActiveProgramEXT(GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glActiveProgramEXT, "glActiveProgramEXT");
   if ( !driverTbl.glActiveProgramEXT ) {
      driverTbl.glActiveProgramEXT = missing_glActiveProgramEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glActiveProgramEXT == loader_glActiveProgramEXT) {
      rCtx->dsp->emuTbl.glActiveProgramEXT = driverTbl.glActiveProgramEXT;
   }
   driverTbl.glActiveProgramEXT(program);
}

static GLuint REGAL_CALL missing_glCreateShaderProgramEXT(GLenum type, const GLchar *string)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(string);
   Warning( "glCreateShaderProgramEXT not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glCreateShaderProgramEXT(GLenum type, const GLchar *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCreateShaderProgramEXT, "glCreateShaderProgramEXT");
   if ( !driverTbl.glCreateShaderProgramEXT ) {
      driverTbl.glCreateShaderProgramEXT = missing_glCreateShaderProgramEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCreateShaderProgramEXT == loader_glCreateShaderProgramEXT) {
      rCtx->dsp->emuTbl.glCreateShaderProgramEXT = driverTbl.glCreateShaderProgramEXT;
   }
   return driverTbl.glCreateShaderProgramEXT(type, string);
}

static void REGAL_CALL missing_glUseShaderProgramEXT(GLenum type, GLuint program)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(program);
   Warning( "glUseShaderProgramEXT not available." );
}

static void REGAL_CALL loader_glUseShaderProgramEXT(GLenum type, GLuint program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUseShaderProgramEXT, "glUseShaderProgramEXT");
   if ( !driverTbl.glUseShaderProgramEXT ) {
      driverTbl.glUseShaderProgramEXT = missing_glUseShaderProgramEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUseShaderProgramEXT == loader_glUseShaderProgramEXT) {
      rCtx->dsp->emuTbl.glUseShaderProgramEXT = driverTbl.glUseShaderProgramEXT;
   }
   driverTbl.glUseShaderProgramEXT(type, program);
}

// GL_EXT_shader_image_load_store

static void REGAL_CALL missing_glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layered);
   UNUSED_PARAMETER(layer);
   UNUSED_PARAMETER(access);
   UNUSED_PARAMETER(format);
   Warning( "glBindImageTextureEXT not available." );
}

static void REGAL_CALL loader_glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindImageTextureEXT, "glBindImageTextureEXT");
   if ( !driverTbl.glBindImageTextureEXT ) {
      driverTbl.glBindImageTextureEXT = missing_glBindImageTextureEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindImageTextureEXT == loader_glBindImageTextureEXT) {
      rCtx->dsp->emuTbl.glBindImageTextureEXT = driverTbl.glBindImageTextureEXT;
   }
   driverTbl.glBindImageTextureEXT(index, texture, level, layered, layer, access, format);
}

static void REGAL_CALL missing_glMemoryBarrierEXT(GLbitfield barriers)
{
   UNUSED_PARAMETER(barriers);
   Warning( "glMemoryBarrierEXT not available." );
}

static void REGAL_CALL loader_glMemoryBarrierEXT(GLbitfield barriers)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMemoryBarrierEXT, "glMemoryBarrierEXT");
   if ( !driverTbl.glMemoryBarrierEXT ) {
      driverTbl.glMemoryBarrierEXT = missing_glMemoryBarrierEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMemoryBarrierEXT == loader_glMemoryBarrierEXT) {
      rCtx->dsp->emuTbl.glMemoryBarrierEXT = driverTbl.glMemoryBarrierEXT;
   }
   driverTbl.glMemoryBarrierEXT(barriers);
}

// GL_EXT_stencil_clear_tag

static void REGAL_CALL missing_glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag)
{
   UNUSED_PARAMETER(stencilTagBits);
   UNUSED_PARAMETER(stencilClearTag);
   Warning( "glStencilClearTagEXT not available." );
}

static void REGAL_CALL loader_glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStencilClearTagEXT, "glStencilClearTagEXT");
   if ( !driverTbl.glStencilClearTagEXT ) {
      driverTbl.glStencilClearTagEXT = missing_glStencilClearTagEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStencilClearTagEXT == loader_glStencilClearTagEXT) {
      rCtx->dsp->emuTbl.glStencilClearTagEXT = driverTbl.glStencilClearTagEXT;
   }
   driverTbl.glStencilClearTagEXT(stencilTagBits, stencilClearTag);
}

// GL_EXT_stencil_two_side

static void REGAL_CALL missing_glActiveStencilFaceEXT(GLenum face)
{
   UNUSED_PARAMETER(face);
   Warning( "glActiveStencilFaceEXT not available." );
}

static void REGAL_CALL loader_glActiveStencilFaceEXT(GLenum face)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glActiveStencilFaceEXT, "glActiveStencilFaceEXT");
   if ( !driverTbl.glActiveStencilFaceEXT ) {
      driverTbl.glActiveStencilFaceEXT = missing_glActiveStencilFaceEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glActiveStencilFaceEXT == loader_glActiveStencilFaceEXT) {
      rCtx->dsp->emuTbl.glActiveStencilFaceEXT = driverTbl.glActiveStencilFaceEXT;
   }
   driverTbl.glActiveStencilFaceEXT(face);
}

// GL_EXT_subtexture

static void REGAL_CALL missing_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTexSubImage1DEXT not available." );
}

static void REGAL_CALL loader_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexSubImage1DEXT, "glTexSubImage1DEXT");
   if ( !driverTbl.glTexSubImage1DEXT ) {
      driverTbl.glTexSubImage1DEXT = missing_glTexSubImage1DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexSubImage1DEXT == loader_glTexSubImage1DEXT) {
      rCtx->dsp->emuTbl.glTexSubImage1DEXT = driverTbl.glTexSubImage1DEXT;
   }
   driverTbl.glTexSubImage1DEXT(target, level, xoffset, width, format, type, pixels);
}

static void REGAL_CALL missing_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTexSubImage2DEXT not available." );
}

static void REGAL_CALL loader_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexSubImage2DEXT, "glTexSubImage2DEXT");
   if ( !driverTbl.glTexSubImage2DEXT ) {
      driverTbl.glTexSubImage2DEXT = missing_glTexSubImage2DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexSubImage2DEXT == loader_glTexSubImage2DEXT) {
      rCtx->dsp->emuTbl.glTexSubImage2DEXT = driverTbl.glTexSubImage2DEXT;
   }
   driverTbl.glTexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

static void REGAL_CALL missing_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTexSubImage3DEXT not available." );
}

static void REGAL_CALL loader_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexSubImage3DEXT, "glTexSubImage3DEXT");
   if ( !driverTbl.glTexSubImage3DEXT ) {
      driverTbl.glTexSubImage3DEXT = missing_glTexSubImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexSubImage3DEXT == loader_glTexSubImage3DEXT) {
      rCtx->dsp->emuTbl.glTexSubImage3DEXT = driverTbl.glTexSubImage3DEXT;
   }
   driverTbl.glTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

// GL_EXT_texture3D

static void REGAL_CALL missing_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTexImage3DEXT not available." );
}

static void REGAL_CALL loader_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexImage3DEXT, "glTexImage3DEXT");
   if ( !driverTbl.glTexImage3DEXT ) {
      driverTbl.glTexImage3DEXT = missing_glTexImage3DEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexImage3DEXT == loader_glTexImage3DEXT) {
      rCtx->dsp->emuTbl.glTexImage3DEXT = driverTbl.glTexImage3DEXT;
   }
   driverTbl.glTexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

// GL_EXT_texture_array

static void REGAL_CALL missing_glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(attachment);
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layer);
   Warning( "glFramebufferTextureLayerEXT not available." );
}

static void REGAL_CALL loader_glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFramebufferTextureLayerEXT, "glFramebufferTextureLayerEXT");
   if ( !driverTbl.glFramebufferTextureLayerEXT ) {
      driverTbl.glFramebufferTextureLayerEXT = missing_glFramebufferTextureLayerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFramebufferTextureLayerEXT == loader_glFramebufferTextureLayerEXT) {
      rCtx->dsp->emuTbl.glFramebufferTextureLayerEXT = driverTbl.glFramebufferTextureLayerEXT;
   }
   driverTbl.glFramebufferTextureLayerEXT(target, attachment, texture, level, layer);
}

// GL_EXT_texture_buffer_object

static void REGAL_CALL missing_glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(buffer);
   Warning( "glTexBufferEXT not available." );
}

static void REGAL_CALL loader_glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexBufferEXT, "glTexBufferEXT");
   if ( !driverTbl.glTexBufferEXT ) {
      driverTbl.glTexBufferEXT = missing_glTexBufferEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexBufferEXT == loader_glTexBufferEXT) {
      rCtx->dsp->emuTbl.glTexBufferEXT = driverTbl.glTexBufferEXT;
   }
   driverTbl.glTexBufferEXT(target, internalformat, buffer);
}

// GL_EXT_texture_integer

static void REGAL_CALL missing_glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glClearColorIiEXT not available." );
}

static void REGAL_CALL loader_glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearColorIiEXT, "glClearColorIiEXT");
   if ( !driverTbl.glClearColorIiEXT ) {
      driverTbl.glClearColorIiEXT = missing_glClearColorIiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearColorIiEXT == loader_glClearColorIiEXT) {
      rCtx->dsp->emuTbl.glClearColorIiEXT = driverTbl.glClearColorIiEXT;
   }
   driverTbl.glClearColorIiEXT(red, green, blue, alpha);
}

static void REGAL_CALL missing_glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glClearColorIuiEXT not available." );
}

static void REGAL_CALL loader_glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearColorIuiEXT, "glClearColorIuiEXT");
   if ( !driverTbl.glClearColorIuiEXT ) {
      driverTbl.glClearColorIuiEXT = missing_glClearColorIuiEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearColorIuiEXT == loader_glClearColorIuiEXT) {
      rCtx->dsp->emuTbl.glClearColorIuiEXT = driverTbl.glClearColorIuiEXT;
   }
   driverTbl.glClearColorIuiEXT(red, green, blue, alpha);
}

static void REGAL_CALL missing_glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTexParameterIivEXT not available." );
}

static void REGAL_CALL loader_glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexParameterIivEXT, "glGetTexParameterIivEXT");
   if ( !driverTbl.glGetTexParameterIivEXT ) {
      driverTbl.glGetTexParameterIivEXT = missing_glGetTexParameterIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexParameterIivEXT == loader_glGetTexParameterIivEXT) {
      rCtx->dsp->emuTbl.glGetTexParameterIivEXT = driverTbl.glGetTexParameterIivEXT;
   }
   driverTbl.glGetTexParameterIivEXT(target, pname, params);
}

static void REGAL_CALL missing_glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTexParameterIuivEXT not available." );
}

static void REGAL_CALL loader_glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexParameterIuivEXT, "glGetTexParameterIuivEXT");
   if ( !driverTbl.glGetTexParameterIuivEXT ) {
      driverTbl.glGetTexParameterIuivEXT = missing_glGetTexParameterIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexParameterIuivEXT == loader_glGetTexParameterIuivEXT) {
      rCtx->dsp->emuTbl.glGetTexParameterIuivEXT = driverTbl.glGetTexParameterIuivEXT;
   }
   driverTbl.glGetTexParameterIuivEXT(target, pname, params);
}

static void REGAL_CALL missing_glTexParameterIivEXT(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glTexParameterIivEXT not available." );
}

static void REGAL_CALL loader_glTexParameterIivEXT(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexParameterIivEXT, "glTexParameterIivEXT");
   if ( !driverTbl.glTexParameterIivEXT ) {
      driverTbl.glTexParameterIivEXT = missing_glTexParameterIivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexParameterIivEXT == loader_glTexParameterIivEXT) {
      rCtx->dsp->emuTbl.glTexParameterIivEXT = driverTbl.glTexParameterIivEXT;
   }
   driverTbl.glTexParameterIivEXT(target, pname, params);
}

static void REGAL_CALL missing_glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glTexParameterIuivEXT not available." );
}

static void REGAL_CALL loader_glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexParameterIuivEXT, "glTexParameterIuivEXT");
   if ( !driverTbl.glTexParameterIuivEXT ) {
      driverTbl.glTexParameterIuivEXT = missing_glTexParameterIuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexParameterIuivEXT == loader_glTexParameterIuivEXT) {
      rCtx->dsp->emuTbl.glTexParameterIuivEXT = driverTbl.glTexParameterIuivEXT;
   }
   driverTbl.glTexParameterIuivEXT(target, pname, params);
}

// GL_EXT_texture_object

static GLboolean REGAL_CALL missing_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   UNUSED_PARAMETER(residences);
   Warning( "glAreTexturesResidentEXT not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glAreTexturesResidentEXT, "glAreTexturesResidentEXT");
   if ( !driverTbl.glAreTexturesResidentEXT ) {
      driverTbl.glAreTexturesResidentEXT = missing_glAreTexturesResidentEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glAreTexturesResidentEXT == loader_glAreTexturesResidentEXT) {
      rCtx->dsp->emuTbl.glAreTexturesResidentEXT = driverTbl.glAreTexturesResidentEXT;
   }
   return driverTbl.glAreTexturesResidentEXT(n, textures, residences);
}

static void REGAL_CALL missing_glBindTextureEXT(GLenum target, GLuint texture)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(texture);
   Warning( "glBindTextureEXT not available." );
}

static void REGAL_CALL loader_glBindTextureEXT(GLenum target, GLuint texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindTextureEXT, "glBindTextureEXT");
   if ( !driverTbl.glBindTextureEXT ) {
      driverTbl.glBindTextureEXT = missing_glBindTextureEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindTextureEXT == loader_glBindTextureEXT) {
      rCtx->dsp->emuTbl.glBindTextureEXT = driverTbl.glBindTextureEXT;
   }
   driverTbl.glBindTextureEXT(target, texture);
}

static void REGAL_CALL missing_glDeleteTexturesEXT(GLsizei n, const GLuint *textures)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   Warning( "glDeleteTexturesEXT not available." );
}

static void REGAL_CALL loader_glDeleteTexturesEXT(GLsizei n, const GLuint *textures)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteTexturesEXT, "glDeleteTexturesEXT");
   if ( !driverTbl.glDeleteTexturesEXT ) {
      driverTbl.glDeleteTexturesEXT = missing_glDeleteTexturesEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteTexturesEXT == loader_glDeleteTexturesEXT) {
      rCtx->dsp->emuTbl.glDeleteTexturesEXT = driverTbl.glDeleteTexturesEXT;
   }
   driverTbl.glDeleteTexturesEXT(n, textures);
}

static void REGAL_CALL missing_glGenTexturesEXT(GLsizei n, GLuint *textures)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   Warning( "glGenTexturesEXT not available." );
}

static void REGAL_CALL loader_glGenTexturesEXT(GLsizei n, GLuint *textures)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenTexturesEXT, "glGenTexturesEXT");
   if ( !driverTbl.glGenTexturesEXT ) {
      driverTbl.glGenTexturesEXT = missing_glGenTexturesEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenTexturesEXT == loader_glGenTexturesEXT) {
      rCtx->dsp->emuTbl.glGenTexturesEXT = driverTbl.glGenTexturesEXT;
   }
   driverTbl.glGenTexturesEXT(n, textures);
}

static GLboolean REGAL_CALL missing_glIsTextureEXT(GLuint texture)
{
   UNUSED_PARAMETER(texture);
   Warning( "glIsTextureEXT not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsTextureEXT(GLuint texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsTextureEXT, "glIsTextureEXT");
   if ( !driverTbl.glIsTextureEXT ) {
      driverTbl.glIsTextureEXT = missing_glIsTextureEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsTextureEXT == loader_glIsTextureEXT) {
      rCtx->dsp->emuTbl.glIsTextureEXT = driverTbl.glIsTextureEXT;
   }
   return driverTbl.glIsTextureEXT(texture);
}

static void REGAL_CALL missing_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(textures);
   UNUSED_PARAMETER(priorities);
   Warning( "glPrioritizeTexturesEXT not available." );
}

static void REGAL_CALL loader_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPrioritizeTexturesEXT, "glPrioritizeTexturesEXT");
   if ( !driverTbl.glPrioritizeTexturesEXT ) {
      driverTbl.glPrioritizeTexturesEXT = missing_glPrioritizeTexturesEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPrioritizeTexturesEXT == loader_glPrioritizeTexturesEXT) {
      rCtx->dsp->emuTbl.glPrioritizeTexturesEXT = driverTbl.glPrioritizeTexturesEXT;
   }
   driverTbl.glPrioritizeTexturesEXT(n, textures, priorities);
}

// GL_EXT_texture_perturb_normal

static void REGAL_CALL missing_glTextureNormalEXT(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glTextureNormalEXT not available." );
}

static void REGAL_CALL loader_glTextureNormalEXT(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureNormalEXT, "glTextureNormalEXT");
   if ( !driverTbl.glTextureNormalEXT ) {
      driverTbl.glTextureNormalEXT = missing_glTextureNormalEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureNormalEXT == loader_glTextureNormalEXT) {
      rCtx->dsp->emuTbl.glTextureNormalEXT = driverTbl.glTextureNormalEXT;
   }
   driverTbl.glTextureNormalEXT(mode);
}

// GL_EXT_timer_query

static void REGAL_CALL missing_glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetQueryObjecti64vEXT not available." );
}

static void REGAL_CALL loader_glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetQueryObjecti64vEXT, "glGetQueryObjecti64vEXT");
   if ( !driverTbl.glGetQueryObjecti64vEXT ) {
      driverTbl.glGetQueryObjecti64vEXT = missing_glGetQueryObjecti64vEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetQueryObjecti64vEXT == loader_glGetQueryObjecti64vEXT) {
      rCtx->dsp->emuTbl.glGetQueryObjecti64vEXT = driverTbl.glGetQueryObjecti64vEXT;
   }
   driverTbl.glGetQueryObjecti64vEXT(id, pname, params);
}

static void REGAL_CALL missing_glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetQueryObjectui64vEXT not available." );
}

static void REGAL_CALL loader_glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetQueryObjectui64vEXT, "glGetQueryObjectui64vEXT");
   if ( !driverTbl.glGetQueryObjectui64vEXT ) {
      driverTbl.glGetQueryObjectui64vEXT = missing_glGetQueryObjectui64vEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetQueryObjectui64vEXT == loader_glGetQueryObjectui64vEXT) {
      rCtx->dsp->emuTbl.glGetQueryObjectui64vEXT = driverTbl.glGetQueryObjectui64vEXT;
   }
   driverTbl.glGetQueryObjectui64vEXT(id, pname, params);
}

// GL_EXT_transform_feedback

static void REGAL_CALL missing_glBeginTransformFeedbackEXT(GLenum primitiveMode)
{
   UNUSED_PARAMETER(primitiveMode);
   Warning( "glBeginTransformFeedbackEXT not available." );
}

static void REGAL_CALL loader_glBeginTransformFeedbackEXT(GLenum primitiveMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBeginTransformFeedbackEXT, "glBeginTransformFeedbackEXT");
   if ( !driverTbl.glBeginTransformFeedbackEXT ) {
      driverTbl.glBeginTransformFeedbackEXT = missing_glBeginTransformFeedbackEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBeginTransformFeedbackEXT == loader_glBeginTransformFeedbackEXT) {
      rCtx->dsp->emuTbl.glBeginTransformFeedbackEXT = driverTbl.glBeginTransformFeedbackEXT;
   }
   driverTbl.glBeginTransformFeedbackEXT(primitiveMode);
}

static void REGAL_CALL missing_glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   Warning( "glBindBufferBaseEXT not available." );
}

static void REGAL_CALL loader_glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindBufferBaseEXT, "glBindBufferBaseEXT");
   if ( !driverTbl.glBindBufferBaseEXT ) {
      driverTbl.glBindBufferBaseEXT = missing_glBindBufferBaseEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindBufferBaseEXT == loader_glBindBufferBaseEXT) {
      rCtx->dsp->emuTbl.glBindBufferBaseEXT = driverTbl.glBindBufferBaseEXT;
   }
   driverTbl.glBindBufferBaseEXT(target, index, buffer);
}

static void REGAL_CALL missing_glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   Warning( "glBindBufferOffsetEXT not available." );
}

static void REGAL_CALL loader_glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindBufferOffsetEXT, "glBindBufferOffsetEXT");
   if ( !driverTbl.glBindBufferOffsetEXT ) {
      driverTbl.glBindBufferOffsetEXT = missing_glBindBufferOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindBufferOffsetEXT == loader_glBindBufferOffsetEXT) {
      rCtx->dsp->emuTbl.glBindBufferOffsetEXT = driverTbl.glBindBufferOffsetEXT;
   }
   driverTbl.glBindBufferOffsetEXT(target, index, buffer, offset);
}

static void REGAL_CALL missing_glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   Warning( "glBindBufferRangeEXT not available." );
}

static void REGAL_CALL loader_glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindBufferRangeEXT, "glBindBufferRangeEXT");
   if ( !driverTbl.glBindBufferRangeEXT ) {
      driverTbl.glBindBufferRangeEXT = missing_glBindBufferRangeEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindBufferRangeEXT == loader_glBindBufferRangeEXT) {
      rCtx->dsp->emuTbl.glBindBufferRangeEXT = driverTbl.glBindBufferRangeEXT;
   }
   driverTbl.glBindBufferRangeEXT(target, index, buffer, offset, size);
}

static void REGAL_CALL missing_glEndTransformFeedbackEXT(void)
{
   Warning( "glEndTransformFeedbackEXT not available." );
}

static void REGAL_CALL loader_glEndTransformFeedbackEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndTransformFeedbackEXT, "glEndTransformFeedbackEXT");
   if ( !driverTbl.glEndTransformFeedbackEXT ) {
      driverTbl.glEndTransformFeedbackEXT = missing_glEndTransformFeedbackEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndTransformFeedbackEXT == loader_glEndTransformFeedbackEXT) {
      rCtx->dsp->emuTbl.glEndTransformFeedbackEXT = driverTbl.glEndTransformFeedbackEXT;
   }
   driverTbl.glEndTransformFeedbackEXT();
}

static void REGAL_CALL missing_glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(name);
   Warning( "glGetTransformFeedbackVaryingEXT not available." );
}

static void REGAL_CALL loader_glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTransformFeedbackVaryingEXT, "glGetTransformFeedbackVaryingEXT");
   if ( !driverTbl.glGetTransformFeedbackVaryingEXT ) {
      driverTbl.glGetTransformFeedbackVaryingEXT = missing_glGetTransformFeedbackVaryingEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTransformFeedbackVaryingEXT == loader_glGetTransformFeedbackVaryingEXT) {
      rCtx->dsp->emuTbl.glGetTransformFeedbackVaryingEXT = driverTbl.glGetTransformFeedbackVaryingEXT;
   }
   driverTbl.glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL missing_glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar **varyings, GLenum bufferMode)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(varyings);
   UNUSED_PARAMETER(bufferMode);
   Warning( "glTransformFeedbackVaryingsEXT not available." );
}

static void REGAL_CALL loader_glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar **varyings, GLenum bufferMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTransformFeedbackVaryingsEXT, "glTransformFeedbackVaryingsEXT");
   if ( !driverTbl.glTransformFeedbackVaryingsEXT ) {
      driverTbl.glTransformFeedbackVaryingsEXT = missing_glTransformFeedbackVaryingsEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTransformFeedbackVaryingsEXT == loader_glTransformFeedbackVaryingsEXT) {
      rCtx->dsp->emuTbl.glTransformFeedbackVaryingsEXT = driverTbl.glTransformFeedbackVaryingsEXT;
   }
   driverTbl.glTransformFeedbackVaryingsEXT(program, count, varyings, bufferMode);
}

// GL_EXT_vertex_array

static void REGAL_CALL missing_glArrayElementEXT(GLint i)
{
   UNUSED_PARAMETER(i);
   Warning( "glArrayElementEXT not available." );
}

static void REGAL_CALL loader_glArrayElementEXT(GLint i)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glArrayElementEXT, "glArrayElementEXT");
   if ( !driverTbl.glArrayElementEXT ) {
      driverTbl.glArrayElementEXT = missing_glArrayElementEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glArrayElementEXT == loader_glArrayElementEXT) {
      rCtx->dsp->emuTbl.glArrayElementEXT = driverTbl.glArrayElementEXT;
   }
   driverTbl.glArrayElementEXT(i);
}

static void REGAL_CALL missing_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(pointer);
   Warning( "glColorPointerEXT not available." );
}

static void REGAL_CALL loader_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorPointerEXT, "glColorPointerEXT");
   if ( !driverTbl.glColorPointerEXT ) {
      driverTbl.glColorPointerEXT = missing_glColorPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorPointerEXT == loader_glColorPointerEXT) {
      rCtx->dsp->emuTbl.glColorPointerEXT = driverTbl.glColorPointerEXT;
   }
   driverTbl.glColorPointerEXT(size, type, stride, count, pointer);
}

static void REGAL_CALL missing_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   Warning( "glDrawArraysEXT not available." );
}

static void REGAL_CALL loader_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawArraysEXT, "glDrawArraysEXT");
   if ( !driverTbl.glDrawArraysEXT ) {
      driverTbl.glDrawArraysEXT = missing_glDrawArraysEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawArraysEXT == loader_glDrawArraysEXT) {
      rCtx->dsp->emuTbl.glDrawArraysEXT = driverTbl.glDrawArraysEXT;
   }
   driverTbl.glDrawArraysEXT(mode, first, count);
}

static void REGAL_CALL missing_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer)
{
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(pointer);
   Warning( "glEdgeFlagPointerEXT not available." );
}

static void REGAL_CALL loader_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEdgeFlagPointerEXT, "glEdgeFlagPointerEXT");
   if ( !driverTbl.glEdgeFlagPointerEXT ) {
      driverTbl.glEdgeFlagPointerEXT = missing_glEdgeFlagPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEdgeFlagPointerEXT == loader_glEdgeFlagPointerEXT) {
      rCtx->dsp->emuTbl.glEdgeFlagPointerEXT = driverTbl.glEdgeFlagPointerEXT;
   }
   driverTbl.glEdgeFlagPointerEXT(stride, count, pointer);
}

static void REGAL_CALL missing_glGetPointervEXT(GLenum pname, GLvoid **params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetPointervEXT not available." );
}

static void REGAL_CALL loader_glGetPointervEXT(GLenum pname, GLvoid **params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPointervEXT, "glGetPointervEXT");
   if ( !driverTbl.glGetPointervEXT ) {
      driverTbl.glGetPointervEXT = missing_glGetPointervEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPointervEXT == loader_glGetPointervEXT) {
      rCtx->dsp->emuTbl.glGetPointervEXT = driverTbl.glGetPointervEXT;
   }
   driverTbl.glGetPointervEXT(pname, params);
}

static void REGAL_CALL missing_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(pointer);
   Warning( "glIndexPointerEXT not available." );
}

static void REGAL_CALL loader_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexPointerEXT, "glIndexPointerEXT");
   if ( !driverTbl.glIndexPointerEXT ) {
      driverTbl.glIndexPointerEXT = missing_glIndexPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexPointerEXT == loader_glIndexPointerEXT) {
      rCtx->dsp->emuTbl.glIndexPointerEXT = driverTbl.glIndexPointerEXT;
   }
   driverTbl.glIndexPointerEXT(type, stride, count, pointer);
}

static void REGAL_CALL missing_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(pointer);
   Warning( "glNormalPointerEXT not available." );
}

static void REGAL_CALL loader_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalPointerEXT, "glNormalPointerEXT");
   if ( !driverTbl.glNormalPointerEXT ) {
      driverTbl.glNormalPointerEXT = missing_glNormalPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalPointerEXT == loader_glNormalPointerEXT) {
      rCtx->dsp->emuTbl.glNormalPointerEXT = driverTbl.glNormalPointerEXT;
   }
   driverTbl.glNormalPointerEXT(type, stride, count, pointer);
}

static void REGAL_CALL missing_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(pointer);
   Warning( "glTexCoordPointerEXT not available." );
}

static void REGAL_CALL loader_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoordPointerEXT, "glTexCoordPointerEXT");
   if ( !driverTbl.glTexCoordPointerEXT ) {
      driverTbl.glTexCoordPointerEXT = missing_glTexCoordPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoordPointerEXT == loader_glTexCoordPointerEXT) {
      rCtx->dsp->emuTbl.glTexCoordPointerEXT = driverTbl.glTexCoordPointerEXT;
   }
   driverTbl.glTexCoordPointerEXT(size, type, stride, count, pointer);
}

static void REGAL_CALL missing_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(pointer);
   Warning( "glVertexPointerEXT not available." );
}

static void REGAL_CALL loader_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexPointerEXT, "glVertexPointerEXT");
   if ( !driverTbl.glVertexPointerEXT ) {
      driverTbl.glVertexPointerEXT = missing_glVertexPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexPointerEXT == loader_glVertexPointerEXT) {
      rCtx->dsp->emuTbl.glVertexPointerEXT = driverTbl.glVertexPointerEXT;
   }
   driverTbl.glVertexPointerEXT(size, type, stride, count, pointer);
}

// GL_EXT_vertex_attrib_64bit

static void REGAL_CALL missing_glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribLdvEXT not available." );
}

static void REGAL_CALL loader_glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribLdvEXT, "glGetVertexAttribLdvEXT");
   if ( !driverTbl.glGetVertexAttribLdvEXT ) {
      driverTbl.glGetVertexAttribLdvEXT = missing_glGetVertexAttribLdvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribLdvEXT == loader_glGetVertexAttribLdvEXT) {
      rCtx->dsp->emuTbl.glGetVertexAttribLdvEXT = driverTbl.glGetVertexAttribLdvEXT;
   }
   driverTbl.glGetVertexAttribLdvEXT(index, pname, params);
}

static void REGAL_CALL missing_glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset)
{
   UNUSED_PARAMETER(vaobj);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(offset);
   Warning( "glVertexArrayVertexAttribLOffsetEXT not available." );
}

static void REGAL_CALL loader_glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArrayVertexAttribLOffsetEXT, "glVertexArrayVertexAttribLOffsetEXT");
   if ( !driverTbl.glVertexArrayVertexAttribLOffsetEXT ) {
      driverTbl.glVertexArrayVertexAttribLOffsetEXT = missing_glVertexArrayVertexAttribLOffsetEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArrayVertexAttribLOffsetEXT == loader_glVertexArrayVertexAttribLOffsetEXT) {
      rCtx->dsp->emuTbl.glVertexArrayVertexAttribLOffsetEXT = driverTbl.glVertexArrayVertexAttribLOffsetEXT;
   }
   driverTbl.glVertexArrayVertexAttribLOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
}

static void REGAL_CALL missing_glVertexAttribL1dEXT(GLuint index, GLdouble x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttribL1dEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribL1dEXT(GLuint index, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL1dEXT, "glVertexAttribL1dEXT");
   if ( !driverTbl.glVertexAttribL1dEXT ) {
      driverTbl.glVertexAttribL1dEXT = missing_glVertexAttribL1dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL1dEXT == loader_glVertexAttribL1dEXT) {
      rCtx->dsp->emuTbl.glVertexAttribL1dEXT = driverTbl.glVertexAttribL1dEXT;
   }
   driverTbl.glVertexAttribL1dEXT(index, x);
}

static void REGAL_CALL missing_glVertexAttribL1dvEXT(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL1dvEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribL1dvEXT(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL1dvEXT, "glVertexAttribL1dvEXT");
   if ( !driverTbl.glVertexAttribL1dvEXT ) {
      driverTbl.glVertexAttribL1dvEXT = missing_glVertexAttribL1dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL1dvEXT == loader_glVertexAttribL1dvEXT) {
      rCtx->dsp->emuTbl.glVertexAttribL1dvEXT = driverTbl.glVertexAttribL1dvEXT;
   }
   driverTbl.glVertexAttribL1dvEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttribL2dEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL2dEXT, "glVertexAttribL2dEXT");
   if ( !driverTbl.glVertexAttribL2dEXT ) {
      driverTbl.glVertexAttribL2dEXT = missing_glVertexAttribL2dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL2dEXT == loader_glVertexAttribL2dEXT) {
      rCtx->dsp->emuTbl.glVertexAttribL2dEXT = driverTbl.glVertexAttribL2dEXT;
   }
   driverTbl.glVertexAttribL2dEXT(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribL2dvEXT(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL2dvEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribL2dvEXT(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL2dvEXT, "glVertexAttribL2dvEXT");
   if ( !driverTbl.glVertexAttribL2dvEXT ) {
      driverTbl.glVertexAttribL2dvEXT = missing_glVertexAttribL2dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL2dvEXT == loader_glVertexAttribL2dvEXT) {
      rCtx->dsp->emuTbl.glVertexAttribL2dvEXT = driverTbl.glVertexAttribL2dvEXT;
   }
   driverTbl.glVertexAttribL2dvEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttribL3dEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL3dEXT, "glVertexAttribL3dEXT");
   if ( !driverTbl.glVertexAttribL3dEXT ) {
      driverTbl.glVertexAttribL3dEXT = missing_glVertexAttribL3dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL3dEXT == loader_glVertexAttribL3dEXT) {
      rCtx->dsp->emuTbl.glVertexAttribL3dEXT = driverTbl.glVertexAttribL3dEXT;
   }
   driverTbl.glVertexAttribL3dEXT(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribL3dvEXT(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL3dvEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribL3dvEXT(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL3dvEXT, "glVertexAttribL3dvEXT");
   if ( !driverTbl.glVertexAttribL3dvEXT ) {
      driverTbl.glVertexAttribL3dvEXT = missing_glVertexAttribL3dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL3dvEXT == loader_glVertexAttribL3dvEXT) {
      rCtx->dsp->emuTbl.glVertexAttribL3dvEXT = driverTbl.glVertexAttribL3dvEXT;
   }
   driverTbl.glVertexAttribL3dvEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttribL4dEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL4dEXT, "glVertexAttribL4dEXT");
   if ( !driverTbl.glVertexAttribL4dEXT ) {
      driverTbl.glVertexAttribL4dEXT = missing_glVertexAttribL4dEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL4dEXT == loader_glVertexAttribL4dEXT) {
      rCtx->dsp->emuTbl.glVertexAttribL4dEXT = driverTbl.glVertexAttribL4dEXT;
   }
   driverTbl.glVertexAttribL4dEXT(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribL4dvEXT(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL4dvEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribL4dvEXT(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL4dvEXT, "glVertexAttribL4dvEXT");
   if ( !driverTbl.glVertexAttribL4dvEXT ) {
      driverTbl.glVertexAttribL4dvEXT = missing_glVertexAttribL4dvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL4dvEXT == loader_glVertexAttribL4dvEXT) {
      rCtx->dsp->emuTbl.glVertexAttribL4dvEXT = driverTbl.glVertexAttribL4dvEXT;
   }
   driverTbl.glVertexAttribL4dvEXT(index, v);
}

static void REGAL_CALL missing_glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glVertexAttribLPointerEXT not available." );
}

static void REGAL_CALL loader_glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribLPointerEXT, "glVertexAttribLPointerEXT");
   if ( !driverTbl.glVertexAttribLPointerEXT ) {
      driverTbl.glVertexAttribLPointerEXT = missing_glVertexAttribLPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribLPointerEXT == loader_glVertexAttribLPointerEXT) {
      rCtx->dsp->emuTbl.glVertexAttribLPointerEXT = driverTbl.glVertexAttribLPointerEXT;
   }
   driverTbl.glVertexAttribLPointerEXT(index, size, type, stride, pointer);
}

// GL_EXT_vertex_shader

static void REGAL_CALL missing_glBeginVertexShaderEXT(void)
{
   Warning( "glBeginVertexShaderEXT not available." );
}

static void REGAL_CALL loader_glBeginVertexShaderEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBeginVertexShaderEXT, "glBeginVertexShaderEXT");
   if ( !driverTbl.glBeginVertexShaderEXT ) {
      driverTbl.glBeginVertexShaderEXT = missing_glBeginVertexShaderEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBeginVertexShaderEXT == loader_glBeginVertexShaderEXT) {
      rCtx->dsp->emuTbl.glBeginVertexShaderEXT = driverTbl.glBeginVertexShaderEXT;
   }
   driverTbl.glBeginVertexShaderEXT();
}

static GLuint REGAL_CALL missing_glBindLightParameterEXT(GLenum light, GLenum value)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(value);
   Warning( "glBindLightParameterEXT not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glBindLightParameterEXT(GLenum light, GLenum value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindLightParameterEXT, "glBindLightParameterEXT");
   if ( !driverTbl.glBindLightParameterEXT ) {
      driverTbl.glBindLightParameterEXT = missing_glBindLightParameterEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindLightParameterEXT == loader_glBindLightParameterEXT) {
      rCtx->dsp->emuTbl.glBindLightParameterEXT = driverTbl.glBindLightParameterEXT;
   }
   return driverTbl.glBindLightParameterEXT(light, value);
}

static GLuint REGAL_CALL missing_glBindMaterialParameterEXT(GLenum face, GLenum value)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(value);
   Warning( "glBindMaterialParameterEXT not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glBindMaterialParameterEXT(GLenum face, GLenum value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindMaterialParameterEXT, "glBindMaterialParameterEXT");
   if ( !driverTbl.glBindMaterialParameterEXT ) {
      driverTbl.glBindMaterialParameterEXT = missing_glBindMaterialParameterEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindMaterialParameterEXT == loader_glBindMaterialParameterEXT) {
      rCtx->dsp->emuTbl.glBindMaterialParameterEXT = driverTbl.glBindMaterialParameterEXT;
   }
   return driverTbl.glBindMaterialParameterEXT(face, value);
}

static GLuint REGAL_CALL missing_glBindParameterEXT(GLenum value)
{
   UNUSED_PARAMETER(value);
   Warning( "glBindParameterEXT not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glBindParameterEXT(GLenum value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindParameterEXT, "glBindParameterEXT");
   if ( !driverTbl.glBindParameterEXT ) {
      driverTbl.glBindParameterEXT = missing_glBindParameterEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindParameterEXT == loader_glBindParameterEXT) {
      rCtx->dsp->emuTbl.glBindParameterEXT = driverTbl.glBindParameterEXT;
   }
   return driverTbl.glBindParameterEXT(value);
}

static GLuint REGAL_CALL missing_glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value)
{
   UNUSED_PARAMETER(unit);
   UNUSED_PARAMETER(coord);
   UNUSED_PARAMETER(value);
   Warning( "glBindTexGenParameterEXT not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindTexGenParameterEXT, "glBindTexGenParameterEXT");
   if ( !driverTbl.glBindTexGenParameterEXT ) {
      driverTbl.glBindTexGenParameterEXT = missing_glBindTexGenParameterEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindTexGenParameterEXT == loader_glBindTexGenParameterEXT) {
      rCtx->dsp->emuTbl.glBindTexGenParameterEXT = driverTbl.glBindTexGenParameterEXT;
   }
   return driverTbl.glBindTexGenParameterEXT(unit, coord, value);
}

static GLuint REGAL_CALL missing_glBindTextureUnitParameterEXT(GLenum unit, GLenum value)
{
   UNUSED_PARAMETER(unit);
   UNUSED_PARAMETER(value);
   Warning( "glBindTextureUnitParameterEXT not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glBindTextureUnitParameterEXT(GLenum unit, GLenum value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindTextureUnitParameterEXT, "glBindTextureUnitParameterEXT");
   if ( !driverTbl.glBindTextureUnitParameterEXT ) {
      driverTbl.glBindTextureUnitParameterEXT = missing_glBindTextureUnitParameterEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindTextureUnitParameterEXT == loader_glBindTextureUnitParameterEXT) {
      rCtx->dsp->emuTbl.glBindTextureUnitParameterEXT = driverTbl.glBindTextureUnitParameterEXT;
   }
   return driverTbl.glBindTextureUnitParameterEXT(unit, value);
}

static void REGAL_CALL missing_glBindVertexShaderEXT(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "glBindVertexShaderEXT not available." );
}

static void REGAL_CALL loader_glBindVertexShaderEXT(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindVertexShaderEXT, "glBindVertexShaderEXT");
   if ( !driverTbl.glBindVertexShaderEXT ) {
      driverTbl.glBindVertexShaderEXT = missing_glBindVertexShaderEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindVertexShaderEXT == loader_glBindVertexShaderEXT) {
      rCtx->dsp->emuTbl.glBindVertexShaderEXT = driverTbl.glBindVertexShaderEXT;
   }
   driverTbl.glBindVertexShaderEXT(id);
}

static void REGAL_CALL missing_glDeleteVertexShaderEXT(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "glDeleteVertexShaderEXT not available." );
}

static void REGAL_CALL loader_glDeleteVertexShaderEXT(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteVertexShaderEXT, "glDeleteVertexShaderEXT");
   if ( !driverTbl.glDeleteVertexShaderEXT ) {
      driverTbl.glDeleteVertexShaderEXT = missing_glDeleteVertexShaderEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteVertexShaderEXT == loader_glDeleteVertexShaderEXT) {
      rCtx->dsp->emuTbl.glDeleteVertexShaderEXT = driverTbl.glDeleteVertexShaderEXT;
   }
   driverTbl.glDeleteVertexShaderEXT(id);
}

static void REGAL_CALL missing_glDisableVariantClientStateEXT(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "glDisableVariantClientStateEXT not available." );
}

static void REGAL_CALL loader_glDisableVariantClientStateEXT(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDisableVariantClientStateEXT, "glDisableVariantClientStateEXT");
   if ( !driverTbl.glDisableVariantClientStateEXT ) {
      driverTbl.glDisableVariantClientStateEXT = missing_glDisableVariantClientStateEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDisableVariantClientStateEXT == loader_glDisableVariantClientStateEXT) {
      rCtx->dsp->emuTbl.glDisableVariantClientStateEXT = driverTbl.glDisableVariantClientStateEXT;
   }
   driverTbl.glDisableVariantClientStateEXT(id);
}

static void REGAL_CALL missing_glEnableVariantClientStateEXT(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "glEnableVariantClientStateEXT not available." );
}

static void REGAL_CALL loader_glEnableVariantClientStateEXT(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEnableVariantClientStateEXT, "glEnableVariantClientStateEXT");
   if ( !driverTbl.glEnableVariantClientStateEXT ) {
      driverTbl.glEnableVariantClientStateEXT = missing_glEnableVariantClientStateEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEnableVariantClientStateEXT == loader_glEnableVariantClientStateEXT) {
      rCtx->dsp->emuTbl.glEnableVariantClientStateEXT = driverTbl.glEnableVariantClientStateEXT;
   }
   driverTbl.glEnableVariantClientStateEXT(id);
}

static void REGAL_CALL missing_glEndVertexShaderEXT(void)
{
   Warning( "glEndVertexShaderEXT not available." );
}

static void REGAL_CALL loader_glEndVertexShaderEXT(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndVertexShaderEXT, "glEndVertexShaderEXT");
   if ( !driverTbl.glEndVertexShaderEXT ) {
      driverTbl.glEndVertexShaderEXT = missing_glEndVertexShaderEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndVertexShaderEXT == loader_glEndVertexShaderEXT) {
      rCtx->dsp->emuTbl.glEndVertexShaderEXT = driverTbl.glEndVertexShaderEXT;
   }
   driverTbl.glEndVertexShaderEXT();
}

static void REGAL_CALL missing_glExtractComponentEXT(GLuint res, GLuint src, GLuint num)
{
   UNUSED_PARAMETER(res);
   UNUSED_PARAMETER(src);
   UNUSED_PARAMETER(num);
   Warning( "glExtractComponentEXT not available." );
}

static void REGAL_CALL loader_glExtractComponentEXT(GLuint res, GLuint src, GLuint num)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glExtractComponentEXT, "glExtractComponentEXT");
   if ( !driverTbl.glExtractComponentEXT ) {
      driverTbl.glExtractComponentEXT = missing_glExtractComponentEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glExtractComponentEXT == loader_glExtractComponentEXT) {
      rCtx->dsp->emuTbl.glExtractComponentEXT = driverTbl.glExtractComponentEXT;
   }
   driverTbl.glExtractComponentEXT(res, src, num);
}

static GLuint REGAL_CALL missing_glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components)
{
   UNUSED_PARAMETER(datatype);
   UNUSED_PARAMETER(storagetype);
   UNUSED_PARAMETER(range);
   UNUSED_PARAMETER(components);
   Warning( "glGenSymbolsEXT not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenSymbolsEXT, "glGenSymbolsEXT");
   if ( !driverTbl.glGenSymbolsEXT ) {
      driverTbl.glGenSymbolsEXT = missing_glGenSymbolsEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenSymbolsEXT == loader_glGenSymbolsEXT) {
      rCtx->dsp->emuTbl.glGenSymbolsEXT = driverTbl.glGenSymbolsEXT;
   }
   return driverTbl.glGenSymbolsEXT(datatype, storagetype, range, components);
}

static GLuint REGAL_CALL missing_glGenVertexShadersEXT(GLuint range)
{
   UNUSED_PARAMETER(range);
   Warning( "glGenVertexShadersEXT not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGenVertexShadersEXT(GLuint range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenVertexShadersEXT, "glGenVertexShadersEXT");
   if ( !driverTbl.glGenVertexShadersEXT ) {
      driverTbl.glGenVertexShadersEXT = missing_glGenVertexShadersEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenVertexShadersEXT == loader_glGenVertexShadersEXT) {
      rCtx->dsp->emuTbl.glGenVertexShadersEXT = driverTbl.glGenVertexShadersEXT;
   }
   return driverTbl.glGenVertexShadersEXT(range);
}

static void REGAL_CALL missing_glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "glGetInvariantBooleanvEXT not available." );
}

static void REGAL_CALL loader_glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetInvariantBooleanvEXT, "glGetInvariantBooleanvEXT");
   if ( !driverTbl.glGetInvariantBooleanvEXT ) {
      driverTbl.glGetInvariantBooleanvEXT = missing_glGetInvariantBooleanvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetInvariantBooleanvEXT == loader_glGetInvariantBooleanvEXT) {
      rCtx->dsp->emuTbl.glGetInvariantBooleanvEXT = driverTbl.glGetInvariantBooleanvEXT;
   }
   driverTbl.glGetInvariantBooleanvEXT(id, value, data);
}

static void REGAL_CALL missing_glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "glGetInvariantFloatvEXT not available." );
}

static void REGAL_CALL loader_glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetInvariantFloatvEXT, "glGetInvariantFloatvEXT");
   if ( !driverTbl.glGetInvariantFloatvEXT ) {
      driverTbl.glGetInvariantFloatvEXT = missing_glGetInvariantFloatvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetInvariantFloatvEXT == loader_glGetInvariantFloatvEXT) {
      rCtx->dsp->emuTbl.glGetInvariantFloatvEXT = driverTbl.glGetInvariantFloatvEXT;
   }
   driverTbl.glGetInvariantFloatvEXT(id, value, data);
}

static void REGAL_CALL missing_glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "glGetInvariantIntegervEXT not available." );
}

static void REGAL_CALL loader_glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetInvariantIntegervEXT, "glGetInvariantIntegervEXT");
   if ( !driverTbl.glGetInvariantIntegervEXT ) {
      driverTbl.glGetInvariantIntegervEXT = missing_glGetInvariantIntegervEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetInvariantIntegervEXT == loader_glGetInvariantIntegervEXT) {
      rCtx->dsp->emuTbl.glGetInvariantIntegervEXT = driverTbl.glGetInvariantIntegervEXT;
   }
   driverTbl.glGetInvariantIntegervEXT(id, value, data);
}

static void REGAL_CALL missing_glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "glGetLocalConstantBooleanvEXT not available." );
}

static void REGAL_CALL loader_glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetLocalConstantBooleanvEXT, "glGetLocalConstantBooleanvEXT");
   if ( !driverTbl.glGetLocalConstantBooleanvEXT ) {
      driverTbl.glGetLocalConstantBooleanvEXT = missing_glGetLocalConstantBooleanvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetLocalConstantBooleanvEXT == loader_glGetLocalConstantBooleanvEXT) {
      rCtx->dsp->emuTbl.glGetLocalConstantBooleanvEXT = driverTbl.glGetLocalConstantBooleanvEXT;
   }
   driverTbl.glGetLocalConstantBooleanvEXT(id, value, data);
}

static void REGAL_CALL missing_glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "glGetLocalConstantFloatvEXT not available." );
}

static void REGAL_CALL loader_glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetLocalConstantFloatvEXT, "glGetLocalConstantFloatvEXT");
   if ( !driverTbl.glGetLocalConstantFloatvEXT ) {
      driverTbl.glGetLocalConstantFloatvEXT = missing_glGetLocalConstantFloatvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetLocalConstantFloatvEXT == loader_glGetLocalConstantFloatvEXT) {
      rCtx->dsp->emuTbl.glGetLocalConstantFloatvEXT = driverTbl.glGetLocalConstantFloatvEXT;
   }
   driverTbl.glGetLocalConstantFloatvEXT(id, value, data);
}

static void REGAL_CALL missing_glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "glGetLocalConstantIntegervEXT not available." );
}

static void REGAL_CALL loader_glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetLocalConstantIntegervEXT, "glGetLocalConstantIntegervEXT");
   if ( !driverTbl.glGetLocalConstantIntegervEXT ) {
      driverTbl.glGetLocalConstantIntegervEXT = missing_glGetLocalConstantIntegervEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetLocalConstantIntegervEXT == loader_glGetLocalConstantIntegervEXT) {
      rCtx->dsp->emuTbl.glGetLocalConstantIntegervEXT = driverTbl.glGetLocalConstantIntegervEXT;
   }
   driverTbl.glGetLocalConstantIntegervEXT(id, value, data);
}

static void REGAL_CALL missing_glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "glGetVariantBooleanvEXT not available." );
}

static void REGAL_CALL loader_glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVariantBooleanvEXT, "glGetVariantBooleanvEXT");
   if ( !driverTbl.glGetVariantBooleanvEXT ) {
      driverTbl.glGetVariantBooleanvEXT = missing_glGetVariantBooleanvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVariantBooleanvEXT == loader_glGetVariantBooleanvEXT) {
      rCtx->dsp->emuTbl.glGetVariantBooleanvEXT = driverTbl.glGetVariantBooleanvEXT;
   }
   driverTbl.glGetVariantBooleanvEXT(id, value, data);
}

static void REGAL_CALL missing_glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "glGetVariantFloatvEXT not available." );
}

static void REGAL_CALL loader_glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVariantFloatvEXT, "glGetVariantFloatvEXT");
   if ( !driverTbl.glGetVariantFloatvEXT ) {
      driverTbl.glGetVariantFloatvEXT = missing_glGetVariantFloatvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVariantFloatvEXT == loader_glGetVariantFloatvEXT) {
      rCtx->dsp->emuTbl.glGetVariantFloatvEXT = driverTbl.glGetVariantFloatvEXT;
   }
   driverTbl.glGetVariantFloatvEXT(id, value, data);
}

static void REGAL_CALL missing_glGetVariantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "glGetVariantIntegervEXT not available." );
}

static void REGAL_CALL loader_glGetVariantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVariantIntegervEXT, "glGetVariantIntegervEXT");
   if ( !driverTbl.glGetVariantIntegervEXT ) {
      driverTbl.glGetVariantIntegervEXT = missing_glGetVariantIntegervEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVariantIntegervEXT == loader_glGetVariantIntegervEXT) {
      rCtx->dsp->emuTbl.glGetVariantIntegervEXT = driverTbl.glGetVariantIntegervEXT;
   }
   driverTbl.glGetVariantIntegervEXT(id, value, data);
}

static void REGAL_CALL missing_glGetVariantPointervEXT(GLuint id, GLenum value, GLvoid **data)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(data);
   Warning( "glGetVariantPointervEXT not available." );
}

static void REGAL_CALL loader_glGetVariantPointervEXT(GLuint id, GLenum value, GLvoid **data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVariantPointervEXT, "glGetVariantPointervEXT");
   if ( !driverTbl.glGetVariantPointervEXT ) {
      driverTbl.glGetVariantPointervEXT = missing_glGetVariantPointervEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVariantPointervEXT == loader_glGetVariantPointervEXT) {
      rCtx->dsp->emuTbl.glGetVariantPointervEXT = driverTbl.glGetVariantPointervEXT;
   }
   driverTbl.glGetVariantPointervEXT(id, value, data);
}

static void REGAL_CALL missing_glInsertComponentEXT(GLuint res, GLuint src, GLuint num)
{
   UNUSED_PARAMETER(res);
   UNUSED_PARAMETER(src);
   UNUSED_PARAMETER(num);
   Warning( "glInsertComponentEXT not available." );
}

static void REGAL_CALL loader_glInsertComponentEXT(GLuint res, GLuint src, GLuint num)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glInsertComponentEXT, "glInsertComponentEXT");
   if ( !driverTbl.glInsertComponentEXT ) {
      driverTbl.glInsertComponentEXT = missing_glInsertComponentEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glInsertComponentEXT == loader_glInsertComponentEXT) {
      rCtx->dsp->emuTbl.glInsertComponentEXT = driverTbl.glInsertComponentEXT;
   }
   driverTbl.glInsertComponentEXT(res, src, num);
}

static GLboolean REGAL_CALL missing_glIsVariantEnabledEXT(GLuint id, GLenum cap)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(cap);
   Warning( "glIsVariantEnabledEXT not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsVariantEnabledEXT(GLuint id, GLenum cap)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsVariantEnabledEXT, "glIsVariantEnabledEXT");
   if ( !driverTbl.glIsVariantEnabledEXT ) {
      driverTbl.glIsVariantEnabledEXT = missing_glIsVariantEnabledEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsVariantEnabledEXT == loader_glIsVariantEnabledEXT) {
      rCtx->dsp->emuTbl.glIsVariantEnabledEXT = driverTbl.glIsVariantEnabledEXT;
   }
   return driverTbl.glIsVariantEnabledEXT(id, cap);
}

static void REGAL_CALL missing_glSetInvariantEXT(GLuint id, GLenum type, const GLvoid *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(addr);
   Warning( "glSetInvariantEXT not available." );
}

static void REGAL_CALL loader_glSetInvariantEXT(GLuint id, GLenum type, const GLvoid *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSetInvariantEXT, "glSetInvariantEXT");
   if ( !driverTbl.glSetInvariantEXT ) {
      driverTbl.glSetInvariantEXT = missing_glSetInvariantEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSetInvariantEXT == loader_glSetInvariantEXT) {
      rCtx->dsp->emuTbl.glSetInvariantEXT = driverTbl.glSetInvariantEXT;
   }
   driverTbl.glSetInvariantEXT(id, type, addr);
}

static void REGAL_CALL missing_glSetLocalConstantEXT(GLuint id, GLenum type, const GLvoid *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(addr);
   Warning( "glSetLocalConstantEXT not available." );
}

static void REGAL_CALL loader_glSetLocalConstantEXT(GLuint id, GLenum type, const GLvoid *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSetLocalConstantEXT, "glSetLocalConstantEXT");
   if ( !driverTbl.glSetLocalConstantEXT ) {
      driverTbl.glSetLocalConstantEXT = missing_glSetLocalConstantEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSetLocalConstantEXT == loader_glSetLocalConstantEXT) {
      rCtx->dsp->emuTbl.glSetLocalConstantEXT = driverTbl.glSetLocalConstantEXT;
   }
   driverTbl.glSetLocalConstantEXT(id, type, addr);
}

static void REGAL_CALL missing_glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(res);
   UNUSED_PARAMETER(arg1);
   Warning( "glShaderOp1EXT not available." );
}

static void REGAL_CALL loader_glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glShaderOp1EXT, "glShaderOp1EXT");
   if ( !driverTbl.glShaderOp1EXT ) {
      driverTbl.glShaderOp1EXT = missing_glShaderOp1EXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glShaderOp1EXT == loader_glShaderOp1EXT) {
      rCtx->dsp->emuTbl.glShaderOp1EXT = driverTbl.glShaderOp1EXT;
   }
   driverTbl.glShaderOp1EXT(op, res, arg1);
}

static void REGAL_CALL missing_glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(res);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg2);
   Warning( "glShaderOp2EXT not available." );
}

static void REGAL_CALL loader_glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glShaderOp2EXT, "glShaderOp2EXT");
   if ( !driverTbl.glShaderOp2EXT ) {
      driverTbl.glShaderOp2EXT = missing_glShaderOp2EXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glShaderOp2EXT == loader_glShaderOp2EXT) {
      rCtx->dsp->emuTbl.glShaderOp2EXT = driverTbl.glShaderOp2EXT;
   }
   driverTbl.glShaderOp2EXT(op, res, arg1, arg2);
}

static void REGAL_CALL missing_glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3)
{
   UNUSED_PARAMETER(op);
   UNUSED_PARAMETER(res);
   UNUSED_PARAMETER(arg1);
   UNUSED_PARAMETER(arg2);
   UNUSED_PARAMETER(arg3);
   Warning( "glShaderOp3EXT not available." );
}

static void REGAL_CALL loader_glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glShaderOp3EXT, "glShaderOp3EXT");
   if ( !driverTbl.glShaderOp3EXT ) {
      driverTbl.glShaderOp3EXT = missing_glShaderOp3EXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glShaderOp3EXT == loader_glShaderOp3EXT) {
      rCtx->dsp->emuTbl.glShaderOp3EXT = driverTbl.glShaderOp3EXT;
   }
   driverTbl.glShaderOp3EXT(op, res, arg1, arg2, arg3);
}

static void REGAL_CALL missing_glSwizzleEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
   UNUSED_PARAMETER(res);
   UNUSED_PARAMETER(in);
   UNUSED_PARAMETER(outX);
   UNUSED_PARAMETER(outY);
   UNUSED_PARAMETER(outZ);
   UNUSED_PARAMETER(outW);
   Warning( "glSwizzleEXT not available." );
}

static void REGAL_CALL loader_glSwizzleEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSwizzleEXT, "glSwizzleEXT");
   if ( !driverTbl.glSwizzleEXT ) {
      driverTbl.glSwizzleEXT = missing_glSwizzleEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSwizzleEXT == loader_glSwizzleEXT) {
      rCtx->dsp->emuTbl.glSwizzleEXT = driverTbl.glSwizzleEXT;
   }
   driverTbl.glSwizzleEXT(res, in, outX, outY, outZ, outW);
}

static void REGAL_CALL missing_glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const GLvoid *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(addr);
   Warning( "glVariantPointerEXT not available." );
}

static void REGAL_CALL loader_glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const GLvoid *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVariantPointerEXT, "glVariantPointerEXT");
   if ( !driverTbl.glVariantPointerEXT ) {
      driverTbl.glVariantPointerEXT = missing_glVariantPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVariantPointerEXT == loader_glVariantPointerEXT) {
      rCtx->dsp->emuTbl.glVariantPointerEXT = driverTbl.glVariantPointerEXT;
   }
   driverTbl.glVariantPointerEXT(id, type, stride, addr);
}

static void REGAL_CALL missing_glVariantbvEXT(GLuint id, const GLbyte *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "glVariantbvEXT not available." );
}

static void REGAL_CALL loader_glVariantbvEXT(GLuint id, const GLbyte *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVariantbvEXT, "glVariantbvEXT");
   if ( !driverTbl.glVariantbvEXT ) {
      driverTbl.glVariantbvEXT = missing_glVariantbvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVariantbvEXT == loader_glVariantbvEXT) {
      rCtx->dsp->emuTbl.glVariantbvEXT = driverTbl.glVariantbvEXT;
   }
   driverTbl.glVariantbvEXT(id, addr);
}

static void REGAL_CALL missing_glVariantdvEXT(GLuint id, const GLdouble *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "glVariantdvEXT not available." );
}

static void REGAL_CALL loader_glVariantdvEXT(GLuint id, const GLdouble *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVariantdvEXT, "glVariantdvEXT");
   if ( !driverTbl.glVariantdvEXT ) {
      driverTbl.glVariantdvEXT = missing_glVariantdvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVariantdvEXT == loader_glVariantdvEXT) {
      rCtx->dsp->emuTbl.glVariantdvEXT = driverTbl.glVariantdvEXT;
   }
   driverTbl.glVariantdvEXT(id, addr);
}

static void REGAL_CALL missing_glVariantfvEXT(GLuint id, const GLfloat *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "glVariantfvEXT not available." );
}

static void REGAL_CALL loader_glVariantfvEXT(GLuint id, const GLfloat *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVariantfvEXT, "glVariantfvEXT");
   if ( !driverTbl.glVariantfvEXT ) {
      driverTbl.glVariantfvEXT = missing_glVariantfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVariantfvEXT == loader_glVariantfvEXT) {
      rCtx->dsp->emuTbl.glVariantfvEXT = driverTbl.glVariantfvEXT;
   }
   driverTbl.glVariantfvEXT(id, addr);
}

static void REGAL_CALL missing_glVariantivEXT(GLuint id, const GLint *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "glVariantivEXT not available." );
}

static void REGAL_CALL loader_glVariantivEXT(GLuint id, const GLint *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVariantivEXT, "glVariantivEXT");
   if ( !driverTbl.glVariantivEXT ) {
      driverTbl.glVariantivEXT = missing_glVariantivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVariantivEXT == loader_glVariantivEXT) {
      rCtx->dsp->emuTbl.glVariantivEXT = driverTbl.glVariantivEXT;
   }
   driverTbl.glVariantivEXT(id, addr);
}

static void REGAL_CALL missing_glVariantsvEXT(GLuint id, const GLshort *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "glVariantsvEXT not available." );
}

static void REGAL_CALL loader_glVariantsvEXT(GLuint id, const GLshort *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVariantsvEXT, "glVariantsvEXT");
   if ( !driverTbl.glVariantsvEXT ) {
      driverTbl.glVariantsvEXT = missing_glVariantsvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVariantsvEXT == loader_glVariantsvEXT) {
      rCtx->dsp->emuTbl.glVariantsvEXT = driverTbl.glVariantsvEXT;
   }
   driverTbl.glVariantsvEXT(id, addr);
}

static void REGAL_CALL missing_glVariantubvEXT(GLuint id, const GLubyte *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "glVariantubvEXT not available." );
}

static void REGAL_CALL loader_glVariantubvEXT(GLuint id, const GLubyte *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVariantubvEXT, "glVariantubvEXT");
   if ( !driverTbl.glVariantubvEXT ) {
      driverTbl.glVariantubvEXT = missing_glVariantubvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVariantubvEXT == loader_glVariantubvEXT) {
      rCtx->dsp->emuTbl.glVariantubvEXT = driverTbl.glVariantubvEXT;
   }
   driverTbl.glVariantubvEXT(id, addr);
}

static void REGAL_CALL missing_glVariantuivEXT(GLuint id, const GLuint *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "glVariantuivEXT not available." );
}

static void REGAL_CALL loader_glVariantuivEXT(GLuint id, const GLuint *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVariantuivEXT, "glVariantuivEXT");
   if ( !driverTbl.glVariantuivEXT ) {
      driverTbl.glVariantuivEXT = missing_glVariantuivEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVariantuivEXT == loader_glVariantuivEXT) {
      rCtx->dsp->emuTbl.glVariantuivEXT = driverTbl.glVariantuivEXT;
   }
   driverTbl.glVariantuivEXT(id, addr);
}

static void REGAL_CALL missing_glVariantusvEXT(GLuint id, const GLushort *addr)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(addr);
   Warning( "glVariantusvEXT not available." );
}

static void REGAL_CALL loader_glVariantusvEXT(GLuint id, const GLushort *addr)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVariantusvEXT, "glVariantusvEXT");
   if ( !driverTbl.glVariantusvEXT ) {
      driverTbl.glVariantusvEXT = missing_glVariantusvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVariantusvEXT == loader_glVariantusvEXT) {
      rCtx->dsp->emuTbl.glVariantusvEXT = driverTbl.glVariantusvEXT;
   }
   driverTbl.glVariantusvEXT(id, addr);
}

static void REGAL_CALL missing_glWriteMaskEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
   UNUSED_PARAMETER(res);
   UNUSED_PARAMETER(in);
   UNUSED_PARAMETER(outX);
   UNUSED_PARAMETER(outY);
   UNUSED_PARAMETER(outZ);
   UNUSED_PARAMETER(outW);
   Warning( "glWriteMaskEXT not available." );
}

static void REGAL_CALL loader_glWriteMaskEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWriteMaskEXT, "glWriteMaskEXT");
   if ( !driverTbl.glWriteMaskEXT ) {
      driverTbl.glWriteMaskEXT = missing_glWriteMaskEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWriteMaskEXT == loader_glWriteMaskEXT) {
      rCtx->dsp->emuTbl.glWriteMaskEXT = driverTbl.glWriteMaskEXT;
   }
   driverTbl.glWriteMaskEXT(res, in, outX, outY, outZ, outW);
}

// GL_EXT_vertex_weighting

static void REGAL_CALL missing_glVertexWeightPointerEXT(GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glVertexWeightPointerEXT not available." );
}

static void REGAL_CALL loader_glVertexWeightPointerEXT(GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexWeightPointerEXT, "glVertexWeightPointerEXT");
   if ( !driverTbl.glVertexWeightPointerEXT ) {
      driverTbl.glVertexWeightPointerEXT = missing_glVertexWeightPointerEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexWeightPointerEXT == loader_glVertexWeightPointerEXT) {
      rCtx->dsp->emuTbl.glVertexWeightPointerEXT = driverTbl.glVertexWeightPointerEXT;
   }
   driverTbl.glVertexWeightPointerEXT(size, type, stride, pointer);
}

static void REGAL_CALL missing_glVertexWeightfEXT(GLfloat weight)
{
   UNUSED_PARAMETER(weight);
   Warning( "glVertexWeightfEXT not available." );
}

static void REGAL_CALL loader_glVertexWeightfEXT(GLfloat weight)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexWeightfEXT, "glVertexWeightfEXT");
   if ( !driverTbl.glVertexWeightfEXT ) {
      driverTbl.glVertexWeightfEXT = missing_glVertexWeightfEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexWeightfEXT == loader_glVertexWeightfEXT) {
      rCtx->dsp->emuTbl.glVertexWeightfEXT = driverTbl.glVertexWeightfEXT;
   }
   driverTbl.glVertexWeightfEXT(weight);
}

static void REGAL_CALL missing_glVertexWeightfvEXT(const GLfloat *weight)
{
   UNUSED_PARAMETER(weight);
   Warning( "glVertexWeightfvEXT not available." );
}

static void REGAL_CALL loader_glVertexWeightfvEXT(const GLfloat *weight)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexWeightfvEXT, "glVertexWeightfvEXT");
   if ( !driverTbl.glVertexWeightfvEXT ) {
      driverTbl.glVertexWeightfvEXT = missing_glVertexWeightfvEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexWeightfvEXT == loader_glVertexWeightfvEXT) {
      rCtx->dsp->emuTbl.glVertexWeightfvEXT = driverTbl.glVertexWeightfvEXT;
   }
   driverTbl.glVertexWeightfvEXT(weight);
}

// GL_EXT_x11_sync_object

static GLsync REGAL_CALL missing_glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags)
{
   UNUSED_PARAMETER(external_sync_type);
   UNUSED_PARAMETER(external_sync);
   UNUSED_PARAMETER(flags);
   Warning( "glImportSyncEXT not available." );
  GLsync  ret = (GLsync )0;
  return ret;
}

static GLsync REGAL_CALL loader_glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glImportSyncEXT, "glImportSyncEXT");
   if ( !driverTbl.glImportSyncEXT ) {
      driverTbl.glImportSyncEXT = missing_glImportSyncEXT;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glImportSyncEXT == loader_glImportSyncEXT) {
      rCtx->dsp->emuTbl.glImportSyncEXT = driverTbl.glImportSyncEXT;
   }
   return driverTbl.glImportSyncEXT(external_sync_type, external_sync, flags);
}

// GL_GREMEDY_frame_terminator

static void REGAL_CALL missing_glFrameTerminatorGREMEDY(void)
{
   Warning( "glFrameTerminatorGREMEDY not available." );
}

static void REGAL_CALL loader_glFrameTerminatorGREMEDY(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFrameTerminatorGREMEDY, "glFrameTerminatorGREMEDY");
   if ( !driverTbl.glFrameTerminatorGREMEDY ) {
      driverTbl.glFrameTerminatorGREMEDY = missing_glFrameTerminatorGREMEDY;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFrameTerminatorGREMEDY == loader_glFrameTerminatorGREMEDY) {
      rCtx->dsp->emuTbl.glFrameTerminatorGREMEDY = driverTbl.glFrameTerminatorGREMEDY;
   }
   driverTbl.glFrameTerminatorGREMEDY();
}

// GL_GREMEDY_string_marker

static void REGAL_CALL missing_glStringMarkerGREMEDY(GLsizei len, const GLvoid *string)
{
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(string);
   Warning( "glStringMarkerGREMEDY not available." );
}

static void REGAL_CALL loader_glStringMarkerGREMEDY(GLsizei len, const GLvoid *string)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStringMarkerGREMEDY, "glStringMarkerGREMEDY");
   if ( !driverTbl.glStringMarkerGREMEDY ) {
      driverTbl.glStringMarkerGREMEDY = missing_glStringMarkerGREMEDY;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStringMarkerGREMEDY == loader_glStringMarkerGREMEDY) {
      rCtx->dsp->emuTbl.glStringMarkerGREMEDY = driverTbl.glStringMarkerGREMEDY;
   }
   driverTbl.glStringMarkerGREMEDY(len, string);
}

// GL_HP_image_transform

static void REGAL_CALL missing_glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetImageTransformParameterfvHP not available." );
}

static void REGAL_CALL loader_glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetImageTransformParameterfvHP, "glGetImageTransformParameterfvHP");
   if ( !driverTbl.glGetImageTransformParameterfvHP ) {
      driverTbl.glGetImageTransformParameterfvHP = missing_glGetImageTransformParameterfvHP;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetImageTransformParameterfvHP == loader_glGetImageTransformParameterfvHP) {
      rCtx->dsp->emuTbl.glGetImageTransformParameterfvHP = driverTbl.glGetImageTransformParameterfvHP;
   }
   driverTbl.glGetImageTransformParameterfvHP(target, pname, params);
}

static void REGAL_CALL missing_glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetImageTransformParameterivHP not available." );
}

static void REGAL_CALL loader_glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetImageTransformParameterivHP, "glGetImageTransformParameterivHP");
   if ( !driverTbl.glGetImageTransformParameterivHP ) {
      driverTbl.glGetImageTransformParameterivHP = missing_glGetImageTransformParameterivHP;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetImageTransformParameterivHP == loader_glGetImageTransformParameterivHP) {
      rCtx->dsp->emuTbl.glGetImageTransformParameterivHP = driverTbl.glGetImageTransformParameterivHP;
   }
   driverTbl.glGetImageTransformParameterivHP(target, pname, params);
}

static void REGAL_CALL missing_glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glImageTransformParameterfHP not available." );
}

static void REGAL_CALL loader_glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glImageTransformParameterfHP, "glImageTransformParameterfHP");
   if ( !driverTbl.glImageTransformParameterfHP ) {
      driverTbl.glImageTransformParameterfHP = missing_glImageTransformParameterfHP;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glImageTransformParameterfHP == loader_glImageTransformParameterfHP) {
      rCtx->dsp->emuTbl.glImageTransformParameterfHP = driverTbl.glImageTransformParameterfHP;
   }
   driverTbl.glImageTransformParameterfHP(target, pname, param);
}

static void REGAL_CALL missing_glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glImageTransformParameterfvHP not available." );
}

static void REGAL_CALL loader_glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glImageTransformParameterfvHP, "glImageTransformParameterfvHP");
   if ( !driverTbl.glImageTransformParameterfvHP ) {
      driverTbl.glImageTransformParameterfvHP = missing_glImageTransformParameterfvHP;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glImageTransformParameterfvHP == loader_glImageTransformParameterfvHP) {
      rCtx->dsp->emuTbl.glImageTransformParameterfvHP = driverTbl.glImageTransformParameterfvHP;
   }
   driverTbl.glImageTransformParameterfvHP(target, pname, params);
}

static void REGAL_CALL missing_glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glImageTransformParameteriHP not available." );
}

static void REGAL_CALL loader_glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glImageTransformParameteriHP, "glImageTransformParameteriHP");
   if ( !driverTbl.glImageTransformParameteriHP ) {
      driverTbl.glImageTransformParameteriHP = missing_glImageTransformParameteriHP;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glImageTransformParameteriHP == loader_glImageTransformParameteriHP) {
      rCtx->dsp->emuTbl.glImageTransformParameteriHP = driverTbl.glImageTransformParameteriHP;
   }
   driverTbl.glImageTransformParameteriHP(target, pname, param);
}

static void REGAL_CALL missing_glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glImageTransformParameterivHP not available." );
}

static void REGAL_CALL loader_glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glImageTransformParameterivHP, "glImageTransformParameterivHP");
   if ( !driverTbl.glImageTransformParameterivHP ) {
      driverTbl.glImageTransformParameterivHP = missing_glImageTransformParameterivHP;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glImageTransformParameterivHP == loader_glImageTransformParameterivHP) {
      rCtx->dsp->emuTbl.glImageTransformParameterivHP = driverTbl.glImageTransformParameterivHP;
   }
   driverTbl.glImageTransformParameterivHP(target, pname, params);
}

// GL_IBM_multimode_draw_arrays

static void REGAL_CALL missing_glMultiModeDrawArraysIBM(const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(modestride);
   Warning( "glMultiModeDrawArraysIBM not available." );
}

static void REGAL_CALL loader_glMultiModeDrawArraysIBM(const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiModeDrawArraysIBM, "glMultiModeDrawArraysIBM");
   if ( !driverTbl.glMultiModeDrawArraysIBM ) {
      driverTbl.glMultiModeDrawArraysIBM = missing_glMultiModeDrawArraysIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiModeDrawArraysIBM == loader_glMultiModeDrawArraysIBM) {
      rCtx->dsp->emuTbl.glMultiModeDrawArraysIBM = driverTbl.glMultiModeDrawArraysIBM;
   }
   driverTbl.glMultiModeDrawArraysIBM(mode, first, count, primcount, modestride);
}

static void REGAL_CALL missing_glMultiModeDrawElementsIBM(const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, GLint modestride)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(indices);
   UNUSED_PARAMETER(primcount);
   UNUSED_PARAMETER(modestride);
   Warning( "glMultiModeDrawElementsIBM not available." );
}

static void REGAL_CALL loader_glMultiModeDrawElementsIBM(const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, GLint modestride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiModeDrawElementsIBM, "glMultiModeDrawElementsIBM");
   if ( !driverTbl.glMultiModeDrawElementsIBM ) {
      driverTbl.glMultiModeDrawElementsIBM = missing_glMultiModeDrawElementsIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiModeDrawElementsIBM == loader_glMultiModeDrawElementsIBM) {
      rCtx->dsp->emuTbl.glMultiModeDrawElementsIBM = driverTbl.glMultiModeDrawElementsIBM;
   }
   driverTbl.glMultiModeDrawElementsIBM(mode, count, type, indices, primcount, modestride);
}

// GL_IBM_vertex_array_lists

static void REGAL_CALL missing_glColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "glColorPointerListIBM not available." );
}

static void REGAL_CALL loader_glColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorPointerListIBM, "glColorPointerListIBM");
   if ( !driverTbl.glColorPointerListIBM ) {
      driverTbl.glColorPointerListIBM = missing_glColorPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorPointerListIBM == loader_glColorPointerListIBM) {
      rCtx->dsp->emuTbl.glColorPointerListIBM = driverTbl.glColorPointerListIBM;
   }
   driverTbl.glColorPointerListIBM(size, type, stride, pointer, ptrstride);
}

static void REGAL_CALL missing_glEdgeFlagPointerListIBM(GLint stride, const GLboolean **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "glEdgeFlagPointerListIBM not available." );
}

static void REGAL_CALL loader_glEdgeFlagPointerListIBM(GLint stride, const GLboolean **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEdgeFlagPointerListIBM, "glEdgeFlagPointerListIBM");
   if ( !driverTbl.glEdgeFlagPointerListIBM ) {
      driverTbl.glEdgeFlagPointerListIBM = missing_glEdgeFlagPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEdgeFlagPointerListIBM == loader_glEdgeFlagPointerListIBM) {
      rCtx->dsp->emuTbl.glEdgeFlagPointerListIBM = driverTbl.glEdgeFlagPointerListIBM;
   }
   driverTbl.glEdgeFlagPointerListIBM(stride, pointer, ptrstride);
}

static void REGAL_CALL missing_glFogCoordPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "glFogCoordPointerListIBM not available." );
}

static void REGAL_CALL loader_glFogCoordPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogCoordPointerListIBM, "glFogCoordPointerListIBM");
   if ( !driverTbl.glFogCoordPointerListIBM ) {
      driverTbl.glFogCoordPointerListIBM = missing_glFogCoordPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogCoordPointerListIBM == loader_glFogCoordPointerListIBM) {
      rCtx->dsp->emuTbl.glFogCoordPointerListIBM = driverTbl.glFogCoordPointerListIBM;
   }
   driverTbl.glFogCoordPointerListIBM(type, stride, pointer, ptrstride);
}

static void REGAL_CALL missing_glIndexPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "glIndexPointerListIBM not available." );
}

static void REGAL_CALL loader_glIndexPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexPointerListIBM, "glIndexPointerListIBM");
   if ( !driverTbl.glIndexPointerListIBM ) {
      driverTbl.glIndexPointerListIBM = missing_glIndexPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexPointerListIBM == loader_glIndexPointerListIBM) {
      rCtx->dsp->emuTbl.glIndexPointerListIBM = driverTbl.glIndexPointerListIBM;
   }
   driverTbl.glIndexPointerListIBM(type, stride, pointer, ptrstride);
}

static void REGAL_CALL missing_glNormalPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "glNormalPointerListIBM not available." );
}

static void REGAL_CALL loader_glNormalPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalPointerListIBM, "glNormalPointerListIBM");
   if ( !driverTbl.glNormalPointerListIBM ) {
      driverTbl.glNormalPointerListIBM = missing_glNormalPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalPointerListIBM == loader_glNormalPointerListIBM) {
      rCtx->dsp->emuTbl.glNormalPointerListIBM = driverTbl.glNormalPointerListIBM;
   }
   driverTbl.glNormalPointerListIBM(type, stride, pointer, ptrstride);
}

static void REGAL_CALL missing_glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "glSecondaryColorPointerListIBM not available." );
}

static void REGAL_CALL loader_glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColorPointerListIBM, "glSecondaryColorPointerListIBM");
   if ( !driverTbl.glSecondaryColorPointerListIBM ) {
      driverTbl.glSecondaryColorPointerListIBM = missing_glSecondaryColorPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColorPointerListIBM == loader_glSecondaryColorPointerListIBM) {
      rCtx->dsp->emuTbl.glSecondaryColorPointerListIBM = driverTbl.glSecondaryColorPointerListIBM;
   }
   driverTbl.glSecondaryColorPointerListIBM(size, type, stride, pointer, ptrstride);
}

static void REGAL_CALL missing_glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "glTexCoordPointerListIBM not available." );
}

static void REGAL_CALL loader_glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoordPointerListIBM, "glTexCoordPointerListIBM");
   if ( !driverTbl.glTexCoordPointerListIBM ) {
      driverTbl.glTexCoordPointerListIBM = missing_glTexCoordPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoordPointerListIBM == loader_glTexCoordPointerListIBM) {
      rCtx->dsp->emuTbl.glTexCoordPointerListIBM = driverTbl.glTexCoordPointerListIBM;
   }
   driverTbl.glTexCoordPointerListIBM(size, type, stride, pointer, ptrstride);
}

static void REGAL_CALL missing_glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   UNUSED_PARAMETER(ptrstride);
   Warning( "glVertexPointerListIBM not available." );
}

static void REGAL_CALL loader_glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexPointerListIBM, "glVertexPointerListIBM");
   if ( !driverTbl.glVertexPointerListIBM ) {
      driverTbl.glVertexPointerListIBM = missing_glVertexPointerListIBM;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexPointerListIBM == loader_glVertexPointerListIBM) {
      rCtx->dsp->emuTbl.glVertexPointerListIBM = driverTbl.glVertexPointerListIBM;
   }
   driverTbl.glVertexPointerListIBM(size, type, stride, pointer, ptrstride);
}

// GL_INGR_blend_func_separate

static void REGAL_CALL missing_glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
   UNUSED_PARAMETER(sfactorRGB);
   UNUSED_PARAMETER(dfactorRGB);
   UNUSED_PARAMETER(sfactorAlpha);
   UNUSED_PARAMETER(dfactorAlpha);
   Warning( "glBlendFuncSeparateINGR not available." );
}

static void REGAL_CALL loader_glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBlendFuncSeparateINGR, "glBlendFuncSeparateINGR");
   if ( !driverTbl.glBlendFuncSeparateINGR ) {
      driverTbl.glBlendFuncSeparateINGR = missing_glBlendFuncSeparateINGR;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBlendFuncSeparateINGR == loader_glBlendFuncSeparateINGR) {
      rCtx->dsp->emuTbl.glBlendFuncSeparateINGR = driverTbl.glBlendFuncSeparateINGR;
   }
   driverTbl.glBlendFuncSeparateINGR(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}

// GL_INTEL_parallel_arrays

static void REGAL_CALL missing_glColorPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pointer);
   Warning( "glColorPointervINTEL not available." );
}

static void REGAL_CALL loader_glColorPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorPointervINTEL, "glColorPointervINTEL");
   if ( !driverTbl.glColorPointervINTEL ) {
      driverTbl.glColorPointervINTEL = missing_glColorPointervINTEL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorPointervINTEL == loader_glColorPointervINTEL) {
      rCtx->dsp->emuTbl.glColorPointervINTEL = driverTbl.glColorPointervINTEL;
   }
   driverTbl.glColorPointervINTEL(size, type, pointer);
}

static void REGAL_CALL missing_glNormalPointervINTEL(GLenum type, const GLvoid **pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pointer);
   Warning( "glNormalPointervINTEL not available." );
}

static void REGAL_CALL loader_glNormalPointervINTEL(GLenum type, const GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalPointervINTEL, "glNormalPointervINTEL");
   if ( !driverTbl.glNormalPointervINTEL ) {
      driverTbl.glNormalPointervINTEL = missing_glNormalPointervINTEL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalPointervINTEL == loader_glNormalPointervINTEL) {
      rCtx->dsp->emuTbl.glNormalPointervINTEL = driverTbl.glNormalPointervINTEL;
   }
   driverTbl.glNormalPointervINTEL(type, pointer);
}

static void REGAL_CALL missing_glTexCoordPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pointer);
   Warning( "glTexCoordPointervINTEL not available." );
}

static void REGAL_CALL loader_glTexCoordPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoordPointervINTEL, "glTexCoordPointervINTEL");
   if ( !driverTbl.glTexCoordPointervINTEL ) {
      driverTbl.glTexCoordPointervINTEL = missing_glTexCoordPointervINTEL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoordPointervINTEL == loader_glTexCoordPointervINTEL) {
      rCtx->dsp->emuTbl.glTexCoordPointervINTEL = driverTbl.glTexCoordPointervINTEL;
   }
   driverTbl.glTexCoordPointervINTEL(size, type, pointer);
}

static void REGAL_CALL missing_glVertexPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pointer);
   Warning( "glVertexPointervINTEL not available." );
}

static void REGAL_CALL loader_glVertexPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexPointervINTEL, "glVertexPointervINTEL");
   if ( !driverTbl.glVertexPointervINTEL ) {
      driverTbl.glVertexPointervINTEL = missing_glVertexPointervINTEL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexPointervINTEL == loader_glVertexPointervINTEL) {
      rCtx->dsp->emuTbl.glVertexPointervINTEL = driverTbl.glVertexPointervINTEL;
   }
   driverTbl.glVertexPointervINTEL(size, type, pointer);
}

// GL_INTEL_texture_scissor

static void REGAL_CALL missing_glTexScissorFuncINTEL(GLenum target, GLenum lfunc, GLenum hfunc)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(lfunc);
   UNUSED_PARAMETER(hfunc);
   Warning( "glTexScissorFuncINTEL not available." );
}

static void REGAL_CALL loader_glTexScissorFuncINTEL(GLenum target, GLenum lfunc, GLenum hfunc)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexScissorFuncINTEL, "glTexScissorFuncINTEL");
   if ( !driverTbl.glTexScissorFuncINTEL ) {
      driverTbl.glTexScissorFuncINTEL = missing_glTexScissorFuncINTEL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexScissorFuncINTEL == loader_glTexScissorFuncINTEL) {
      rCtx->dsp->emuTbl.glTexScissorFuncINTEL = driverTbl.glTexScissorFuncINTEL;
   }
   driverTbl.glTexScissorFuncINTEL(target, lfunc, hfunc);
}

static void REGAL_CALL missing_glTexScissorINTEL(GLenum target, GLclampf tlow, GLclampf thigh)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(tlow);
   UNUSED_PARAMETER(thigh);
   Warning( "glTexScissorINTEL not available." );
}

static void REGAL_CALL loader_glTexScissorINTEL(GLenum target, GLclampf tlow, GLclampf thigh)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexScissorINTEL, "glTexScissorINTEL");
   if ( !driverTbl.glTexScissorINTEL ) {
      driverTbl.glTexScissorINTEL = missing_glTexScissorINTEL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexScissorINTEL == loader_glTexScissorINTEL) {
      rCtx->dsp->emuTbl.glTexScissorINTEL = driverTbl.glTexScissorINTEL;
   }
   driverTbl.glTexScissorINTEL(target, tlow, thigh);
}

// GL_KHR_debug

static void REGAL_CALL missing_glDebugMessageCallback(GLDEBUGPROC callback, GLvoid *userParam)
{
   UNUSED_PARAMETER(callback);
   UNUSED_PARAMETER(userParam);
   Warning( "glDebugMessageCallback not available." );
}

static void REGAL_CALL loader_glDebugMessageCallback(GLDEBUGPROC callback, GLvoid *userParam)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDebugMessageCallback, "glDebugMessageCallback");
   if ( !driverTbl.glDebugMessageCallback ) {
      driverTbl.glDebugMessageCallback = missing_glDebugMessageCallback;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDebugMessageCallback == loader_glDebugMessageCallback) {
      rCtx->dsp->emuTbl.glDebugMessageCallback = driverTbl.glDebugMessageCallback;
   }
   driverTbl.glDebugMessageCallback(callback, userParam);
}

static void REGAL_CALL missing_glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
   UNUSED_PARAMETER(source);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(severity);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(ids);
   UNUSED_PARAMETER(enabled);
   Warning( "glDebugMessageControl not available." );
}

static void REGAL_CALL loader_glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDebugMessageControl, "glDebugMessageControl");
   if ( !driverTbl.glDebugMessageControl ) {
      driverTbl.glDebugMessageControl = missing_glDebugMessageControl;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDebugMessageControl == loader_glDebugMessageControl) {
      rCtx->dsp->emuTbl.glDebugMessageControl = driverTbl.glDebugMessageControl;
   }
   driverTbl.glDebugMessageControl(source, type, severity, count, ids, enabled);
}

static void REGAL_CALL missing_glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
{
   UNUSED_PARAMETER(source);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(severity);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(buf);
   Warning( "glDebugMessageInsert not available." );
}

static void REGAL_CALL loader_glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDebugMessageInsert, "glDebugMessageInsert");
   if ( !driverTbl.glDebugMessageInsert ) {
      driverTbl.glDebugMessageInsert = missing_glDebugMessageInsert;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDebugMessageInsert == loader_glDebugMessageInsert) {
      rCtx->dsp->emuTbl.glDebugMessageInsert = driverTbl.glDebugMessageInsert;
   }
   driverTbl.glDebugMessageInsert(source, type, id, severity, length, buf);
}

static GLuint REGAL_CALL missing_glGetDebugMessageLog(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
{
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(bufsize);
   UNUSED_PARAMETER(sources);
   UNUSED_PARAMETER(types);
   UNUSED_PARAMETER(ids);
   UNUSED_PARAMETER(severities);
   UNUSED_PARAMETER(lengths);
   UNUSED_PARAMETER(messageLog);
   Warning( "glGetDebugMessageLog not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGetDebugMessageLog(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetDebugMessageLog, "glGetDebugMessageLog");
   if ( !driverTbl.glGetDebugMessageLog ) {
      driverTbl.glGetDebugMessageLog = missing_glGetDebugMessageLog;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetDebugMessageLog == loader_glGetDebugMessageLog) {
      rCtx->dsp->emuTbl.glGetDebugMessageLog = driverTbl.glGetDebugMessageLog;
   }
   return driverTbl.glGetDebugMessageLog(count, bufsize, sources, types, ids, severities, lengths, messageLog);
}

static void REGAL_CALL missing_glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label)
{
   UNUSED_PARAMETER(identifier);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(label);
   Warning( "glGetObjectLabel not available." );
}

static void REGAL_CALL loader_glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetObjectLabel, "glGetObjectLabel");
   if ( !driverTbl.glGetObjectLabel ) {
      driverTbl.glGetObjectLabel = missing_glGetObjectLabel;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetObjectLabel == loader_glGetObjectLabel) {
      rCtx->dsp->emuTbl.glGetObjectLabel = driverTbl.glGetObjectLabel;
   }
   driverTbl.glGetObjectLabel(identifier, name, bufSize, length, label);
}

static void REGAL_CALL missing_glGetObjectPtrLabel(GLvoid *ptr, GLsizei bufSize, GLsizei *length, GLchar *label)
{
   UNUSED_PARAMETER(ptr);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(label);
   Warning( "glGetObjectPtrLabel not available." );
}

static void REGAL_CALL loader_glGetObjectPtrLabel(GLvoid *ptr, GLsizei bufSize, GLsizei *length, GLchar *label)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetObjectPtrLabel, "glGetObjectPtrLabel");
   if ( !driverTbl.glGetObjectPtrLabel ) {
      driverTbl.glGetObjectPtrLabel = missing_glGetObjectPtrLabel;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetObjectPtrLabel == loader_glGetObjectPtrLabel) {
      rCtx->dsp->emuTbl.glGetObjectPtrLabel = driverTbl.glGetObjectPtrLabel;
   }
   driverTbl.glGetObjectPtrLabel(ptr, bufSize, length, label);
}

static void REGAL_CALL missing_glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const GLchar *label)
{
   UNUSED_PARAMETER(identifier);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(label);
   Warning( "glObjectLabel not available." );
}

static void REGAL_CALL loader_glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const GLchar *label)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glObjectLabel, "glObjectLabel");
   if ( !driverTbl.glObjectLabel ) {
      driverTbl.glObjectLabel = missing_glObjectLabel;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glObjectLabel == loader_glObjectLabel) {
      rCtx->dsp->emuTbl.glObjectLabel = driverTbl.glObjectLabel;
   }
   driverTbl.glObjectLabel(identifier, name, length, label);
}

static void REGAL_CALL missing_glObjectPtrLabel(GLvoid *ptr, GLsizei length, const GLchar *label)
{
   UNUSED_PARAMETER(ptr);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(label);
   Warning( "glObjectPtrLabel not available." );
}

static void REGAL_CALL loader_glObjectPtrLabel(GLvoid *ptr, GLsizei length, const GLchar *label)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glObjectPtrLabel, "glObjectPtrLabel");
   if ( !driverTbl.glObjectPtrLabel ) {
      driverTbl.glObjectPtrLabel = missing_glObjectPtrLabel;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glObjectPtrLabel == loader_glObjectPtrLabel) {
      rCtx->dsp->emuTbl.glObjectPtrLabel = driverTbl.glObjectPtrLabel;
   }
   driverTbl.glObjectPtrLabel(ptr, length, label);
}

static void REGAL_CALL missing_glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const GLchar *message)
{
   UNUSED_PARAMETER(source);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(message);
   Warning( "glPushDebugGroup not available." );
}

static void REGAL_CALL loader_glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const GLchar *message)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPushDebugGroup, "glPushDebugGroup");
   if ( !driverTbl.glPushDebugGroup ) {
      driverTbl.glPushDebugGroup = missing_glPushDebugGroup;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPushDebugGroup == loader_glPushDebugGroup) {
      rCtx->dsp->emuTbl.glPushDebugGroup = driverTbl.glPushDebugGroup;
   }
   driverTbl.glPushDebugGroup(source, id, length, message);
}

// GL_KTX_buffer_region

static GLuint REGAL_CALL missing_glBufferRegionEnabled(void)
{
   Warning( "glBufferRegionEnabled not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glBufferRegionEnabled(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBufferRegionEnabled, "glBufferRegionEnabled");
   if ( !driverTbl.glBufferRegionEnabled ) {
      driverTbl.glBufferRegionEnabled = missing_glBufferRegionEnabled;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBufferRegionEnabled == loader_glBufferRegionEnabled) {
      rCtx->dsp->emuTbl.glBufferRegionEnabled = driverTbl.glBufferRegionEnabled;
   }
   return driverTbl.glBufferRegionEnabled();
}

static void REGAL_CALL missing_glDeleteBufferRegion(GLenum region)
{
   UNUSED_PARAMETER(region);
   Warning( "glDeleteBufferRegion not available." );
}

static void REGAL_CALL loader_glDeleteBufferRegion(GLenum region)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteBufferRegion, "glDeleteBufferRegion");
   if ( !driverTbl.glDeleteBufferRegion ) {
      driverTbl.glDeleteBufferRegion = missing_glDeleteBufferRegion;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteBufferRegion == loader_glDeleteBufferRegion) {
      rCtx->dsp->emuTbl.glDeleteBufferRegion = driverTbl.glDeleteBufferRegion;
   }
   driverTbl.glDeleteBufferRegion(region);
}

static void REGAL_CALL missing_glDrawBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest)
{
   UNUSED_PARAMETER(region);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(xDest);
   UNUSED_PARAMETER(yDest);
   Warning( "glDrawBufferRegion not available." );
}

static void REGAL_CALL loader_glDrawBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawBufferRegion, "glDrawBufferRegion");
   if ( !driverTbl.glDrawBufferRegion ) {
      driverTbl.glDrawBufferRegion = missing_glDrawBufferRegion;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawBufferRegion == loader_glDrawBufferRegion) {
      rCtx->dsp->emuTbl.glDrawBufferRegion = driverTbl.glDrawBufferRegion;
   }
   driverTbl.glDrawBufferRegion(region, x, y, width, height, xDest, yDest);
}

static GLuint REGAL_CALL missing_glNewBufferRegion(GLenum region)
{
   UNUSED_PARAMETER(region);
   Warning( "glNewBufferRegion not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glNewBufferRegion(GLenum region)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNewBufferRegion, "glNewBufferRegion");
   if ( !driverTbl.glNewBufferRegion ) {
      driverTbl.glNewBufferRegion = missing_glNewBufferRegion;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNewBufferRegion == loader_glNewBufferRegion) {
      rCtx->dsp->emuTbl.glNewBufferRegion = driverTbl.glNewBufferRegion;
   }
   return driverTbl.glNewBufferRegion(region);
}

static void REGAL_CALL missing_glReadBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(region);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glReadBufferRegion not available." );
}

static void REGAL_CALL loader_glReadBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReadBufferRegion, "glReadBufferRegion");
   if ( !driverTbl.glReadBufferRegion ) {
      driverTbl.glReadBufferRegion = missing_glReadBufferRegion;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReadBufferRegion == loader_glReadBufferRegion) {
      rCtx->dsp->emuTbl.glReadBufferRegion = driverTbl.glReadBufferRegion;
   }
   driverTbl.glReadBufferRegion(region, x, y, width, height);
}

// GL_MESA_resize_buffers

static void REGAL_CALL missing_glResizeBuffersMESA(void)
{
   Warning( "glResizeBuffersMESA not available." );
}

static void REGAL_CALL loader_glResizeBuffersMESA(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glResizeBuffersMESA, "glResizeBuffersMESA");
   if ( !driverTbl.glResizeBuffersMESA ) {
      driverTbl.glResizeBuffersMESA = missing_glResizeBuffersMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glResizeBuffersMESA == loader_glResizeBuffersMESA) {
      rCtx->dsp->emuTbl.glResizeBuffersMESA = driverTbl.glResizeBuffersMESA;
   }
   driverTbl.glResizeBuffersMESA();
}

// GL_MESA_window_pos

static void REGAL_CALL missing_glWindowPos2dMESA(GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glWindowPos2dMESA not available." );
}

static void REGAL_CALL loader_glWindowPos2dMESA(GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2dMESA, "glWindowPos2dMESA");
   if ( !driverTbl.glWindowPos2dMESA ) {
      driverTbl.glWindowPos2dMESA = missing_glWindowPos2dMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2dMESA == loader_glWindowPos2dMESA) {
      rCtx->dsp->emuTbl.glWindowPos2dMESA = driverTbl.glWindowPos2dMESA;
   }
   driverTbl.glWindowPos2dMESA(x, y);
}

static void REGAL_CALL missing_glWindowPos2dvMESA(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glWindowPos2dvMESA not available." );
}

static void REGAL_CALL loader_glWindowPos2dvMESA(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2dvMESA, "glWindowPos2dvMESA");
   if ( !driverTbl.glWindowPos2dvMESA ) {
      driverTbl.glWindowPos2dvMESA = missing_glWindowPos2dvMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2dvMESA == loader_glWindowPos2dvMESA) {
      rCtx->dsp->emuTbl.glWindowPos2dvMESA = driverTbl.glWindowPos2dvMESA;
   }
   driverTbl.glWindowPos2dvMESA(v);
}

static void REGAL_CALL missing_glWindowPos2fMESA(GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glWindowPos2fMESA not available." );
}

static void REGAL_CALL loader_glWindowPos2fMESA(GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2fMESA, "glWindowPos2fMESA");
   if ( !driverTbl.glWindowPos2fMESA ) {
      driverTbl.glWindowPos2fMESA = missing_glWindowPos2fMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2fMESA == loader_glWindowPos2fMESA) {
      rCtx->dsp->emuTbl.glWindowPos2fMESA = driverTbl.glWindowPos2fMESA;
   }
   driverTbl.glWindowPos2fMESA(x, y);
}

static void REGAL_CALL missing_glWindowPos2fvMESA(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glWindowPos2fvMESA not available." );
}

static void REGAL_CALL loader_glWindowPos2fvMESA(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2fvMESA, "glWindowPos2fvMESA");
   if ( !driverTbl.glWindowPos2fvMESA ) {
      driverTbl.glWindowPos2fvMESA = missing_glWindowPos2fvMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2fvMESA == loader_glWindowPos2fvMESA) {
      rCtx->dsp->emuTbl.glWindowPos2fvMESA = driverTbl.glWindowPos2fvMESA;
   }
   driverTbl.glWindowPos2fvMESA(v);
}

static void REGAL_CALL missing_glWindowPos2iMESA(GLint x, GLint y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glWindowPos2iMESA not available." );
}

static void REGAL_CALL loader_glWindowPos2iMESA(GLint x, GLint y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2iMESA, "glWindowPos2iMESA");
   if ( !driverTbl.glWindowPos2iMESA ) {
      driverTbl.glWindowPos2iMESA = missing_glWindowPos2iMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2iMESA == loader_glWindowPos2iMESA) {
      rCtx->dsp->emuTbl.glWindowPos2iMESA = driverTbl.glWindowPos2iMESA;
   }
   driverTbl.glWindowPos2iMESA(x, y);
}

static void REGAL_CALL missing_glWindowPos2ivMESA(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glWindowPos2ivMESA not available." );
}

static void REGAL_CALL loader_glWindowPos2ivMESA(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2ivMESA, "glWindowPos2ivMESA");
   if ( !driverTbl.glWindowPos2ivMESA ) {
      driverTbl.glWindowPos2ivMESA = missing_glWindowPos2ivMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2ivMESA == loader_glWindowPos2ivMESA) {
      rCtx->dsp->emuTbl.glWindowPos2ivMESA = driverTbl.glWindowPos2ivMESA;
   }
   driverTbl.glWindowPos2ivMESA(v);
}

static void REGAL_CALL missing_glWindowPos2sMESA(GLshort x, GLshort y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glWindowPos2sMESA not available." );
}

static void REGAL_CALL loader_glWindowPos2sMESA(GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2sMESA, "glWindowPos2sMESA");
   if ( !driverTbl.glWindowPos2sMESA ) {
      driverTbl.glWindowPos2sMESA = missing_glWindowPos2sMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2sMESA == loader_glWindowPos2sMESA) {
      rCtx->dsp->emuTbl.glWindowPos2sMESA = driverTbl.glWindowPos2sMESA;
   }
   driverTbl.glWindowPos2sMESA(x, y);
}

static void REGAL_CALL missing_glWindowPos2svMESA(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glWindowPos2svMESA not available." );
}

static void REGAL_CALL loader_glWindowPos2svMESA(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos2svMESA, "glWindowPos2svMESA");
   if ( !driverTbl.glWindowPos2svMESA ) {
      driverTbl.glWindowPos2svMESA = missing_glWindowPos2svMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos2svMESA == loader_glWindowPos2svMESA) {
      rCtx->dsp->emuTbl.glWindowPos2svMESA = driverTbl.glWindowPos2svMESA;
   }
   driverTbl.glWindowPos2svMESA(v);
}

static void REGAL_CALL missing_glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glWindowPos3dMESA not available." );
}

static void REGAL_CALL loader_glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3dMESA, "glWindowPos3dMESA");
   if ( !driverTbl.glWindowPos3dMESA ) {
      driverTbl.glWindowPos3dMESA = missing_glWindowPos3dMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3dMESA == loader_glWindowPos3dMESA) {
      rCtx->dsp->emuTbl.glWindowPos3dMESA = driverTbl.glWindowPos3dMESA;
   }
   driverTbl.glWindowPos3dMESA(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3dvMESA(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glWindowPos3dvMESA not available." );
}

static void REGAL_CALL loader_glWindowPos3dvMESA(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3dvMESA, "glWindowPos3dvMESA");
   if ( !driverTbl.glWindowPos3dvMESA ) {
      driverTbl.glWindowPos3dvMESA = missing_glWindowPos3dvMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3dvMESA == loader_glWindowPos3dvMESA) {
      rCtx->dsp->emuTbl.glWindowPos3dvMESA = driverTbl.glWindowPos3dvMESA;
   }
   driverTbl.glWindowPos3dvMESA(v);
}

static void REGAL_CALL missing_glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glWindowPos3fMESA not available." );
}

static void REGAL_CALL loader_glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3fMESA, "glWindowPos3fMESA");
   if ( !driverTbl.glWindowPos3fMESA ) {
      driverTbl.glWindowPos3fMESA = missing_glWindowPos3fMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3fMESA == loader_glWindowPos3fMESA) {
      rCtx->dsp->emuTbl.glWindowPos3fMESA = driverTbl.glWindowPos3fMESA;
   }
   driverTbl.glWindowPos3fMESA(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3fvMESA(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glWindowPos3fvMESA not available." );
}

static void REGAL_CALL loader_glWindowPos3fvMESA(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3fvMESA, "glWindowPos3fvMESA");
   if ( !driverTbl.glWindowPos3fvMESA ) {
      driverTbl.glWindowPos3fvMESA = missing_glWindowPos3fvMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3fvMESA == loader_glWindowPos3fvMESA) {
      rCtx->dsp->emuTbl.glWindowPos3fvMESA = driverTbl.glWindowPos3fvMESA;
   }
   driverTbl.glWindowPos3fvMESA(v);
}

static void REGAL_CALL missing_glWindowPos3iMESA(GLint x, GLint y, GLint z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glWindowPos3iMESA not available." );
}

static void REGAL_CALL loader_glWindowPos3iMESA(GLint x, GLint y, GLint z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3iMESA, "glWindowPos3iMESA");
   if ( !driverTbl.glWindowPos3iMESA ) {
      driverTbl.glWindowPos3iMESA = missing_glWindowPos3iMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3iMESA == loader_glWindowPos3iMESA) {
      rCtx->dsp->emuTbl.glWindowPos3iMESA = driverTbl.glWindowPos3iMESA;
   }
   driverTbl.glWindowPos3iMESA(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3ivMESA(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glWindowPos3ivMESA not available." );
}

static void REGAL_CALL loader_glWindowPos3ivMESA(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3ivMESA, "glWindowPos3ivMESA");
   if ( !driverTbl.glWindowPos3ivMESA ) {
      driverTbl.glWindowPos3ivMESA = missing_glWindowPos3ivMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3ivMESA == loader_glWindowPos3ivMESA) {
      rCtx->dsp->emuTbl.glWindowPos3ivMESA = driverTbl.glWindowPos3ivMESA;
   }
   driverTbl.glWindowPos3ivMESA(v);
}

static void REGAL_CALL missing_glWindowPos3sMESA(GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glWindowPos3sMESA not available." );
}

static void REGAL_CALL loader_glWindowPos3sMESA(GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3sMESA, "glWindowPos3sMESA");
   if ( !driverTbl.glWindowPos3sMESA ) {
      driverTbl.glWindowPos3sMESA = missing_glWindowPos3sMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3sMESA == loader_glWindowPos3sMESA) {
      rCtx->dsp->emuTbl.glWindowPos3sMESA = driverTbl.glWindowPos3sMESA;
   }
   driverTbl.glWindowPos3sMESA(x, y, z);
}

static void REGAL_CALL missing_glWindowPos3svMESA(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glWindowPos3svMESA not available." );
}

static void REGAL_CALL loader_glWindowPos3svMESA(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos3svMESA, "glWindowPos3svMESA");
   if ( !driverTbl.glWindowPos3svMESA ) {
      driverTbl.glWindowPos3svMESA = missing_glWindowPos3svMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos3svMESA == loader_glWindowPos3svMESA) {
      rCtx->dsp->emuTbl.glWindowPos3svMESA = driverTbl.glWindowPos3svMESA;
   }
   driverTbl.glWindowPos3svMESA(v);
}

static void REGAL_CALL missing_glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glWindowPos4dMESA not available." );
}

static void REGAL_CALL loader_glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos4dMESA, "glWindowPos4dMESA");
   if ( !driverTbl.glWindowPos4dMESA ) {
      driverTbl.glWindowPos4dMESA = missing_glWindowPos4dMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos4dMESA == loader_glWindowPos4dMESA) {
      rCtx->dsp->emuTbl.glWindowPos4dMESA = driverTbl.glWindowPos4dMESA;
   }
   driverTbl.glWindowPos4dMESA(x, y, z, w);
}

static void REGAL_CALL missing_glWindowPos4dvMESA(const GLdouble *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glWindowPos4dvMESA not available." );
}

static void REGAL_CALL loader_glWindowPos4dvMESA(const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos4dvMESA, "glWindowPos4dvMESA");
   if ( !driverTbl.glWindowPos4dvMESA ) {
      driverTbl.glWindowPos4dvMESA = missing_glWindowPos4dvMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos4dvMESA == loader_glWindowPos4dvMESA) {
      rCtx->dsp->emuTbl.glWindowPos4dvMESA = driverTbl.glWindowPos4dvMESA;
   }
   driverTbl.glWindowPos4dvMESA(v);
}

static void REGAL_CALL missing_glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glWindowPos4fMESA not available." );
}

static void REGAL_CALL loader_glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos4fMESA, "glWindowPos4fMESA");
   if ( !driverTbl.glWindowPos4fMESA ) {
      driverTbl.glWindowPos4fMESA = missing_glWindowPos4fMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos4fMESA == loader_glWindowPos4fMESA) {
      rCtx->dsp->emuTbl.glWindowPos4fMESA = driverTbl.glWindowPos4fMESA;
   }
   driverTbl.glWindowPos4fMESA(x, y, z, w);
}

static void REGAL_CALL missing_glWindowPos4fvMESA(const GLfloat *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glWindowPos4fvMESA not available." );
}

static void REGAL_CALL loader_glWindowPos4fvMESA(const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos4fvMESA, "glWindowPos4fvMESA");
   if ( !driverTbl.glWindowPos4fvMESA ) {
      driverTbl.glWindowPos4fvMESA = missing_glWindowPos4fvMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos4fvMESA == loader_glWindowPos4fvMESA) {
      rCtx->dsp->emuTbl.glWindowPos4fvMESA = driverTbl.glWindowPos4fvMESA;
   }
   driverTbl.glWindowPos4fvMESA(v);
}

static void REGAL_CALL missing_glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glWindowPos4iMESA not available." );
}

static void REGAL_CALL loader_glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos4iMESA, "glWindowPos4iMESA");
   if ( !driverTbl.glWindowPos4iMESA ) {
      driverTbl.glWindowPos4iMESA = missing_glWindowPos4iMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos4iMESA == loader_glWindowPos4iMESA) {
      rCtx->dsp->emuTbl.glWindowPos4iMESA = driverTbl.glWindowPos4iMESA;
   }
   driverTbl.glWindowPos4iMESA(x, y, z, w);
}

static void REGAL_CALL missing_glWindowPos4ivMESA(const GLint *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glWindowPos4ivMESA not available." );
}

static void REGAL_CALL loader_glWindowPos4ivMESA(const GLint *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos4ivMESA, "glWindowPos4ivMESA");
   if ( !driverTbl.glWindowPos4ivMESA ) {
      driverTbl.glWindowPos4ivMESA = missing_glWindowPos4ivMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos4ivMESA == loader_glWindowPos4ivMESA) {
      rCtx->dsp->emuTbl.glWindowPos4ivMESA = driverTbl.glWindowPos4ivMESA;
   }
   driverTbl.glWindowPos4ivMESA(v);
}

static void REGAL_CALL missing_glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glWindowPos4sMESA not available." );
}

static void REGAL_CALL loader_glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos4sMESA, "glWindowPos4sMESA");
   if ( !driverTbl.glWindowPos4sMESA ) {
      driverTbl.glWindowPos4sMESA = missing_glWindowPos4sMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos4sMESA == loader_glWindowPos4sMESA) {
      rCtx->dsp->emuTbl.glWindowPos4sMESA = driverTbl.glWindowPos4sMESA;
   }
   driverTbl.glWindowPos4sMESA(x, y, z, w);
}

static void REGAL_CALL missing_glWindowPos4svMESA(const GLshort *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glWindowPos4svMESA not available." );
}

static void REGAL_CALL loader_glWindowPos4svMESA(const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWindowPos4svMESA, "glWindowPos4svMESA");
   if ( !driverTbl.glWindowPos4svMESA ) {
      driverTbl.glWindowPos4svMESA = missing_glWindowPos4svMESA;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWindowPos4svMESA == loader_glWindowPos4svMESA) {
      rCtx->dsp->emuTbl.glWindowPos4svMESA = driverTbl.glWindowPos4svMESA;
   }
   driverTbl.glWindowPos4svMESA(v);
}

// GL_NV_bindless_texture

static GLuint64 REGAL_CALL missing_glGetImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(layered);
   UNUSED_PARAMETER(layer);
   UNUSED_PARAMETER(format);
   Warning( "glGetImageHandleNV not available." );
  GLuint64  ret = (GLuint64 )0;
  return ret;
}

static GLuint64 REGAL_CALL loader_glGetImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetImageHandleNV, "glGetImageHandleNV");
   if ( !driverTbl.glGetImageHandleNV ) {
      driverTbl.glGetImageHandleNV = missing_glGetImageHandleNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetImageHandleNV == loader_glGetImageHandleNV) {
      rCtx->dsp->emuTbl.glGetImageHandleNV = driverTbl.glGetImageHandleNV;
   }
   return driverTbl.glGetImageHandleNV(texture, level, layered, layer, format);
}

static GLuint64 REGAL_CALL missing_glGetTextureHandleNV(GLuint texture)
{
   UNUSED_PARAMETER(texture);
   Warning( "glGetTextureHandleNV not available." );
  GLuint64  ret = (GLuint64 )0;
  return ret;
}

static GLuint64 REGAL_CALL loader_glGetTextureHandleNV(GLuint texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTextureHandleNV, "glGetTextureHandleNV");
   if ( !driverTbl.glGetTextureHandleNV ) {
      driverTbl.glGetTextureHandleNV = missing_glGetTextureHandleNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTextureHandleNV == loader_glGetTextureHandleNV) {
      rCtx->dsp->emuTbl.glGetTextureHandleNV = driverTbl.glGetTextureHandleNV;
   }
   return driverTbl.glGetTextureHandleNV(texture);
}

static GLuint64 REGAL_CALL missing_glGetTextureSamplerHandleNV(GLuint texture, GLuint sampler)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(sampler);
   Warning( "glGetTextureSamplerHandleNV not available." );
  GLuint64  ret = (GLuint64 )0;
  return ret;
}

static GLuint64 REGAL_CALL loader_glGetTextureSamplerHandleNV(GLuint texture, GLuint sampler)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTextureSamplerHandleNV, "glGetTextureSamplerHandleNV");
   if ( !driverTbl.glGetTextureSamplerHandleNV ) {
      driverTbl.glGetTextureSamplerHandleNV = missing_glGetTextureSamplerHandleNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTextureSamplerHandleNV == loader_glGetTextureSamplerHandleNV) {
      rCtx->dsp->emuTbl.glGetTextureSamplerHandleNV = driverTbl.glGetTextureSamplerHandleNV;
   }
   return driverTbl.glGetTextureSamplerHandleNV(texture, sampler);
}

static GLboolean REGAL_CALL missing_glIsImageHandleResidentNV(GLuint64 handle)
{
   UNUSED_PARAMETER(handle);
   Warning( "glIsImageHandleResidentNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsImageHandleResidentNV(GLuint64 handle)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsImageHandleResidentNV, "glIsImageHandleResidentNV");
   if ( !driverTbl.glIsImageHandleResidentNV ) {
      driverTbl.glIsImageHandleResidentNV = missing_glIsImageHandleResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsImageHandleResidentNV == loader_glIsImageHandleResidentNV) {
      rCtx->dsp->emuTbl.glIsImageHandleResidentNV = driverTbl.glIsImageHandleResidentNV;
   }
   return driverTbl.glIsImageHandleResidentNV(handle);
}

static GLboolean REGAL_CALL missing_glIsTextureHandleResidentNV(GLuint64 handle)
{
   UNUSED_PARAMETER(handle);
   Warning( "glIsTextureHandleResidentNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsTextureHandleResidentNV(GLuint64 handle)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsTextureHandleResidentNV, "glIsTextureHandleResidentNV");
   if ( !driverTbl.glIsTextureHandleResidentNV ) {
      driverTbl.glIsTextureHandleResidentNV = missing_glIsTextureHandleResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsTextureHandleResidentNV == loader_glIsTextureHandleResidentNV) {
      rCtx->dsp->emuTbl.glIsTextureHandleResidentNV = driverTbl.glIsTextureHandleResidentNV;
   }
   return driverTbl.glIsTextureHandleResidentNV(handle);
}

static void REGAL_CALL missing_glMakeImageHandleNonResidentNV(GLuint64 handle)
{
   UNUSED_PARAMETER(handle);
   Warning( "glMakeImageHandleNonResidentNV not available." );
}

static void REGAL_CALL loader_glMakeImageHandleNonResidentNV(GLuint64 handle)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMakeImageHandleNonResidentNV, "glMakeImageHandleNonResidentNV");
   if ( !driverTbl.glMakeImageHandleNonResidentNV ) {
      driverTbl.glMakeImageHandleNonResidentNV = missing_glMakeImageHandleNonResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMakeImageHandleNonResidentNV == loader_glMakeImageHandleNonResidentNV) {
      rCtx->dsp->emuTbl.glMakeImageHandleNonResidentNV = driverTbl.glMakeImageHandleNonResidentNV;
   }
   driverTbl.glMakeImageHandleNonResidentNV(handle);
}

static void REGAL_CALL missing_glMakeImageHandleResidentNV(GLuint64 handle, GLenum access)
{
   UNUSED_PARAMETER(handle);
   UNUSED_PARAMETER(access);
   Warning( "glMakeImageHandleResidentNV not available." );
}

static void REGAL_CALL loader_glMakeImageHandleResidentNV(GLuint64 handle, GLenum access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMakeImageHandleResidentNV, "glMakeImageHandleResidentNV");
   if ( !driverTbl.glMakeImageHandleResidentNV ) {
      driverTbl.glMakeImageHandleResidentNV = missing_glMakeImageHandleResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMakeImageHandleResidentNV == loader_glMakeImageHandleResidentNV) {
      rCtx->dsp->emuTbl.glMakeImageHandleResidentNV = driverTbl.glMakeImageHandleResidentNV;
   }
   driverTbl.glMakeImageHandleResidentNV(handle, access);
}

static void REGAL_CALL missing_glMakeTextureHandleNonResidentNV(GLuint64 handle)
{
   UNUSED_PARAMETER(handle);
   Warning( "glMakeTextureHandleNonResidentNV not available." );
}

static void REGAL_CALL loader_glMakeTextureHandleNonResidentNV(GLuint64 handle)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMakeTextureHandleNonResidentNV, "glMakeTextureHandleNonResidentNV");
   if ( !driverTbl.glMakeTextureHandleNonResidentNV ) {
      driverTbl.glMakeTextureHandleNonResidentNV = missing_glMakeTextureHandleNonResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMakeTextureHandleNonResidentNV == loader_glMakeTextureHandleNonResidentNV) {
      rCtx->dsp->emuTbl.glMakeTextureHandleNonResidentNV = driverTbl.glMakeTextureHandleNonResidentNV;
   }
   driverTbl.glMakeTextureHandleNonResidentNV(handle);
}

static void REGAL_CALL missing_glMakeTextureHandleResidentNV(GLuint64 handle)
{
   UNUSED_PARAMETER(handle);
   Warning( "glMakeTextureHandleResidentNV not available." );
}

static void REGAL_CALL loader_glMakeTextureHandleResidentNV(GLuint64 handle)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMakeTextureHandleResidentNV, "glMakeTextureHandleResidentNV");
   if ( !driverTbl.glMakeTextureHandleResidentNV ) {
      driverTbl.glMakeTextureHandleResidentNV = missing_glMakeTextureHandleResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMakeTextureHandleResidentNV == loader_glMakeTextureHandleResidentNV) {
      rCtx->dsp->emuTbl.glMakeTextureHandleResidentNV = driverTbl.glMakeTextureHandleResidentNV;
   }
   driverTbl.glMakeTextureHandleResidentNV(handle);
}

static void REGAL_CALL missing_glProgramUniformHandleui64NV(GLuint program, GLint location, GLuint64 value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformHandleui64NV not available." );
}

static void REGAL_CALL loader_glProgramUniformHandleui64NV(GLuint program, GLint location, GLuint64 value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformHandleui64NV, "glProgramUniformHandleui64NV");
   if ( !driverTbl.glProgramUniformHandleui64NV ) {
      driverTbl.glProgramUniformHandleui64NV = missing_glProgramUniformHandleui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformHandleui64NV == loader_glProgramUniformHandleui64NV) {
      rCtx->dsp->emuTbl.glProgramUniformHandleui64NV = driverTbl.glProgramUniformHandleui64NV;
   }
   driverTbl.glProgramUniformHandleui64NV(program, location, value);
}

static void REGAL_CALL missing_glProgramUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64 *values)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(values);
   Warning( "glProgramUniformHandleui64vNV not available." );
}

static void REGAL_CALL loader_glProgramUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64 *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformHandleui64vNV, "glProgramUniformHandleui64vNV");
   if ( !driverTbl.glProgramUniformHandleui64vNV ) {
      driverTbl.glProgramUniformHandleui64vNV = missing_glProgramUniformHandleui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformHandleui64vNV == loader_glProgramUniformHandleui64vNV) {
      rCtx->dsp->emuTbl.glProgramUniformHandleui64vNV = driverTbl.glProgramUniformHandleui64vNV;
   }
   driverTbl.glProgramUniformHandleui64vNV(program, location, count, values);
}

static void REGAL_CALL missing_glUniformHandleui64NV(GLint location, GLuint64 value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(value);
   Warning( "glUniformHandleui64NV not available." );
}

static void REGAL_CALL loader_glUniformHandleui64NV(GLint location, GLuint64 value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformHandleui64NV, "glUniformHandleui64NV");
   if ( !driverTbl.glUniformHandleui64NV ) {
      driverTbl.glUniformHandleui64NV = missing_glUniformHandleui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformHandleui64NV == loader_glUniformHandleui64NV) {
      rCtx->dsp->emuTbl.glUniformHandleui64NV = driverTbl.glUniformHandleui64NV;
   }
   driverTbl.glUniformHandleui64NV(location, value);
}

static void REGAL_CALL missing_glUniformHandleui64vNV(GLint location, GLsizei count, const GLuint64 *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniformHandleui64vNV not available." );
}

static void REGAL_CALL loader_glUniformHandleui64vNV(GLint location, GLsizei count, const GLuint64 *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformHandleui64vNV, "glUniformHandleui64vNV");
   if ( !driverTbl.glUniformHandleui64vNV ) {
      driverTbl.glUniformHandleui64vNV = missing_glUniformHandleui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformHandleui64vNV == loader_glUniformHandleui64vNV) {
      rCtx->dsp->emuTbl.glUniformHandleui64vNV = driverTbl.glUniformHandleui64vNV;
   }
   driverTbl.glUniformHandleui64vNV(location, count, value);
}

// GL_NV_conditional_render

static void REGAL_CALL missing_glBeginConditionalRenderNV(GLuint id, GLenum mode)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(mode);
   Warning( "glBeginConditionalRenderNV not available." );
}

static void REGAL_CALL loader_glBeginConditionalRenderNV(GLuint id, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBeginConditionalRenderNV, "glBeginConditionalRenderNV");
   if ( !driverTbl.glBeginConditionalRenderNV ) {
      driverTbl.glBeginConditionalRenderNV = missing_glBeginConditionalRenderNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBeginConditionalRenderNV == loader_glBeginConditionalRenderNV) {
      rCtx->dsp->emuTbl.glBeginConditionalRenderNV = driverTbl.glBeginConditionalRenderNV;
   }
   driverTbl.glBeginConditionalRenderNV(id, mode);
}

static void REGAL_CALL missing_glEndConditionalRenderNV(void)
{
   Warning( "glEndConditionalRenderNV not available." );
}

static void REGAL_CALL loader_glEndConditionalRenderNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndConditionalRenderNV, "glEndConditionalRenderNV");
   if ( !driverTbl.glEndConditionalRenderNV ) {
      driverTbl.glEndConditionalRenderNV = missing_glEndConditionalRenderNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndConditionalRenderNV == loader_glEndConditionalRenderNV) {
      rCtx->dsp->emuTbl.glEndConditionalRenderNV = driverTbl.glEndConditionalRenderNV;
   }
   driverTbl.glEndConditionalRenderNV();
}

// GL_NV_copy_image

static void REGAL_CALL missing_glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
   UNUSED_PARAMETER(srcName);
   UNUSED_PARAMETER(srcTarget);
   UNUSED_PARAMETER(srcLevel);
   UNUSED_PARAMETER(srcX);
   UNUSED_PARAMETER(srcY);
   UNUSED_PARAMETER(srcZ);
   UNUSED_PARAMETER(dstName);
   UNUSED_PARAMETER(dstTarget);
   UNUSED_PARAMETER(dstLevel);
   UNUSED_PARAMETER(dstX);
   UNUSED_PARAMETER(dstY);
   UNUSED_PARAMETER(dstZ);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   Warning( "glCopyImageSubDataNV not available." );
}

static void REGAL_CALL loader_glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyImageSubDataNV, "glCopyImageSubDataNV");
   if ( !driverTbl.glCopyImageSubDataNV ) {
      driverTbl.glCopyImageSubDataNV = missing_glCopyImageSubDataNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyImageSubDataNV == loader_glCopyImageSubDataNV) {
      rCtx->dsp->emuTbl.glCopyImageSubDataNV = driverTbl.glCopyImageSubDataNV;
   }
   driverTbl.glCopyImageSubDataNV(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
}

// GL_NV_depth_buffer_float

static void REGAL_CALL missing_glClearDepthdNV(GLdouble depth)
{
   UNUSED_PARAMETER(depth);
   Warning( "glClearDepthdNV not available." );
}

static void REGAL_CALL loader_glClearDepthdNV(GLdouble depth)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glClearDepthdNV, "glClearDepthdNV");
   if ( !driverTbl.glClearDepthdNV ) {
      driverTbl.glClearDepthdNV = missing_glClearDepthdNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glClearDepthdNV == loader_glClearDepthdNV) {
      rCtx->dsp->emuTbl.glClearDepthdNV = driverTbl.glClearDepthdNV;
   }
   driverTbl.glClearDepthdNV(depth);
}

static void REGAL_CALL missing_glDepthBoundsdNV(GLdouble zmin, GLdouble zmax)
{
   UNUSED_PARAMETER(zmin);
   UNUSED_PARAMETER(zmax);
   Warning( "glDepthBoundsdNV not available." );
}

static void REGAL_CALL loader_glDepthBoundsdNV(GLdouble zmin, GLdouble zmax)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDepthBoundsdNV, "glDepthBoundsdNV");
   if ( !driverTbl.glDepthBoundsdNV ) {
      driverTbl.glDepthBoundsdNV = missing_glDepthBoundsdNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDepthBoundsdNV == loader_glDepthBoundsdNV) {
      rCtx->dsp->emuTbl.glDepthBoundsdNV = driverTbl.glDepthBoundsdNV;
   }
   driverTbl.glDepthBoundsdNV(zmin, zmax);
}

static void REGAL_CALL missing_glDepthRangedNV(GLdouble zNear, GLdouble zFar)
{
   UNUSED_PARAMETER(zNear);
   UNUSED_PARAMETER(zFar);
   Warning( "glDepthRangedNV not available." );
}

static void REGAL_CALL loader_glDepthRangedNV(GLdouble zNear, GLdouble zFar)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDepthRangedNV, "glDepthRangedNV");
   if ( !driverTbl.glDepthRangedNV ) {
      driverTbl.glDepthRangedNV = missing_glDepthRangedNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDepthRangedNV == loader_glDepthRangedNV) {
      rCtx->dsp->emuTbl.glDepthRangedNV = driverTbl.glDepthRangedNV;
   }
   driverTbl.glDepthRangedNV(zNear, zFar);
}

// GL_NV_evaluators

static void REGAL_CALL missing_glEvalMapsNV(GLenum target, GLenum mode)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(mode);
   Warning( "glEvalMapsNV not available." );
}

static void REGAL_CALL loader_glEvalMapsNV(GLenum target, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEvalMapsNV, "glEvalMapsNV");
   if ( !driverTbl.glEvalMapsNV ) {
      driverTbl.glEvalMapsNV = missing_glEvalMapsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEvalMapsNV == loader_glEvalMapsNV) {
      rCtx->dsp->emuTbl.glEvalMapsNV = driverTbl.glEvalMapsNV;
   }
   driverTbl.glEvalMapsNV(target, mode);
}

static void REGAL_CALL missing_glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMapAttribParameterfvNV not available." );
}

static void REGAL_CALL loader_glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMapAttribParameterfvNV, "glGetMapAttribParameterfvNV");
   if ( !driverTbl.glGetMapAttribParameterfvNV ) {
      driverTbl.glGetMapAttribParameterfvNV = missing_glGetMapAttribParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMapAttribParameterfvNV == loader_glGetMapAttribParameterfvNV) {
      rCtx->dsp->emuTbl.glGetMapAttribParameterfvNV = driverTbl.glGetMapAttribParameterfvNV;
   }
   driverTbl.glGetMapAttribParameterfvNV(target, index, pname, params);
}

static void REGAL_CALL missing_glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMapAttribParameterivNV not available." );
}

static void REGAL_CALL loader_glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMapAttribParameterivNV, "glGetMapAttribParameterivNV");
   if ( !driverTbl.glGetMapAttribParameterivNV ) {
      driverTbl.glGetMapAttribParameterivNV = missing_glGetMapAttribParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMapAttribParameterivNV == loader_glGetMapAttribParameterivNV) {
      rCtx->dsp->emuTbl.glGetMapAttribParameterivNV = driverTbl.glGetMapAttribParameterivNV;
   }
   driverTbl.glGetMapAttribParameterivNV(target, index, pname, params);
}

static void REGAL_CALL missing_glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(packed);
   UNUSED_PARAMETER(points);
   Warning( "glGetMapControlPointsNV not available." );
}

static void REGAL_CALL loader_glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMapControlPointsNV, "glGetMapControlPointsNV");
   if ( !driverTbl.glGetMapControlPointsNV ) {
      driverTbl.glGetMapControlPointsNV = missing_glGetMapControlPointsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMapControlPointsNV == loader_glGetMapControlPointsNV) {
      rCtx->dsp->emuTbl.glGetMapControlPointsNV = driverTbl.glGetMapControlPointsNV;
   }
   driverTbl.glGetMapControlPointsNV(target, index, type, ustride, vstride, packed, points);
}

static void REGAL_CALL missing_glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMapParameterfvNV not available." );
}

static void REGAL_CALL loader_glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMapParameterfvNV, "glGetMapParameterfvNV");
   if ( !driverTbl.glGetMapParameterfvNV ) {
      driverTbl.glGetMapParameterfvNV = missing_glGetMapParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMapParameterfvNV == loader_glGetMapParameterfvNV) {
      rCtx->dsp->emuTbl.glGetMapParameterfvNV = driverTbl.glGetMapParameterfvNV;
   }
   driverTbl.glGetMapParameterfvNV(target, pname, params);
}

static void REGAL_CALL missing_glGetMapParameterivNV(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetMapParameterivNV not available." );
}

static void REGAL_CALL loader_glGetMapParameterivNV(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMapParameterivNV, "glGetMapParameterivNV");
   if ( !driverTbl.glGetMapParameterivNV ) {
      driverTbl.glGetMapParameterivNV = missing_glGetMapParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMapParameterivNV == loader_glGetMapParameterivNV) {
      rCtx->dsp->emuTbl.glGetMapParameterivNV = driverTbl.glGetMapParameterivNV;
   }
   driverTbl.glGetMapParameterivNV(target, pname, params);
}

static void REGAL_CALL missing_glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(uorder);
   UNUSED_PARAMETER(vorder);
   UNUSED_PARAMETER(packed);
   UNUSED_PARAMETER(points);
   Warning( "glMapControlPointsNV not available." );
}

static void REGAL_CALL loader_glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapControlPointsNV, "glMapControlPointsNV");
   if ( !driverTbl.glMapControlPointsNV ) {
      driverTbl.glMapControlPointsNV = missing_glMapControlPointsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapControlPointsNV == loader_glMapControlPointsNV) {
      rCtx->dsp->emuTbl.glMapControlPointsNV = driverTbl.glMapControlPointsNV;
   }
   driverTbl.glMapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed, points);
}

static void REGAL_CALL missing_glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glMapParameterfvNV not available." );
}

static void REGAL_CALL loader_glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapParameterfvNV, "glMapParameterfvNV");
   if ( !driverTbl.glMapParameterfvNV ) {
      driverTbl.glMapParameterfvNV = missing_glMapParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapParameterfvNV == loader_glMapParameterfvNV) {
      rCtx->dsp->emuTbl.glMapParameterfvNV = driverTbl.glMapParameterfvNV;
   }
   driverTbl.glMapParameterfvNV(target, pname, params);
}

static void REGAL_CALL missing_glMapParameterivNV(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glMapParameterivNV not available." );
}

static void REGAL_CALL loader_glMapParameterivNV(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMapParameterivNV, "glMapParameterivNV");
   if ( !driverTbl.glMapParameterivNV ) {
      driverTbl.glMapParameterivNV = missing_glMapParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMapParameterivNV == loader_glMapParameterivNV) {
      rCtx->dsp->emuTbl.glMapParameterivNV = driverTbl.glMapParameterivNV;
   }
   driverTbl.glMapParameterivNV(target, pname, params);
}

// GL_NV_explicit_multisample

static void REGAL_CALL missing_glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat *val)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(val);
   Warning( "glGetMultisamplefvNV not available." );
}

static void REGAL_CALL loader_glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat *val)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetMultisamplefvNV, "glGetMultisamplefvNV");
   if ( !driverTbl.glGetMultisamplefvNV ) {
      driverTbl.glGetMultisamplefvNV = missing_glGetMultisamplefvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetMultisamplefvNV == loader_glGetMultisamplefvNV) {
      rCtx->dsp->emuTbl.glGetMultisamplefvNV = driverTbl.glGetMultisamplefvNV;
   }
   driverTbl.glGetMultisamplefvNV(pname, index, val);
}

static void REGAL_CALL missing_glSampleMaskIndexedNV(GLuint index, GLbitfield mask)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(mask);
   Warning( "glSampleMaskIndexedNV not available." );
}

static void REGAL_CALL loader_glSampleMaskIndexedNV(GLuint index, GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSampleMaskIndexedNV, "glSampleMaskIndexedNV");
   if ( !driverTbl.glSampleMaskIndexedNV ) {
      driverTbl.glSampleMaskIndexedNV = missing_glSampleMaskIndexedNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSampleMaskIndexedNV == loader_glSampleMaskIndexedNV) {
      rCtx->dsp->emuTbl.glSampleMaskIndexedNV = driverTbl.glSampleMaskIndexedNV;
   }
   driverTbl.glSampleMaskIndexedNV(index, mask);
}

static void REGAL_CALL missing_glTexRenderbufferNV(GLenum target, GLuint renderbuffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(renderbuffer);
   Warning( "glTexRenderbufferNV not available." );
}

static void REGAL_CALL loader_glTexRenderbufferNV(GLenum target, GLuint renderbuffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexRenderbufferNV, "glTexRenderbufferNV");
   if ( !driverTbl.glTexRenderbufferNV ) {
      driverTbl.glTexRenderbufferNV = missing_glTexRenderbufferNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexRenderbufferNV == loader_glTexRenderbufferNV) {
      rCtx->dsp->emuTbl.glTexRenderbufferNV = driverTbl.glTexRenderbufferNV;
   }
   driverTbl.glTexRenderbufferNV(target, renderbuffer);
}

// GL_NV_fence

static void REGAL_CALL missing_glDeleteFencesNV(GLsizei n, const GLuint *fences)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(fences);
   Warning( "glDeleteFencesNV not available." );
}

static void REGAL_CALL loader_glDeleteFencesNV(GLsizei n, const GLuint *fences)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteFencesNV, "glDeleteFencesNV");
   if ( !driverTbl.glDeleteFencesNV ) {
      driverTbl.glDeleteFencesNV = missing_glDeleteFencesNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteFencesNV == loader_glDeleteFencesNV) {
      rCtx->dsp->emuTbl.glDeleteFencesNV = driverTbl.glDeleteFencesNV;
   }
   driverTbl.glDeleteFencesNV(n, fences);
}

static void REGAL_CALL missing_glFinishFenceNV(GLuint fence)
{
   UNUSED_PARAMETER(fence);
   Warning( "glFinishFenceNV not available." );
}

static void REGAL_CALL loader_glFinishFenceNV(GLuint fence)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFinishFenceNV, "glFinishFenceNV");
   if ( !driverTbl.glFinishFenceNV ) {
      driverTbl.glFinishFenceNV = missing_glFinishFenceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFinishFenceNV == loader_glFinishFenceNV) {
      rCtx->dsp->emuTbl.glFinishFenceNV = driverTbl.glFinishFenceNV;
   }
   driverTbl.glFinishFenceNV(fence);
}

static void REGAL_CALL missing_glGenFencesNV(GLsizei n, GLuint *fences)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(fences);
   Warning( "glGenFencesNV not available." );
}

static void REGAL_CALL loader_glGenFencesNV(GLsizei n, GLuint *fences)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenFencesNV, "glGenFencesNV");
   if ( !driverTbl.glGenFencesNV ) {
      driverTbl.glGenFencesNV = missing_glGenFencesNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenFencesNV == loader_glGenFencesNV) {
      rCtx->dsp->emuTbl.glGenFencesNV = driverTbl.glGenFencesNV;
   }
   driverTbl.glGenFencesNV(n, fences);
}

static void REGAL_CALL missing_glGetFenceivNV(GLuint fence, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(fence);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFenceivNV not available." );
}

static void REGAL_CALL loader_glGetFenceivNV(GLuint fence, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFenceivNV, "glGetFenceivNV");
   if ( !driverTbl.glGetFenceivNV ) {
      driverTbl.glGetFenceivNV = missing_glGetFenceivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFenceivNV == loader_glGetFenceivNV) {
      rCtx->dsp->emuTbl.glGetFenceivNV = driverTbl.glGetFenceivNV;
   }
   driverTbl.glGetFenceivNV(fence, pname, params);
}

static GLboolean REGAL_CALL missing_glIsFenceNV(GLuint fence)
{
   UNUSED_PARAMETER(fence);
   Warning( "glIsFenceNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsFenceNV(GLuint fence)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsFenceNV, "glIsFenceNV");
   if ( !driverTbl.glIsFenceNV ) {
      driverTbl.glIsFenceNV = missing_glIsFenceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsFenceNV == loader_glIsFenceNV) {
      rCtx->dsp->emuTbl.glIsFenceNV = driverTbl.glIsFenceNV;
   }
   return driverTbl.glIsFenceNV(fence);
}

static void REGAL_CALL missing_glSetFenceNV(GLuint fence, GLenum condition)
{
   UNUSED_PARAMETER(fence);
   UNUSED_PARAMETER(condition);
   Warning( "glSetFenceNV not available." );
}

static void REGAL_CALL loader_glSetFenceNV(GLuint fence, GLenum condition)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSetFenceNV, "glSetFenceNV");
   if ( !driverTbl.glSetFenceNV ) {
      driverTbl.glSetFenceNV = missing_glSetFenceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSetFenceNV == loader_glSetFenceNV) {
      rCtx->dsp->emuTbl.glSetFenceNV = driverTbl.glSetFenceNV;
   }
   driverTbl.glSetFenceNV(fence, condition);
}

static GLboolean REGAL_CALL missing_glTestFenceNV(GLuint fence)
{
   UNUSED_PARAMETER(fence);
   Warning( "glTestFenceNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glTestFenceNV(GLuint fence)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTestFenceNV, "glTestFenceNV");
   if ( !driverTbl.glTestFenceNV ) {
      driverTbl.glTestFenceNV = missing_glTestFenceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTestFenceNV == loader_glTestFenceNV) {
      rCtx->dsp->emuTbl.glTestFenceNV = driverTbl.glTestFenceNV;
   }
   return driverTbl.glTestFenceNV(fence);
}

// GL_NV_fragment_program

static void REGAL_CALL missing_glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramNamedParameterdvNV not available." );
}

static void REGAL_CALL loader_glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramNamedParameterdvNV, "glGetProgramNamedParameterdvNV");
   if ( !driverTbl.glGetProgramNamedParameterdvNV ) {
      driverTbl.glGetProgramNamedParameterdvNV = missing_glGetProgramNamedParameterdvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramNamedParameterdvNV == loader_glGetProgramNamedParameterdvNV) {
      rCtx->dsp->emuTbl.glGetProgramNamedParameterdvNV = driverTbl.glGetProgramNamedParameterdvNV;
   }
   driverTbl.glGetProgramNamedParameterdvNV(id, len, name, params);
}

static void REGAL_CALL missing_glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramNamedParameterfvNV not available." );
}

static void REGAL_CALL loader_glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramNamedParameterfvNV, "glGetProgramNamedParameterfvNV");
   if ( !driverTbl.glGetProgramNamedParameterfvNV ) {
      driverTbl.glGetProgramNamedParameterfvNV = missing_glGetProgramNamedParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramNamedParameterfvNV == loader_glGetProgramNamedParameterfvNV) {
      rCtx->dsp->emuTbl.glGetProgramNamedParameterfvNV = driverTbl.glGetProgramNamedParameterfvNV;
   }
   driverTbl.glGetProgramNamedParameterfvNV(id, len, name, params);
}

static void REGAL_CALL missing_glProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramNamedParameter4dNV not available." );
}

static void REGAL_CALL loader_glProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramNamedParameter4dNV, "glProgramNamedParameter4dNV");
   if ( !driverTbl.glProgramNamedParameter4dNV ) {
      driverTbl.glProgramNamedParameter4dNV = missing_glProgramNamedParameter4dNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramNamedParameter4dNV == loader_glProgramNamedParameter4dNV) {
      rCtx->dsp->emuTbl.glProgramNamedParameter4dNV = driverTbl.glProgramNamedParameter4dNV;
   }
   driverTbl.glProgramNamedParameter4dNV(id, len, name, x, y, z, w);
}

static void REGAL_CALL missing_glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(v);
   Warning( "glProgramNamedParameter4dvNV not available." );
}

static void REGAL_CALL loader_glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramNamedParameter4dvNV, "glProgramNamedParameter4dvNV");
   if ( !driverTbl.glProgramNamedParameter4dvNV ) {
      driverTbl.glProgramNamedParameter4dvNV = missing_glProgramNamedParameter4dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramNamedParameter4dvNV == loader_glProgramNamedParameter4dvNV) {
      rCtx->dsp->emuTbl.glProgramNamedParameter4dvNV = driverTbl.glProgramNamedParameter4dvNV;
   }
   driverTbl.glProgramNamedParameter4dvNV(id, len, name, v);
}

static void REGAL_CALL missing_glProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramNamedParameter4fNV not available." );
}

static void REGAL_CALL loader_glProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramNamedParameter4fNV, "glProgramNamedParameter4fNV");
   if ( !driverTbl.glProgramNamedParameter4fNV ) {
      driverTbl.glProgramNamedParameter4fNV = missing_glProgramNamedParameter4fNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramNamedParameter4fNV == loader_glProgramNamedParameter4fNV) {
      rCtx->dsp->emuTbl.glProgramNamedParameter4fNV = driverTbl.glProgramNamedParameter4fNV;
   }
   driverTbl.glProgramNamedParameter4fNV(id, len, name, x, y, z, w);
}

static void REGAL_CALL missing_glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(v);
   Warning( "glProgramNamedParameter4fvNV not available." );
}

static void REGAL_CALL loader_glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramNamedParameter4fvNV, "glProgramNamedParameter4fvNV");
   if ( !driverTbl.glProgramNamedParameter4fvNV ) {
      driverTbl.glProgramNamedParameter4fvNV = missing_glProgramNamedParameter4fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramNamedParameter4fvNV == loader_glProgramNamedParameter4fvNV) {
      rCtx->dsp->emuTbl.glProgramNamedParameter4fvNV = driverTbl.glProgramNamedParameter4fvNV;
   }
   driverTbl.glProgramNamedParameter4fvNV(id, len, name, v);
}

// GL_NV_framebuffer_multisample_coverage

static void REGAL_CALL missing_glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(coverageSamples);
   UNUSED_PARAMETER(colorSamples);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glRenderbufferStorageMultisampleCoverageNV not available." );
}

static void REGAL_CALL loader_glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRenderbufferStorageMultisampleCoverageNV, "glRenderbufferStorageMultisampleCoverageNV");
   if ( !driverTbl.glRenderbufferStorageMultisampleCoverageNV ) {
      driverTbl.glRenderbufferStorageMultisampleCoverageNV = missing_glRenderbufferStorageMultisampleCoverageNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRenderbufferStorageMultisampleCoverageNV == loader_glRenderbufferStorageMultisampleCoverageNV) {
      rCtx->dsp->emuTbl.glRenderbufferStorageMultisampleCoverageNV = driverTbl.glRenderbufferStorageMultisampleCoverageNV;
   }
   driverTbl.glRenderbufferStorageMultisampleCoverageNV(target, coverageSamples, colorSamples, internalformat, width, height);
}

// GL_NV_geometry_program4

static void REGAL_CALL missing_glProgramVertexLimitNV(GLenum target, GLint limit)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(limit);
   Warning( "glProgramVertexLimitNV not available." );
}

static void REGAL_CALL loader_glProgramVertexLimitNV(GLenum target, GLint limit)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramVertexLimitNV, "glProgramVertexLimitNV");
   if ( !driverTbl.glProgramVertexLimitNV ) {
      driverTbl.glProgramVertexLimitNV = missing_glProgramVertexLimitNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramVertexLimitNV == loader_glProgramVertexLimitNV) {
      rCtx->dsp->emuTbl.glProgramVertexLimitNV = driverTbl.glProgramVertexLimitNV;
   }
   driverTbl.glProgramVertexLimitNV(target, limit);
}

// GL_NV_gpu_program4

static void REGAL_CALL missing_glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramEnvParameterIivNV not available." );
}

static void REGAL_CALL loader_glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramEnvParameterIivNV, "glGetProgramEnvParameterIivNV");
   if ( !driverTbl.glGetProgramEnvParameterIivNV ) {
      driverTbl.glGetProgramEnvParameterIivNV = missing_glGetProgramEnvParameterIivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramEnvParameterIivNV == loader_glGetProgramEnvParameterIivNV) {
      rCtx->dsp->emuTbl.glGetProgramEnvParameterIivNV = driverTbl.glGetProgramEnvParameterIivNV;
   }
   driverTbl.glGetProgramEnvParameterIivNV(target, index, params);
}

static void REGAL_CALL missing_glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramEnvParameterIuivNV not available." );
}

static void REGAL_CALL loader_glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramEnvParameterIuivNV, "glGetProgramEnvParameterIuivNV");
   if ( !driverTbl.glGetProgramEnvParameterIuivNV ) {
      driverTbl.glGetProgramEnvParameterIuivNV = missing_glGetProgramEnvParameterIuivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramEnvParameterIuivNV == loader_glGetProgramEnvParameterIuivNV) {
      rCtx->dsp->emuTbl.glGetProgramEnvParameterIuivNV = driverTbl.glGetProgramEnvParameterIuivNV;
   }
   driverTbl.glGetProgramEnvParameterIuivNV(target, index, params);
}

static void REGAL_CALL missing_glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramLocalParameterIivNV not available." );
}

static void REGAL_CALL loader_glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramLocalParameterIivNV, "glGetProgramLocalParameterIivNV");
   if ( !driverTbl.glGetProgramLocalParameterIivNV ) {
      driverTbl.glGetProgramLocalParameterIivNV = missing_glGetProgramLocalParameterIivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramLocalParameterIivNV == loader_glGetProgramLocalParameterIivNV) {
      rCtx->dsp->emuTbl.glGetProgramLocalParameterIivNV = driverTbl.glGetProgramLocalParameterIivNV;
   }
   driverTbl.glGetProgramLocalParameterIivNV(target, index, params);
}

static void REGAL_CALL missing_glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramLocalParameterIuivNV not available." );
}

static void REGAL_CALL loader_glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramLocalParameterIuivNV, "glGetProgramLocalParameterIuivNV");
   if ( !driverTbl.glGetProgramLocalParameterIuivNV ) {
      driverTbl.glGetProgramLocalParameterIuivNV = missing_glGetProgramLocalParameterIuivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramLocalParameterIuivNV == loader_glGetProgramLocalParameterIuivNV) {
      rCtx->dsp->emuTbl.glGetProgramLocalParameterIuivNV = driverTbl.glGetProgramLocalParameterIuivNV;
   }
   driverTbl.glGetProgramLocalParameterIuivNV(target, index, params);
}

static void REGAL_CALL missing_glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramEnvParameterI4iNV not available." );
}

static void REGAL_CALL loader_glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramEnvParameterI4iNV, "glProgramEnvParameterI4iNV");
   if ( !driverTbl.glProgramEnvParameterI4iNV ) {
      driverTbl.glProgramEnvParameterI4iNV = missing_glProgramEnvParameterI4iNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramEnvParameterI4iNV == loader_glProgramEnvParameterI4iNV) {
      rCtx->dsp->emuTbl.glProgramEnvParameterI4iNV = driverTbl.glProgramEnvParameterI4iNV;
   }
   driverTbl.glProgramEnvParameterI4iNV(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glProgramEnvParameterI4ivNV not available." );
}

static void REGAL_CALL loader_glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramEnvParameterI4ivNV, "glProgramEnvParameterI4ivNV");
   if ( !driverTbl.glProgramEnvParameterI4ivNV ) {
      driverTbl.glProgramEnvParameterI4ivNV = missing_glProgramEnvParameterI4ivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramEnvParameterI4ivNV == loader_glProgramEnvParameterI4ivNV) {
      rCtx->dsp->emuTbl.glProgramEnvParameterI4ivNV = driverTbl.glProgramEnvParameterI4ivNV;
   }
   driverTbl.glProgramEnvParameterI4ivNV(target, index, params);
}

static void REGAL_CALL missing_glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramEnvParameterI4uiNV not available." );
}

static void REGAL_CALL loader_glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramEnvParameterI4uiNV, "glProgramEnvParameterI4uiNV");
   if ( !driverTbl.glProgramEnvParameterI4uiNV ) {
      driverTbl.glProgramEnvParameterI4uiNV = missing_glProgramEnvParameterI4uiNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramEnvParameterI4uiNV == loader_glProgramEnvParameterI4uiNV) {
      rCtx->dsp->emuTbl.glProgramEnvParameterI4uiNV = driverTbl.glProgramEnvParameterI4uiNV;
   }
   driverTbl.glProgramEnvParameterI4uiNV(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glProgramEnvParameterI4uivNV not available." );
}

static void REGAL_CALL loader_glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramEnvParameterI4uivNV, "glProgramEnvParameterI4uivNV");
   if ( !driverTbl.glProgramEnvParameterI4uivNV ) {
      driverTbl.glProgramEnvParameterI4uivNV = missing_glProgramEnvParameterI4uivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramEnvParameterI4uivNV == loader_glProgramEnvParameterI4uivNV) {
      rCtx->dsp->emuTbl.glProgramEnvParameterI4uivNV = driverTbl.glProgramEnvParameterI4uivNV;
   }
   driverTbl.glProgramEnvParameterI4uivNV(target, index, params);
}

static void REGAL_CALL missing_glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "glProgramEnvParametersI4ivNV not available." );
}

static void REGAL_CALL loader_glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramEnvParametersI4ivNV, "glProgramEnvParametersI4ivNV");
   if ( !driverTbl.glProgramEnvParametersI4ivNV ) {
      driverTbl.glProgramEnvParametersI4ivNV = missing_glProgramEnvParametersI4ivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramEnvParametersI4ivNV == loader_glProgramEnvParametersI4ivNV) {
      rCtx->dsp->emuTbl.glProgramEnvParametersI4ivNV = driverTbl.glProgramEnvParametersI4ivNV;
   }
   driverTbl.glProgramEnvParametersI4ivNV(target, index, count, params);
}

static void REGAL_CALL missing_glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "glProgramEnvParametersI4uivNV not available." );
}

static void REGAL_CALL loader_glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramEnvParametersI4uivNV, "glProgramEnvParametersI4uivNV");
   if ( !driverTbl.glProgramEnvParametersI4uivNV ) {
      driverTbl.glProgramEnvParametersI4uivNV = missing_glProgramEnvParametersI4uivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramEnvParametersI4uivNV == loader_glProgramEnvParametersI4uivNV) {
      rCtx->dsp->emuTbl.glProgramEnvParametersI4uivNV = driverTbl.glProgramEnvParametersI4uivNV;
   }
   driverTbl.glProgramEnvParametersI4uivNV(target, index, count, params);
}

static void REGAL_CALL missing_glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramLocalParameterI4iNV not available." );
}

static void REGAL_CALL loader_glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramLocalParameterI4iNV, "glProgramLocalParameterI4iNV");
   if ( !driverTbl.glProgramLocalParameterI4iNV ) {
      driverTbl.glProgramLocalParameterI4iNV = missing_glProgramLocalParameterI4iNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramLocalParameterI4iNV == loader_glProgramLocalParameterI4iNV) {
      rCtx->dsp->emuTbl.glProgramLocalParameterI4iNV = driverTbl.glProgramLocalParameterI4iNV;
   }
   driverTbl.glProgramLocalParameterI4iNV(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glProgramLocalParameterI4ivNV not available." );
}

static void REGAL_CALL loader_glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramLocalParameterI4ivNV, "glProgramLocalParameterI4ivNV");
   if ( !driverTbl.glProgramLocalParameterI4ivNV ) {
      driverTbl.glProgramLocalParameterI4ivNV = missing_glProgramLocalParameterI4ivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramLocalParameterI4ivNV == loader_glProgramLocalParameterI4ivNV) {
      rCtx->dsp->emuTbl.glProgramLocalParameterI4ivNV = driverTbl.glProgramLocalParameterI4ivNV;
   }
   driverTbl.glProgramLocalParameterI4ivNV(target, index, params);
}

static void REGAL_CALL missing_glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramLocalParameterI4uiNV not available." );
}

static void REGAL_CALL loader_glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramLocalParameterI4uiNV, "glProgramLocalParameterI4uiNV");
   if ( !driverTbl.glProgramLocalParameterI4uiNV ) {
      driverTbl.glProgramLocalParameterI4uiNV = missing_glProgramLocalParameterI4uiNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramLocalParameterI4uiNV == loader_glProgramLocalParameterI4uiNV) {
      rCtx->dsp->emuTbl.glProgramLocalParameterI4uiNV = driverTbl.glProgramLocalParameterI4uiNV;
   }
   driverTbl.glProgramLocalParameterI4uiNV(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(params);
   Warning( "glProgramLocalParameterI4uivNV not available." );
}

static void REGAL_CALL loader_glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramLocalParameterI4uivNV, "glProgramLocalParameterI4uivNV");
   if ( !driverTbl.glProgramLocalParameterI4uivNV ) {
      driverTbl.glProgramLocalParameterI4uivNV = missing_glProgramLocalParameterI4uivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramLocalParameterI4uivNV == loader_glProgramLocalParameterI4uivNV) {
      rCtx->dsp->emuTbl.glProgramLocalParameterI4uivNV = driverTbl.glProgramLocalParameterI4uivNV;
   }
   driverTbl.glProgramLocalParameterI4uivNV(target, index, params);
}

static void REGAL_CALL missing_glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "glProgramLocalParametersI4ivNV not available." );
}

static void REGAL_CALL loader_glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramLocalParametersI4ivNV, "glProgramLocalParametersI4ivNV");
   if ( !driverTbl.glProgramLocalParametersI4ivNV ) {
      driverTbl.glProgramLocalParametersI4ivNV = missing_glProgramLocalParametersI4ivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramLocalParametersI4ivNV == loader_glProgramLocalParametersI4ivNV) {
      rCtx->dsp->emuTbl.glProgramLocalParametersI4ivNV = driverTbl.glProgramLocalParametersI4ivNV;
   }
   driverTbl.glProgramLocalParametersI4ivNV(target, index, count, params);
}

static void REGAL_CALL missing_glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "glProgramLocalParametersI4uivNV not available." );
}

static void REGAL_CALL loader_glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramLocalParametersI4uivNV, "glProgramLocalParametersI4uivNV");
   if ( !driverTbl.glProgramLocalParametersI4uivNV ) {
      driverTbl.glProgramLocalParametersI4uivNV = missing_glProgramLocalParametersI4uivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramLocalParametersI4uivNV == loader_glProgramLocalParametersI4uivNV) {
      rCtx->dsp->emuTbl.glProgramLocalParametersI4uivNV = driverTbl.glProgramLocalParametersI4uivNV;
   }
   driverTbl.glProgramLocalParametersI4uivNV(target, index, count, params);
}

// GL_NV_gpu_shader5

static void REGAL_CALL missing_glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "glGetUniformi64vNV not available." );
}

static void REGAL_CALL loader_glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformi64vNV, "glGetUniformi64vNV");
   if ( !driverTbl.glGetUniformi64vNV ) {
      driverTbl.glGetUniformi64vNV = missing_glGetUniformi64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformi64vNV == loader_glGetUniformi64vNV) {
      rCtx->dsp->emuTbl.glGetUniformi64vNV = driverTbl.glGetUniformi64vNV;
   }
   driverTbl.glGetUniformi64vNV(program, location, params);
}

static void REGAL_CALL missing_glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "glProgramUniform1i64NV not available." );
}

static void REGAL_CALL loader_glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1i64NV, "glProgramUniform1i64NV");
   if ( !driverTbl.glProgramUniform1i64NV ) {
      driverTbl.glProgramUniform1i64NV = missing_glProgramUniform1i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1i64NV == loader_glProgramUniform1i64NV) {
      rCtx->dsp->emuTbl.glProgramUniform1i64NV = driverTbl.glProgramUniform1i64NV;
   }
   driverTbl.glProgramUniform1i64NV(program, location, x);
}

static void REGAL_CALL missing_glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform1i64vNV not available." );
}

static void REGAL_CALL loader_glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1i64vNV, "glProgramUniform1i64vNV");
   if ( !driverTbl.glProgramUniform1i64vNV ) {
      driverTbl.glProgramUniform1i64vNV = missing_glProgramUniform1i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1i64vNV == loader_glProgramUniform1i64vNV) {
      rCtx->dsp->emuTbl.glProgramUniform1i64vNV = driverTbl.glProgramUniform1i64vNV;
   }
   driverTbl.glProgramUniform1i64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "glProgramUniform1ui64NV not available." );
}

static void REGAL_CALL loader_glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1ui64NV, "glProgramUniform1ui64NV");
   if ( !driverTbl.glProgramUniform1ui64NV ) {
      driverTbl.glProgramUniform1ui64NV = missing_glProgramUniform1ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1ui64NV == loader_glProgramUniform1ui64NV) {
      rCtx->dsp->emuTbl.glProgramUniform1ui64NV = driverTbl.glProgramUniform1ui64NV;
   }
   driverTbl.glProgramUniform1ui64NV(program, location, x);
}

static void REGAL_CALL missing_glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform1ui64vNV not available." );
}

static void REGAL_CALL loader_glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform1ui64vNV, "glProgramUniform1ui64vNV");
   if ( !driverTbl.glProgramUniform1ui64vNV ) {
      driverTbl.glProgramUniform1ui64vNV = missing_glProgramUniform1ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform1ui64vNV == loader_glProgramUniform1ui64vNV) {
      rCtx->dsp->emuTbl.glProgramUniform1ui64vNV = driverTbl.glProgramUniform1ui64vNV;
   }
   driverTbl.glProgramUniform1ui64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glProgramUniform2i64NV not available." );
}

static void REGAL_CALL loader_glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2i64NV, "glProgramUniform2i64NV");
   if ( !driverTbl.glProgramUniform2i64NV ) {
      driverTbl.glProgramUniform2i64NV = missing_glProgramUniform2i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2i64NV == loader_glProgramUniform2i64NV) {
      rCtx->dsp->emuTbl.glProgramUniform2i64NV = driverTbl.glProgramUniform2i64NV;
   }
   driverTbl.glProgramUniform2i64NV(program, location, x, y);
}

static void REGAL_CALL missing_glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform2i64vNV not available." );
}

static void REGAL_CALL loader_glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2i64vNV, "glProgramUniform2i64vNV");
   if ( !driverTbl.glProgramUniform2i64vNV ) {
      driverTbl.glProgramUniform2i64vNV = missing_glProgramUniform2i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2i64vNV == loader_glProgramUniform2i64vNV) {
      rCtx->dsp->emuTbl.glProgramUniform2i64vNV = driverTbl.glProgramUniform2i64vNV;
   }
   driverTbl.glProgramUniform2i64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glProgramUniform2ui64NV not available." );
}

static void REGAL_CALL loader_glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2ui64NV, "glProgramUniform2ui64NV");
   if ( !driverTbl.glProgramUniform2ui64NV ) {
      driverTbl.glProgramUniform2ui64NV = missing_glProgramUniform2ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2ui64NV == loader_glProgramUniform2ui64NV) {
      rCtx->dsp->emuTbl.glProgramUniform2ui64NV = driverTbl.glProgramUniform2ui64NV;
   }
   driverTbl.glProgramUniform2ui64NV(program, location, x, y);
}

static void REGAL_CALL missing_glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform2ui64vNV not available." );
}

static void REGAL_CALL loader_glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform2ui64vNV, "glProgramUniform2ui64vNV");
   if ( !driverTbl.glProgramUniform2ui64vNV ) {
      driverTbl.glProgramUniform2ui64vNV = missing_glProgramUniform2ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform2ui64vNV == loader_glProgramUniform2ui64vNV) {
      rCtx->dsp->emuTbl.glProgramUniform2ui64vNV = driverTbl.glProgramUniform2ui64vNV;
   }
   driverTbl.glProgramUniform2ui64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glProgramUniform3i64NV not available." );
}

static void REGAL_CALL loader_glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3i64NV, "glProgramUniform3i64NV");
   if ( !driverTbl.glProgramUniform3i64NV ) {
      driverTbl.glProgramUniform3i64NV = missing_glProgramUniform3i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3i64NV == loader_glProgramUniform3i64NV) {
      rCtx->dsp->emuTbl.glProgramUniform3i64NV = driverTbl.glProgramUniform3i64NV;
   }
   driverTbl.glProgramUniform3i64NV(program, location, x, y, z);
}

static void REGAL_CALL missing_glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform3i64vNV not available." );
}

static void REGAL_CALL loader_glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3i64vNV, "glProgramUniform3i64vNV");
   if ( !driverTbl.glProgramUniform3i64vNV ) {
      driverTbl.glProgramUniform3i64vNV = missing_glProgramUniform3i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3i64vNV == loader_glProgramUniform3i64vNV) {
      rCtx->dsp->emuTbl.glProgramUniform3i64vNV = driverTbl.glProgramUniform3i64vNV;
   }
   driverTbl.glProgramUniform3i64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glProgramUniform3ui64NV not available." );
}

static void REGAL_CALL loader_glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3ui64NV, "glProgramUniform3ui64NV");
   if ( !driverTbl.glProgramUniform3ui64NV ) {
      driverTbl.glProgramUniform3ui64NV = missing_glProgramUniform3ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3ui64NV == loader_glProgramUniform3ui64NV) {
      rCtx->dsp->emuTbl.glProgramUniform3ui64NV = driverTbl.glProgramUniform3ui64NV;
   }
   driverTbl.glProgramUniform3ui64NV(program, location, x, y, z);
}

static void REGAL_CALL missing_glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform3ui64vNV not available." );
}

static void REGAL_CALL loader_glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform3ui64vNV, "glProgramUniform3ui64vNV");
   if ( !driverTbl.glProgramUniform3ui64vNV ) {
      driverTbl.glProgramUniform3ui64vNV = missing_glProgramUniform3ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform3ui64vNV == loader_glProgramUniform3ui64vNV) {
      rCtx->dsp->emuTbl.glProgramUniform3ui64vNV = driverTbl.glProgramUniform3ui64vNV;
   }
   driverTbl.glProgramUniform3ui64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramUniform4i64NV not available." );
}

static void REGAL_CALL loader_glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4i64NV, "glProgramUniform4i64NV");
   if ( !driverTbl.glProgramUniform4i64NV ) {
      driverTbl.glProgramUniform4i64NV = missing_glProgramUniform4i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4i64NV == loader_glProgramUniform4i64NV) {
      rCtx->dsp->emuTbl.glProgramUniform4i64NV = driverTbl.glProgramUniform4i64NV;
   }
   driverTbl.glProgramUniform4i64NV(program, location, x, y, z, w);
}

static void REGAL_CALL missing_glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform4i64vNV not available." );
}

static void REGAL_CALL loader_glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4i64vNV, "glProgramUniform4i64vNV");
   if ( !driverTbl.glProgramUniform4i64vNV ) {
      driverTbl.glProgramUniform4i64vNV = missing_glProgramUniform4i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4i64vNV == loader_glProgramUniform4i64vNV) {
      rCtx->dsp->emuTbl.glProgramUniform4i64vNV = driverTbl.glProgramUniform4i64vNV;
   }
   driverTbl.glProgramUniform4i64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramUniform4ui64NV not available." );
}

static void REGAL_CALL loader_glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4ui64NV, "glProgramUniform4ui64NV");
   if ( !driverTbl.glProgramUniform4ui64NV ) {
      driverTbl.glProgramUniform4ui64NV = missing_glProgramUniform4ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4ui64NV == loader_glProgramUniform4ui64NV) {
      rCtx->dsp->emuTbl.glProgramUniform4ui64NV = driverTbl.glProgramUniform4ui64NV;
   }
   driverTbl.glProgramUniform4ui64NV(program, location, x, y, z, w);
}

static void REGAL_CALL missing_glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniform4ui64vNV not available." );
}

static void REGAL_CALL loader_glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniform4ui64vNV, "glProgramUniform4ui64vNV");
   if ( !driverTbl.glProgramUniform4ui64vNV ) {
      driverTbl.glProgramUniform4ui64vNV = missing_glProgramUniform4ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniform4ui64vNV == loader_glProgramUniform4ui64vNV) {
      rCtx->dsp->emuTbl.glProgramUniform4ui64vNV = driverTbl.glProgramUniform4ui64vNV;
   }
   driverTbl.glProgramUniform4ui64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glUniform1i64NV(GLint location, GLint64EXT x)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "glUniform1i64NV not available." );
}

static void REGAL_CALL loader_glUniform1i64NV(GLint location, GLint64EXT x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1i64NV, "glUniform1i64NV");
   if ( !driverTbl.glUniform1i64NV ) {
      driverTbl.glUniform1i64NV = missing_glUniform1i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1i64NV == loader_glUniform1i64NV) {
      rCtx->dsp->emuTbl.glUniform1i64NV = driverTbl.glUniform1i64NV;
   }
   driverTbl.glUniform1i64NV(location, x);
}

static void REGAL_CALL missing_glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform1i64vNV not available." );
}

static void REGAL_CALL loader_glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1i64vNV, "glUniform1i64vNV");
   if ( !driverTbl.glUniform1i64vNV ) {
      driverTbl.glUniform1i64vNV = missing_glUniform1i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1i64vNV == loader_glUniform1i64vNV) {
      rCtx->dsp->emuTbl.glUniform1i64vNV = driverTbl.glUniform1i64vNV;
   }
   driverTbl.glUniform1i64vNV(location, count, value);
}

static void REGAL_CALL missing_glUniform1ui64NV(GLint location, GLuint64EXT x)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   Warning( "glUniform1ui64NV not available." );
}

static void REGAL_CALL loader_glUniform1ui64NV(GLint location, GLuint64EXT x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1ui64NV, "glUniform1ui64NV");
   if ( !driverTbl.glUniform1ui64NV ) {
      driverTbl.glUniform1ui64NV = missing_glUniform1ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1ui64NV == loader_glUniform1ui64NV) {
      rCtx->dsp->emuTbl.glUniform1ui64NV = driverTbl.glUniform1ui64NV;
   }
   driverTbl.glUniform1ui64NV(location, x);
}

static void REGAL_CALL missing_glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform1ui64vNV not available." );
}

static void REGAL_CALL loader_glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform1ui64vNV, "glUniform1ui64vNV");
   if ( !driverTbl.glUniform1ui64vNV ) {
      driverTbl.glUniform1ui64vNV = missing_glUniform1ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform1ui64vNV == loader_glUniform1ui64vNV) {
      rCtx->dsp->emuTbl.glUniform1ui64vNV = driverTbl.glUniform1ui64vNV;
   }
   driverTbl.glUniform1ui64vNV(location, count, value);
}

static void REGAL_CALL missing_glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glUniform2i64NV not available." );
}

static void REGAL_CALL loader_glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2i64NV, "glUniform2i64NV");
   if ( !driverTbl.glUniform2i64NV ) {
      driverTbl.glUniform2i64NV = missing_glUniform2i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2i64NV == loader_glUniform2i64NV) {
      rCtx->dsp->emuTbl.glUniform2i64NV = driverTbl.glUniform2i64NV;
   }
   driverTbl.glUniform2i64NV(location, x, y);
}

static void REGAL_CALL missing_glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform2i64vNV not available." );
}

static void REGAL_CALL loader_glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2i64vNV, "glUniform2i64vNV");
   if ( !driverTbl.glUniform2i64vNV ) {
      driverTbl.glUniform2i64vNV = missing_glUniform2i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2i64vNV == loader_glUniform2i64vNV) {
      rCtx->dsp->emuTbl.glUniform2i64vNV = driverTbl.glUniform2i64vNV;
   }
   driverTbl.glUniform2i64vNV(location, count, value);
}

static void REGAL_CALL missing_glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glUniform2ui64NV not available." );
}

static void REGAL_CALL loader_glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2ui64NV, "glUniform2ui64NV");
   if ( !driverTbl.glUniform2ui64NV ) {
      driverTbl.glUniform2ui64NV = missing_glUniform2ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2ui64NV == loader_glUniform2ui64NV) {
      rCtx->dsp->emuTbl.glUniform2ui64NV = driverTbl.glUniform2ui64NV;
   }
   driverTbl.glUniform2ui64NV(location, x, y);
}

static void REGAL_CALL missing_glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform2ui64vNV not available." );
}

static void REGAL_CALL loader_glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform2ui64vNV, "glUniform2ui64vNV");
   if ( !driverTbl.glUniform2ui64vNV ) {
      driverTbl.glUniform2ui64vNV = missing_glUniform2ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform2ui64vNV == loader_glUniform2ui64vNV) {
      rCtx->dsp->emuTbl.glUniform2ui64vNV = driverTbl.glUniform2ui64vNV;
   }
   driverTbl.glUniform2ui64vNV(location, count, value);
}

static void REGAL_CALL missing_glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glUniform3i64NV not available." );
}

static void REGAL_CALL loader_glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3i64NV, "glUniform3i64NV");
   if ( !driverTbl.glUniform3i64NV ) {
      driverTbl.glUniform3i64NV = missing_glUniform3i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3i64NV == loader_glUniform3i64NV) {
      rCtx->dsp->emuTbl.glUniform3i64NV = driverTbl.glUniform3i64NV;
   }
   driverTbl.glUniform3i64NV(location, x, y, z);
}

static void REGAL_CALL missing_glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform3i64vNV not available." );
}

static void REGAL_CALL loader_glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3i64vNV, "glUniform3i64vNV");
   if ( !driverTbl.glUniform3i64vNV ) {
      driverTbl.glUniform3i64vNV = missing_glUniform3i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3i64vNV == loader_glUniform3i64vNV) {
      rCtx->dsp->emuTbl.glUniform3i64vNV = driverTbl.glUniform3i64vNV;
   }
   driverTbl.glUniform3i64vNV(location, count, value);
}

static void REGAL_CALL missing_glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glUniform3ui64NV not available." );
}

static void REGAL_CALL loader_glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3ui64NV, "glUniform3ui64NV");
   if ( !driverTbl.glUniform3ui64NV ) {
      driverTbl.glUniform3ui64NV = missing_glUniform3ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3ui64NV == loader_glUniform3ui64NV) {
      rCtx->dsp->emuTbl.glUniform3ui64NV = driverTbl.glUniform3ui64NV;
   }
   driverTbl.glUniform3ui64NV(location, x, y, z);
}

static void REGAL_CALL missing_glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform3ui64vNV not available." );
}

static void REGAL_CALL loader_glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform3ui64vNV, "glUniform3ui64vNV");
   if ( !driverTbl.glUniform3ui64vNV ) {
      driverTbl.glUniform3ui64vNV = missing_glUniform3ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform3ui64vNV == loader_glUniform3ui64vNV) {
      rCtx->dsp->emuTbl.glUniform3ui64vNV = driverTbl.glUniform3ui64vNV;
   }
   driverTbl.glUniform3ui64vNV(location, count, value);
}

static void REGAL_CALL missing_glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glUniform4i64NV not available." );
}

static void REGAL_CALL loader_glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4i64NV, "glUniform4i64NV");
   if ( !driverTbl.glUniform4i64NV ) {
      driverTbl.glUniform4i64NV = missing_glUniform4i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4i64NV == loader_glUniform4i64NV) {
      rCtx->dsp->emuTbl.glUniform4i64NV = driverTbl.glUniform4i64NV;
   }
   driverTbl.glUniform4i64NV(location, x, y, z, w);
}

static void REGAL_CALL missing_glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform4i64vNV not available." );
}

static void REGAL_CALL loader_glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4i64vNV, "glUniform4i64vNV");
   if ( !driverTbl.glUniform4i64vNV ) {
      driverTbl.glUniform4i64vNV = missing_glUniform4i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4i64vNV == loader_glUniform4i64vNV) {
      rCtx->dsp->emuTbl.glUniform4i64vNV = driverTbl.glUniform4i64vNV;
   }
   driverTbl.glUniform4i64vNV(location, count, value);
}

static void REGAL_CALL missing_glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glUniform4ui64NV not available." );
}

static void REGAL_CALL loader_glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4ui64NV, "glUniform4ui64NV");
   if ( !driverTbl.glUniform4ui64NV ) {
      driverTbl.glUniform4ui64NV = missing_glUniform4ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4ui64NV == loader_glUniform4ui64NV) {
      rCtx->dsp->emuTbl.glUniform4ui64NV = driverTbl.glUniform4ui64NV;
   }
   driverTbl.glUniform4ui64NV(location, x, y, z, w);
}

static void REGAL_CALL missing_glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniform4ui64vNV not available." );
}

static void REGAL_CALL loader_glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniform4ui64vNV, "glUniform4ui64vNV");
   if ( !driverTbl.glUniform4ui64vNV ) {
      driverTbl.glUniform4ui64vNV = missing_glUniform4ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniform4ui64vNV == loader_glUniform4ui64vNV) {
      rCtx->dsp->emuTbl.glUniform4ui64vNV = driverTbl.glUniform4ui64vNV;
   }
   driverTbl.glUniform4ui64vNV(location, count, value);
}

// GL_NV_half_float

static void REGAL_CALL missing_glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glColor3hNV not available." );
}

static void REGAL_CALL loader_glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3hNV, "glColor3hNV");
   if ( !driverTbl.glColor3hNV ) {
      driverTbl.glColor3hNV = missing_glColor3hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3hNV == loader_glColor3hNV) {
      rCtx->dsp->emuTbl.glColor3hNV = driverTbl.glColor3hNV;
   }
   driverTbl.glColor3hNV(red, green, blue);
}

static void REGAL_CALL missing_glColor3hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor3hvNV not available." );
}

static void REGAL_CALL loader_glColor3hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3hvNV, "glColor3hvNV");
   if ( !driverTbl.glColor3hvNV ) {
      driverTbl.glColor3hvNV = missing_glColor3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3hvNV == loader_glColor3hvNV) {
      rCtx->dsp->emuTbl.glColor3hvNV = driverTbl.glColor3hvNV;
   }
   driverTbl.glColor3hvNV(v);
}

static void REGAL_CALL missing_glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glColor4hNV not available." );
}

static void REGAL_CALL loader_glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4hNV, "glColor4hNV");
   if ( !driverTbl.glColor4hNV ) {
      driverTbl.glColor4hNV = missing_glColor4hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4hNV == loader_glColor4hNV) {
      rCtx->dsp->emuTbl.glColor4hNV = driverTbl.glColor4hNV;
   }
   driverTbl.glColor4hNV(red, green, blue, alpha);
}

static void REGAL_CALL missing_glColor4hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glColor4hvNV not available." );
}

static void REGAL_CALL loader_glColor4hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4hvNV, "glColor4hvNV");
   if ( !driverTbl.glColor4hvNV ) {
      driverTbl.glColor4hvNV = missing_glColor4hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4hvNV == loader_glColor4hvNV) {
      rCtx->dsp->emuTbl.glColor4hvNV = driverTbl.glColor4hvNV;
   }
   driverTbl.glColor4hvNV(v);
}

static void REGAL_CALL missing_glFogCoordhNV(GLhalfNV coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "glFogCoordhNV not available." );
}

static void REGAL_CALL loader_glFogCoordhNV(GLhalfNV coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogCoordhNV, "glFogCoordhNV");
   if ( !driverTbl.glFogCoordhNV ) {
      driverTbl.glFogCoordhNV = missing_glFogCoordhNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogCoordhNV == loader_glFogCoordhNV) {
      rCtx->dsp->emuTbl.glFogCoordhNV = driverTbl.glFogCoordhNV;
   }
   driverTbl.glFogCoordhNV(coord);
}

static void REGAL_CALL missing_glFogCoordhvNV(const GLhalfNV *coord)
{
   UNUSED_PARAMETER(coord);
   Warning( "glFogCoordhvNV not available." );
}

static void REGAL_CALL loader_glFogCoordhvNV(const GLhalfNV *coord)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogCoordhvNV, "glFogCoordhvNV");
   if ( !driverTbl.glFogCoordhvNV ) {
      driverTbl.glFogCoordhvNV = missing_glFogCoordhvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogCoordhvNV == loader_glFogCoordhvNV) {
      rCtx->dsp->emuTbl.glFogCoordhvNV = driverTbl.glFogCoordhvNV;
   }
   driverTbl.glFogCoordhvNV(coord);
}

static void REGAL_CALL missing_glMultiTexCoord1hNV(GLenum target, GLhalfNV s)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   Warning( "glMultiTexCoord1hNV not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1hNV(GLenum target, GLhalfNV s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1hNV, "glMultiTexCoord1hNV");
   if ( !driverTbl.glMultiTexCoord1hNV ) {
      driverTbl.glMultiTexCoord1hNV = missing_glMultiTexCoord1hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1hNV == loader_glMultiTexCoord1hNV) {
      rCtx->dsp->emuTbl.glMultiTexCoord1hNV = driverTbl.glMultiTexCoord1hNV;
   }
   driverTbl.glMultiTexCoord1hNV(target, s);
}

static void REGAL_CALL missing_glMultiTexCoord1hvNV(GLenum target, const GLhalfNV *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord1hvNV not available." );
}

static void REGAL_CALL loader_glMultiTexCoord1hvNV(GLenum target, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord1hvNV, "glMultiTexCoord1hvNV");
   if ( !driverTbl.glMultiTexCoord1hvNV ) {
      driverTbl.glMultiTexCoord1hvNV = missing_glMultiTexCoord1hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord1hvNV == loader_glMultiTexCoord1hvNV) {
      rCtx->dsp->emuTbl.glMultiTexCoord1hvNV = driverTbl.glMultiTexCoord1hvNV;
   }
   driverTbl.glMultiTexCoord1hvNV(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "glMultiTexCoord2hNV not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2hNV, "glMultiTexCoord2hNV");
   if ( !driverTbl.glMultiTexCoord2hNV ) {
      driverTbl.glMultiTexCoord2hNV = missing_glMultiTexCoord2hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2hNV == loader_glMultiTexCoord2hNV) {
      rCtx->dsp->emuTbl.glMultiTexCoord2hNV = driverTbl.glMultiTexCoord2hNV;
   }
   driverTbl.glMultiTexCoord2hNV(target, s, t);
}

static void REGAL_CALL missing_glMultiTexCoord2hvNV(GLenum target, const GLhalfNV *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord2hvNV not available." );
}

static void REGAL_CALL loader_glMultiTexCoord2hvNV(GLenum target, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord2hvNV, "glMultiTexCoord2hvNV");
   if ( !driverTbl.glMultiTexCoord2hvNV ) {
      driverTbl.glMultiTexCoord2hvNV = missing_glMultiTexCoord2hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord2hvNV == loader_glMultiTexCoord2hvNV) {
      rCtx->dsp->emuTbl.glMultiTexCoord2hvNV = driverTbl.glMultiTexCoord2hvNV;
   }
   driverTbl.glMultiTexCoord2hvNV(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "glMultiTexCoord3hNV not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3hNV, "glMultiTexCoord3hNV");
   if ( !driverTbl.glMultiTexCoord3hNV ) {
      driverTbl.glMultiTexCoord3hNV = missing_glMultiTexCoord3hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3hNV == loader_glMultiTexCoord3hNV) {
      rCtx->dsp->emuTbl.glMultiTexCoord3hNV = driverTbl.glMultiTexCoord3hNV;
   }
   driverTbl.glMultiTexCoord3hNV(target, s, t, r);
}

static void REGAL_CALL missing_glMultiTexCoord3hvNV(GLenum target, const GLhalfNV *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord3hvNV not available." );
}

static void REGAL_CALL loader_glMultiTexCoord3hvNV(GLenum target, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord3hvNV, "glMultiTexCoord3hvNV");
   if ( !driverTbl.glMultiTexCoord3hvNV ) {
      driverTbl.glMultiTexCoord3hvNV = missing_glMultiTexCoord3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord3hvNV == loader_glMultiTexCoord3hvNV) {
      rCtx->dsp->emuTbl.glMultiTexCoord3hvNV = driverTbl.glMultiTexCoord3hvNV;
   }
   driverTbl.glMultiTexCoord3hvNV(target, v);
}

static void REGAL_CALL missing_glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "glMultiTexCoord4hNV not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4hNV, "glMultiTexCoord4hNV");
   if ( !driverTbl.glMultiTexCoord4hNV ) {
      driverTbl.glMultiTexCoord4hNV = missing_glMultiTexCoord4hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4hNV == loader_glMultiTexCoord4hNV) {
      rCtx->dsp->emuTbl.glMultiTexCoord4hNV = driverTbl.glMultiTexCoord4hNV;
   }
   driverTbl.glMultiTexCoord4hNV(target, s, t, r, q);
}

static void REGAL_CALL missing_glMultiTexCoord4hvNV(GLenum target, const GLhalfNV *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(v);
   Warning( "glMultiTexCoord4hvNV not available." );
}

static void REGAL_CALL loader_glMultiTexCoord4hvNV(GLenum target, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMultiTexCoord4hvNV, "glMultiTexCoord4hvNV");
   if ( !driverTbl.glMultiTexCoord4hvNV ) {
      driverTbl.glMultiTexCoord4hvNV = missing_glMultiTexCoord4hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMultiTexCoord4hvNV == loader_glMultiTexCoord4hvNV) {
      rCtx->dsp->emuTbl.glMultiTexCoord4hvNV = driverTbl.glMultiTexCoord4hvNV;
   }
   driverTbl.glMultiTexCoord4hvNV(target, v);
}

static void REGAL_CALL missing_glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz)
{
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   Warning( "glNormal3hNV not available." );
}

static void REGAL_CALL loader_glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormal3hNV, "glNormal3hNV");
   if ( !driverTbl.glNormal3hNV ) {
      driverTbl.glNormal3hNV = missing_glNormal3hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormal3hNV == loader_glNormal3hNV) {
      rCtx->dsp->emuTbl.glNormal3hNV = driverTbl.glNormal3hNV;
   }
   driverTbl.glNormal3hNV(nx, ny, nz);
}

static void REGAL_CALL missing_glNormal3hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glNormal3hvNV not available." );
}

static void REGAL_CALL loader_glNormal3hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormal3hvNV, "glNormal3hvNV");
   if ( !driverTbl.glNormal3hvNV ) {
      driverTbl.glNormal3hvNV = missing_glNormal3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormal3hvNV == loader_glNormal3hvNV) {
      rCtx->dsp->emuTbl.glNormal3hvNV = driverTbl.glNormal3hvNV;
   }
   driverTbl.glNormal3hvNV(v);
}

static void REGAL_CALL missing_glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   Warning( "glSecondaryColor3hNV not available." );
}

static void REGAL_CALL loader_glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3hNV, "glSecondaryColor3hNV");
   if ( !driverTbl.glSecondaryColor3hNV ) {
      driverTbl.glSecondaryColor3hNV = missing_glSecondaryColor3hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3hNV == loader_glSecondaryColor3hNV) {
      rCtx->dsp->emuTbl.glSecondaryColor3hNV = driverTbl.glSecondaryColor3hNV;
   }
   driverTbl.glSecondaryColor3hNV(red, green, blue);
}

static void REGAL_CALL missing_glSecondaryColor3hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glSecondaryColor3hvNV not available." );
}

static void REGAL_CALL loader_glSecondaryColor3hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColor3hvNV, "glSecondaryColor3hvNV");
   if ( !driverTbl.glSecondaryColor3hvNV ) {
      driverTbl.glSecondaryColor3hvNV = missing_glSecondaryColor3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColor3hvNV == loader_glSecondaryColor3hvNV) {
      rCtx->dsp->emuTbl.glSecondaryColor3hvNV = driverTbl.glSecondaryColor3hvNV;
   }
   driverTbl.glSecondaryColor3hvNV(v);
}

static void REGAL_CALL missing_glTexCoord1hNV(GLhalfNV s)
{
   UNUSED_PARAMETER(s);
   Warning( "glTexCoord1hNV not available." );
}

static void REGAL_CALL loader_glTexCoord1hNV(GLhalfNV s)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord1hNV, "glTexCoord1hNV");
   if ( !driverTbl.glTexCoord1hNV ) {
      driverTbl.glTexCoord1hNV = missing_glTexCoord1hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord1hNV == loader_glTexCoord1hNV) {
      rCtx->dsp->emuTbl.glTexCoord1hNV = driverTbl.glTexCoord1hNV;
   }
   driverTbl.glTexCoord1hNV(s);
}

static void REGAL_CALL missing_glTexCoord1hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord1hvNV not available." );
}

static void REGAL_CALL loader_glTexCoord1hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord1hvNV, "glTexCoord1hvNV");
   if ( !driverTbl.glTexCoord1hvNV ) {
      driverTbl.glTexCoord1hvNV = missing_glTexCoord1hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord1hvNV == loader_glTexCoord1hvNV) {
      rCtx->dsp->emuTbl.glTexCoord1hvNV = driverTbl.glTexCoord1hvNV;
   }
   driverTbl.glTexCoord1hvNV(v);
}

static void REGAL_CALL missing_glTexCoord2hNV(GLhalfNV s, GLhalfNV t)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   Warning( "glTexCoord2hNV not available." );
}

static void REGAL_CALL loader_glTexCoord2hNV(GLhalfNV s, GLhalfNV t)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2hNV, "glTexCoord2hNV");
   if ( !driverTbl.glTexCoord2hNV ) {
      driverTbl.glTexCoord2hNV = missing_glTexCoord2hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2hNV == loader_glTexCoord2hNV) {
      rCtx->dsp->emuTbl.glTexCoord2hNV = driverTbl.glTexCoord2hNV;
   }
   driverTbl.glTexCoord2hNV(s, t);
}

static void REGAL_CALL missing_glTexCoord2hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord2hvNV not available." );
}

static void REGAL_CALL loader_glTexCoord2hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2hvNV, "glTexCoord2hvNV");
   if ( !driverTbl.glTexCoord2hvNV ) {
      driverTbl.glTexCoord2hvNV = missing_glTexCoord2hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2hvNV == loader_glTexCoord2hvNV) {
      rCtx->dsp->emuTbl.glTexCoord2hvNV = driverTbl.glTexCoord2hvNV;
   }
   driverTbl.glTexCoord2hvNV(v);
}

static void REGAL_CALL missing_glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   Warning( "glTexCoord3hNV not available." );
}

static void REGAL_CALL loader_glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord3hNV, "glTexCoord3hNV");
   if ( !driverTbl.glTexCoord3hNV ) {
      driverTbl.glTexCoord3hNV = missing_glTexCoord3hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord3hNV == loader_glTexCoord3hNV) {
      rCtx->dsp->emuTbl.glTexCoord3hNV = driverTbl.glTexCoord3hNV;
   }
   driverTbl.glTexCoord3hNV(s, t, r);
}

static void REGAL_CALL missing_glTexCoord3hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord3hvNV not available." );
}

static void REGAL_CALL loader_glTexCoord3hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord3hvNV, "glTexCoord3hvNV");
   if ( !driverTbl.glTexCoord3hvNV ) {
      driverTbl.glTexCoord3hvNV = missing_glTexCoord3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord3hvNV == loader_glTexCoord3hvNV) {
      rCtx->dsp->emuTbl.glTexCoord3hvNV = driverTbl.glTexCoord3hvNV;
   }
   driverTbl.glTexCoord3hvNV(v);
}

static void REGAL_CALL missing_glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(q);
   Warning( "glTexCoord4hNV not available." );
}

static void REGAL_CALL loader_glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord4hNV, "glTexCoord4hNV");
   if ( !driverTbl.glTexCoord4hNV ) {
      driverTbl.glTexCoord4hNV = missing_glTexCoord4hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord4hNV == loader_glTexCoord4hNV) {
      rCtx->dsp->emuTbl.glTexCoord4hNV = driverTbl.glTexCoord4hNV;
   }
   driverTbl.glTexCoord4hNV(s, t, r, q);
}

static void REGAL_CALL missing_glTexCoord4hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord4hvNV not available." );
}

static void REGAL_CALL loader_glTexCoord4hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord4hvNV, "glTexCoord4hvNV");
   if ( !driverTbl.glTexCoord4hvNV ) {
      driverTbl.glTexCoord4hvNV = missing_glTexCoord4hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord4hvNV == loader_glTexCoord4hvNV) {
      rCtx->dsp->emuTbl.glTexCoord4hvNV = driverTbl.glTexCoord4hvNV;
   }
   driverTbl.glTexCoord4hvNV(v);
}

static void REGAL_CALL missing_glVertex2hNV(GLhalfNV x, GLhalfNV y)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertex2hNV not available." );
}

static void REGAL_CALL loader_glVertex2hNV(GLhalfNV x, GLhalfNV y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex2hNV, "glVertex2hNV");
   if ( !driverTbl.glVertex2hNV ) {
      driverTbl.glVertex2hNV = missing_glVertex2hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex2hNV == loader_glVertex2hNV) {
      rCtx->dsp->emuTbl.glVertex2hNV = driverTbl.glVertex2hNV;
   }
   driverTbl.glVertex2hNV(x, y);
}

static void REGAL_CALL missing_glVertex2hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex2hvNV not available." );
}

static void REGAL_CALL loader_glVertex2hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex2hvNV, "glVertex2hvNV");
   if ( !driverTbl.glVertex2hvNV ) {
      driverTbl.glVertex2hvNV = missing_glVertex2hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex2hvNV == loader_glVertex2hvNV) {
      rCtx->dsp->emuTbl.glVertex2hvNV = driverTbl.glVertex2hvNV;
   }
   driverTbl.glVertex2hvNV(v);
}

static void REGAL_CALL missing_glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertex3hNV not available." );
}

static void REGAL_CALL loader_glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex3hNV, "glVertex3hNV");
   if ( !driverTbl.glVertex3hNV ) {
      driverTbl.glVertex3hNV = missing_glVertex3hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex3hNV == loader_glVertex3hNV) {
      rCtx->dsp->emuTbl.glVertex3hNV = driverTbl.glVertex3hNV;
   }
   driverTbl.glVertex3hNV(x, y, z);
}

static void REGAL_CALL missing_glVertex3hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex3hvNV not available." );
}

static void REGAL_CALL loader_glVertex3hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex3hvNV, "glVertex3hvNV");
   if ( !driverTbl.glVertex3hvNV ) {
      driverTbl.glVertex3hvNV = missing_glVertex3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex3hvNV == loader_glVertex3hvNV) {
      rCtx->dsp->emuTbl.glVertex3hvNV = driverTbl.glVertex3hvNV;
   }
   driverTbl.glVertex3hvNV(v);
}

static void REGAL_CALL missing_glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertex4hNV not available." );
}

static void REGAL_CALL loader_glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex4hNV, "glVertex4hNV");
   if ( !driverTbl.glVertex4hNV ) {
      driverTbl.glVertex4hNV = missing_glVertex4hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex4hNV == loader_glVertex4hNV) {
      rCtx->dsp->emuTbl.glVertex4hNV = driverTbl.glVertex4hNV;
   }
   driverTbl.glVertex4hNV(x, y, z, w);
}

static void REGAL_CALL missing_glVertex4hvNV(const GLhalfNV *v)
{
   UNUSED_PARAMETER(v);
   Warning( "glVertex4hvNV not available." );
}

static void REGAL_CALL loader_glVertex4hvNV(const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertex4hvNV, "glVertex4hvNV");
   if ( !driverTbl.glVertex4hvNV ) {
      driverTbl.glVertex4hvNV = missing_glVertex4hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertex4hvNV == loader_glVertex4hvNV) {
      rCtx->dsp->emuTbl.glVertex4hvNV = driverTbl.glVertex4hvNV;
   }
   driverTbl.glVertex4hvNV(v);
}

static void REGAL_CALL missing_glVertexAttrib1hNV(GLuint index, GLhalfNV x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttrib1hNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib1hNV(GLuint index, GLhalfNV x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1hNV, "glVertexAttrib1hNV");
   if ( !driverTbl.glVertexAttrib1hNV ) {
      driverTbl.glVertexAttrib1hNV = missing_glVertexAttrib1hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1hNV == loader_glVertexAttrib1hNV) {
      rCtx->dsp->emuTbl.glVertexAttrib1hNV = driverTbl.glVertexAttrib1hNV;
   }
   driverTbl.glVertexAttrib1hNV(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1hvNV(GLuint index, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib1hvNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib1hvNV(GLuint index, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1hvNV, "glVertexAttrib1hvNV");
   if ( !driverTbl.glVertexAttrib1hvNV ) {
      driverTbl.glVertexAttrib1hvNV = missing_glVertexAttrib1hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1hvNV == loader_glVertexAttrib1hvNV) {
      rCtx->dsp->emuTbl.glVertexAttrib1hvNV = driverTbl.glVertexAttrib1hvNV;
   }
   driverTbl.glVertexAttrib1hvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttrib2hNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2hNV, "glVertexAttrib2hNV");
   if ( !driverTbl.glVertexAttrib2hNV ) {
      driverTbl.glVertexAttrib2hNV = missing_glVertexAttrib2hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2hNV == loader_glVertexAttrib2hNV) {
      rCtx->dsp->emuTbl.glVertexAttrib2hNV = driverTbl.glVertexAttrib2hNV;
   }
   driverTbl.glVertexAttrib2hNV(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2hvNV(GLuint index, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib2hvNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib2hvNV(GLuint index, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2hvNV, "glVertexAttrib2hvNV");
   if ( !driverTbl.glVertexAttrib2hvNV ) {
      driverTbl.glVertexAttrib2hvNV = missing_glVertexAttrib2hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2hvNV == loader_glVertexAttrib2hvNV) {
      rCtx->dsp->emuTbl.glVertexAttrib2hvNV = driverTbl.glVertexAttrib2hvNV;
   }
   driverTbl.glVertexAttrib2hvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttrib3hNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3hNV, "glVertexAttrib3hNV");
   if ( !driverTbl.glVertexAttrib3hNV ) {
      driverTbl.glVertexAttrib3hNV = missing_glVertexAttrib3hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3hNV == loader_glVertexAttrib3hNV) {
      rCtx->dsp->emuTbl.glVertexAttrib3hNV = driverTbl.glVertexAttrib3hNV;
   }
   driverTbl.glVertexAttrib3hNV(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3hvNV(GLuint index, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib3hvNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib3hvNV(GLuint index, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3hvNV, "glVertexAttrib3hvNV");
   if ( !driverTbl.glVertexAttrib3hvNV ) {
      driverTbl.glVertexAttrib3hvNV = missing_glVertexAttrib3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3hvNV == loader_glVertexAttrib3hvNV) {
      rCtx->dsp->emuTbl.glVertexAttrib3hvNV = driverTbl.glVertexAttrib3hvNV;
   }
   driverTbl.glVertexAttrib3hvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttrib4hNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4hNV, "glVertexAttrib4hNV");
   if ( !driverTbl.glVertexAttrib4hNV ) {
      driverTbl.glVertexAttrib4hNV = missing_glVertexAttrib4hNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4hNV == loader_glVertexAttrib4hNV) {
      rCtx->dsp->emuTbl.glVertexAttrib4hNV = driverTbl.glVertexAttrib4hNV;
   }
   driverTbl.glVertexAttrib4hNV(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4hvNV(GLuint index, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4hvNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib4hvNV(GLuint index, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4hvNV, "glVertexAttrib4hvNV");
   if ( !driverTbl.glVertexAttrib4hvNV ) {
      driverTbl.glVertexAttrib4hvNV = missing_glVertexAttrib4hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4hvNV == loader_glVertexAttrib4hvNV) {
      rCtx->dsp->emuTbl.glVertexAttrib4hvNV = driverTbl.glVertexAttrib4hvNV;
   }
   driverTbl.glVertexAttrib4hvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribs1hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs1hvNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs1hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs1hvNV, "glVertexAttribs1hvNV");
   if ( !driverTbl.glVertexAttribs1hvNV ) {
      driverTbl.glVertexAttribs1hvNV = missing_glVertexAttribs1hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs1hvNV == loader_glVertexAttribs1hvNV) {
      rCtx->dsp->emuTbl.glVertexAttribs1hvNV = driverTbl.glVertexAttribs1hvNV;
   }
   driverTbl.glVertexAttribs1hvNV(index, count, v);
}

static void REGAL_CALL missing_glVertexAttribs2hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs2hvNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs2hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs2hvNV, "glVertexAttribs2hvNV");
   if ( !driverTbl.glVertexAttribs2hvNV ) {
      driverTbl.glVertexAttribs2hvNV = missing_glVertexAttribs2hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs2hvNV == loader_glVertexAttribs2hvNV) {
      rCtx->dsp->emuTbl.glVertexAttribs2hvNV = driverTbl.glVertexAttribs2hvNV;
   }
   driverTbl.glVertexAttribs2hvNV(index, count, v);
}

static void REGAL_CALL missing_glVertexAttribs3hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs3hvNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs3hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs3hvNV, "glVertexAttribs3hvNV");
   if ( !driverTbl.glVertexAttribs3hvNV ) {
      driverTbl.glVertexAttribs3hvNV = missing_glVertexAttribs3hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs3hvNV == loader_glVertexAttribs3hvNV) {
      rCtx->dsp->emuTbl.glVertexAttribs3hvNV = driverTbl.glVertexAttribs3hvNV;
   }
   driverTbl.glVertexAttribs3hvNV(index, count, v);
}

static void REGAL_CALL missing_glVertexAttribs4hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs4hvNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs4hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs4hvNV, "glVertexAttribs4hvNV");
   if ( !driverTbl.glVertexAttribs4hvNV ) {
      driverTbl.glVertexAttribs4hvNV = missing_glVertexAttribs4hvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs4hvNV == loader_glVertexAttribs4hvNV) {
      rCtx->dsp->emuTbl.glVertexAttribs4hvNV = driverTbl.glVertexAttribs4hvNV;
   }
   driverTbl.glVertexAttribs4hvNV(index, count, v);
}

static void REGAL_CALL missing_glVertexWeighthNV(GLhalfNV weight)
{
   UNUSED_PARAMETER(weight);
   Warning( "glVertexWeighthNV not available." );
}

static void REGAL_CALL loader_glVertexWeighthNV(GLhalfNV weight)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexWeighthNV, "glVertexWeighthNV");
   if ( !driverTbl.glVertexWeighthNV ) {
      driverTbl.glVertexWeighthNV = missing_glVertexWeighthNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexWeighthNV == loader_glVertexWeighthNV) {
      rCtx->dsp->emuTbl.glVertexWeighthNV = driverTbl.glVertexWeighthNV;
   }
   driverTbl.glVertexWeighthNV(weight);
}

static void REGAL_CALL missing_glVertexWeighthvNV(const GLhalfNV *weight)
{
   UNUSED_PARAMETER(weight);
   Warning( "glVertexWeighthvNV not available." );
}

static void REGAL_CALL loader_glVertexWeighthvNV(const GLhalfNV *weight)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexWeighthvNV, "glVertexWeighthvNV");
   if ( !driverTbl.glVertexWeighthvNV ) {
      driverTbl.glVertexWeighthvNV = missing_glVertexWeighthvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexWeighthvNV == loader_glVertexWeighthvNV) {
      rCtx->dsp->emuTbl.glVertexWeighthvNV = driverTbl.glVertexWeighthvNV;
   }
   driverTbl.glVertexWeighthvNV(weight);
}

// GL_NV_occlusion_query

static void REGAL_CALL missing_glBeginOcclusionQueryNV(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "glBeginOcclusionQueryNV not available." );
}

static void REGAL_CALL loader_glBeginOcclusionQueryNV(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBeginOcclusionQueryNV, "glBeginOcclusionQueryNV");
   if ( !driverTbl.glBeginOcclusionQueryNV ) {
      driverTbl.glBeginOcclusionQueryNV = missing_glBeginOcclusionQueryNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBeginOcclusionQueryNV == loader_glBeginOcclusionQueryNV) {
      rCtx->dsp->emuTbl.glBeginOcclusionQueryNV = driverTbl.glBeginOcclusionQueryNV;
   }
   driverTbl.glBeginOcclusionQueryNV(id);
}

static void REGAL_CALL missing_glDeleteOcclusionQueriesNV(GLsizei n, const GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "glDeleteOcclusionQueriesNV not available." );
}

static void REGAL_CALL loader_glDeleteOcclusionQueriesNV(GLsizei n, const GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteOcclusionQueriesNV, "glDeleteOcclusionQueriesNV");
   if ( !driverTbl.glDeleteOcclusionQueriesNV ) {
      driverTbl.glDeleteOcclusionQueriesNV = missing_glDeleteOcclusionQueriesNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteOcclusionQueriesNV == loader_glDeleteOcclusionQueriesNV) {
      rCtx->dsp->emuTbl.glDeleteOcclusionQueriesNV = driverTbl.glDeleteOcclusionQueriesNV;
   }
   driverTbl.glDeleteOcclusionQueriesNV(n, ids);
}

static void REGAL_CALL missing_glEndOcclusionQueryNV(void)
{
   Warning( "glEndOcclusionQueryNV not available." );
}

static void REGAL_CALL loader_glEndOcclusionQueryNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndOcclusionQueryNV, "glEndOcclusionQueryNV");
   if ( !driverTbl.glEndOcclusionQueryNV ) {
      driverTbl.glEndOcclusionQueryNV = missing_glEndOcclusionQueryNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndOcclusionQueryNV == loader_glEndOcclusionQueryNV) {
      rCtx->dsp->emuTbl.glEndOcclusionQueryNV = driverTbl.glEndOcclusionQueryNV;
   }
   driverTbl.glEndOcclusionQueryNV();
}

static void REGAL_CALL missing_glGenOcclusionQueriesNV(GLsizei n, GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "glGenOcclusionQueriesNV not available." );
}

static void REGAL_CALL loader_glGenOcclusionQueriesNV(GLsizei n, GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenOcclusionQueriesNV, "glGenOcclusionQueriesNV");
   if ( !driverTbl.glGenOcclusionQueriesNV ) {
      driverTbl.glGenOcclusionQueriesNV = missing_glGenOcclusionQueriesNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenOcclusionQueriesNV == loader_glGenOcclusionQueriesNV) {
      rCtx->dsp->emuTbl.glGenOcclusionQueriesNV = driverTbl.glGenOcclusionQueriesNV;
   }
   driverTbl.glGenOcclusionQueriesNV(n, ids);
}

static void REGAL_CALL missing_glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetOcclusionQueryivNV not available." );
}

static void REGAL_CALL loader_glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetOcclusionQueryivNV, "glGetOcclusionQueryivNV");
   if ( !driverTbl.glGetOcclusionQueryivNV ) {
      driverTbl.glGetOcclusionQueryivNV = missing_glGetOcclusionQueryivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetOcclusionQueryivNV == loader_glGetOcclusionQueryivNV) {
      rCtx->dsp->emuTbl.glGetOcclusionQueryivNV = driverTbl.glGetOcclusionQueryivNV;
   }
   driverTbl.glGetOcclusionQueryivNV(id, pname, params);
}

static void REGAL_CALL missing_glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetOcclusionQueryuivNV not available." );
}

static void REGAL_CALL loader_glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetOcclusionQueryuivNV, "glGetOcclusionQueryuivNV");
   if ( !driverTbl.glGetOcclusionQueryuivNV ) {
      driverTbl.glGetOcclusionQueryuivNV = missing_glGetOcclusionQueryuivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetOcclusionQueryuivNV == loader_glGetOcclusionQueryuivNV) {
      rCtx->dsp->emuTbl.glGetOcclusionQueryuivNV = driverTbl.glGetOcclusionQueryuivNV;
   }
   driverTbl.glGetOcclusionQueryuivNV(id, pname, params);
}

static GLboolean REGAL_CALL missing_glIsOcclusionQueryNV(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "glIsOcclusionQueryNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsOcclusionQueryNV(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsOcclusionQueryNV, "glIsOcclusionQueryNV");
   if ( !driverTbl.glIsOcclusionQueryNV ) {
      driverTbl.glIsOcclusionQueryNV = missing_glIsOcclusionQueryNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsOcclusionQueryNV == loader_glIsOcclusionQueryNV) {
      rCtx->dsp->emuTbl.glIsOcclusionQueryNV = driverTbl.glIsOcclusionQueryNV;
   }
   return driverTbl.glIsOcclusionQueryNV(id);
}

// GL_NV_parameter_buffer_object

static void REGAL_CALL missing_glProgramBufferParametersIivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "glProgramBufferParametersIivNV not available." );
}

static void REGAL_CALL loader_glProgramBufferParametersIivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramBufferParametersIivNV, "glProgramBufferParametersIivNV");
   if ( !driverTbl.glProgramBufferParametersIivNV ) {
      driverTbl.glProgramBufferParametersIivNV = missing_glProgramBufferParametersIivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramBufferParametersIivNV == loader_glProgramBufferParametersIivNV) {
      rCtx->dsp->emuTbl.glProgramBufferParametersIivNV = driverTbl.glProgramBufferParametersIivNV;
   }
   driverTbl.glProgramBufferParametersIivNV(target, buffer, index, count, params);
}

static void REGAL_CALL missing_glProgramBufferParametersIuivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "glProgramBufferParametersIuivNV not available." );
}

static void REGAL_CALL loader_glProgramBufferParametersIuivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramBufferParametersIuivNV, "glProgramBufferParametersIuivNV");
   if ( !driverTbl.glProgramBufferParametersIuivNV ) {
      driverTbl.glProgramBufferParametersIuivNV = missing_glProgramBufferParametersIuivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramBufferParametersIuivNV == loader_glProgramBufferParametersIuivNV) {
      rCtx->dsp->emuTbl.glProgramBufferParametersIuivNV = driverTbl.glProgramBufferParametersIuivNV;
   }
   driverTbl.glProgramBufferParametersIuivNV(target, buffer, index, count, params);
}

static void REGAL_CALL missing_glProgramBufferParametersfvNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(params);
   Warning( "glProgramBufferParametersfvNV not available." );
}

static void REGAL_CALL loader_glProgramBufferParametersfvNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramBufferParametersfvNV, "glProgramBufferParametersfvNV");
   if ( !driverTbl.glProgramBufferParametersfvNV ) {
      driverTbl.glProgramBufferParametersfvNV = missing_glProgramBufferParametersfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramBufferParametersfvNV == loader_glProgramBufferParametersfvNV) {
      rCtx->dsp->emuTbl.glProgramBufferParametersfvNV = driverTbl.glProgramBufferParametersfvNV;
   }
   driverTbl.glProgramBufferParametersfvNV(target, buffer, index, count, params);
}

// GL_NV_path_rendering

static void REGAL_CALL missing_glCopyPathNV(GLuint resultPath, GLuint srcPath)
{
   UNUSED_PARAMETER(resultPath);
   UNUSED_PARAMETER(srcPath);
   Warning( "glCopyPathNV not available." );
}

static void REGAL_CALL loader_glCopyPathNV(GLuint resultPath, GLuint srcPath)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyPathNV, "glCopyPathNV");
   if ( !driverTbl.glCopyPathNV ) {
      driverTbl.glCopyPathNV = missing_glCopyPathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyPathNV == loader_glCopyPathNV) {
      rCtx->dsp->emuTbl.glCopyPathNV = driverTbl.glCopyPathNV;
   }
   driverTbl.glCopyPathNV(resultPath, srcPath);
}

static void REGAL_CALL missing_glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
{
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(pathNameType);
   UNUSED_PARAMETER(paths);
   UNUSED_PARAMETER(pathBase);
   UNUSED_PARAMETER(coverMode);
   UNUSED_PARAMETER(transformType);
   UNUSED_PARAMETER(transformValues);
   Warning( "glCoverFillPathInstancedNV not available." );
}

static void REGAL_CALL loader_glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCoverFillPathInstancedNV, "glCoverFillPathInstancedNV");
   if ( !driverTbl.glCoverFillPathInstancedNV ) {
      driverTbl.glCoverFillPathInstancedNV = missing_glCoverFillPathInstancedNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCoverFillPathInstancedNV == loader_glCoverFillPathInstancedNV) {
      rCtx->dsp->emuTbl.glCoverFillPathInstancedNV = driverTbl.glCoverFillPathInstancedNV;
   }
   driverTbl.glCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
}

static void REGAL_CALL missing_glCoverFillPathNV(GLuint path, GLenum coverMode)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(coverMode);
   Warning( "glCoverFillPathNV not available." );
}

static void REGAL_CALL loader_glCoverFillPathNV(GLuint path, GLenum coverMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCoverFillPathNV, "glCoverFillPathNV");
   if ( !driverTbl.glCoverFillPathNV ) {
      driverTbl.glCoverFillPathNV = missing_glCoverFillPathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCoverFillPathNV == loader_glCoverFillPathNV) {
      rCtx->dsp->emuTbl.glCoverFillPathNV = driverTbl.glCoverFillPathNV;
   }
   driverTbl.glCoverFillPathNV(path, coverMode);
}

static void REGAL_CALL missing_glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
{
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(pathNameType);
   UNUSED_PARAMETER(paths);
   UNUSED_PARAMETER(pathBase);
   UNUSED_PARAMETER(coverMode);
   UNUSED_PARAMETER(transformType);
   UNUSED_PARAMETER(transformValues);
   Warning( "glCoverStrokePathInstancedNV not available." );
}

static void REGAL_CALL loader_glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCoverStrokePathInstancedNV, "glCoverStrokePathInstancedNV");
   if ( !driverTbl.glCoverStrokePathInstancedNV ) {
      driverTbl.glCoverStrokePathInstancedNV = missing_glCoverStrokePathInstancedNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCoverStrokePathInstancedNV == loader_glCoverStrokePathInstancedNV) {
      rCtx->dsp->emuTbl.glCoverStrokePathInstancedNV = driverTbl.glCoverStrokePathInstancedNV;
   }
   driverTbl.glCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
}

static void REGAL_CALL missing_glCoverStrokePathNV(GLuint name, GLenum coverMode)
{
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(coverMode);
   Warning( "glCoverStrokePathNV not available." );
}

static void REGAL_CALL loader_glCoverStrokePathNV(GLuint name, GLenum coverMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCoverStrokePathNV, "glCoverStrokePathNV");
   if ( !driverTbl.glCoverStrokePathNV ) {
      driverTbl.glCoverStrokePathNV = missing_glCoverStrokePathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCoverStrokePathNV == loader_glCoverStrokePathNV) {
      rCtx->dsp->emuTbl.glCoverStrokePathNV = driverTbl.glCoverStrokePathNV;
   }
   driverTbl.glCoverStrokePathNV(name, coverMode);
}

static void REGAL_CALL missing_glDeletePathsNV(GLuint path, GLsizei range)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(range);
   Warning( "glDeletePathsNV not available." );
}

static void REGAL_CALL loader_glDeletePathsNV(GLuint path, GLsizei range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeletePathsNV, "glDeletePathsNV");
   if ( !driverTbl.glDeletePathsNV ) {
      driverTbl.glDeletePathsNV = missing_glDeletePathsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeletePathsNV == loader_glDeletePathsNV) {
      rCtx->dsp->emuTbl.glDeletePathsNV = driverTbl.glDeletePathsNV;
   }
   driverTbl.glDeletePathsNV(path, range);
}

static GLuint REGAL_CALL missing_glGenPathsNV(GLsizei range)
{
   UNUSED_PARAMETER(range);
   Warning( "glGenPathsNV not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGenPathsNV(GLsizei range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenPathsNV, "glGenPathsNV");
   if ( !driverTbl.glGenPathsNV ) {
      driverTbl.glGenPathsNV = missing_glGenPathsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenPathsNV == loader_glGenPathsNV) {
      rCtx->dsp->emuTbl.glGenPathsNV = driverTbl.glGenPathsNV;
   }
   return driverTbl.glGenPathsNV(range);
}

static void REGAL_CALL missing_glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat *value)
{
   UNUSED_PARAMETER(color);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "glGetPathColorGenfvNV not available." );
}

static void REGAL_CALL loader_glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPathColorGenfvNV, "glGetPathColorGenfvNV");
   if ( !driverTbl.glGetPathColorGenfvNV ) {
      driverTbl.glGetPathColorGenfvNV = missing_glGetPathColorGenfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPathColorGenfvNV == loader_glGetPathColorGenfvNV) {
      rCtx->dsp->emuTbl.glGetPathColorGenfvNV = driverTbl.glGetPathColorGenfvNV;
   }
   driverTbl.glGetPathColorGenfvNV(color, pname, value);
}

static void REGAL_CALL missing_glGetPathColorGenivNV(GLenum color, GLenum pname, GLint *value)
{
   UNUSED_PARAMETER(color);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "glGetPathColorGenivNV not available." );
}

static void REGAL_CALL loader_glGetPathColorGenivNV(GLenum color, GLenum pname, GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPathColorGenivNV, "glGetPathColorGenivNV");
   if ( !driverTbl.glGetPathColorGenivNV ) {
      driverTbl.glGetPathColorGenivNV = missing_glGetPathColorGenivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPathColorGenivNV == loader_glGetPathColorGenivNV) {
      rCtx->dsp->emuTbl.glGetPathColorGenivNV = driverTbl.glGetPathColorGenivNV;
   }
   driverTbl.glGetPathColorGenivNV(color, pname, value);
}

static void REGAL_CALL missing_glGetPathCommandsNV(GLuint name, GLubyte *commands)
{
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(commands);
   Warning( "glGetPathCommandsNV not available." );
}

static void REGAL_CALL loader_glGetPathCommandsNV(GLuint name, GLubyte *commands)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPathCommandsNV, "glGetPathCommandsNV");
   if ( !driverTbl.glGetPathCommandsNV ) {
      driverTbl.glGetPathCommandsNV = missing_glGetPathCommandsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPathCommandsNV == loader_glGetPathCommandsNV) {
      rCtx->dsp->emuTbl.glGetPathCommandsNV = driverTbl.glGetPathCommandsNV;
   }
   driverTbl.glGetPathCommandsNV(name, commands);
}

static void REGAL_CALL missing_glGetPathCoordsNV(GLuint name, GLfloat *coords)
{
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(coords);
   Warning( "glGetPathCoordsNV not available." );
}

static void REGAL_CALL loader_glGetPathCoordsNV(GLuint name, GLfloat *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPathCoordsNV, "glGetPathCoordsNV");
   if ( !driverTbl.glGetPathCoordsNV ) {
      driverTbl.glGetPathCoordsNV = missing_glGetPathCoordsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPathCoordsNV == loader_glGetPathCoordsNV) {
      rCtx->dsp->emuTbl.glGetPathCoordsNV = driverTbl.glGetPathCoordsNV;
   }
   driverTbl.glGetPathCoordsNV(name, coords);
}

static void REGAL_CALL missing_glGetPathDashArrayNV(GLuint name, GLfloat *dashArray)
{
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(dashArray);
   Warning( "glGetPathDashArrayNV not available." );
}

static void REGAL_CALL loader_glGetPathDashArrayNV(GLuint name, GLfloat *dashArray)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPathDashArrayNV, "glGetPathDashArrayNV");
   if ( !driverTbl.glGetPathDashArrayNV ) {
      driverTbl.glGetPathDashArrayNV = missing_glGetPathDashArrayNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPathDashArrayNV == loader_glGetPathDashArrayNV) {
      rCtx->dsp->emuTbl.glGetPathDashArrayNV = driverTbl.glGetPathDashArrayNV;
   }
   driverTbl.glGetPathDashArrayNV(name, dashArray);
}

static GLfloat REGAL_CALL missing_glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(startSegment);
   UNUSED_PARAMETER(numSegments);
   Warning( "glGetPathLengthNV not available." );
  GLfloat  ret = (GLfloat )0;
  return ret;
}

static GLfloat REGAL_CALL loader_glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPathLengthNV, "glGetPathLengthNV");
   if ( !driverTbl.glGetPathLengthNV ) {
      driverTbl.glGetPathLengthNV = missing_glGetPathLengthNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPathLengthNV == loader_glGetPathLengthNV) {
      rCtx->dsp->emuTbl.glGetPathLengthNV = driverTbl.glGetPathLengthNV;
   }
   return driverTbl.glGetPathLengthNV(path, startSegment, numSegments);
}

static void REGAL_CALL missing_glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint fistPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics)
{
   UNUSED_PARAMETER(metricQueryMask);
   UNUSED_PARAMETER(fistPathName);
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(metrics);
   Warning( "glGetPathMetricRangeNV not available." );
}

static void REGAL_CALL loader_glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint fistPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPathMetricRangeNV, "glGetPathMetricRangeNV");
   if ( !driverTbl.glGetPathMetricRangeNV ) {
      driverTbl.glGetPathMetricRangeNV = missing_glGetPathMetricRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPathMetricRangeNV == loader_glGetPathMetricRangeNV) {
      rCtx->dsp->emuTbl.glGetPathMetricRangeNV = driverTbl.glGetPathMetricRangeNV;
   }
   driverTbl.glGetPathMetricRangeNV(metricQueryMask, fistPathName, numPaths, stride, metrics);
}

static void REGAL_CALL missing_glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics)
{
   UNUSED_PARAMETER(metricQueryMask);
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(pathNameType);
   UNUSED_PARAMETER(paths);
   UNUSED_PARAMETER(pathBase);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(metrics);
   Warning( "glGetPathMetricsNV not available." );
}

static void REGAL_CALL loader_glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPathMetricsNV, "glGetPathMetricsNV");
   if ( !driverTbl.glGetPathMetricsNV ) {
      driverTbl.glGetPathMetricsNV = missing_glGetPathMetricsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPathMetricsNV == loader_glGetPathMetricsNV) {
      rCtx->dsp->emuTbl.glGetPathMetricsNV = driverTbl.glGetPathMetricsNV;
   }
   driverTbl.glGetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
}

static void REGAL_CALL missing_glGetPathParameterfvNV(GLuint name, GLenum param, GLfloat *value)
{
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(param);
   UNUSED_PARAMETER(value);
   Warning( "glGetPathParameterfvNV not available." );
}

static void REGAL_CALL loader_glGetPathParameterfvNV(GLuint name, GLenum param, GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPathParameterfvNV, "glGetPathParameterfvNV");
   if ( !driverTbl.glGetPathParameterfvNV ) {
      driverTbl.glGetPathParameterfvNV = missing_glGetPathParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPathParameterfvNV == loader_glGetPathParameterfvNV) {
      rCtx->dsp->emuTbl.glGetPathParameterfvNV = driverTbl.glGetPathParameterfvNV;
   }
   driverTbl.glGetPathParameterfvNV(name, param, value);
}

static void REGAL_CALL missing_glGetPathParameterivNV(GLuint name, GLenum param, GLint *value)
{
   UNUSED_PARAMETER(name);
   UNUSED_PARAMETER(param);
   UNUSED_PARAMETER(value);
   Warning( "glGetPathParameterivNV not available." );
}

static void REGAL_CALL loader_glGetPathParameterivNV(GLuint name, GLenum param, GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPathParameterivNV, "glGetPathParameterivNV");
   if ( !driverTbl.glGetPathParameterivNV ) {
      driverTbl.glGetPathParameterivNV = missing_glGetPathParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPathParameterivNV == loader_glGetPathParameterivNV) {
      rCtx->dsp->emuTbl.glGetPathParameterivNV = driverTbl.glGetPathParameterivNV;
   }
   driverTbl.glGetPathParameterivNV(name, param, value);
}

static void REGAL_CALL missing_glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing)
{
   UNUSED_PARAMETER(pathListMode);
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(pathNameType);
   UNUSED_PARAMETER(paths);
   UNUSED_PARAMETER(pathBase);
   UNUSED_PARAMETER(advanceScale);
   UNUSED_PARAMETER(kerningScale);
   UNUSED_PARAMETER(transformType);
   UNUSED_PARAMETER(returnedSpacing);
   Warning( "glGetPathSpacingNV not available." );
}

static void REGAL_CALL loader_glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPathSpacingNV, "glGetPathSpacingNV");
   if ( !driverTbl.glGetPathSpacingNV ) {
      driverTbl.glGetPathSpacingNV = missing_glGetPathSpacingNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPathSpacingNV == loader_glGetPathSpacingNV) {
      rCtx->dsp->emuTbl.glGetPathSpacingNV = driverTbl.glGetPathSpacingNV;
   }
   driverTbl.glGetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
}

static void REGAL_CALL missing_glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat *value)
{
   UNUSED_PARAMETER(texCoordSet);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "glGetPathTexGenfvNV not available." );
}

static void REGAL_CALL loader_glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPathTexGenfvNV, "glGetPathTexGenfvNV");
   if ( !driverTbl.glGetPathTexGenfvNV ) {
      driverTbl.glGetPathTexGenfvNV = missing_glGetPathTexGenfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPathTexGenfvNV == loader_glGetPathTexGenfvNV) {
      rCtx->dsp->emuTbl.glGetPathTexGenfvNV = driverTbl.glGetPathTexGenfvNV;
   }
   driverTbl.glGetPathTexGenfvNV(texCoordSet, pname, value);
}

static void REGAL_CALL missing_glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint *value)
{
   UNUSED_PARAMETER(texCoordSet);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "glGetPathTexGenivNV not available." );
}

static void REGAL_CALL loader_glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPathTexGenivNV, "glGetPathTexGenivNV");
   if ( !driverTbl.glGetPathTexGenivNV ) {
      driverTbl.glGetPathTexGenivNV = missing_glGetPathTexGenivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPathTexGenivNV == loader_glGetPathTexGenivNV) {
      rCtx->dsp->emuTbl.glGetPathTexGenivNV = driverTbl.glGetPathTexGenivNV;
   }
   driverTbl.glGetPathTexGenivNV(texCoordSet, pname, value);
}

static void REGAL_CALL missing_glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight)
{
   UNUSED_PARAMETER(resultPath);
   UNUSED_PARAMETER(pathA);
   UNUSED_PARAMETER(pathB);
   UNUSED_PARAMETER(weight);
   Warning( "glInterpolatePathsNV not available." );
}

static void REGAL_CALL loader_glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glInterpolatePathsNV, "glInterpolatePathsNV");
   if ( !driverTbl.glInterpolatePathsNV ) {
      driverTbl.glInterpolatePathsNV = missing_glInterpolatePathsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glInterpolatePathsNV == loader_glInterpolatePathsNV) {
      rCtx->dsp->emuTbl.glInterpolatePathsNV = driverTbl.glInterpolatePathsNV;
   }
   driverTbl.glInterpolatePathsNV(resultPath, pathA, pathB, weight);
}

static GLboolean REGAL_CALL missing_glIsPathNV(GLuint path)
{
   UNUSED_PARAMETER(path);
   Warning( "glIsPathNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsPathNV(GLuint path)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsPathNV, "glIsPathNV");
   if ( !driverTbl.glIsPathNV ) {
      driverTbl.glIsPathNV = missing_glIsPathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsPathNV == loader_glIsPathNV) {
      rCtx->dsp->emuTbl.glIsPathNV = driverTbl.glIsPathNV;
   }
   return driverTbl.glIsPathNV(path);
}

static GLboolean REGAL_CALL missing_glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(mask);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glIsPointInFillPathNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsPointInFillPathNV, "glIsPointInFillPathNV");
   if ( !driverTbl.glIsPointInFillPathNV ) {
      driverTbl.glIsPointInFillPathNV = missing_glIsPointInFillPathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsPointInFillPathNV == loader_glIsPointInFillPathNV) {
      rCtx->dsp->emuTbl.glIsPointInFillPathNV = driverTbl.glIsPointInFillPathNV;
   }
   return driverTbl.glIsPointInFillPathNV(path, mask, x, y);
}

static GLboolean REGAL_CALL missing_glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glIsPointInStrokePathNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsPointInStrokePathNV, "glIsPointInStrokePathNV");
   if ( !driverTbl.glIsPointInStrokePathNV ) {
      driverTbl.glIsPointInStrokePathNV = missing_glIsPointInStrokePathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsPointInStrokePathNV == loader_glIsPointInStrokePathNV) {
      rCtx->dsp->emuTbl.glIsPointInStrokePathNV = driverTbl.glIsPointInStrokePathNV;
   }
   return driverTbl.glIsPointInStrokePathNV(path, x, y);
}

static void REGAL_CALL missing_glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs)
{
   UNUSED_PARAMETER(color);
   UNUSED_PARAMETER(genMode);
   UNUSED_PARAMETER(colorFormat);
   UNUSED_PARAMETER(coeffs);
   Warning( "glPathColorGenNV not available." );
}

static void REGAL_CALL loader_glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathColorGenNV, "glPathColorGenNV");
   if ( !driverTbl.glPathColorGenNV ) {
      driverTbl.glPathColorGenNV = missing_glPathColorGenNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathColorGenNV == loader_glPathColorGenNV) {
      rCtx->dsp->emuTbl.glPathColorGenNV = driverTbl.glPathColorGenNV;
   }
   driverTbl.glPathColorGenNV(color, genMode, colorFormat, coeffs);
}

static void REGAL_CALL missing_glPathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(numCommands);
   UNUSED_PARAMETER(commands);
   UNUSED_PARAMETER(numCoords);
   UNUSED_PARAMETER(coordType);
   UNUSED_PARAMETER(coords);
   Warning( "glPathCommandsNV not available." );
}

static void REGAL_CALL loader_glPathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathCommandsNV, "glPathCommandsNV");
   if ( !driverTbl.glPathCommandsNV ) {
      driverTbl.glPathCommandsNV = missing_glPathCommandsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathCommandsNV == loader_glPathCommandsNV) {
      rCtx->dsp->emuTbl.glPathCommandsNV = driverTbl.glPathCommandsNV;
   }
   driverTbl.glPathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);
}

static void REGAL_CALL missing_glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(numCoords);
   UNUSED_PARAMETER(coordType);
   UNUSED_PARAMETER(coords);
   Warning( "glPathCoordsNV not available." );
}

static void REGAL_CALL loader_glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathCoordsNV, "glPathCoordsNV");
   if ( !driverTbl.glPathCoordsNV ) {
      driverTbl.glPathCoordsNV = missing_glPathCoordsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathCoordsNV == loader_glPathCoordsNV) {
      rCtx->dsp->emuTbl.glPathCoordsNV = driverTbl.glPathCoordsNV;
   }
   driverTbl.glPathCoordsNV(path, numCoords, coordType, coords);
}

static void REGAL_CALL missing_glPathCoverDepthFuncNV(GLenum zfunc)
{
   UNUSED_PARAMETER(zfunc);
   Warning( "glPathCoverDepthFuncNV not available." );
}

static void REGAL_CALL loader_glPathCoverDepthFuncNV(GLenum zfunc)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathCoverDepthFuncNV, "glPathCoverDepthFuncNV");
   if ( !driverTbl.glPathCoverDepthFuncNV ) {
      driverTbl.glPathCoverDepthFuncNV = missing_glPathCoverDepthFuncNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathCoverDepthFuncNV == loader_glPathCoverDepthFuncNV) {
      rCtx->dsp->emuTbl.glPathCoverDepthFuncNV = driverTbl.glPathCoverDepthFuncNV;
   }
   driverTbl.glPathCoverDepthFuncNV(zfunc);
}

static void REGAL_CALL missing_glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat *dashArray)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(dashCount);
   UNUSED_PARAMETER(dashArray);
   Warning( "glPathDashArrayNV not available." );
}

static void REGAL_CALL loader_glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat *dashArray)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathDashArrayNV, "glPathDashArrayNV");
   if ( !driverTbl.glPathDashArrayNV ) {
      driverTbl.glPathDashArrayNV = missing_glPathDashArrayNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathDashArrayNV == loader_glPathDashArrayNV) {
      rCtx->dsp->emuTbl.glPathDashArrayNV = driverTbl.glPathDashArrayNV;
   }
   driverTbl.glPathDashArrayNV(path, dashCount, dashArray);
}

static void REGAL_CALL missing_glPathFogGenNV(GLenum genMode)
{
   UNUSED_PARAMETER(genMode);
   Warning( "glPathFogGenNV not available." );
}

static void REGAL_CALL loader_glPathFogGenNV(GLenum genMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathFogGenNV, "glPathFogGenNV");
   if ( !driverTbl.glPathFogGenNV ) {
      driverTbl.glPathFogGenNV = missing_glPathFogGenNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathFogGenNV == loader_glPathFogGenNV) {
      rCtx->dsp->emuTbl.glPathFogGenNV = driverTbl.glPathFogGenNV;
   }
   driverTbl.glPathFogGenNV(genMode);
}

static void REGAL_CALL missing_glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
   UNUSED_PARAMETER(firstPathName);
   UNUSED_PARAMETER(fontTarget);
   UNUSED_PARAMETER(fontName);
   UNUSED_PARAMETER(fontStyle);
   UNUSED_PARAMETER(firstGlyph);
   UNUSED_PARAMETER(numGlyphs);
   UNUSED_PARAMETER(handleMissingGlyphs);
   UNUSED_PARAMETER(pathParameterTemplate);
   UNUSED_PARAMETER(emScale);
   Warning( "glPathGlyphRangeNV not available." );
}

static void REGAL_CALL loader_glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathGlyphRangeNV, "glPathGlyphRangeNV");
   if ( !driverTbl.glPathGlyphRangeNV ) {
      driverTbl.glPathGlyphRangeNV = missing_glPathGlyphRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathGlyphRangeNV == loader_glPathGlyphRangeNV) {
      rCtx->dsp->emuTbl.glPathGlyphRangeNV = driverTbl.glPathGlyphRangeNV;
   }
   driverTbl.glPathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
}

static void REGAL_CALL missing_glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
   UNUSED_PARAMETER(firstPathName);
   UNUSED_PARAMETER(fontTarget);
   UNUSED_PARAMETER(fontName);
   UNUSED_PARAMETER(fontStyle);
   UNUSED_PARAMETER(numGlyphs);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(charcodes);
   UNUSED_PARAMETER(handleMissingGlyphs);
   UNUSED_PARAMETER(pathParameterTemplate);
   UNUSED_PARAMETER(emScale);
   Warning( "glPathGlyphsNV not available." );
}

static void REGAL_CALL loader_glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathGlyphsNV, "glPathGlyphsNV");
   if ( !driverTbl.glPathGlyphsNV ) {
      driverTbl.glPathGlyphsNV = missing_glPathGlyphsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathGlyphsNV == loader_glPathGlyphsNV) {
      rCtx->dsp->emuTbl.glPathGlyphsNV = driverTbl.glPathGlyphsNV;
   }
   driverTbl.glPathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
}

static void REGAL_CALL missing_glPathParameterfNV(GLuint path, GLenum pname, GLfloat value)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "glPathParameterfNV not available." );
}

static void REGAL_CALL loader_glPathParameterfNV(GLuint path, GLenum pname, GLfloat value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathParameterfNV, "glPathParameterfNV");
   if ( !driverTbl.glPathParameterfNV ) {
      driverTbl.glPathParameterfNV = missing_glPathParameterfNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathParameterfNV == loader_glPathParameterfNV) {
      rCtx->dsp->emuTbl.glPathParameterfNV = driverTbl.glPathParameterfNV;
   }
   driverTbl.glPathParameterfNV(path, pname, value);
}

static void REGAL_CALL missing_glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat *value)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "glPathParameterfvNV not available." );
}

static void REGAL_CALL loader_glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathParameterfvNV, "glPathParameterfvNV");
   if ( !driverTbl.glPathParameterfvNV ) {
      driverTbl.glPathParameterfvNV = missing_glPathParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathParameterfvNV == loader_glPathParameterfvNV) {
      rCtx->dsp->emuTbl.glPathParameterfvNV = driverTbl.glPathParameterfvNV;
   }
   driverTbl.glPathParameterfvNV(path, pname, value);
}

static void REGAL_CALL missing_glPathParameteriNV(GLuint path, GLenum pname, GLint value)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "glPathParameteriNV not available." );
}

static void REGAL_CALL loader_glPathParameteriNV(GLuint path, GLenum pname, GLint value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathParameteriNV, "glPathParameteriNV");
   if ( !driverTbl.glPathParameteriNV ) {
      driverTbl.glPathParameteriNV = missing_glPathParameteriNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathParameteriNV == loader_glPathParameteriNV) {
      rCtx->dsp->emuTbl.glPathParameteriNV = driverTbl.glPathParameteriNV;
   }
   driverTbl.glPathParameteriNV(path, pname, value);
}

static void REGAL_CALL missing_glPathParameterivNV(GLuint path, GLenum pname, const GLint *value)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(value);
   Warning( "glPathParameterivNV not available." );
}

static void REGAL_CALL loader_glPathParameterivNV(GLuint path, GLenum pname, const GLint *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathParameterivNV, "glPathParameterivNV");
   if ( !driverTbl.glPathParameterivNV ) {
      driverTbl.glPathParameterivNV = missing_glPathParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathParameterivNV == loader_glPathParameterivNV) {
      rCtx->dsp->emuTbl.glPathParameterivNV = driverTbl.glPathParameterivNV;
   }
   driverTbl.glPathParameterivNV(path, pname, value);
}

static void REGAL_CALL missing_glPathStencilDepthOffsetNV(GLfloat factor, GLfloat units)
{
   UNUSED_PARAMETER(factor);
   UNUSED_PARAMETER(units);
   Warning( "glPathStencilDepthOffsetNV not available." );
}

static void REGAL_CALL loader_glPathStencilDepthOffsetNV(GLfloat factor, GLfloat units)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathStencilDepthOffsetNV, "glPathStencilDepthOffsetNV");
   if ( !driverTbl.glPathStencilDepthOffsetNV ) {
      driverTbl.glPathStencilDepthOffsetNV = missing_glPathStencilDepthOffsetNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathStencilDepthOffsetNV == loader_glPathStencilDepthOffsetNV) {
      rCtx->dsp->emuTbl.glPathStencilDepthOffsetNV = driverTbl.glPathStencilDepthOffsetNV;
   }
   driverTbl.glPathStencilDepthOffsetNV(factor, units);
}

static void REGAL_CALL missing_glPathStencilFuncNV(GLenum func, GLint ref, GLuint mask)
{
   UNUSED_PARAMETER(func);
   UNUSED_PARAMETER(ref);
   UNUSED_PARAMETER(mask);
   Warning( "glPathStencilFuncNV not available." );
}

static void REGAL_CALL loader_glPathStencilFuncNV(GLenum func, GLint ref, GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathStencilFuncNV, "glPathStencilFuncNV");
   if ( !driverTbl.glPathStencilFuncNV ) {
      driverTbl.glPathStencilFuncNV = missing_glPathStencilFuncNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathStencilFuncNV == loader_glPathStencilFuncNV) {
      rCtx->dsp->emuTbl.glPathStencilFuncNV = driverTbl.glPathStencilFuncNV;
   }
   driverTbl.glPathStencilFuncNV(func, ref, mask);
}

static void REGAL_CALL missing_glPathStringNV(GLuint path, GLenum format, GLsizei length, const GLvoid *pathString)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(pathString);
   Warning( "glPathStringNV not available." );
}

static void REGAL_CALL loader_glPathStringNV(GLuint path, GLenum format, GLsizei length, const GLvoid *pathString)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathStringNV, "glPathStringNV");
   if ( !driverTbl.glPathStringNV ) {
      driverTbl.glPathStringNV = missing_glPathStringNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathStringNV == loader_glPathStringNV) {
      rCtx->dsp->emuTbl.glPathStringNV = driverTbl.glPathStringNV;
   }
   driverTbl.glPathStringNV(path, format, length, pathString);
}

static void REGAL_CALL missing_glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(commandStart);
   UNUSED_PARAMETER(commandsToDelete);
   UNUSED_PARAMETER(numCommands);
   UNUSED_PARAMETER(commands);
   UNUSED_PARAMETER(numCoords);
   UNUSED_PARAMETER(coordType);
   UNUSED_PARAMETER(coords);
   Warning( "glPathSubCommandsNV not available." );
}

static void REGAL_CALL loader_glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathSubCommandsNV, "glPathSubCommandsNV");
   if ( !driverTbl.glPathSubCommandsNV ) {
      driverTbl.glPathSubCommandsNV = missing_glPathSubCommandsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathSubCommandsNV == loader_glPathSubCommandsNV) {
      rCtx->dsp->emuTbl.glPathSubCommandsNV = driverTbl.glPathSubCommandsNV;
   }
   driverTbl.glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
}

static void REGAL_CALL missing_glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(coordStart);
   UNUSED_PARAMETER(numCoords);
   UNUSED_PARAMETER(coordType);
   UNUSED_PARAMETER(coords);
   Warning( "glPathSubCoordsNV not available." );
}

static void REGAL_CALL loader_glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathSubCoordsNV, "glPathSubCoordsNV");
   if ( !driverTbl.glPathSubCoordsNV ) {
      driverTbl.glPathSubCoordsNV = missing_glPathSubCoordsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathSubCoordsNV == loader_glPathSubCoordsNV) {
      rCtx->dsp->emuTbl.glPathSubCoordsNV = driverTbl.glPathSubCoordsNV;
   }
   driverTbl.glPathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
}

static void REGAL_CALL missing_glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs)
{
   UNUSED_PARAMETER(texCoordSet);
   UNUSED_PARAMETER(genMode);
   UNUSED_PARAMETER(components);
   UNUSED_PARAMETER(coeffs);
   Warning( "glPathTexGenNV not available." );
}

static void REGAL_CALL loader_glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPathTexGenNV, "glPathTexGenNV");
   if ( !driverTbl.glPathTexGenNV ) {
      driverTbl.glPathTexGenNV = missing_glPathTexGenNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPathTexGenNV == loader_glPathTexGenNV) {
      rCtx->dsp->emuTbl.glPathTexGenNV = driverTbl.glPathTexGenNV;
   }
   driverTbl.glPathTexGenNV(texCoordSet, genMode, components, coeffs);
}

static GLboolean REGAL_CALL missing_glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(startSegment);
   UNUSED_PARAMETER(numSegments);
   UNUSED_PARAMETER(distance);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(tangentX);
   UNUSED_PARAMETER(tangentY);
   Warning( "glPointAlongPathNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPointAlongPathNV, "glPointAlongPathNV");
   if ( !driverTbl.glPointAlongPathNV ) {
      driverTbl.glPointAlongPathNV = missing_glPointAlongPathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPointAlongPathNV == loader_glPointAlongPathNV) {
      rCtx->dsp->emuTbl.glPointAlongPathNV = driverTbl.glPointAlongPathNV;
   }
   return driverTbl.glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
}

static void REGAL_CALL missing_glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues)
{
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(pathNameType);
   UNUSED_PARAMETER(paths);
   UNUSED_PARAMETER(pathBase);
   UNUSED_PARAMETER(fillMode);
   UNUSED_PARAMETER(mask);
   UNUSED_PARAMETER(transformType);
   UNUSED_PARAMETER(transformValues);
   Warning( "glStencilFillPathInstancedNV not available." );
}

static void REGAL_CALL loader_glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStencilFillPathInstancedNV, "glStencilFillPathInstancedNV");
   if ( !driverTbl.glStencilFillPathInstancedNV ) {
      driverTbl.glStencilFillPathInstancedNV = missing_glStencilFillPathInstancedNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStencilFillPathInstancedNV == loader_glStencilFillPathInstancedNV) {
      rCtx->dsp->emuTbl.glStencilFillPathInstancedNV = driverTbl.glStencilFillPathInstancedNV;
   }
   driverTbl.glStencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
}

static void REGAL_CALL missing_glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(fillMode);
   UNUSED_PARAMETER(mask);
   Warning( "glStencilFillPathNV not available." );
}

static void REGAL_CALL loader_glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStencilFillPathNV, "glStencilFillPathNV");
   if ( !driverTbl.glStencilFillPathNV ) {
      driverTbl.glStencilFillPathNV = missing_glStencilFillPathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStencilFillPathNV == loader_glStencilFillPathNV) {
      rCtx->dsp->emuTbl.glStencilFillPathNV = driverTbl.glStencilFillPathNV;
   }
   driverTbl.glStencilFillPathNV(path, fillMode, mask);
}

static void REGAL_CALL missing_glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues)
{
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(pathNameType);
   UNUSED_PARAMETER(paths);
   UNUSED_PARAMETER(pathBase);
   UNUSED_PARAMETER(reference);
   UNUSED_PARAMETER(mask);
   UNUSED_PARAMETER(transformType);
   UNUSED_PARAMETER(transformValues);
   Warning( "glStencilStrokePathInstancedNV not available." );
}

static void REGAL_CALL loader_glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStencilStrokePathInstancedNV, "glStencilStrokePathInstancedNV");
   if ( !driverTbl.glStencilStrokePathInstancedNV ) {
      driverTbl.glStencilStrokePathInstancedNV = missing_glStencilStrokePathInstancedNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStencilStrokePathInstancedNV == loader_glStencilStrokePathInstancedNV) {
      rCtx->dsp->emuTbl.glStencilStrokePathInstancedNV = driverTbl.glStencilStrokePathInstancedNV;
   }
   driverTbl.glStencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
}

static void REGAL_CALL missing_glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask)
{
   UNUSED_PARAMETER(path);
   UNUSED_PARAMETER(reference);
   UNUSED_PARAMETER(mask);
   Warning( "glStencilStrokePathNV not available." );
}

static void REGAL_CALL loader_glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStencilStrokePathNV, "glStencilStrokePathNV");
   if ( !driverTbl.glStencilStrokePathNV ) {
      driverTbl.glStencilStrokePathNV = missing_glStencilStrokePathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStencilStrokePathNV == loader_glStencilStrokePathNV) {
      rCtx->dsp->emuTbl.glStencilStrokePathNV = driverTbl.glStencilStrokePathNV;
   }
   driverTbl.glStencilStrokePathNV(path, reference, mask);
}

static void REGAL_CALL missing_glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues)
{
   UNUSED_PARAMETER(resultPath);
   UNUSED_PARAMETER(srcPath);
   UNUSED_PARAMETER(transformType);
   UNUSED_PARAMETER(transformValues);
   Warning( "glTransformPathNV not available." );
}

static void REGAL_CALL loader_glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTransformPathNV, "glTransformPathNV");
   if ( !driverTbl.glTransformPathNV ) {
      driverTbl.glTransformPathNV = missing_glTransformPathNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTransformPathNV == loader_glTransformPathNV) {
      rCtx->dsp->emuTbl.glTransformPathNV = driverTbl.glTransformPathNV;
   }
   driverTbl.glTransformPathNV(resultPath, srcPath, transformType, transformValues);
}

static void REGAL_CALL missing_glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights)
{
   UNUSED_PARAMETER(resultPath);
   UNUSED_PARAMETER(numPaths);
   UNUSED_PARAMETER(paths);
   UNUSED_PARAMETER(weights);
   Warning( "glWeightPathsNV not available." );
}

static void REGAL_CALL loader_glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glWeightPathsNV, "glWeightPathsNV");
   if ( !driverTbl.glWeightPathsNV ) {
      driverTbl.glWeightPathsNV = missing_glWeightPathsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glWeightPathsNV == loader_glWeightPathsNV) {
      rCtx->dsp->emuTbl.glWeightPathsNV = driverTbl.glWeightPathsNV;
   }
   driverTbl.glWeightPathsNV(resultPath, numPaths, paths, weights);
}

// GL_NV_pixel_data_range

static void REGAL_CALL missing_glFlushPixelDataRangeNV(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glFlushPixelDataRangeNV not available." );
}

static void REGAL_CALL loader_glFlushPixelDataRangeNV(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFlushPixelDataRangeNV, "glFlushPixelDataRangeNV");
   if ( !driverTbl.glFlushPixelDataRangeNV ) {
      driverTbl.glFlushPixelDataRangeNV = missing_glFlushPixelDataRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFlushPixelDataRangeNV == loader_glFlushPixelDataRangeNV) {
      rCtx->dsp->emuTbl.glFlushPixelDataRangeNV = driverTbl.glFlushPixelDataRangeNV;
   }
   driverTbl.glFlushPixelDataRangeNV(target);
}

static void REGAL_CALL missing_glPixelDataRangeNV(GLenum target, GLsizei size, const GLvoid *pointer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(pointer);
   Warning( "glPixelDataRangeNV not available." );
}

static void REGAL_CALL loader_glPixelDataRangeNV(GLenum target, GLsizei size, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelDataRangeNV, "glPixelDataRangeNV");
   if ( !driverTbl.glPixelDataRangeNV ) {
      driverTbl.glPixelDataRangeNV = missing_glPixelDataRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelDataRangeNV == loader_glPixelDataRangeNV) {
      rCtx->dsp->emuTbl.glPixelDataRangeNV = driverTbl.glPixelDataRangeNV;
   }
   driverTbl.glPixelDataRangeNV(target, size, pointer);
}

// GL_NV_point_sprite

static void REGAL_CALL missing_glPointParameteriNV(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPointParameteriNV not available." );
}

static void REGAL_CALL loader_glPointParameteriNV(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPointParameteriNV, "glPointParameteriNV");
   if ( !driverTbl.glPointParameteriNV ) {
      driverTbl.glPointParameteriNV = missing_glPointParameteriNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPointParameteriNV == loader_glPointParameteriNV) {
      rCtx->dsp->emuTbl.glPointParameteriNV = driverTbl.glPointParameteriNV;
   }
   driverTbl.glPointParameteriNV(pname, param);
}

static void REGAL_CALL missing_glPointParameterivNV(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glPointParameterivNV not available." );
}

static void REGAL_CALL loader_glPointParameterivNV(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPointParameterivNV, "glPointParameterivNV");
   if ( !driverTbl.glPointParameterivNV ) {
      driverTbl.glPointParameterivNV = missing_glPointParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPointParameterivNV == loader_glPointParameterivNV) {
      rCtx->dsp->emuTbl.glPointParameterivNV = driverTbl.glPointParameterivNV;
   }
   driverTbl.glPointParameterivNV(pname, params);
}

// GL_NV_present_video

static void REGAL_CALL missing_glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT *params)
{
   UNUSED_PARAMETER(video_slot);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVideoi64vNV not available." );
}

static void REGAL_CALL loader_glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVideoi64vNV, "glGetVideoi64vNV");
   if ( !driverTbl.glGetVideoi64vNV ) {
      driverTbl.glGetVideoi64vNV = missing_glGetVideoi64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVideoi64vNV == loader_glGetVideoi64vNV) {
      rCtx->dsp->emuTbl.glGetVideoi64vNV = driverTbl.glGetVideoi64vNV;
   }
   driverTbl.glGetVideoi64vNV(video_slot, pname, params);
}

static void REGAL_CALL missing_glGetVideoivNV(GLuint video_slot, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(video_slot);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVideoivNV not available." );
}

static void REGAL_CALL loader_glGetVideoivNV(GLuint video_slot, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVideoivNV, "glGetVideoivNV");
   if ( !driverTbl.glGetVideoivNV ) {
      driverTbl.glGetVideoivNV = missing_glGetVideoivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVideoivNV == loader_glGetVideoivNV) {
      rCtx->dsp->emuTbl.glGetVideoivNV = driverTbl.glGetVideoivNV;
   }
   driverTbl.glGetVideoivNV(video_slot, pname, params);
}

static void REGAL_CALL missing_glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT *params)
{
   UNUSED_PARAMETER(video_slot);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVideoui64vNV not available." );
}

static void REGAL_CALL loader_glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVideoui64vNV, "glGetVideoui64vNV");
   if ( !driverTbl.glGetVideoui64vNV ) {
      driverTbl.glGetVideoui64vNV = missing_glGetVideoui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVideoui64vNV == loader_glGetVideoui64vNV) {
      rCtx->dsp->emuTbl.glGetVideoui64vNV = driverTbl.glGetVideoui64vNV;
   }
   driverTbl.glGetVideoui64vNV(video_slot, pname, params);
}

static void REGAL_CALL missing_glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint *params)
{
   UNUSED_PARAMETER(video_slot);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVideouivNV not available." );
}

static void REGAL_CALL loader_glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVideouivNV, "glGetVideouivNV");
   if ( !driverTbl.glGetVideouivNV ) {
      driverTbl.glGetVideouivNV = missing_glGetVideouivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVideouivNV == loader_glGetVideouivNV) {
      rCtx->dsp->emuTbl.glGetVideouivNV = driverTbl.glGetVideouivNV;
   }
   driverTbl.glGetVideouivNV(video_slot, pname, params);
}

static void REGAL_CALL missing_glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3)
{
   UNUSED_PARAMETER(video_slot);
   UNUSED_PARAMETER(minPresentTime);
   UNUSED_PARAMETER(beginPresentTimeId);
   UNUSED_PARAMETER(presentDurationId);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(target0);
   UNUSED_PARAMETER(fill0);
   UNUSED_PARAMETER(target1);
   UNUSED_PARAMETER(fill1);
   UNUSED_PARAMETER(target2);
   UNUSED_PARAMETER(fill2);
   UNUSED_PARAMETER(target3);
   UNUSED_PARAMETER(fill3);
   Warning( "glPresentFrameDualFillNV not available." );
}

static void REGAL_CALL loader_glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPresentFrameDualFillNV, "glPresentFrameDualFillNV");
   if ( !driverTbl.glPresentFrameDualFillNV ) {
      driverTbl.glPresentFrameDualFillNV = missing_glPresentFrameDualFillNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPresentFrameDualFillNV == loader_glPresentFrameDualFillNV) {
      rCtx->dsp->emuTbl.glPresentFrameDualFillNV = driverTbl.glPresentFrameDualFillNV;
   }
   driverTbl.glPresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
}

static void REGAL_CALL missing_glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1)
{
   UNUSED_PARAMETER(video_slot);
   UNUSED_PARAMETER(minPresentTime);
   UNUSED_PARAMETER(beginPresentTimeId);
   UNUSED_PARAMETER(presentDurationId);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(target0);
   UNUSED_PARAMETER(fill0);
   UNUSED_PARAMETER(key0);
   UNUSED_PARAMETER(target1);
   UNUSED_PARAMETER(fill1);
   UNUSED_PARAMETER(key1);
   Warning( "glPresentFrameKeyedNV not available." );
}

static void REGAL_CALL loader_glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPresentFrameKeyedNV, "glPresentFrameKeyedNV");
   if ( !driverTbl.glPresentFrameKeyedNV ) {
      driverTbl.glPresentFrameKeyedNV = missing_glPresentFrameKeyedNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPresentFrameKeyedNV == loader_glPresentFrameKeyedNV) {
      rCtx->dsp->emuTbl.glPresentFrameKeyedNV = driverTbl.glPresentFrameKeyedNV;
   }
   driverTbl.glPresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
}

// GL_NV_primitive_restart

static void REGAL_CALL missing_glPrimitiveRestartIndexNV(GLuint index)
{
   UNUSED_PARAMETER(index);
   Warning( "glPrimitiveRestartIndexNV not available." );
}

static void REGAL_CALL loader_glPrimitiveRestartIndexNV(GLuint index)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPrimitiveRestartIndexNV, "glPrimitiveRestartIndexNV");
   if ( !driverTbl.glPrimitiveRestartIndexNV ) {
      driverTbl.glPrimitiveRestartIndexNV = missing_glPrimitiveRestartIndexNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPrimitiveRestartIndexNV == loader_glPrimitiveRestartIndexNV) {
      rCtx->dsp->emuTbl.glPrimitiveRestartIndexNV = driverTbl.glPrimitiveRestartIndexNV;
   }
   driverTbl.glPrimitiveRestartIndexNV(index);
}

static void REGAL_CALL missing_glPrimitiveRestartNV(void)
{
   Warning( "glPrimitiveRestartNV not available." );
}

static void REGAL_CALL loader_glPrimitiveRestartNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPrimitiveRestartNV, "glPrimitiveRestartNV");
   if ( !driverTbl.glPrimitiveRestartNV ) {
      driverTbl.glPrimitiveRestartNV = missing_glPrimitiveRestartNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPrimitiveRestartNV == loader_glPrimitiveRestartNV) {
      rCtx->dsp->emuTbl.glPrimitiveRestartNV = driverTbl.glPrimitiveRestartNV;
   }
   driverTbl.glPrimitiveRestartNV();
}

// GL_NV_register_combiners

static void REGAL_CALL missing_glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(portion);
   UNUSED_PARAMETER(variable);
   UNUSED_PARAMETER(input);
   UNUSED_PARAMETER(mapping);
   UNUSED_PARAMETER(componentUsage);
   Warning( "glCombinerInputNV not available." );
}

static void REGAL_CALL loader_glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCombinerInputNV, "glCombinerInputNV");
   if ( !driverTbl.glCombinerInputNV ) {
      driverTbl.glCombinerInputNV = missing_glCombinerInputNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCombinerInputNV == loader_glCombinerInputNV) {
      rCtx->dsp->emuTbl.glCombinerInputNV = driverTbl.glCombinerInputNV;
   }
   driverTbl.glCombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
}

static void REGAL_CALL missing_glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(portion);
   UNUSED_PARAMETER(abOutput);
   UNUSED_PARAMETER(cdOutput);
   UNUSED_PARAMETER(sumOutput);
   UNUSED_PARAMETER(scale);
   UNUSED_PARAMETER(bias);
   UNUSED_PARAMETER(abDotProduct);
   UNUSED_PARAMETER(cdDotProduct);
   UNUSED_PARAMETER(muxSum);
   Warning( "glCombinerOutputNV not available." );
}

static void REGAL_CALL loader_glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCombinerOutputNV, "glCombinerOutputNV");
   if ( !driverTbl.glCombinerOutputNV ) {
      driverTbl.glCombinerOutputNV = missing_glCombinerOutputNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCombinerOutputNV == loader_glCombinerOutputNV) {
      rCtx->dsp->emuTbl.glCombinerOutputNV = driverTbl.glCombinerOutputNV;
   }
   driverTbl.glCombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
}

static void REGAL_CALL missing_glCombinerParameterfNV(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glCombinerParameterfNV not available." );
}

static void REGAL_CALL loader_glCombinerParameterfNV(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCombinerParameterfNV, "glCombinerParameterfNV");
   if ( !driverTbl.glCombinerParameterfNV ) {
      driverTbl.glCombinerParameterfNV = missing_glCombinerParameterfNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCombinerParameterfNV == loader_glCombinerParameterfNV) {
      rCtx->dsp->emuTbl.glCombinerParameterfNV = driverTbl.glCombinerParameterfNV;
   }
   driverTbl.glCombinerParameterfNV(pname, param);
}

static void REGAL_CALL missing_glCombinerParameterfvNV(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glCombinerParameterfvNV not available." );
}

static void REGAL_CALL loader_glCombinerParameterfvNV(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCombinerParameterfvNV, "glCombinerParameterfvNV");
   if ( !driverTbl.glCombinerParameterfvNV ) {
      driverTbl.glCombinerParameterfvNV = missing_glCombinerParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCombinerParameterfvNV == loader_glCombinerParameterfvNV) {
      rCtx->dsp->emuTbl.glCombinerParameterfvNV = driverTbl.glCombinerParameterfvNV;
   }
   driverTbl.glCombinerParameterfvNV(pname, params);
}

static void REGAL_CALL missing_glCombinerParameteriNV(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glCombinerParameteriNV not available." );
}

static void REGAL_CALL loader_glCombinerParameteriNV(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCombinerParameteriNV, "glCombinerParameteriNV");
   if ( !driverTbl.glCombinerParameteriNV ) {
      driverTbl.glCombinerParameteriNV = missing_glCombinerParameteriNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCombinerParameteriNV == loader_glCombinerParameteriNV) {
      rCtx->dsp->emuTbl.glCombinerParameteriNV = driverTbl.glCombinerParameteriNV;
   }
   driverTbl.glCombinerParameteriNV(pname, param);
}

static void REGAL_CALL missing_glCombinerParameterivNV(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glCombinerParameterivNV not available." );
}

static void REGAL_CALL loader_glCombinerParameterivNV(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCombinerParameterivNV, "glCombinerParameterivNV");
   if ( !driverTbl.glCombinerParameterivNV ) {
      driverTbl.glCombinerParameterivNV = missing_glCombinerParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCombinerParameterivNV == loader_glCombinerParameterivNV) {
      rCtx->dsp->emuTbl.glCombinerParameterivNV = driverTbl.glCombinerParameterivNV;
   }
   driverTbl.glCombinerParameterivNV(pname, params);
}

static void REGAL_CALL missing_glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
   UNUSED_PARAMETER(variable);
   UNUSED_PARAMETER(input);
   UNUSED_PARAMETER(mapping);
   UNUSED_PARAMETER(componentUsage);
   Warning( "glFinalCombinerInputNV not available." );
}

static void REGAL_CALL loader_glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFinalCombinerInputNV, "glFinalCombinerInputNV");
   if ( !driverTbl.glFinalCombinerInputNV ) {
      driverTbl.glFinalCombinerInputNV = missing_glFinalCombinerInputNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFinalCombinerInputNV == loader_glFinalCombinerInputNV) {
      rCtx->dsp->emuTbl.glFinalCombinerInputNV = driverTbl.glFinalCombinerInputNV;
   }
   driverTbl.glFinalCombinerInputNV(variable, input, mapping, componentUsage);
}

static void REGAL_CALL missing_glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(portion);
   UNUSED_PARAMETER(variable);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetCombinerInputParameterfvNV not available." );
}

static void REGAL_CALL loader_glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetCombinerInputParameterfvNV, "glGetCombinerInputParameterfvNV");
   if ( !driverTbl.glGetCombinerInputParameterfvNV ) {
      driverTbl.glGetCombinerInputParameterfvNV = missing_glGetCombinerInputParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetCombinerInputParameterfvNV == loader_glGetCombinerInputParameterfvNV) {
      rCtx->dsp->emuTbl.glGetCombinerInputParameterfvNV = driverTbl.glGetCombinerInputParameterfvNV;
   }
   driverTbl.glGetCombinerInputParameterfvNV(stage, portion, variable, pname, params);
}

static void REGAL_CALL missing_glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(portion);
   UNUSED_PARAMETER(variable);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetCombinerInputParameterivNV not available." );
}

static void REGAL_CALL loader_glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetCombinerInputParameterivNV, "glGetCombinerInputParameterivNV");
   if ( !driverTbl.glGetCombinerInputParameterivNV ) {
      driverTbl.glGetCombinerInputParameterivNV = missing_glGetCombinerInputParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetCombinerInputParameterivNV == loader_glGetCombinerInputParameterivNV) {
      rCtx->dsp->emuTbl.glGetCombinerInputParameterivNV = driverTbl.glGetCombinerInputParameterivNV;
   }
   driverTbl.glGetCombinerInputParameterivNV(stage, portion, variable, pname, params);
}

static void REGAL_CALL missing_glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(portion);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetCombinerOutputParameterfvNV not available." );
}

static void REGAL_CALL loader_glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetCombinerOutputParameterfvNV, "glGetCombinerOutputParameterfvNV");
   if ( !driverTbl.glGetCombinerOutputParameterfvNV ) {
      driverTbl.glGetCombinerOutputParameterfvNV = missing_glGetCombinerOutputParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetCombinerOutputParameterfvNV == loader_glGetCombinerOutputParameterfvNV) {
      rCtx->dsp->emuTbl.glGetCombinerOutputParameterfvNV = driverTbl.glGetCombinerOutputParameterfvNV;
   }
   driverTbl.glGetCombinerOutputParameterfvNV(stage, portion, pname, params);
}

static void REGAL_CALL missing_glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(portion);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetCombinerOutputParameterivNV not available." );
}

static void REGAL_CALL loader_glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetCombinerOutputParameterivNV, "glGetCombinerOutputParameterivNV");
   if ( !driverTbl.glGetCombinerOutputParameterivNV ) {
      driverTbl.glGetCombinerOutputParameterivNV = missing_glGetCombinerOutputParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetCombinerOutputParameterivNV == loader_glGetCombinerOutputParameterivNV) {
      rCtx->dsp->emuTbl.glGetCombinerOutputParameterivNV = driverTbl.glGetCombinerOutputParameterivNV;
   }
   driverTbl.glGetCombinerOutputParameterivNV(stage, portion, pname, params);
}

static void REGAL_CALL missing_glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(variable);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFinalCombinerInputParameterfvNV not available." );
}

static void REGAL_CALL loader_glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFinalCombinerInputParameterfvNV, "glGetFinalCombinerInputParameterfvNV");
   if ( !driverTbl.glGetFinalCombinerInputParameterfvNV ) {
      driverTbl.glGetFinalCombinerInputParameterfvNV = missing_glGetFinalCombinerInputParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFinalCombinerInputParameterfvNV == loader_glGetFinalCombinerInputParameterfvNV) {
      rCtx->dsp->emuTbl.glGetFinalCombinerInputParameterfvNV = driverTbl.glGetFinalCombinerInputParameterfvNV;
   }
   driverTbl.glGetFinalCombinerInputParameterfvNV(variable, pname, params);
}

static void REGAL_CALL missing_glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(variable);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFinalCombinerInputParameterivNV not available." );
}

static void REGAL_CALL loader_glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFinalCombinerInputParameterivNV, "glGetFinalCombinerInputParameterivNV");
   if ( !driverTbl.glGetFinalCombinerInputParameterivNV ) {
      driverTbl.glGetFinalCombinerInputParameterivNV = missing_glGetFinalCombinerInputParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFinalCombinerInputParameterivNV == loader_glGetFinalCombinerInputParameterivNV) {
      rCtx->dsp->emuTbl.glGetFinalCombinerInputParameterivNV = driverTbl.glGetFinalCombinerInputParameterivNV;
   }
   driverTbl.glGetFinalCombinerInputParameterivNV(variable, pname, params);
}

// GL_NV_register_combiners2

static void REGAL_CALL missing_glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glCombinerStageParameterfvNV not available." );
}

static void REGAL_CALL loader_glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCombinerStageParameterfvNV, "glCombinerStageParameterfvNV");
   if ( !driverTbl.glCombinerStageParameterfvNV ) {
      driverTbl.glCombinerStageParameterfvNV = missing_glCombinerStageParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCombinerStageParameterfvNV == loader_glCombinerStageParameterfvNV) {
      rCtx->dsp->emuTbl.glCombinerStageParameterfvNV = driverTbl.glCombinerStageParameterfvNV;
   }
   driverTbl.glCombinerStageParameterfvNV(stage, pname, params);
}

static void REGAL_CALL missing_glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(stage);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetCombinerStageParameterfvNV not available." );
}

static void REGAL_CALL loader_glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetCombinerStageParameterfvNV, "glGetCombinerStageParameterfvNV");
   if ( !driverTbl.glGetCombinerStageParameterfvNV ) {
      driverTbl.glGetCombinerStageParameterfvNV = missing_glGetCombinerStageParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetCombinerStageParameterfvNV == loader_glGetCombinerStageParameterfvNV) {
      rCtx->dsp->emuTbl.glGetCombinerStageParameterfvNV = driverTbl.glGetCombinerStageParameterfvNV;
   }
   driverTbl.glGetCombinerStageParameterfvNV(stage, pname, params);
}

// GL_NV_shader_buffer_load

static void REGAL_CALL missing_glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetBufferParameterui64vNV not available." );
}

static void REGAL_CALL loader_glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetBufferParameterui64vNV, "glGetBufferParameterui64vNV");
   if ( !driverTbl.glGetBufferParameterui64vNV ) {
      driverTbl.glGetBufferParameterui64vNV = missing_glGetBufferParameterui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetBufferParameterui64vNV == loader_glGetBufferParameterui64vNV) {
      rCtx->dsp->emuTbl.glGetBufferParameterui64vNV = driverTbl.glGetBufferParameterui64vNV;
   }
   driverTbl.glGetBufferParameterui64vNV(target, pname, params);
}

static void REGAL_CALL missing_glGetIntegerui64vNV(GLenum target, GLuint64EXT *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(data);
   Warning( "glGetIntegerui64vNV not available." );
}

static void REGAL_CALL loader_glGetIntegerui64vNV(GLenum target, GLuint64EXT *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetIntegerui64vNV, "glGetIntegerui64vNV");
   if ( !driverTbl.glGetIntegerui64vNV ) {
      driverTbl.glGetIntegerui64vNV = missing_glGetIntegerui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetIntegerui64vNV == loader_glGetIntegerui64vNV) {
      rCtx->dsp->emuTbl.glGetIntegerui64vNV = driverTbl.glGetIntegerui64vNV;
   }
   driverTbl.glGetIntegerui64vNV(target, data);
}

static void REGAL_CALL missing_glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT *params)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetNamedBufferParameterui64vNV not available." );
}

static void REGAL_CALL loader_glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetNamedBufferParameterui64vNV, "glGetNamedBufferParameterui64vNV");
   if ( !driverTbl.glGetNamedBufferParameterui64vNV ) {
      driverTbl.glGetNamedBufferParameterui64vNV = missing_glGetNamedBufferParameterui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetNamedBufferParameterui64vNV == loader_glGetNamedBufferParameterui64vNV) {
      rCtx->dsp->emuTbl.glGetNamedBufferParameterui64vNV = driverTbl.glGetNamedBufferParameterui64vNV;
   }
   driverTbl.glGetNamedBufferParameterui64vNV(buffer, pname, params);
}

static void REGAL_CALL missing_glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT *params)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(params);
   Warning( "glGetUniformui64vNV not available." );
}

static void REGAL_CALL loader_glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetUniformui64vNV, "glGetUniformui64vNV");
   if ( !driverTbl.glGetUniformui64vNV ) {
      driverTbl.glGetUniformui64vNV = missing_glGetUniformui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetUniformui64vNV == loader_glGetUniformui64vNV) {
      rCtx->dsp->emuTbl.glGetUniformui64vNV = driverTbl.glGetUniformui64vNV;
   }
   driverTbl.glGetUniformui64vNV(program, location, params);
}

static GLboolean REGAL_CALL missing_glIsBufferResidentNV(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glIsBufferResidentNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsBufferResidentNV(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsBufferResidentNV, "glIsBufferResidentNV");
   if ( !driverTbl.glIsBufferResidentNV ) {
      driverTbl.glIsBufferResidentNV = missing_glIsBufferResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsBufferResidentNV == loader_glIsBufferResidentNV) {
      rCtx->dsp->emuTbl.glIsBufferResidentNV = driverTbl.glIsBufferResidentNV;
   }
   return driverTbl.glIsBufferResidentNV(target);
}

static GLboolean REGAL_CALL missing_glIsNamedBufferResidentNV(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "glIsNamedBufferResidentNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsNamedBufferResidentNV(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsNamedBufferResidentNV, "glIsNamedBufferResidentNV");
   if ( !driverTbl.glIsNamedBufferResidentNV ) {
      driverTbl.glIsNamedBufferResidentNV = missing_glIsNamedBufferResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsNamedBufferResidentNV == loader_glIsNamedBufferResidentNV) {
      rCtx->dsp->emuTbl.glIsNamedBufferResidentNV = driverTbl.glIsNamedBufferResidentNV;
   }
   return driverTbl.glIsNamedBufferResidentNV(buffer);
}

static void REGAL_CALL missing_glMakeBufferNonResidentNV(GLenum target)
{
   UNUSED_PARAMETER(target);
   Warning( "glMakeBufferNonResidentNV not available." );
}

static void REGAL_CALL loader_glMakeBufferNonResidentNV(GLenum target)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMakeBufferNonResidentNV, "glMakeBufferNonResidentNV");
   if ( !driverTbl.glMakeBufferNonResidentNV ) {
      driverTbl.glMakeBufferNonResidentNV = missing_glMakeBufferNonResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMakeBufferNonResidentNV == loader_glMakeBufferNonResidentNV) {
      rCtx->dsp->emuTbl.glMakeBufferNonResidentNV = driverTbl.glMakeBufferNonResidentNV;
   }
   driverTbl.glMakeBufferNonResidentNV(target);
}

static void REGAL_CALL missing_glMakeBufferResidentNV(GLenum target, GLenum access)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(access);
   Warning( "glMakeBufferResidentNV not available." );
}

static void REGAL_CALL loader_glMakeBufferResidentNV(GLenum target, GLenum access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMakeBufferResidentNV, "glMakeBufferResidentNV");
   if ( !driverTbl.glMakeBufferResidentNV ) {
      driverTbl.glMakeBufferResidentNV = missing_glMakeBufferResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMakeBufferResidentNV == loader_glMakeBufferResidentNV) {
      rCtx->dsp->emuTbl.glMakeBufferResidentNV = driverTbl.glMakeBufferResidentNV;
   }
   driverTbl.glMakeBufferResidentNV(target, access);
}

static void REGAL_CALL missing_glMakeNamedBufferNonResidentNV(GLuint buffer)
{
   UNUSED_PARAMETER(buffer);
   Warning( "glMakeNamedBufferNonResidentNV not available." );
}

static void REGAL_CALL loader_glMakeNamedBufferNonResidentNV(GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMakeNamedBufferNonResidentNV, "glMakeNamedBufferNonResidentNV");
   if ( !driverTbl.glMakeNamedBufferNonResidentNV ) {
      driverTbl.glMakeNamedBufferNonResidentNV = missing_glMakeNamedBufferNonResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMakeNamedBufferNonResidentNV == loader_glMakeNamedBufferNonResidentNV) {
      rCtx->dsp->emuTbl.glMakeNamedBufferNonResidentNV = driverTbl.glMakeNamedBufferNonResidentNV;
   }
   driverTbl.glMakeNamedBufferNonResidentNV(buffer);
}

static void REGAL_CALL missing_glMakeNamedBufferResidentNV(GLuint buffer, GLenum access)
{
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(access);
   Warning( "glMakeNamedBufferResidentNV not available." );
}

static void REGAL_CALL loader_glMakeNamedBufferResidentNV(GLuint buffer, GLenum access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glMakeNamedBufferResidentNV, "glMakeNamedBufferResidentNV");
   if ( !driverTbl.glMakeNamedBufferResidentNV ) {
      driverTbl.glMakeNamedBufferResidentNV = missing_glMakeNamedBufferResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glMakeNamedBufferResidentNV == loader_glMakeNamedBufferResidentNV) {
      rCtx->dsp->emuTbl.glMakeNamedBufferResidentNV = driverTbl.glMakeNamedBufferResidentNV;
   }
   driverTbl.glMakeNamedBufferResidentNV(buffer, access);
}

static void REGAL_CALL missing_glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT v0)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "glProgramUniformui64NV not available." );
}

static void REGAL_CALL loader_glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformui64NV, "glProgramUniformui64NV");
   if ( !driverTbl.glProgramUniformui64NV ) {
      driverTbl.glProgramUniformui64NV = missing_glProgramUniformui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformui64NV == loader_glProgramUniformui64NV) {
      rCtx->dsp->emuTbl.glProgramUniformui64NV = driverTbl.glProgramUniformui64NV;
   }
   driverTbl.glProgramUniformui64NV(program, location, v0);
}

static void REGAL_CALL missing_glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glProgramUniformui64vNV not available." );
}

static void REGAL_CALL loader_glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramUniformui64vNV, "glProgramUniformui64vNV");
   if ( !driverTbl.glProgramUniformui64vNV ) {
      driverTbl.glProgramUniformui64vNV = missing_glProgramUniformui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramUniformui64vNV == loader_glProgramUniformui64vNV) {
      rCtx->dsp->emuTbl.glProgramUniformui64vNV = driverTbl.glProgramUniformui64vNV;
   }
   driverTbl.glProgramUniformui64vNV(program, location, count, value);
}

static void REGAL_CALL missing_glUniformui64NV(GLint location, GLuint64EXT v0)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(v0);
   Warning( "glUniformui64NV not available." );
}

static void REGAL_CALL loader_glUniformui64NV(GLint location, GLuint64EXT v0)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformui64NV, "glUniformui64NV");
   if ( !driverTbl.glUniformui64NV ) {
      driverTbl.glUniformui64NV = missing_glUniformui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformui64NV == loader_glUniformui64NV) {
      rCtx->dsp->emuTbl.glUniformui64NV = driverTbl.glUniformui64NV;
   }
   driverTbl.glUniformui64NV(location, v0);
}

static void REGAL_CALL missing_glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   UNUSED_PARAMETER(location);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(value);
   Warning( "glUniformui64vNV not available." );
}

static void REGAL_CALL loader_glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glUniformui64vNV, "glUniformui64vNV");
   if ( !driverTbl.glUniformui64vNV ) {
      driverTbl.glUniformui64vNV = missing_glUniformui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glUniformui64vNV == loader_glUniformui64vNV) {
      rCtx->dsp->emuTbl.glUniformui64vNV = driverTbl.glUniformui64vNV;
   }
   driverTbl.glUniformui64vNV(location, count, value);
}

// GL_NV_texture_barrier

static void REGAL_CALL missing_glTextureBarrierNV(void)
{
   Warning( "glTextureBarrierNV not available." );
}

static void REGAL_CALL loader_glTextureBarrierNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureBarrierNV, "glTextureBarrierNV");
   if ( !driverTbl.glTextureBarrierNV ) {
      driverTbl.glTextureBarrierNV = missing_glTextureBarrierNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureBarrierNV == loader_glTextureBarrierNV) {
      rCtx->dsp->emuTbl.glTextureBarrierNV = driverTbl.glTextureBarrierNV;
   }
   driverTbl.glTextureBarrierNV();
}

// GL_NV_texture_multisample

static void REGAL_CALL missing_glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(coverageSamples);
   UNUSED_PARAMETER(colorSamples);
   UNUSED_PARAMETER(internalFormat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(fixedSampleLocations);
   Warning( "glTexImage2DMultisampleCoverageNV not available." );
}

static void REGAL_CALL loader_glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexImage2DMultisampleCoverageNV, "glTexImage2DMultisampleCoverageNV");
   if ( !driverTbl.glTexImage2DMultisampleCoverageNV ) {
      driverTbl.glTexImage2DMultisampleCoverageNV = missing_glTexImage2DMultisampleCoverageNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexImage2DMultisampleCoverageNV == loader_glTexImage2DMultisampleCoverageNV) {
      rCtx->dsp->emuTbl.glTexImage2DMultisampleCoverageNV = driverTbl.glTexImage2DMultisampleCoverageNV;
   }
   driverTbl.glTexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
}

static void REGAL_CALL missing_glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(coverageSamples);
   UNUSED_PARAMETER(colorSamples);
   UNUSED_PARAMETER(internalFormat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(fixedSampleLocations);
   Warning( "glTexImage3DMultisampleCoverageNV not available." );
}

static void REGAL_CALL loader_glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexImage3DMultisampleCoverageNV, "glTexImage3DMultisampleCoverageNV");
   if ( !driverTbl.glTexImage3DMultisampleCoverageNV ) {
      driverTbl.glTexImage3DMultisampleCoverageNV = missing_glTexImage3DMultisampleCoverageNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexImage3DMultisampleCoverageNV == loader_glTexImage3DMultisampleCoverageNV) {
      rCtx->dsp->emuTbl.glTexImage3DMultisampleCoverageNV = driverTbl.glTexImage3DMultisampleCoverageNV;
   }
   driverTbl.glTexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
}

static void REGAL_CALL missing_glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(coverageSamples);
   UNUSED_PARAMETER(colorSamples);
   UNUSED_PARAMETER(internalFormat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(fixedSampleLocations);
   Warning( "glTextureImage2DMultisampleCoverageNV not available." );
}

static void REGAL_CALL loader_glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureImage2DMultisampleCoverageNV, "glTextureImage2DMultisampleCoverageNV");
   if ( !driverTbl.glTextureImage2DMultisampleCoverageNV ) {
      driverTbl.glTextureImage2DMultisampleCoverageNV = missing_glTextureImage2DMultisampleCoverageNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureImage2DMultisampleCoverageNV == loader_glTextureImage2DMultisampleCoverageNV) {
      rCtx->dsp->emuTbl.glTextureImage2DMultisampleCoverageNV = driverTbl.glTextureImage2DMultisampleCoverageNV;
   }
   driverTbl.glTextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
}

static void REGAL_CALL missing_glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalFormat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(fixedSampleLocations);
   Warning( "glTextureImage2DMultisampleNV not available." );
}

static void REGAL_CALL loader_glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureImage2DMultisampleNV, "glTextureImage2DMultisampleNV");
   if ( !driverTbl.glTextureImage2DMultisampleNV ) {
      driverTbl.glTextureImage2DMultisampleNV = missing_glTextureImage2DMultisampleNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureImage2DMultisampleNV == loader_glTextureImage2DMultisampleNV) {
      rCtx->dsp->emuTbl.glTextureImage2DMultisampleNV = driverTbl.glTextureImage2DMultisampleNV;
   }
   driverTbl.glTextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
}

static void REGAL_CALL missing_glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(coverageSamples);
   UNUSED_PARAMETER(colorSamples);
   UNUSED_PARAMETER(internalFormat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(fixedSampleLocations);
   Warning( "glTextureImage3DMultisampleCoverageNV not available." );
}

static void REGAL_CALL loader_glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureImage3DMultisampleCoverageNV, "glTextureImage3DMultisampleCoverageNV");
   if ( !driverTbl.glTextureImage3DMultisampleCoverageNV ) {
      driverTbl.glTextureImage3DMultisampleCoverageNV = missing_glTextureImage3DMultisampleCoverageNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureImage3DMultisampleCoverageNV == loader_glTextureImage3DMultisampleCoverageNV) {
      rCtx->dsp->emuTbl.glTextureImage3DMultisampleCoverageNV = driverTbl.glTextureImage3DMultisampleCoverageNV;
   }
   driverTbl.glTextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
}

static void REGAL_CALL missing_glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
   UNUSED_PARAMETER(texture);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(samples);
   UNUSED_PARAMETER(internalFormat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(fixedSampleLocations);
   Warning( "glTextureImage3DMultisampleNV not available." );
}

static void REGAL_CALL loader_glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureImage3DMultisampleNV, "glTextureImage3DMultisampleNV");
   if ( !driverTbl.glTextureImage3DMultisampleNV ) {
      driverTbl.glTextureImage3DMultisampleNV = missing_glTextureImage3DMultisampleNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureImage3DMultisampleNV == loader_glTextureImage3DMultisampleNV) {
      rCtx->dsp->emuTbl.glTextureImage3DMultisampleNV = driverTbl.glTextureImage3DMultisampleNV;
   }
   driverTbl.glTextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
}

// GL_NV_transform_feedback

static void REGAL_CALL missing_glActiveVaryingNV(GLuint program, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(name);
   Warning( "glActiveVaryingNV not available." );
}

static void REGAL_CALL loader_glActiveVaryingNV(GLuint program, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glActiveVaryingNV, "glActiveVaryingNV");
   if ( !driverTbl.glActiveVaryingNV ) {
      driverTbl.glActiveVaryingNV = missing_glActiveVaryingNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glActiveVaryingNV == loader_glActiveVaryingNV) {
      rCtx->dsp->emuTbl.glActiveVaryingNV = driverTbl.glActiveVaryingNV;
   }
   driverTbl.glActiveVaryingNV(program, name);
}

static void REGAL_CALL missing_glBeginTransformFeedbackNV(GLenum primitiveMode)
{
   UNUSED_PARAMETER(primitiveMode);
   Warning( "glBeginTransformFeedbackNV not available." );
}

static void REGAL_CALL loader_glBeginTransformFeedbackNV(GLenum primitiveMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBeginTransformFeedbackNV, "glBeginTransformFeedbackNV");
   if ( !driverTbl.glBeginTransformFeedbackNV ) {
      driverTbl.glBeginTransformFeedbackNV = missing_glBeginTransformFeedbackNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBeginTransformFeedbackNV == loader_glBeginTransformFeedbackNV) {
      rCtx->dsp->emuTbl.glBeginTransformFeedbackNV = driverTbl.glBeginTransformFeedbackNV;
   }
   driverTbl.glBeginTransformFeedbackNV(primitiveMode);
}

static void REGAL_CALL missing_glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   Warning( "glBindBufferBaseNV not available." );
}

static void REGAL_CALL loader_glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindBufferBaseNV, "glBindBufferBaseNV");
   if ( !driverTbl.glBindBufferBaseNV ) {
      driverTbl.glBindBufferBaseNV = missing_glBindBufferBaseNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindBufferBaseNV == loader_glBindBufferBaseNV) {
      rCtx->dsp->emuTbl.glBindBufferBaseNV = driverTbl.glBindBufferBaseNV;
   }
   driverTbl.glBindBufferBaseNV(target, index, buffer);
}

static void REGAL_CALL missing_glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   Warning( "glBindBufferOffsetNV not available." );
}

static void REGAL_CALL loader_glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindBufferOffsetNV, "glBindBufferOffsetNV");
   if ( !driverTbl.glBindBufferOffsetNV ) {
      driverTbl.glBindBufferOffsetNV = missing_glBindBufferOffsetNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindBufferOffsetNV == loader_glBindBufferOffsetNV) {
      rCtx->dsp->emuTbl.glBindBufferOffsetNV = driverTbl.glBindBufferOffsetNV;
   }
   driverTbl.glBindBufferOffsetNV(target, index, buffer, offset);
}

static void REGAL_CALL missing_glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(buffer);
   UNUSED_PARAMETER(offset);
   UNUSED_PARAMETER(size);
   Warning( "glBindBufferRangeNV not available." );
}

static void REGAL_CALL loader_glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindBufferRangeNV, "glBindBufferRangeNV");
   if ( !driverTbl.glBindBufferRangeNV ) {
      driverTbl.glBindBufferRangeNV = missing_glBindBufferRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindBufferRangeNV == loader_glBindBufferRangeNV) {
      rCtx->dsp->emuTbl.glBindBufferRangeNV = driverTbl.glBindBufferRangeNV;
   }
   driverTbl.glBindBufferRangeNV(target, index, buffer, offset, size);
}

static void REGAL_CALL missing_glEndTransformFeedbackNV(void)
{
   Warning( "glEndTransformFeedbackNV not available." );
}

static void REGAL_CALL loader_glEndTransformFeedbackNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndTransformFeedbackNV, "glEndTransformFeedbackNV");
   if ( !driverTbl.glEndTransformFeedbackNV ) {
      driverTbl.glEndTransformFeedbackNV = missing_glEndTransformFeedbackNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndTransformFeedbackNV == loader_glEndTransformFeedbackNV) {
      rCtx->dsp->emuTbl.glEndTransformFeedbackNV = driverTbl.glEndTransformFeedbackNV;
   }
   driverTbl.glEndTransformFeedbackNV();
}

static void REGAL_CALL missing_glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(name);
   Warning( "glGetActiveVaryingNV not available." );
}

static void REGAL_CALL loader_glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetActiveVaryingNV, "glGetActiveVaryingNV");
   if ( !driverTbl.glGetActiveVaryingNV ) {
      driverTbl.glGetActiveVaryingNV = missing_glGetActiveVaryingNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetActiveVaryingNV == loader_glGetActiveVaryingNV) {
      rCtx->dsp->emuTbl.glGetActiveVaryingNV = driverTbl.glGetActiveVaryingNV;
   }
   driverTbl.glGetActiveVaryingNV(program, index, bufSize, length, size, type, name);
}

static void REGAL_CALL missing_glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint *location)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(location);
   Warning( "glGetTransformFeedbackVaryingNV not available." );
}

static void REGAL_CALL loader_glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint *location)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTransformFeedbackVaryingNV, "glGetTransformFeedbackVaryingNV");
   if ( !driverTbl.glGetTransformFeedbackVaryingNV ) {
      driverTbl.glGetTransformFeedbackVaryingNV = missing_glGetTransformFeedbackVaryingNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTransformFeedbackVaryingNV == loader_glGetTransformFeedbackVaryingNV) {
      rCtx->dsp->emuTbl.glGetTransformFeedbackVaryingNV = driverTbl.glGetTransformFeedbackVaryingNV;
   }
   driverTbl.glGetTransformFeedbackVaryingNV(program, index, location);
}

static GLint REGAL_CALL missing_glGetVaryingLocationNV(GLuint program, const GLchar *name)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(name);
   Warning( "glGetVaryingLocationNV not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetVaryingLocationNV(GLuint program, const GLchar *name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVaryingLocationNV, "glGetVaryingLocationNV");
   if ( !driverTbl.glGetVaryingLocationNV ) {
      driverTbl.glGetVaryingLocationNV = missing_glGetVaryingLocationNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVaryingLocationNV == loader_glGetVaryingLocationNV) {
      rCtx->dsp->emuTbl.glGetVaryingLocationNV = driverTbl.glGetVaryingLocationNV;
   }
   return driverTbl.glGetVaryingLocationNV(program, name);
}

static void REGAL_CALL missing_glTransformFeedbackAttribsNV(GLuint count, const GLint *attribs, GLenum bufferMode)
{
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(attribs);
   UNUSED_PARAMETER(bufferMode);
   Warning( "glTransformFeedbackAttribsNV not available." );
}

static void REGAL_CALL loader_glTransformFeedbackAttribsNV(GLuint count, const GLint *attribs, GLenum bufferMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTransformFeedbackAttribsNV, "glTransformFeedbackAttribsNV");
   if ( !driverTbl.glTransformFeedbackAttribsNV ) {
      driverTbl.glTransformFeedbackAttribsNV = missing_glTransformFeedbackAttribsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTransformFeedbackAttribsNV == loader_glTransformFeedbackAttribsNV) {
      rCtx->dsp->emuTbl.glTransformFeedbackAttribsNV = driverTbl.glTransformFeedbackAttribsNV;
   }
   driverTbl.glTransformFeedbackAttribsNV(count, attribs, bufferMode);
}

static void REGAL_CALL missing_glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode)
{
   UNUSED_PARAMETER(program);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(locations);
   UNUSED_PARAMETER(bufferMode);
   Warning( "glTransformFeedbackVaryingsNV not available." );
}

static void REGAL_CALL loader_glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTransformFeedbackVaryingsNV, "glTransformFeedbackVaryingsNV");
   if ( !driverTbl.glTransformFeedbackVaryingsNV ) {
      driverTbl.glTransformFeedbackVaryingsNV = missing_glTransformFeedbackVaryingsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTransformFeedbackVaryingsNV == loader_glTransformFeedbackVaryingsNV) {
      rCtx->dsp->emuTbl.glTransformFeedbackVaryingsNV = driverTbl.glTransformFeedbackVaryingsNV;
   }
   driverTbl.glTransformFeedbackVaryingsNV(program, count, locations, bufferMode);
}

// GL_NV_transform_feedback2

static void REGAL_CALL missing_glBindTransformFeedbackNV(GLenum target, GLuint id)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(id);
   Warning( "glBindTransformFeedbackNV not available." );
}

static void REGAL_CALL loader_glBindTransformFeedbackNV(GLenum target, GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindTransformFeedbackNV, "glBindTransformFeedbackNV");
   if ( !driverTbl.glBindTransformFeedbackNV ) {
      driverTbl.glBindTransformFeedbackNV = missing_glBindTransformFeedbackNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindTransformFeedbackNV == loader_glBindTransformFeedbackNV) {
      rCtx->dsp->emuTbl.glBindTransformFeedbackNV = driverTbl.glBindTransformFeedbackNV;
   }
   driverTbl.glBindTransformFeedbackNV(target, id);
}

static void REGAL_CALL missing_glDeleteTransformFeedbacksNV(GLsizei n, const GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "glDeleteTransformFeedbacksNV not available." );
}

static void REGAL_CALL loader_glDeleteTransformFeedbacksNV(GLsizei n, const GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteTransformFeedbacksNV, "glDeleteTransformFeedbacksNV");
   if ( !driverTbl.glDeleteTransformFeedbacksNV ) {
      driverTbl.glDeleteTransformFeedbacksNV = missing_glDeleteTransformFeedbacksNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteTransformFeedbacksNV == loader_glDeleteTransformFeedbacksNV) {
      rCtx->dsp->emuTbl.glDeleteTransformFeedbacksNV = driverTbl.glDeleteTransformFeedbacksNV;
   }
   driverTbl.glDeleteTransformFeedbacksNV(n, ids);
}

static void REGAL_CALL missing_glDrawTransformFeedbackNV(GLenum mode, GLuint name)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(name);
   Warning( "glDrawTransformFeedbackNV not available." );
}

static void REGAL_CALL loader_glDrawTransformFeedbackNV(GLenum mode, GLuint name)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawTransformFeedbackNV, "glDrawTransformFeedbackNV");
   if ( !driverTbl.glDrawTransformFeedbackNV ) {
      driverTbl.glDrawTransformFeedbackNV = missing_glDrawTransformFeedbackNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawTransformFeedbackNV == loader_glDrawTransformFeedbackNV) {
      rCtx->dsp->emuTbl.glDrawTransformFeedbackNV = driverTbl.glDrawTransformFeedbackNV;
   }
   driverTbl.glDrawTransformFeedbackNV(mode, name);
}

static void REGAL_CALL missing_glGenTransformFeedbacksNV(GLsizei n, GLuint *ids)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(ids);
   Warning( "glGenTransformFeedbacksNV not available." );
}

static void REGAL_CALL loader_glGenTransformFeedbacksNV(GLsizei n, GLuint *ids)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenTransformFeedbacksNV, "glGenTransformFeedbacksNV");
   if ( !driverTbl.glGenTransformFeedbacksNV ) {
      driverTbl.glGenTransformFeedbacksNV = missing_glGenTransformFeedbacksNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenTransformFeedbacksNV == loader_glGenTransformFeedbacksNV) {
      rCtx->dsp->emuTbl.glGenTransformFeedbacksNV = driverTbl.glGenTransformFeedbacksNV;
   }
   driverTbl.glGenTransformFeedbacksNV(n, ids);
}

static GLboolean REGAL_CALL missing_glIsTransformFeedbackNV(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "glIsTransformFeedbackNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsTransformFeedbackNV(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsTransformFeedbackNV, "glIsTransformFeedbackNV");
   if ( !driverTbl.glIsTransformFeedbackNV ) {
      driverTbl.glIsTransformFeedbackNV = missing_glIsTransformFeedbackNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsTransformFeedbackNV == loader_glIsTransformFeedbackNV) {
      rCtx->dsp->emuTbl.glIsTransformFeedbackNV = driverTbl.glIsTransformFeedbackNV;
   }
   return driverTbl.glIsTransformFeedbackNV(id);
}

static void REGAL_CALL missing_glPauseTransformFeedbackNV(void)
{
   Warning( "glPauseTransformFeedbackNV not available." );
}

static void REGAL_CALL loader_glPauseTransformFeedbackNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPauseTransformFeedbackNV, "glPauseTransformFeedbackNV");
   if ( !driverTbl.glPauseTransformFeedbackNV ) {
      driverTbl.glPauseTransformFeedbackNV = missing_glPauseTransformFeedbackNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPauseTransformFeedbackNV == loader_glPauseTransformFeedbackNV) {
      rCtx->dsp->emuTbl.glPauseTransformFeedbackNV = driverTbl.glPauseTransformFeedbackNV;
   }
   driverTbl.glPauseTransformFeedbackNV();
}

static void REGAL_CALL missing_glResumeTransformFeedbackNV(void)
{
   Warning( "glResumeTransformFeedbackNV not available." );
}

static void REGAL_CALL loader_glResumeTransformFeedbackNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glResumeTransformFeedbackNV, "glResumeTransformFeedbackNV");
   if ( !driverTbl.glResumeTransformFeedbackNV ) {
      driverTbl.glResumeTransformFeedbackNV = missing_glResumeTransformFeedbackNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glResumeTransformFeedbackNV == loader_glResumeTransformFeedbackNV) {
      rCtx->dsp->emuTbl.glResumeTransformFeedbackNV = driverTbl.glResumeTransformFeedbackNV;
   }
   driverTbl.glResumeTransformFeedbackNV();
}

// GL_NV_vdpau_interop

static void REGAL_CALL missing_glVDPAUFiniNV(void)
{
   Warning( "glVDPAUFiniNV not available." );
}

static void REGAL_CALL loader_glVDPAUFiniNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVDPAUFiniNV, "glVDPAUFiniNV");
   if ( !driverTbl.glVDPAUFiniNV ) {
      driverTbl.glVDPAUFiniNV = missing_glVDPAUFiniNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVDPAUFiniNV == loader_glVDPAUFiniNV) {
      rCtx->dsp->emuTbl.glVDPAUFiniNV = driverTbl.glVDPAUFiniNV;
   }
   driverTbl.glVDPAUFiniNV();
}

static void REGAL_CALL missing_glVDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
   UNUSED_PARAMETER(surface);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(bufSize);
   UNUSED_PARAMETER(length);
   UNUSED_PARAMETER(values);
   Warning( "glVDPAUGetSurfaceivNV not available." );
}

static void REGAL_CALL loader_glVDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVDPAUGetSurfaceivNV, "glVDPAUGetSurfaceivNV");
   if ( !driverTbl.glVDPAUGetSurfaceivNV ) {
      driverTbl.glVDPAUGetSurfaceivNV = missing_glVDPAUGetSurfaceivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVDPAUGetSurfaceivNV == loader_glVDPAUGetSurfaceivNV) {
      rCtx->dsp->emuTbl.glVDPAUGetSurfaceivNV = driverTbl.glVDPAUGetSurfaceivNV;
   }
   driverTbl.glVDPAUGetSurfaceivNV(surface, pname, bufSize, length, values);
}

static void REGAL_CALL missing_glVDPAUInitNV(const GLvoid *vdpDevice, const GLvoid *getProcAddress)
{
   UNUSED_PARAMETER(vdpDevice);
   UNUSED_PARAMETER(getProcAddress);
   Warning( "glVDPAUInitNV not available." );
}

static void REGAL_CALL loader_glVDPAUInitNV(const GLvoid *vdpDevice, const GLvoid *getProcAddress)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVDPAUInitNV, "glVDPAUInitNV");
   if ( !driverTbl.glVDPAUInitNV ) {
      driverTbl.glVDPAUInitNV = missing_glVDPAUInitNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVDPAUInitNV == loader_glVDPAUInitNV) {
      rCtx->dsp->emuTbl.glVDPAUInitNV = driverTbl.glVDPAUInitNV;
   }
   driverTbl.glVDPAUInitNV(vdpDevice, getProcAddress);
}

static GLboolean REGAL_CALL missing_glVDPAUIsSurfaceNV(GLvdpauSurfaceNV surface)
{
   UNUSED_PARAMETER(surface);
   Warning( "glVDPAUIsSurfaceNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glVDPAUIsSurfaceNV(GLvdpauSurfaceNV surface)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVDPAUIsSurfaceNV, "glVDPAUIsSurfaceNV");
   if ( !driverTbl.glVDPAUIsSurfaceNV ) {
      driverTbl.glVDPAUIsSurfaceNV = missing_glVDPAUIsSurfaceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVDPAUIsSurfaceNV == loader_glVDPAUIsSurfaceNV) {
      rCtx->dsp->emuTbl.glVDPAUIsSurfaceNV = driverTbl.glVDPAUIsSurfaceNV;
   }
   return driverTbl.glVDPAUIsSurfaceNV(surface);
}

static void REGAL_CALL missing_glVDPAUMapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces)
{
   UNUSED_PARAMETER(numSurfaces);
   UNUSED_PARAMETER(surfaces);
   Warning( "glVDPAUMapSurfacesNV not available." );
}

static void REGAL_CALL loader_glVDPAUMapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVDPAUMapSurfacesNV, "glVDPAUMapSurfacesNV");
   if ( !driverTbl.glVDPAUMapSurfacesNV ) {
      driverTbl.glVDPAUMapSurfacesNV = missing_glVDPAUMapSurfacesNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVDPAUMapSurfacesNV == loader_glVDPAUMapSurfacesNV) {
      rCtx->dsp->emuTbl.glVDPAUMapSurfacesNV = driverTbl.glVDPAUMapSurfacesNV;
   }
   driverTbl.glVDPAUMapSurfacesNV(numSurfaces, surfaces);
}

static GLvdpauSurfaceNV REGAL_CALL missing_glVDPAURegisterOutputSurfaceNV(const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames)
{
   UNUSED_PARAMETER(vdpSurface);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(numTextureNames);
   UNUSED_PARAMETER(textureNames);
   Warning( "glVDPAURegisterOutputSurfaceNV not available." );
  GLvdpauSurfaceNV  ret = (GLvdpauSurfaceNV )0;
  return ret;
}

static GLvdpauSurfaceNV REGAL_CALL loader_glVDPAURegisterOutputSurfaceNV(const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVDPAURegisterOutputSurfaceNV, "glVDPAURegisterOutputSurfaceNV");
   if ( !driverTbl.glVDPAURegisterOutputSurfaceNV ) {
      driverTbl.glVDPAURegisterOutputSurfaceNV = missing_glVDPAURegisterOutputSurfaceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVDPAURegisterOutputSurfaceNV == loader_glVDPAURegisterOutputSurfaceNV) {
      rCtx->dsp->emuTbl.glVDPAURegisterOutputSurfaceNV = driverTbl.glVDPAURegisterOutputSurfaceNV;
   }
   return driverTbl.glVDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
}

static GLvdpauSurfaceNV REGAL_CALL missing_glVDPAURegisterVideoSurfaceNV(const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames)
{
   UNUSED_PARAMETER(vdpSurface);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(numTextureNames);
   UNUSED_PARAMETER(textureNames);
   Warning( "glVDPAURegisterVideoSurfaceNV not available." );
  GLvdpauSurfaceNV  ret = (GLvdpauSurfaceNV )0;
  return ret;
}

static GLvdpauSurfaceNV REGAL_CALL loader_glVDPAURegisterVideoSurfaceNV(const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVDPAURegisterVideoSurfaceNV, "glVDPAURegisterVideoSurfaceNV");
   if ( !driverTbl.glVDPAURegisterVideoSurfaceNV ) {
      driverTbl.glVDPAURegisterVideoSurfaceNV = missing_glVDPAURegisterVideoSurfaceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVDPAURegisterVideoSurfaceNV == loader_glVDPAURegisterVideoSurfaceNV) {
      rCtx->dsp->emuTbl.glVDPAURegisterVideoSurfaceNV = driverTbl.glVDPAURegisterVideoSurfaceNV;
   }
   return driverTbl.glVDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
}

static void REGAL_CALL missing_glVDPAUSurfaceAccessNV(GLvdpauSurfaceNV surface, GLenum access)
{
   UNUSED_PARAMETER(surface);
   UNUSED_PARAMETER(access);
   Warning( "glVDPAUSurfaceAccessNV not available." );
}

static void REGAL_CALL loader_glVDPAUSurfaceAccessNV(GLvdpauSurfaceNV surface, GLenum access)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVDPAUSurfaceAccessNV, "glVDPAUSurfaceAccessNV");
   if ( !driverTbl.glVDPAUSurfaceAccessNV ) {
      driverTbl.glVDPAUSurfaceAccessNV = missing_glVDPAUSurfaceAccessNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVDPAUSurfaceAccessNV == loader_glVDPAUSurfaceAccessNV) {
      rCtx->dsp->emuTbl.glVDPAUSurfaceAccessNV = driverTbl.glVDPAUSurfaceAccessNV;
   }
   driverTbl.glVDPAUSurfaceAccessNV(surface, access);
}

static void REGAL_CALL missing_glVDPAUUnmapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces)
{
   UNUSED_PARAMETER(numSurfaces);
   UNUSED_PARAMETER(surfaces);
   Warning( "glVDPAUUnmapSurfacesNV not available." );
}

static void REGAL_CALL loader_glVDPAUUnmapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVDPAUUnmapSurfacesNV, "glVDPAUUnmapSurfacesNV");
   if ( !driverTbl.glVDPAUUnmapSurfacesNV ) {
      driverTbl.glVDPAUUnmapSurfacesNV = missing_glVDPAUUnmapSurfacesNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVDPAUUnmapSurfacesNV == loader_glVDPAUUnmapSurfacesNV) {
      rCtx->dsp->emuTbl.glVDPAUUnmapSurfacesNV = driverTbl.glVDPAUUnmapSurfacesNV;
   }
   driverTbl.glVDPAUUnmapSurfacesNV(numSurfaces, surfaces);
}

static void REGAL_CALL missing_glVDPAUUnregisterSurfaceNV(GLvdpauSurfaceNV surface)
{
   UNUSED_PARAMETER(surface);
   Warning( "glVDPAUUnregisterSurfaceNV not available." );
}

static void REGAL_CALL loader_glVDPAUUnregisterSurfaceNV(GLvdpauSurfaceNV surface)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVDPAUUnregisterSurfaceNV, "glVDPAUUnregisterSurfaceNV");
   if ( !driverTbl.glVDPAUUnregisterSurfaceNV ) {
      driverTbl.glVDPAUUnregisterSurfaceNV = missing_glVDPAUUnregisterSurfaceNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVDPAUUnregisterSurfaceNV == loader_glVDPAUUnregisterSurfaceNV) {
      rCtx->dsp->emuTbl.glVDPAUUnregisterSurfaceNV = driverTbl.glVDPAUUnregisterSurfaceNV;
   }
   driverTbl.glVDPAUUnregisterSurfaceNV(surface);
}

// GL_NV_vertex_array_range

static void REGAL_CALL missing_glFlushVertexArrayRangeNV(void)
{
   Warning( "glFlushVertexArrayRangeNV not available." );
}

static void REGAL_CALL loader_glFlushVertexArrayRangeNV(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFlushVertexArrayRangeNV, "glFlushVertexArrayRangeNV");
   if ( !driverTbl.glFlushVertexArrayRangeNV ) {
      driverTbl.glFlushVertexArrayRangeNV = missing_glFlushVertexArrayRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFlushVertexArrayRangeNV == loader_glFlushVertexArrayRangeNV) {
      rCtx->dsp->emuTbl.glFlushVertexArrayRangeNV = driverTbl.glFlushVertexArrayRangeNV;
   }
   driverTbl.glFlushVertexArrayRangeNV();
}

static void REGAL_CALL missing_glVertexArrayRangeNV(GLsizei size, const GLvoid *pointer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(pointer);
   Warning( "glVertexArrayRangeNV not available." );
}

static void REGAL_CALL loader_glVertexArrayRangeNV(GLsizei size, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexArrayRangeNV, "glVertexArrayRangeNV");
   if ( !driverTbl.glVertexArrayRangeNV ) {
      driverTbl.glVertexArrayRangeNV = missing_glVertexArrayRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexArrayRangeNV == loader_glVertexArrayRangeNV) {
      rCtx->dsp->emuTbl.glVertexArrayRangeNV = driverTbl.glVertexArrayRangeNV;
   }
   driverTbl.glVertexArrayRangeNV(size, pointer);
}

// GL_NV_vertex_attrib_integer_64bit

static void REGAL_CALL missing_glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribLi64vNV not available." );
}

static void REGAL_CALL loader_glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribLi64vNV, "glGetVertexAttribLi64vNV");
   if ( !driverTbl.glGetVertexAttribLi64vNV ) {
      driverTbl.glGetVertexAttribLi64vNV = missing_glGetVertexAttribLi64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribLi64vNV == loader_glGetVertexAttribLi64vNV) {
      rCtx->dsp->emuTbl.glGetVertexAttribLi64vNV = driverTbl.glGetVertexAttribLi64vNV;
   }
   driverTbl.glGetVertexAttribLi64vNV(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribLui64vNV not available." );
}

static void REGAL_CALL loader_glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribLui64vNV, "glGetVertexAttribLui64vNV");
   if ( !driverTbl.glGetVertexAttribLui64vNV ) {
      driverTbl.glGetVertexAttribLui64vNV = missing_glGetVertexAttribLui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribLui64vNV == loader_glGetVertexAttribLui64vNV) {
      rCtx->dsp->emuTbl.glGetVertexAttribLui64vNV = driverTbl.glGetVertexAttribLui64vNV;
   }
   driverTbl.glGetVertexAttribLui64vNV(index, pname, params);
}

static void REGAL_CALL missing_glVertexAttribL1i64NV(GLuint index, GLint64EXT x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttribL1i64NV not available." );
}

static void REGAL_CALL loader_glVertexAttribL1i64NV(GLuint index, GLint64EXT x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL1i64NV, "glVertexAttribL1i64NV");
   if ( !driverTbl.glVertexAttribL1i64NV ) {
      driverTbl.glVertexAttribL1i64NV = missing_glVertexAttribL1i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL1i64NV == loader_glVertexAttribL1i64NV) {
      rCtx->dsp->emuTbl.glVertexAttribL1i64NV = driverTbl.glVertexAttribL1i64NV;
   }
   driverTbl.glVertexAttribL1i64NV(index, x);
}

static void REGAL_CALL missing_glVertexAttribL1i64vNV(GLuint index, const GLint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL1i64vNV not available." );
}

static void REGAL_CALL loader_glVertexAttribL1i64vNV(GLuint index, const GLint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL1i64vNV, "glVertexAttribL1i64vNV");
   if ( !driverTbl.glVertexAttribL1i64vNV ) {
      driverTbl.glVertexAttribL1i64vNV = missing_glVertexAttribL1i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL1i64vNV == loader_glVertexAttribL1i64vNV) {
      rCtx->dsp->emuTbl.glVertexAttribL1i64vNV = driverTbl.glVertexAttribL1i64vNV;
   }
   driverTbl.glVertexAttribL1i64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttribL1ui64NV not available." );
}

static void REGAL_CALL loader_glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL1ui64NV, "glVertexAttribL1ui64NV");
   if ( !driverTbl.glVertexAttribL1ui64NV ) {
      driverTbl.glVertexAttribL1ui64NV = missing_glVertexAttribL1ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL1ui64NV == loader_glVertexAttribL1ui64NV) {
      rCtx->dsp->emuTbl.glVertexAttribL1ui64NV = driverTbl.glVertexAttribL1ui64NV;
   }
   driverTbl.glVertexAttribL1ui64NV(index, x);
}

static void REGAL_CALL missing_glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL1ui64vNV not available." );
}

static void REGAL_CALL loader_glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL1ui64vNV, "glVertexAttribL1ui64vNV");
   if ( !driverTbl.glVertexAttribL1ui64vNV ) {
      driverTbl.glVertexAttribL1ui64vNV = missing_glVertexAttribL1ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL1ui64vNV == loader_glVertexAttribL1ui64vNV) {
      rCtx->dsp->emuTbl.glVertexAttribL1ui64vNV = driverTbl.glVertexAttribL1ui64vNV;
   }
   driverTbl.glVertexAttribL1ui64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttribL2i64NV not available." );
}

static void REGAL_CALL loader_glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL2i64NV, "glVertexAttribL2i64NV");
   if ( !driverTbl.glVertexAttribL2i64NV ) {
      driverTbl.glVertexAttribL2i64NV = missing_glVertexAttribL2i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL2i64NV == loader_glVertexAttribL2i64NV) {
      rCtx->dsp->emuTbl.glVertexAttribL2i64NV = driverTbl.glVertexAttribL2i64NV;
   }
   driverTbl.glVertexAttribL2i64NV(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribL2i64vNV(GLuint index, const GLint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL2i64vNV not available." );
}

static void REGAL_CALL loader_glVertexAttribL2i64vNV(GLuint index, const GLint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL2i64vNV, "glVertexAttribL2i64vNV");
   if ( !driverTbl.glVertexAttribL2i64vNV ) {
      driverTbl.glVertexAttribL2i64vNV = missing_glVertexAttribL2i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL2i64vNV == loader_glVertexAttribL2i64vNV) {
      rCtx->dsp->emuTbl.glVertexAttribL2i64vNV = driverTbl.glVertexAttribL2i64vNV;
   }
   driverTbl.glVertexAttribL2i64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttribL2ui64NV not available." );
}

static void REGAL_CALL loader_glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL2ui64NV, "glVertexAttribL2ui64NV");
   if ( !driverTbl.glVertexAttribL2ui64NV ) {
      driverTbl.glVertexAttribL2ui64NV = missing_glVertexAttribL2ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL2ui64NV == loader_glVertexAttribL2ui64NV) {
      rCtx->dsp->emuTbl.glVertexAttribL2ui64NV = driverTbl.glVertexAttribL2ui64NV;
   }
   driverTbl.glVertexAttribL2ui64NV(index, x, y);
}

static void REGAL_CALL missing_glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL2ui64vNV not available." );
}

static void REGAL_CALL loader_glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL2ui64vNV, "glVertexAttribL2ui64vNV");
   if ( !driverTbl.glVertexAttribL2ui64vNV ) {
      driverTbl.glVertexAttribL2ui64vNV = missing_glVertexAttribL2ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL2ui64vNV == loader_glVertexAttribL2ui64vNV) {
      rCtx->dsp->emuTbl.glVertexAttribL2ui64vNV = driverTbl.glVertexAttribL2ui64vNV;
   }
   driverTbl.glVertexAttribL2ui64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttribL3i64NV not available." );
}

static void REGAL_CALL loader_glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL3i64NV, "glVertexAttribL3i64NV");
   if ( !driverTbl.glVertexAttribL3i64NV ) {
      driverTbl.glVertexAttribL3i64NV = missing_glVertexAttribL3i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL3i64NV == loader_glVertexAttribL3i64NV) {
      rCtx->dsp->emuTbl.glVertexAttribL3i64NV = driverTbl.glVertexAttribL3i64NV;
   }
   driverTbl.glVertexAttribL3i64NV(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribL3i64vNV(GLuint index, const GLint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL3i64vNV not available." );
}

static void REGAL_CALL loader_glVertexAttribL3i64vNV(GLuint index, const GLint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL3i64vNV, "glVertexAttribL3i64vNV");
   if ( !driverTbl.glVertexAttribL3i64vNV ) {
      driverTbl.glVertexAttribL3i64vNV = missing_glVertexAttribL3i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL3i64vNV == loader_glVertexAttribL3i64vNV) {
      rCtx->dsp->emuTbl.glVertexAttribL3i64vNV = driverTbl.glVertexAttribL3i64vNV;
   }
   driverTbl.glVertexAttribL3i64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttribL3ui64NV not available." );
}

static void REGAL_CALL loader_glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL3ui64NV, "glVertexAttribL3ui64NV");
   if ( !driverTbl.glVertexAttribL3ui64NV ) {
      driverTbl.glVertexAttribL3ui64NV = missing_glVertexAttribL3ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL3ui64NV == loader_glVertexAttribL3ui64NV) {
      rCtx->dsp->emuTbl.glVertexAttribL3ui64NV = driverTbl.glVertexAttribL3ui64NV;
   }
   driverTbl.glVertexAttribL3ui64NV(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL3ui64vNV not available." );
}

static void REGAL_CALL loader_glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL3ui64vNV, "glVertexAttribL3ui64vNV");
   if ( !driverTbl.glVertexAttribL3ui64vNV ) {
      driverTbl.glVertexAttribL3ui64vNV = missing_glVertexAttribL3ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL3ui64vNV == loader_glVertexAttribL3ui64vNV) {
      rCtx->dsp->emuTbl.glVertexAttribL3ui64vNV = driverTbl.glVertexAttribL3ui64vNV;
   }
   driverTbl.glVertexAttribL3ui64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttribL4i64NV not available." );
}

static void REGAL_CALL loader_glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL4i64NV, "glVertexAttribL4i64NV");
   if ( !driverTbl.glVertexAttribL4i64NV ) {
      driverTbl.glVertexAttribL4i64NV = missing_glVertexAttribL4i64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL4i64NV == loader_glVertexAttribL4i64NV) {
      rCtx->dsp->emuTbl.glVertexAttribL4i64NV = driverTbl.glVertexAttribL4i64NV;
   }
   driverTbl.glVertexAttribL4i64NV(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribL4i64vNV(GLuint index, const GLint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL4i64vNV not available." );
}

static void REGAL_CALL loader_glVertexAttribL4i64vNV(GLuint index, const GLint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL4i64vNV, "glVertexAttribL4i64vNV");
   if ( !driverTbl.glVertexAttribL4i64vNV ) {
      driverTbl.glVertexAttribL4i64vNV = missing_glVertexAttribL4i64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL4i64vNV == loader_glVertexAttribL4i64vNV) {
      rCtx->dsp->emuTbl.glVertexAttribL4i64vNV = driverTbl.glVertexAttribL4i64vNV;
   }
   driverTbl.glVertexAttribL4i64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttribL4ui64NV not available." );
}

static void REGAL_CALL loader_glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL4ui64NV, "glVertexAttribL4ui64NV");
   if ( !driverTbl.glVertexAttribL4ui64NV ) {
      driverTbl.glVertexAttribL4ui64NV = missing_glVertexAttribL4ui64NV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL4ui64NV == loader_glVertexAttribL4ui64NV) {
      rCtx->dsp->emuTbl.glVertexAttribL4ui64NV = driverTbl.glVertexAttribL4ui64NV;
   }
   driverTbl.glVertexAttribL4ui64NV(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribL4ui64vNV not available." );
}

static void REGAL_CALL loader_glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribL4ui64vNV, "glVertexAttribL4ui64vNV");
   if ( !driverTbl.glVertexAttribL4ui64vNV ) {
      driverTbl.glVertexAttribL4ui64vNV = missing_glVertexAttribL4ui64vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribL4ui64vNV == loader_glVertexAttribL4ui64vNV) {
      rCtx->dsp->emuTbl.glVertexAttribL4ui64vNV = driverTbl.glVertexAttribL4ui64vNV;
   }
   driverTbl.glVertexAttribL4ui64vNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "glVertexAttribLFormatNV not available." );
}

static void REGAL_CALL loader_glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribLFormatNV, "glVertexAttribLFormatNV");
   if ( !driverTbl.glVertexAttribLFormatNV ) {
      driverTbl.glVertexAttribLFormatNV = missing_glVertexAttribLFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribLFormatNV == loader_glVertexAttribLFormatNV) {
      rCtx->dsp->emuTbl.glVertexAttribLFormatNV = driverTbl.glVertexAttribLFormatNV;
   }
   driverTbl.glVertexAttribLFormatNV(index, size, type, stride);
}

// GL_NV_vertex_buffer_unified_memory

static void REGAL_CALL missing_glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(address);
   UNUSED_PARAMETER(length);
   Warning( "glBufferAddressRangeNV not available." );
}

static void REGAL_CALL loader_glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBufferAddressRangeNV, "glBufferAddressRangeNV");
   if ( !driverTbl.glBufferAddressRangeNV ) {
      driverTbl.glBufferAddressRangeNV = missing_glBufferAddressRangeNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBufferAddressRangeNV == loader_glBufferAddressRangeNV) {
      rCtx->dsp->emuTbl.glBufferAddressRangeNV = driverTbl.glBufferAddressRangeNV;
   }
   driverTbl.glBufferAddressRangeNV(pname, index, address, length);
}

static void REGAL_CALL missing_glColorFormatNV(GLint size, GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "glColorFormatNV not available." );
}

static void REGAL_CALL loader_glColorFormatNV(GLint size, GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorFormatNV, "glColorFormatNV");
   if ( !driverTbl.glColorFormatNV ) {
      driverTbl.glColorFormatNV = missing_glColorFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorFormatNV == loader_glColorFormatNV) {
      rCtx->dsp->emuTbl.glColorFormatNV = driverTbl.glColorFormatNV;
   }
   driverTbl.glColorFormatNV(size, type, stride);
}

static void REGAL_CALL missing_glEdgeFlagFormatNV(GLsizei stride)
{
   UNUSED_PARAMETER(stride);
   Warning( "glEdgeFlagFormatNV not available." );
}

static void REGAL_CALL loader_glEdgeFlagFormatNV(GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEdgeFlagFormatNV, "glEdgeFlagFormatNV");
   if ( !driverTbl.glEdgeFlagFormatNV ) {
      driverTbl.glEdgeFlagFormatNV = missing_glEdgeFlagFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEdgeFlagFormatNV == loader_glEdgeFlagFormatNV) {
      rCtx->dsp->emuTbl.glEdgeFlagFormatNV = driverTbl.glEdgeFlagFormatNV;
   }
   driverTbl.glEdgeFlagFormatNV(stride);
}

static void REGAL_CALL missing_glFogCoordFormatNV(GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "glFogCoordFormatNV not available." );
}

static void REGAL_CALL loader_glFogCoordFormatNV(GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogCoordFormatNV, "glFogCoordFormatNV");
   if ( !driverTbl.glFogCoordFormatNV ) {
      driverTbl.glFogCoordFormatNV = missing_glFogCoordFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogCoordFormatNV == loader_glFogCoordFormatNV) {
      rCtx->dsp->emuTbl.glFogCoordFormatNV = driverTbl.glFogCoordFormatNV;
   }
   driverTbl.glFogCoordFormatNV(type, stride);
}

static void REGAL_CALL missing_glGetIntegerui64i_vNV(GLenum target, GLuint index, GLuint64EXT *data)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(data);
   Warning( "glGetIntegerui64i_vNV not available." );
}

static void REGAL_CALL loader_glGetIntegerui64i_vNV(GLenum target, GLuint index, GLuint64EXT *data)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetIntegerui64i_vNV, "glGetIntegerui64i_vNV");
   if ( !driverTbl.glGetIntegerui64i_vNV ) {
      driverTbl.glGetIntegerui64i_vNV = missing_glGetIntegerui64i_vNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetIntegerui64i_vNV == loader_glGetIntegerui64i_vNV) {
      rCtx->dsp->emuTbl.glGetIntegerui64i_vNV = driverTbl.glGetIntegerui64i_vNV;
   }
   driverTbl.glGetIntegerui64i_vNV(target, index, data);
}

static void REGAL_CALL missing_glIndexFormatNV(GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "glIndexFormatNV not available." );
}

static void REGAL_CALL loader_glIndexFormatNV(GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIndexFormatNV, "glIndexFormatNV");
   if ( !driverTbl.glIndexFormatNV ) {
      driverTbl.glIndexFormatNV = missing_glIndexFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIndexFormatNV == loader_glIndexFormatNV) {
      rCtx->dsp->emuTbl.glIndexFormatNV = driverTbl.glIndexFormatNV;
   }
   driverTbl.glIndexFormatNV(type, stride);
}

static void REGAL_CALL missing_glNormalFormatNV(GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "glNormalFormatNV not available." );
}

static void REGAL_CALL loader_glNormalFormatNV(GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormalFormatNV, "glNormalFormatNV");
   if ( !driverTbl.glNormalFormatNV ) {
      driverTbl.glNormalFormatNV = missing_glNormalFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormalFormatNV == loader_glNormalFormatNV) {
      rCtx->dsp->emuTbl.glNormalFormatNV = driverTbl.glNormalFormatNV;
   }
   driverTbl.glNormalFormatNV(type, stride);
}

static void REGAL_CALL missing_glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "glSecondaryColorFormatNV not available." );
}

static void REGAL_CALL loader_glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSecondaryColorFormatNV, "glSecondaryColorFormatNV");
   if ( !driverTbl.glSecondaryColorFormatNV ) {
      driverTbl.glSecondaryColorFormatNV = missing_glSecondaryColorFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSecondaryColorFormatNV == loader_glSecondaryColorFormatNV) {
      rCtx->dsp->emuTbl.glSecondaryColorFormatNV = driverTbl.glSecondaryColorFormatNV;
   }
   driverTbl.glSecondaryColorFormatNV(size, type, stride);
}

static void REGAL_CALL missing_glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "glTexCoordFormatNV not available." );
}

static void REGAL_CALL loader_glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoordFormatNV, "glTexCoordFormatNV");
   if ( !driverTbl.glTexCoordFormatNV ) {
      driverTbl.glTexCoordFormatNV = missing_glTexCoordFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoordFormatNV == loader_glTexCoordFormatNV) {
      rCtx->dsp->emuTbl.glTexCoordFormatNV = driverTbl.glTexCoordFormatNV;
   }
   driverTbl.glTexCoordFormatNV(size, type, stride);
}

static void REGAL_CALL missing_glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(normalized);
   UNUSED_PARAMETER(stride);
   Warning( "glVertexAttribFormatNV not available." );
}

static void REGAL_CALL loader_glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribFormatNV, "glVertexAttribFormatNV");
   if ( !driverTbl.glVertexAttribFormatNV ) {
      driverTbl.glVertexAttribFormatNV = missing_glVertexAttribFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribFormatNV == loader_glVertexAttribFormatNV) {
      rCtx->dsp->emuTbl.glVertexAttribFormatNV = driverTbl.glVertexAttribFormatNV;
   }
   driverTbl.glVertexAttribFormatNV(index, size, type, normalized, stride);
}

static void REGAL_CALL missing_glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "glVertexAttribIFormatNV not available." );
}

static void REGAL_CALL loader_glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribIFormatNV, "glVertexAttribIFormatNV");
   if ( !driverTbl.glVertexAttribIFormatNV ) {
      driverTbl.glVertexAttribIFormatNV = missing_glVertexAttribIFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribIFormatNV == loader_glVertexAttribIFormatNV) {
      rCtx->dsp->emuTbl.glVertexAttribIFormatNV = driverTbl.glVertexAttribIFormatNV;
   }
   driverTbl.glVertexAttribIFormatNV(index, size, type, stride);
}

static void REGAL_CALL missing_glVertexFormatNV(GLint size, GLenum type, GLsizei stride)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   Warning( "glVertexFormatNV not available." );
}

static void REGAL_CALL loader_glVertexFormatNV(GLint size, GLenum type, GLsizei stride)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexFormatNV, "glVertexFormatNV");
   if ( !driverTbl.glVertexFormatNV ) {
      driverTbl.glVertexFormatNV = missing_glVertexFormatNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexFormatNV == loader_glVertexFormatNV) {
      rCtx->dsp->emuTbl.glVertexFormatNV = driverTbl.glVertexFormatNV;
   }
   driverTbl.glVertexFormatNV(size, type, stride);
}

// GL_NV_vertex_program

static GLboolean REGAL_CALL missing_glAreProgramsResidentNV(GLsizei n, const GLuint *programs, GLboolean *residences)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(programs);
   UNUSED_PARAMETER(residences);
   Warning( "glAreProgramsResidentNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glAreProgramsResidentNV(GLsizei n, const GLuint *programs, GLboolean *residences)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glAreProgramsResidentNV, "glAreProgramsResidentNV");
   if ( !driverTbl.glAreProgramsResidentNV ) {
      driverTbl.glAreProgramsResidentNV = missing_glAreProgramsResidentNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glAreProgramsResidentNV == loader_glAreProgramsResidentNV) {
      rCtx->dsp->emuTbl.glAreProgramsResidentNV = driverTbl.glAreProgramsResidentNV;
   }
   return driverTbl.glAreProgramsResidentNV(n, programs, residences);
}

static void REGAL_CALL missing_glBindProgramNV(GLenum target, GLuint id)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(id);
   Warning( "glBindProgramNV not available." );
}

static void REGAL_CALL loader_glBindProgramNV(GLenum target, GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindProgramNV, "glBindProgramNV");
   if ( !driverTbl.glBindProgramNV ) {
      driverTbl.glBindProgramNV = missing_glBindProgramNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindProgramNV == loader_glBindProgramNV) {
      rCtx->dsp->emuTbl.glBindProgramNV = driverTbl.glBindProgramNV;
   }
   driverTbl.glBindProgramNV(target, id);
}

static void REGAL_CALL missing_glDeleteProgramsNV(GLsizei n, const GLuint *programs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(programs);
   Warning( "glDeleteProgramsNV not available." );
}

static void REGAL_CALL loader_glDeleteProgramsNV(GLsizei n, const GLuint *programs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteProgramsNV, "glDeleteProgramsNV");
   if ( !driverTbl.glDeleteProgramsNV ) {
      driverTbl.glDeleteProgramsNV = missing_glDeleteProgramsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteProgramsNV == loader_glDeleteProgramsNV) {
      rCtx->dsp->emuTbl.glDeleteProgramsNV = driverTbl.glDeleteProgramsNV;
   }
   driverTbl.glDeleteProgramsNV(n, programs);
}

static void REGAL_CALL missing_glExecuteProgramNV(GLenum target, GLuint id, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(params);
   Warning( "glExecuteProgramNV not available." );
}

static void REGAL_CALL loader_glExecuteProgramNV(GLenum target, GLuint id, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glExecuteProgramNV, "glExecuteProgramNV");
   if ( !driverTbl.glExecuteProgramNV ) {
      driverTbl.glExecuteProgramNV = missing_glExecuteProgramNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glExecuteProgramNV == loader_glExecuteProgramNV) {
      rCtx->dsp->emuTbl.glExecuteProgramNV = driverTbl.glExecuteProgramNV;
   }
   driverTbl.glExecuteProgramNV(target, id, params);
}

static void REGAL_CALL missing_glGenProgramsNV(GLsizei n, GLuint *programs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(programs);
   Warning( "glGenProgramsNV not available." );
}

static void REGAL_CALL loader_glGenProgramsNV(GLsizei n, GLuint *programs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenProgramsNV, "glGenProgramsNV");
   if ( !driverTbl.glGenProgramsNV ) {
      driverTbl.glGenProgramsNV = missing_glGenProgramsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenProgramsNV == loader_glGenProgramsNV) {
      rCtx->dsp->emuTbl.glGenProgramsNV = driverTbl.glGenProgramsNV;
   }
   driverTbl.glGenProgramsNV(n, programs);
}

static void REGAL_CALL missing_glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramParameterdvNV not available." );
}

static void REGAL_CALL loader_glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramParameterdvNV, "glGetProgramParameterdvNV");
   if ( !driverTbl.glGetProgramParameterdvNV ) {
      driverTbl.glGetProgramParameterdvNV = missing_glGetProgramParameterdvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramParameterdvNV == loader_glGetProgramParameterdvNV) {
      rCtx->dsp->emuTbl.glGetProgramParameterdvNV = driverTbl.glGetProgramParameterdvNV;
   }
   driverTbl.glGetProgramParameterdvNV(target, index, pname, params);
}

static void REGAL_CALL missing_glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramParameterfvNV not available." );
}

static void REGAL_CALL loader_glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramParameterfvNV, "glGetProgramParameterfvNV");
   if ( !driverTbl.glGetProgramParameterfvNV ) {
      driverTbl.glGetProgramParameterfvNV = missing_glGetProgramParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramParameterfvNV == loader_glGetProgramParameterfvNV) {
      rCtx->dsp->emuTbl.glGetProgramParameterfvNV = driverTbl.glGetProgramParameterfvNV;
   }
   driverTbl.glGetProgramParameterfvNV(target, index, pname, params);
}

static void REGAL_CALL missing_glGetProgramStringNV(GLuint id, GLenum pname, GLubyte *program)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(program);
   Warning( "glGetProgramStringNV not available." );
}

static void REGAL_CALL loader_glGetProgramStringNV(GLuint id, GLenum pname, GLubyte *program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramStringNV, "glGetProgramStringNV");
   if ( !driverTbl.glGetProgramStringNV ) {
      driverTbl.glGetProgramStringNV = missing_glGetProgramStringNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramStringNV == loader_glGetProgramStringNV) {
      rCtx->dsp->emuTbl.glGetProgramStringNV = driverTbl.glGetProgramStringNV;
   }
   driverTbl.glGetProgramStringNV(id, pname, program);
}

static void REGAL_CALL missing_glGetProgramivNV(GLuint id, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetProgramivNV not available." );
}

static void REGAL_CALL loader_glGetProgramivNV(GLuint id, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetProgramivNV, "glGetProgramivNV");
   if ( !driverTbl.glGetProgramivNV ) {
      driverTbl.glGetProgramivNV = missing_glGetProgramivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetProgramivNV == loader_glGetProgramivNV) {
      rCtx->dsp->emuTbl.glGetProgramivNV = driverTbl.glGetProgramivNV;
   }
   driverTbl.glGetProgramivNV(id, pname, params);
}

static void REGAL_CALL missing_glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(address);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetTrackMatrixivNV not available." );
}

static void REGAL_CALL loader_glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTrackMatrixivNV, "glGetTrackMatrixivNV");
   if ( !driverTbl.glGetTrackMatrixivNV ) {
      driverTbl.glGetTrackMatrixivNV = missing_glGetTrackMatrixivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTrackMatrixivNV == loader_glGetTrackMatrixivNV) {
      rCtx->dsp->emuTbl.glGetTrackMatrixivNV = driverTbl.glGetTrackMatrixivNV;
   }
   driverTbl.glGetTrackMatrixivNV(target, address, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid **pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(pointer);
   Warning( "glGetVertexAttribPointervNV not available." );
}

static void REGAL_CALL loader_glGetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribPointervNV, "glGetVertexAttribPointervNV");
   if ( !driverTbl.glGetVertexAttribPointervNV ) {
      driverTbl.glGetVertexAttribPointervNV = missing_glGetVertexAttribPointervNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribPointervNV == loader_glGetVertexAttribPointervNV) {
      rCtx->dsp->emuTbl.glGetVertexAttribPointervNV = driverTbl.glGetVertexAttribPointervNV;
   }
   driverTbl.glGetVertexAttribPointervNV(index, pname, pointer);
}

static void REGAL_CALL missing_glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribdvNV not available." );
}

static void REGAL_CALL loader_glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribdvNV, "glGetVertexAttribdvNV");
   if ( !driverTbl.glGetVertexAttribdvNV ) {
      driverTbl.glGetVertexAttribdvNV = missing_glGetVertexAttribdvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribdvNV == loader_glGetVertexAttribdvNV) {
      rCtx->dsp->emuTbl.glGetVertexAttribdvNV = driverTbl.glGetVertexAttribdvNV;
   }
   driverTbl.glGetVertexAttribdvNV(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribfvNV not available." );
}

static void REGAL_CALL loader_glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribfvNV, "glGetVertexAttribfvNV");
   if ( !driverTbl.glGetVertexAttribfvNV ) {
      driverTbl.glGetVertexAttribfvNV = missing_glGetVertexAttribfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribfvNV == loader_glGetVertexAttribfvNV) {
      rCtx->dsp->emuTbl.glGetVertexAttribfvNV = driverTbl.glGetVertexAttribfvNV;
   }
   driverTbl.glGetVertexAttribfvNV(index, pname, params);
}

static void REGAL_CALL missing_glGetVertexAttribivNV(GLuint index, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVertexAttribivNV not available." );
}

static void REGAL_CALL loader_glGetVertexAttribivNV(GLuint index, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVertexAttribivNV, "glGetVertexAttribivNV");
   if ( !driverTbl.glGetVertexAttribivNV ) {
      driverTbl.glGetVertexAttribivNV = missing_glGetVertexAttribivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVertexAttribivNV == loader_glGetVertexAttribivNV) {
      rCtx->dsp->emuTbl.glGetVertexAttribivNV = driverTbl.glGetVertexAttribivNV;
   }
   driverTbl.glGetVertexAttribivNV(index, pname, params);
}

static GLboolean REGAL_CALL missing_glIsProgramNV(GLuint id)
{
   UNUSED_PARAMETER(id);
   Warning( "glIsProgramNV not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsProgramNV(GLuint id)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsProgramNV, "glIsProgramNV");
   if ( !driverTbl.glIsProgramNV ) {
      driverTbl.glIsProgramNV = missing_glIsProgramNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsProgramNV == loader_glIsProgramNV) {
      rCtx->dsp->emuTbl.glIsProgramNV = driverTbl.glIsProgramNV;
   }
   return driverTbl.glIsProgramNV(id);
}

static void REGAL_CALL missing_glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte *program)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(id);
   UNUSED_PARAMETER(len);
   UNUSED_PARAMETER(program);
   Warning( "glLoadProgramNV not available." );
}

static void REGAL_CALL loader_glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte *program)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLoadProgramNV, "glLoadProgramNV");
   if ( !driverTbl.glLoadProgramNV ) {
      driverTbl.glLoadProgramNV = missing_glLoadProgramNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLoadProgramNV == loader_glLoadProgramNV) {
      rCtx->dsp->emuTbl.glLoadProgramNV = driverTbl.glLoadProgramNV;
   }
   driverTbl.glLoadProgramNV(target, id, len, program);
}

static void REGAL_CALL missing_glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramParameter4dNV not available." );
}

static void REGAL_CALL loader_glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramParameter4dNV, "glProgramParameter4dNV");
   if ( !driverTbl.glProgramParameter4dNV ) {
      driverTbl.glProgramParameter4dNV = missing_glProgramParameter4dNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramParameter4dNV == loader_glProgramParameter4dNV) {
      rCtx->dsp->emuTbl.glProgramParameter4dNV = driverTbl.glProgramParameter4dNV;
   }
   driverTbl.glProgramParameter4dNV(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glProgramParameter4dvNV not available." );
}

static void REGAL_CALL loader_glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramParameter4dvNV, "glProgramParameter4dvNV");
   if ( !driverTbl.glProgramParameter4dvNV ) {
      driverTbl.glProgramParameter4dvNV = missing_glProgramParameter4dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramParameter4dvNV == loader_glProgramParameter4dvNV) {
      rCtx->dsp->emuTbl.glProgramParameter4dvNV = driverTbl.glProgramParameter4dvNV;
   }
   driverTbl.glProgramParameter4dvNV(target, index, v);
}

static void REGAL_CALL missing_glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glProgramParameter4fNV not available." );
}

static void REGAL_CALL loader_glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramParameter4fNV, "glProgramParameter4fNV");
   if ( !driverTbl.glProgramParameter4fNV ) {
      driverTbl.glProgramParameter4fNV = missing_glProgramParameter4fNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramParameter4fNV == loader_glProgramParameter4fNV) {
      rCtx->dsp->emuTbl.glProgramParameter4fNV = driverTbl.glProgramParameter4fNV;
   }
   driverTbl.glProgramParameter4fNV(target, index, x, y, z, w);
}

static void REGAL_CALL missing_glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glProgramParameter4fvNV not available." );
}

static void REGAL_CALL loader_glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramParameter4fvNV, "glProgramParameter4fvNV");
   if ( !driverTbl.glProgramParameter4fvNV ) {
      driverTbl.glProgramParameter4fvNV = missing_glProgramParameter4fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramParameter4fvNV == loader_glProgramParameter4fvNV) {
      rCtx->dsp->emuTbl.glProgramParameter4fvNV = driverTbl.glProgramParameter4fvNV;
   }
   driverTbl.glProgramParameter4fvNV(target, index, v);
}

static void REGAL_CALL missing_glProgramParameters4dvNV(GLenum target, GLuint index, GLuint count, const GLdouble *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "glProgramParameters4dvNV not available." );
}

static void REGAL_CALL loader_glProgramParameters4dvNV(GLenum target, GLuint index, GLuint count, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramParameters4dvNV, "glProgramParameters4dvNV");
   if ( !driverTbl.glProgramParameters4dvNV ) {
      driverTbl.glProgramParameters4dvNV = missing_glProgramParameters4dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramParameters4dvNV == loader_glProgramParameters4dvNV) {
      rCtx->dsp->emuTbl.glProgramParameters4dvNV = driverTbl.glProgramParameters4dvNV;
   }
   driverTbl.glProgramParameters4dvNV(target, index, count, v);
}

static void REGAL_CALL missing_glProgramParameters4fvNV(GLenum target, GLuint index, GLuint count, const GLfloat *v)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(v);
   Warning( "glProgramParameters4fvNV not available." );
}

static void REGAL_CALL loader_glProgramParameters4fvNV(GLenum target, GLuint index, GLuint count, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glProgramParameters4fvNV, "glProgramParameters4fvNV");
   if ( !driverTbl.glProgramParameters4fvNV ) {
      driverTbl.glProgramParameters4fvNV = missing_glProgramParameters4fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glProgramParameters4fvNV == loader_glProgramParameters4fvNV) {
      rCtx->dsp->emuTbl.glProgramParameters4fvNV = driverTbl.glProgramParameters4fvNV;
   }
   driverTbl.glProgramParameters4fvNV(target, index, count, v);
}

static void REGAL_CALL missing_glRequestResidentProgramsNV(GLsizei n, const GLuint *programs)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(programs);
   Warning( "glRequestResidentProgramsNV not available." );
}

static void REGAL_CALL loader_glRequestResidentProgramsNV(GLsizei n, const GLuint *programs)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glRequestResidentProgramsNV, "glRequestResidentProgramsNV");
   if ( !driverTbl.glRequestResidentProgramsNV ) {
      driverTbl.glRequestResidentProgramsNV = missing_glRequestResidentProgramsNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glRequestResidentProgramsNV == loader_glRequestResidentProgramsNV) {
      rCtx->dsp->emuTbl.glRequestResidentProgramsNV = driverTbl.glRequestResidentProgramsNV;
   }
   driverTbl.glRequestResidentProgramsNV(n, programs);
}

static void REGAL_CALL missing_glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(address);
   UNUSED_PARAMETER(matrix);
   UNUSED_PARAMETER(transform);
   Warning( "glTrackMatrixNV not available." );
}

static void REGAL_CALL loader_glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTrackMatrixNV, "glTrackMatrixNV");
   if ( !driverTbl.glTrackMatrixNV ) {
      driverTbl.glTrackMatrixNV = missing_glTrackMatrixNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTrackMatrixNV == loader_glTrackMatrixNV) {
      rCtx->dsp->emuTbl.glTrackMatrixNV = driverTbl.glTrackMatrixNV;
   }
   driverTbl.glTrackMatrixNV(target, address, matrix, transform);
}

static void REGAL_CALL missing_glVertexAttrib1dNV(GLuint index, GLdouble x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttrib1dNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib1dNV(GLuint index, GLdouble x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1dNV, "glVertexAttrib1dNV");
   if ( !driverTbl.glVertexAttrib1dNV ) {
      driverTbl.glVertexAttrib1dNV = missing_glVertexAttrib1dNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1dNV == loader_glVertexAttrib1dNV) {
      rCtx->dsp->emuTbl.glVertexAttrib1dNV = driverTbl.glVertexAttrib1dNV;
   }
   driverTbl.glVertexAttrib1dNV(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1dvNV(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib1dvNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib1dvNV(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1dvNV, "glVertexAttrib1dvNV");
   if ( !driverTbl.glVertexAttrib1dvNV ) {
      driverTbl.glVertexAttrib1dvNV = missing_glVertexAttrib1dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1dvNV == loader_glVertexAttrib1dvNV) {
      rCtx->dsp->emuTbl.glVertexAttrib1dvNV = driverTbl.glVertexAttrib1dvNV;
   }
   driverTbl.glVertexAttrib1dvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib1fNV(GLuint index, GLfloat x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttrib1fNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib1fNV(GLuint index, GLfloat x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1fNV, "glVertexAttrib1fNV");
   if ( !driverTbl.glVertexAttrib1fNV ) {
      driverTbl.glVertexAttrib1fNV = missing_glVertexAttrib1fNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1fNV == loader_glVertexAttrib1fNV) {
      rCtx->dsp->emuTbl.glVertexAttrib1fNV = driverTbl.glVertexAttrib1fNV;
   }
   driverTbl.glVertexAttrib1fNV(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1fvNV(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib1fvNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib1fvNV(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1fvNV, "glVertexAttrib1fvNV");
   if ( !driverTbl.glVertexAttrib1fvNV ) {
      driverTbl.glVertexAttrib1fvNV = missing_glVertexAttrib1fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1fvNV == loader_glVertexAttrib1fvNV) {
      rCtx->dsp->emuTbl.glVertexAttrib1fvNV = driverTbl.glVertexAttrib1fvNV;
   }
   driverTbl.glVertexAttrib1fvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib1sNV(GLuint index, GLshort x)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   Warning( "glVertexAttrib1sNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib1sNV(GLuint index, GLshort x)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1sNV, "glVertexAttrib1sNV");
   if ( !driverTbl.glVertexAttrib1sNV ) {
      driverTbl.glVertexAttrib1sNV = missing_glVertexAttrib1sNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1sNV == loader_glVertexAttrib1sNV) {
      rCtx->dsp->emuTbl.glVertexAttrib1sNV = driverTbl.glVertexAttrib1sNV;
   }
   driverTbl.glVertexAttrib1sNV(index, x);
}

static void REGAL_CALL missing_glVertexAttrib1svNV(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib1svNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib1svNV(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib1svNV, "glVertexAttrib1svNV");
   if ( !driverTbl.glVertexAttrib1svNV ) {
      driverTbl.glVertexAttrib1svNV = missing_glVertexAttrib1svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib1svNV == loader_glVertexAttrib1svNV) {
      rCtx->dsp->emuTbl.glVertexAttrib1svNV = driverTbl.glVertexAttrib1svNV;
   }
   driverTbl.glVertexAttrib1svNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttrib2dNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2dNV, "glVertexAttrib2dNV");
   if ( !driverTbl.glVertexAttrib2dNV ) {
      driverTbl.glVertexAttrib2dNV = missing_glVertexAttrib2dNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2dNV == loader_glVertexAttrib2dNV) {
      rCtx->dsp->emuTbl.glVertexAttrib2dNV = driverTbl.glVertexAttrib2dNV;
   }
   driverTbl.glVertexAttrib2dNV(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2dvNV(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib2dvNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib2dvNV(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2dvNV, "glVertexAttrib2dvNV");
   if ( !driverTbl.glVertexAttrib2dvNV ) {
      driverTbl.glVertexAttrib2dvNV = missing_glVertexAttrib2dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2dvNV == loader_glVertexAttrib2dvNV) {
      rCtx->dsp->emuTbl.glVertexAttrib2dvNV = driverTbl.glVertexAttrib2dvNV;
   }
   driverTbl.glVertexAttrib2dvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttrib2fNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2fNV, "glVertexAttrib2fNV");
   if ( !driverTbl.glVertexAttrib2fNV ) {
      driverTbl.glVertexAttrib2fNV = missing_glVertexAttrib2fNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2fNV == loader_glVertexAttrib2fNV) {
      rCtx->dsp->emuTbl.glVertexAttrib2fNV = driverTbl.glVertexAttrib2fNV;
   }
   driverTbl.glVertexAttrib2fNV(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2fvNV(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib2fvNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib2fvNV(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2fvNV, "glVertexAttrib2fvNV");
   if ( !driverTbl.glVertexAttrib2fvNV ) {
      driverTbl.glVertexAttrib2fvNV = missing_glVertexAttrib2fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2fvNV == loader_glVertexAttrib2fvNV) {
      rCtx->dsp->emuTbl.glVertexAttrib2fvNV = driverTbl.glVertexAttrib2fvNV;
   }
   driverTbl.glVertexAttrib2fvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glVertexAttrib2sNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2sNV, "glVertexAttrib2sNV");
   if ( !driverTbl.glVertexAttrib2sNV ) {
      driverTbl.glVertexAttrib2sNV = missing_glVertexAttrib2sNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2sNV == loader_glVertexAttrib2sNV) {
      rCtx->dsp->emuTbl.glVertexAttrib2sNV = driverTbl.glVertexAttrib2sNV;
   }
   driverTbl.glVertexAttrib2sNV(index, x, y);
}

static void REGAL_CALL missing_glVertexAttrib2svNV(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib2svNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib2svNV(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib2svNV, "glVertexAttrib2svNV");
   if ( !driverTbl.glVertexAttrib2svNV ) {
      driverTbl.glVertexAttrib2svNV = missing_glVertexAttrib2svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib2svNV == loader_glVertexAttrib2svNV) {
      rCtx->dsp->emuTbl.glVertexAttrib2svNV = driverTbl.glVertexAttrib2svNV;
   }
   driverTbl.glVertexAttrib2svNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttrib3dNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3dNV, "glVertexAttrib3dNV");
   if ( !driverTbl.glVertexAttrib3dNV ) {
      driverTbl.glVertexAttrib3dNV = missing_glVertexAttrib3dNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3dNV == loader_glVertexAttrib3dNV) {
      rCtx->dsp->emuTbl.glVertexAttrib3dNV = driverTbl.glVertexAttrib3dNV;
   }
   driverTbl.glVertexAttrib3dNV(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3dvNV(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib3dvNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib3dvNV(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3dvNV, "glVertexAttrib3dvNV");
   if ( !driverTbl.glVertexAttrib3dvNV ) {
      driverTbl.glVertexAttrib3dvNV = missing_glVertexAttrib3dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3dvNV == loader_glVertexAttrib3dvNV) {
      rCtx->dsp->emuTbl.glVertexAttrib3dvNV = driverTbl.glVertexAttrib3dvNV;
   }
   driverTbl.glVertexAttrib3dvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttrib3fNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3fNV, "glVertexAttrib3fNV");
   if ( !driverTbl.glVertexAttrib3fNV ) {
      driverTbl.glVertexAttrib3fNV = missing_glVertexAttrib3fNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3fNV == loader_glVertexAttrib3fNV) {
      rCtx->dsp->emuTbl.glVertexAttrib3fNV = driverTbl.glVertexAttrib3fNV;
   }
   driverTbl.glVertexAttrib3fNV(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3fvNV(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib3fvNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib3fvNV(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3fvNV, "glVertexAttrib3fvNV");
   if ( !driverTbl.glVertexAttrib3fvNV ) {
      driverTbl.glVertexAttrib3fvNV = missing_glVertexAttrib3fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3fvNV == loader_glVertexAttrib3fvNV) {
      rCtx->dsp->emuTbl.glVertexAttrib3fvNV = driverTbl.glVertexAttrib3fvNV;
   }
   driverTbl.glVertexAttrib3fvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glVertexAttrib3sNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3sNV, "glVertexAttrib3sNV");
   if ( !driverTbl.glVertexAttrib3sNV ) {
      driverTbl.glVertexAttrib3sNV = missing_glVertexAttrib3sNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3sNV == loader_glVertexAttrib3sNV) {
      rCtx->dsp->emuTbl.glVertexAttrib3sNV = driverTbl.glVertexAttrib3sNV;
   }
   driverTbl.glVertexAttrib3sNV(index, x, y, z);
}

static void REGAL_CALL missing_glVertexAttrib3svNV(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib3svNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib3svNV(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib3svNV, "glVertexAttrib3svNV");
   if ( !driverTbl.glVertexAttrib3svNV ) {
      driverTbl.glVertexAttrib3svNV = missing_glVertexAttrib3svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib3svNV == loader_glVertexAttrib3svNV) {
      rCtx->dsp->emuTbl.glVertexAttrib3svNV = driverTbl.glVertexAttrib3svNV;
   }
   driverTbl.glVertexAttrib3svNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttrib4dNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4dNV, "glVertexAttrib4dNV");
   if ( !driverTbl.glVertexAttrib4dNV ) {
      driverTbl.glVertexAttrib4dNV = missing_glVertexAttrib4dNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4dNV == loader_glVertexAttrib4dNV) {
      rCtx->dsp->emuTbl.glVertexAttrib4dNV = driverTbl.glVertexAttrib4dNV;
   }
   driverTbl.glVertexAttrib4dNV(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4dvNV(GLuint index, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4dvNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib4dvNV(GLuint index, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4dvNV, "glVertexAttrib4dvNV");
   if ( !driverTbl.glVertexAttrib4dvNV ) {
      driverTbl.glVertexAttrib4dvNV = missing_glVertexAttrib4dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4dvNV == loader_glVertexAttrib4dvNV) {
      rCtx->dsp->emuTbl.glVertexAttrib4dvNV = driverTbl.glVertexAttrib4dvNV;
   }
   driverTbl.glVertexAttrib4dvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttrib4fNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4fNV, "glVertexAttrib4fNV");
   if ( !driverTbl.glVertexAttrib4fNV ) {
      driverTbl.glVertexAttrib4fNV = missing_glVertexAttrib4fNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4fNV == loader_glVertexAttrib4fNV) {
      rCtx->dsp->emuTbl.glVertexAttrib4fNV = driverTbl.glVertexAttrib4fNV;
   }
   driverTbl.glVertexAttrib4fNV(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4fvNV(GLuint index, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4fvNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib4fvNV(GLuint index, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4fvNV, "glVertexAttrib4fvNV");
   if ( !driverTbl.glVertexAttrib4fvNV ) {
      driverTbl.glVertexAttrib4fvNV = missing_glVertexAttrib4fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4fvNV == loader_glVertexAttrib4fvNV) {
      rCtx->dsp->emuTbl.glVertexAttrib4fvNV = driverTbl.glVertexAttrib4fvNV;
   }
   driverTbl.glVertexAttrib4fvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttrib4sNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4sNV, "glVertexAttrib4sNV");
   if ( !driverTbl.glVertexAttrib4sNV ) {
      driverTbl.glVertexAttrib4sNV = missing_glVertexAttrib4sNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4sNV == loader_glVertexAttrib4sNV) {
      rCtx->dsp->emuTbl.glVertexAttrib4sNV = driverTbl.glVertexAttrib4sNV;
   }
   driverTbl.glVertexAttrib4sNV(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4svNV(GLuint index, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4svNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib4svNV(GLuint index, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4svNV, "glVertexAttrib4svNV");
   if ( !driverTbl.glVertexAttrib4svNV ) {
      driverTbl.glVertexAttrib4svNV = missing_glVertexAttrib4svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4svNV == loader_glVertexAttrib4svNV) {
      rCtx->dsp->emuTbl.glVertexAttrib4svNV = driverTbl.glVertexAttrib4svNV;
   }
   driverTbl.glVertexAttrib4svNV(index, v);
}

static void REGAL_CALL missing_glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glVertexAttrib4ubNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4ubNV, "glVertexAttrib4ubNV");
   if ( !driverTbl.glVertexAttrib4ubNV ) {
      driverTbl.glVertexAttrib4ubNV = missing_glVertexAttrib4ubNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4ubNV == loader_glVertexAttrib4ubNV) {
      rCtx->dsp->emuTbl.glVertexAttrib4ubNV = driverTbl.glVertexAttrib4ubNV;
   }
   driverTbl.glVertexAttrib4ubNV(index, x, y, z, w);
}

static void REGAL_CALL missing_glVertexAttrib4ubvNV(GLuint index, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttrib4ubvNV not available." );
}

static void REGAL_CALL loader_glVertexAttrib4ubvNV(GLuint index, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttrib4ubvNV, "glVertexAttrib4ubvNV");
   if ( !driverTbl.glVertexAttrib4ubvNV ) {
      driverTbl.glVertexAttrib4ubvNV = missing_glVertexAttrib4ubvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttrib4ubvNV == loader_glVertexAttrib4ubvNV) {
      rCtx->dsp->emuTbl.glVertexAttrib4ubvNV = driverTbl.glVertexAttrib4ubvNV;
   }
   driverTbl.glVertexAttrib4ubvNV(index, v);
}

static void REGAL_CALL missing_glVertexAttribPointerNV(GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(fsize);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glVertexAttribPointerNV not available." );
}

static void REGAL_CALL loader_glVertexAttribPointerNV(GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribPointerNV, "glVertexAttribPointerNV");
   if ( !driverTbl.glVertexAttribPointerNV ) {
      driverTbl.glVertexAttribPointerNV = missing_glVertexAttribPointerNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribPointerNV == loader_glVertexAttribPointerNV) {
      rCtx->dsp->emuTbl.glVertexAttribPointerNV = driverTbl.glVertexAttribPointerNV;
   }
   driverTbl.glVertexAttribPointerNV(index, fsize, type, stride, pointer);
}

static void REGAL_CALL missing_glVertexAttribs1dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs1dvNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs1dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs1dvNV, "glVertexAttribs1dvNV");
   if ( !driverTbl.glVertexAttribs1dvNV ) {
      driverTbl.glVertexAttribs1dvNV = missing_glVertexAttribs1dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs1dvNV == loader_glVertexAttribs1dvNV) {
      rCtx->dsp->emuTbl.glVertexAttribs1dvNV = driverTbl.glVertexAttribs1dvNV;
   }
   driverTbl.glVertexAttribs1dvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs1fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs1fvNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs1fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs1fvNV, "glVertexAttribs1fvNV");
   if ( !driverTbl.glVertexAttribs1fvNV ) {
      driverTbl.glVertexAttribs1fvNV = missing_glVertexAttribs1fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs1fvNV == loader_glVertexAttribs1fvNV) {
      rCtx->dsp->emuTbl.glVertexAttribs1fvNV = driverTbl.glVertexAttribs1fvNV;
   }
   driverTbl.glVertexAttribs1fvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs1svNV(GLuint index, GLsizei n, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs1svNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs1svNV(GLuint index, GLsizei n, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs1svNV, "glVertexAttribs1svNV");
   if ( !driverTbl.glVertexAttribs1svNV ) {
      driverTbl.glVertexAttribs1svNV = missing_glVertexAttribs1svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs1svNV == loader_glVertexAttribs1svNV) {
      rCtx->dsp->emuTbl.glVertexAttribs1svNV = driverTbl.glVertexAttribs1svNV;
   }
   driverTbl.glVertexAttribs1svNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs2dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs2dvNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs2dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs2dvNV, "glVertexAttribs2dvNV");
   if ( !driverTbl.glVertexAttribs2dvNV ) {
      driverTbl.glVertexAttribs2dvNV = missing_glVertexAttribs2dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs2dvNV == loader_glVertexAttribs2dvNV) {
      rCtx->dsp->emuTbl.glVertexAttribs2dvNV = driverTbl.glVertexAttribs2dvNV;
   }
   driverTbl.glVertexAttribs2dvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs2fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs2fvNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs2fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs2fvNV, "glVertexAttribs2fvNV");
   if ( !driverTbl.glVertexAttribs2fvNV ) {
      driverTbl.glVertexAttribs2fvNV = missing_glVertexAttribs2fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs2fvNV == loader_glVertexAttribs2fvNV) {
      rCtx->dsp->emuTbl.glVertexAttribs2fvNV = driverTbl.glVertexAttribs2fvNV;
   }
   driverTbl.glVertexAttribs2fvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs2svNV(GLuint index, GLsizei n, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs2svNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs2svNV(GLuint index, GLsizei n, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs2svNV, "glVertexAttribs2svNV");
   if ( !driverTbl.glVertexAttribs2svNV ) {
      driverTbl.glVertexAttribs2svNV = missing_glVertexAttribs2svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs2svNV == loader_glVertexAttribs2svNV) {
      rCtx->dsp->emuTbl.glVertexAttribs2svNV = driverTbl.glVertexAttribs2svNV;
   }
   driverTbl.glVertexAttribs2svNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs3dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs3dvNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs3dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs3dvNV, "glVertexAttribs3dvNV");
   if ( !driverTbl.glVertexAttribs3dvNV ) {
      driverTbl.glVertexAttribs3dvNV = missing_glVertexAttribs3dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs3dvNV == loader_glVertexAttribs3dvNV) {
      rCtx->dsp->emuTbl.glVertexAttribs3dvNV = driverTbl.glVertexAttribs3dvNV;
   }
   driverTbl.glVertexAttribs3dvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs3fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs3fvNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs3fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs3fvNV, "glVertexAttribs3fvNV");
   if ( !driverTbl.glVertexAttribs3fvNV ) {
      driverTbl.glVertexAttribs3fvNV = missing_glVertexAttribs3fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs3fvNV == loader_glVertexAttribs3fvNV) {
      rCtx->dsp->emuTbl.glVertexAttribs3fvNV = driverTbl.glVertexAttribs3fvNV;
   }
   driverTbl.glVertexAttribs3fvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs3svNV(GLuint index, GLsizei n, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs3svNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs3svNV(GLuint index, GLsizei n, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs3svNV, "glVertexAttribs3svNV");
   if ( !driverTbl.glVertexAttribs3svNV ) {
      driverTbl.glVertexAttribs3svNV = missing_glVertexAttribs3svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs3svNV == loader_glVertexAttribs3svNV) {
      rCtx->dsp->emuTbl.glVertexAttribs3svNV = driverTbl.glVertexAttribs3svNV;
   }
   driverTbl.glVertexAttribs3svNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs4dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs4dvNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs4dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs4dvNV, "glVertexAttribs4dvNV");
   if ( !driverTbl.glVertexAttribs4dvNV ) {
      driverTbl.glVertexAttribs4dvNV = missing_glVertexAttribs4dvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs4dvNV == loader_glVertexAttribs4dvNV) {
      rCtx->dsp->emuTbl.glVertexAttribs4dvNV = driverTbl.glVertexAttribs4dvNV;
   }
   driverTbl.glVertexAttribs4dvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs4fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs4fvNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs4fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs4fvNV, "glVertexAttribs4fvNV");
   if ( !driverTbl.glVertexAttribs4fvNV ) {
      driverTbl.glVertexAttribs4fvNV = missing_glVertexAttribs4fvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs4fvNV == loader_glVertexAttribs4fvNV) {
      rCtx->dsp->emuTbl.glVertexAttribs4fvNV = driverTbl.glVertexAttribs4fvNV;
   }
   driverTbl.glVertexAttribs4fvNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs4svNV(GLuint index, GLsizei n, const GLshort *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs4svNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs4svNV(GLuint index, GLsizei n, const GLshort *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs4svNV, "glVertexAttribs4svNV");
   if ( !driverTbl.glVertexAttribs4svNV ) {
      driverTbl.glVertexAttribs4svNV = missing_glVertexAttribs4svNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs4svNV == loader_glVertexAttribs4svNV) {
      rCtx->dsp->emuTbl.glVertexAttribs4svNV = driverTbl.glVertexAttribs4svNV;
   }
   driverTbl.glVertexAttribs4svNV(index, n, v);
}

static void REGAL_CALL missing_glVertexAttribs4ubvNV(GLuint index, GLsizei n, const GLubyte *v)
{
   UNUSED_PARAMETER(index);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glVertexAttribs4ubvNV not available." );
}

static void REGAL_CALL loader_glVertexAttribs4ubvNV(GLuint index, GLsizei n, const GLubyte *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVertexAttribs4ubvNV, "glVertexAttribs4ubvNV");
   if ( !driverTbl.glVertexAttribs4ubvNV ) {
      driverTbl.glVertexAttribs4ubvNV = missing_glVertexAttribs4ubvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVertexAttribs4ubvNV == loader_glVertexAttribs4ubvNV) {
      rCtx->dsp->emuTbl.glVertexAttribs4ubvNV = driverTbl.glVertexAttribs4ubvNV;
   }
   driverTbl.glVertexAttribs4ubvNV(index, n, v);
}

// GL_NV_video_capture

static void REGAL_CALL missing_glBeginVideoCaptureNV(GLuint video_capture_slot)
{
   UNUSED_PARAMETER(video_capture_slot);
   Warning( "glBeginVideoCaptureNV not available." );
}

static void REGAL_CALL loader_glBeginVideoCaptureNV(GLuint video_capture_slot)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBeginVideoCaptureNV, "glBeginVideoCaptureNV");
   if ( !driverTbl.glBeginVideoCaptureNV ) {
      driverTbl.glBeginVideoCaptureNV = missing_glBeginVideoCaptureNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBeginVideoCaptureNV == loader_glBeginVideoCaptureNV) {
      rCtx->dsp->emuTbl.glBeginVideoCaptureNV = driverTbl.glBeginVideoCaptureNV;
   }
   driverTbl.glBeginVideoCaptureNV(video_capture_slot);
}

static void REGAL_CALL missing_glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptr offset)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(frame_region);
   UNUSED_PARAMETER(offset);
   Warning( "glBindVideoCaptureStreamBufferNV not available." );
}

static void REGAL_CALL loader_glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptr offset)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindVideoCaptureStreamBufferNV, "glBindVideoCaptureStreamBufferNV");
   if ( !driverTbl.glBindVideoCaptureStreamBufferNV ) {
      driverTbl.glBindVideoCaptureStreamBufferNV = missing_glBindVideoCaptureStreamBufferNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindVideoCaptureStreamBufferNV == loader_glBindVideoCaptureStreamBufferNV) {
      rCtx->dsp->emuTbl.glBindVideoCaptureStreamBufferNV = driverTbl.glBindVideoCaptureStreamBufferNV;
   }
   driverTbl.glBindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
}

static void REGAL_CALL missing_glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(frame_region);
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(texture);
   Warning( "glBindVideoCaptureStreamTextureNV not available." );
}

static void REGAL_CALL loader_glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glBindVideoCaptureStreamTextureNV, "glBindVideoCaptureStreamTextureNV");
   if ( !driverTbl.glBindVideoCaptureStreamTextureNV ) {
      driverTbl.glBindVideoCaptureStreamTextureNV = missing_glBindVideoCaptureStreamTextureNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glBindVideoCaptureStreamTextureNV == loader_glBindVideoCaptureStreamTextureNV) {
      rCtx->dsp->emuTbl.glBindVideoCaptureStreamTextureNV = driverTbl.glBindVideoCaptureStreamTextureNV;
   }
   driverTbl.glBindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
}

static void REGAL_CALL missing_glEndVideoCaptureNV(GLuint video_capture_slot)
{
   UNUSED_PARAMETER(video_capture_slot);
   Warning( "glEndVideoCaptureNV not available." );
}

static void REGAL_CALL loader_glEndVideoCaptureNV(GLuint video_capture_slot)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glEndVideoCaptureNV, "glEndVideoCaptureNV");
   if ( !driverTbl.glEndVideoCaptureNV ) {
      driverTbl.glEndVideoCaptureNV = missing_glEndVideoCaptureNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glEndVideoCaptureNV == loader_glEndVideoCaptureNV) {
      rCtx->dsp->emuTbl.glEndVideoCaptureNV = driverTbl.glEndVideoCaptureNV;
   }
   driverTbl.glEndVideoCaptureNV(video_capture_slot);
}

static void REGAL_CALL missing_glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVideoCaptureStreamdvNV not available." );
}

static void REGAL_CALL loader_glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVideoCaptureStreamdvNV, "glGetVideoCaptureStreamdvNV");
   if ( !driverTbl.glGetVideoCaptureStreamdvNV ) {
      driverTbl.glGetVideoCaptureStreamdvNV = missing_glGetVideoCaptureStreamdvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVideoCaptureStreamdvNV == loader_glGetVideoCaptureStreamdvNV) {
      rCtx->dsp->emuTbl.glGetVideoCaptureStreamdvNV = driverTbl.glGetVideoCaptureStreamdvNV;
   }
   driverTbl.glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL missing_glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVideoCaptureStreamfvNV not available." );
}

static void REGAL_CALL loader_glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVideoCaptureStreamfvNV, "glGetVideoCaptureStreamfvNV");
   if ( !driverTbl.glGetVideoCaptureStreamfvNV ) {
      driverTbl.glGetVideoCaptureStreamfvNV = missing_glGetVideoCaptureStreamfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVideoCaptureStreamfvNV == loader_glGetVideoCaptureStreamfvNV) {
      rCtx->dsp->emuTbl.glGetVideoCaptureStreamfvNV = driverTbl.glGetVideoCaptureStreamfvNV;
   }
   driverTbl.glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL missing_glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVideoCaptureStreamivNV not available." );
}

static void REGAL_CALL loader_glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVideoCaptureStreamivNV, "glGetVideoCaptureStreamivNV");
   if ( !driverTbl.glGetVideoCaptureStreamivNV ) {
      driverTbl.glGetVideoCaptureStreamivNV = missing_glGetVideoCaptureStreamivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVideoCaptureStreamivNV == loader_glGetVideoCaptureStreamivNV) {
      rCtx->dsp->emuTbl.glGetVideoCaptureStreamivNV = driverTbl.glGetVideoCaptureStreamivNV;
   }
   driverTbl.glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL missing_glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetVideoCaptureivNV not available." );
}

static void REGAL_CALL loader_glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetVideoCaptureivNV, "glGetVideoCaptureivNV");
   if ( !driverTbl.glGetVideoCaptureivNV ) {
      driverTbl.glGetVideoCaptureivNV = missing_glGetVideoCaptureivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetVideoCaptureivNV == loader_glGetVideoCaptureivNV) {
      rCtx->dsp->emuTbl.glGetVideoCaptureivNV = driverTbl.glGetVideoCaptureivNV;
   }
   driverTbl.glGetVideoCaptureivNV(video_capture_slot, pname, params);
}

static GLenum REGAL_CALL missing_glVideoCaptureNV(GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(sequence_num);
   UNUSED_PARAMETER(capture_time);
   Warning( "glVideoCaptureNV not available." );
  GLenum  ret = (GLenum )0;
  return ret;
}

static GLenum REGAL_CALL loader_glVideoCaptureNV(GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVideoCaptureNV, "glVideoCaptureNV");
   if ( !driverTbl.glVideoCaptureNV ) {
      driverTbl.glVideoCaptureNV = missing_glVideoCaptureNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVideoCaptureNV == loader_glVideoCaptureNV) {
      rCtx->dsp->emuTbl.glVideoCaptureNV = driverTbl.glVideoCaptureNV;
   }
   return driverTbl.glVideoCaptureNV(video_capture_slot, sequence_num, capture_time);
}

static void REGAL_CALL missing_glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glVideoCaptureStreamParameterdvNV not available." );
}

static void REGAL_CALL loader_glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVideoCaptureStreamParameterdvNV, "glVideoCaptureStreamParameterdvNV");
   if ( !driverTbl.glVideoCaptureStreamParameterdvNV ) {
      driverTbl.glVideoCaptureStreamParameterdvNV = missing_glVideoCaptureStreamParameterdvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVideoCaptureStreamParameterdvNV == loader_glVideoCaptureStreamParameterdvNV) {
      rCtx->dsp->emuTbl.glVideoCaptureStreamParameterdvNV = driverTbl.glVideoCaptureStreamParameterdvNV;
   }
   driverTbl.glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL missing_glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glVideoCaptureStreamParameterfvNV not available." );
}

static void REGAL_CALL loader_glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVideoCaptureStreamParameterfvNV, "glVideoCaptureStreamParameterfvNV");
   if ( !driverTbl.glVideoCaptureStreamParameterfvNV ) {
      driverTbl.glVideoCaptureStreamParameterfvNV = missing_glVideoCaptureStreamParameterfvNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVideoCaptureStreamParameterfvNV == loader_glVideoCaptureStreamParameterfvNV) {
      rCtx->dsp->emuTbl.glVideoCaptureStreamParameterfvNV = driverTbl.glVideoCaptureStreamParameterfvNV;
   }
   driverTbl.glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, params);
}

static void REGAL_CALL missing_glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(video_capture_slot);
   UNUSED_PARAMETER(stream);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glVideoCaptureStreamParameterivNV not available." );
}

static void REGAL_CALL loader_glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glVideoCaptureStreamParameterivNV, "glVideoCaptureStreamParameterivNV");
   if ( !driverTbl.glVideoCaptureStreamParameterivNV ) {
      driverTbl.glVideoCaptureStreamParameterivNV = missing_glVideoCaptureStreamParameterivNV;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glVideoCaptureStreamParameterivNV == loader_glVideoCaptureStreamParameterivNV) {
      rCtx->dsp->emuTbl.glVideoCaptureStreamParameterivNV = driverTbl.glVideoCaptureStreamParameterivNV;
   }
   driverTbl.glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, params);
}

// GL_PGI_misc_hints

static void REGAL_CALL missing_glHintPGI(GLenum target, GLint mode)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(mode);
   Warning( "glHintPGI not available." );
}

static void REGAL_CALL loader_glHintPGI(GLenum target, GLint mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glHintPGI, "glHintPGI");
   if ( !driverTbl.glHintPGI ) {
      driverTbl.glHintPGI = missing_glHintPGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glHintPGI == loader_glHintPGI) {
      rCtx->dsp->emuTbl.glHintPGI = driverTbl.glHintPGI;
   }
   driverTbl.glHintPGI(target, mode);
}

// GL_REGAL_error_string

static const GLchar *REGAL_CALL missing_glErrorStringREGAL(GLenum error)
{
   UNUSED_PARAMETER(error);
   Warning( "glErrorStringREGAL not available." );
  const GLchar * ret = NULL;
  return ret;
}

static const GLchar *REGAL_CALL loader_glErrorStringREGAL(GLenum error)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glErrorStringREGAL, "glErrorStringREGAL");
   if ( !driverTbl.glErrorStringREGAL ) {
      driverTbl.glErrorStringREGAL = missing_glErrorStringREGAL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glErrorStringREGAL == loader_glErrorStringREGAL) {
      rCtx->dsp->emuTbl.glErrorStringREGAL = driverTbl.glErrorStringREGAL;
   }
   return driverTbl.glErrorStringREGAL(error);
}

// GL_REGAL_extension_query

static GLboolean REGAL_CALL missing_glGetExtensionREGAL(const GLchar *ext)
{
   UNUSED_PARAMETER(ext);
   Warning( "glGetExtensionREGAL not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glGetExtensionREGAL(const GLchar *ext)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetExtensionREGAL, "glGetExtensionREGAL");
   if ( !driverTbl.glGetExtensionREGAL ) {
      driverTbl.glGetExtensionREGAL = missing_glGetExtensionREGAL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetExtensionREGAL == loader_glGetExtensionREGAL) {
      rCtx->dsp->emuTbl.glGetExtensionREGAL = driverTbl.glGetExtensionREGAL;
   }
   return driverTbl.glGetExtensionREGAL(ext);
}

static GLboolean REGAL_CALL missing_glIsSupportedREGAL(const GLchar *ext)
{
   UNUSED_PARAMETER(ext);
   Warning( "glIsSupportedREGAL not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsSupportedREGAL(const GLchar *ext)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsSupportedREGAL, "glIsSupportedREGAL");
   if ( !driverTbl.glIsSupportedREGAL ) {
      driverTbl.glIsSupportedREGAL = missing_glIsSupportedREGAL;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsSupportedREGAL == loader_glIsSupportedREGAL) {
      rCtx->dsp->emuTbl.glIsSupportedREGAL = driverTbl.glIsSupportedREGAL;
   }
   return driverTbl.glIsSupportedREGAL(ext);
}

// GL_SGIS_detail_texture

static void REGAL_CALL missing_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(points);
   Warning( "glDetailTexFuncSGIS not available." );
}

static void REGAL_CALL loader_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDetailTexFuncSGIS, "glDetailTexFuncSGIS");
   if ( !driverTbl.glDetailTexFuncSGIS ) {
      driverTbl.glDetailTexFuncSGIS = missing_glDetailTexFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDetailTexFuncSGIS == loader_glDetailTexFuncSGIS) {
      rCtx->dsp->emuTbl.glDetailTexFuncSGIS = driverTbl.glDetailTexFuncSGIS;
   }
   driverTbl.glDetailTexFuncSGIS(target, n, points);
}

static void REGAL_CALL missing_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(points);
   Warning( "glGetDetailTexFuncSGIS not available." );
}

static void REGAL_CALL loader_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetDetailTexFuncSGIS, "glGetDetailTexFuncSGIS");
   if ( !driverTbl.glGetDetailTexFuncSGIS ) {
      driverTbl.glGetDetailTexFuncSGIS = missing_glGetDetailTexFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetDetailTexFuncSGIS == loader_glGetDetailTexFuncSGIS) {
      rCtx->dsp->emuTbl.glGetDetailTexFuncSGIS = driverTbl.glGetDetailTexFuncSGIS;
   }
   driverTbl.glGetDetailTexFuncSGIS(target, points);
}

// GL_SGIS_fog_function

static void REGAL_CALL missing_glFogFuncSGIS(GLsizei n, const GLfloat *points)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(points);
   Warning( "glFogFuncSGIS not available." );
}

static void REGAL_CALL loader_glFogFuncSGIS(GLsizei n, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFogFuncSGIS, "glFogFuncSGIS");
   if ( !driverTbl.glFogFuncSGIS ) {
      driverTbl.glFogFuncSGIS = missing_glFogFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFogFuncSGIS == loader_glFogFuncSGIS) {
      rCtx->dsp->emuTbl.glFogFuncSGIS = driverTbl.glFogFuncSGIS;
   }
   driverTbl.glFogFuncSGIS(n, points);
}

static void REGAL_CALL missing_glGetFogFuncSGIS(GLfloat *points)
{
   UNUSED_PARAMETER(points);
   Warning( "glGetFogFuncSGIS not available." );
}

static void REGAL_CALL loader_glGetFogFuncSGIS(GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFogFuncSGIS, "glGetFogFuncSGIS");
   if ( !driverTbl.glGetFogFuncSGIS ) {
      driverTbl.glGetFogFuncSGIS = missing_glGetFogFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFogFuncSGIS == loader_glGetFogFuncSGIS) {
      rCtx->dsp->emuTbl.glGetFogFuncSGIS = driverTbl.glGetFogFuncSGIS;
   }
   driverTbl.glGetFogFuncSGIS(points);
}

// GL_SGIS_multisample

static void REGAL_CALL missing_glSampleMaskSGIS(GLclampf value, GLboolean invert)
{
   UNUSED_PARAMETER(value);
   UNUSED_PARAMETER(invert);
   Warning( "glSampleMaskSGIS not available." );
}

static void REGAL_CALL loader_glSampleMaskSGIS(GLclampf value, GLboolean invert)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSampleMaskSGIS, "glSampleMaskSGIS");
   if ( !driverTbl.glSampleMaskSGIS ) {
      driverTbl.glSampleMaskSGIS = missing_glSampleMaskSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSampleMaskSGIS == loader_glSampleMaskSGIS) {
      rCtx->dsp->emuTbl.glSampleMaskSGIS = driverTbl.glSampleMaskSGIS;
   }
   driverTbl.glSampleMaskSGIS(value, invert);
}

static void REGAL_CALL missing_glSamplePatternSGIS(GLenum pattern)
{
   UNUSED_PARAMETER(pattern);
   Warning( "glSamplePatternSGIS not available." );
}

static void REGAL_CALL loader_glSamplePatternSGIS(GLenum pattern)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSamplePatternSGIS, "glSamplePatternSGIS");
   if ( !driverTbl.glSamplePatternSGIS ) {
      driverTbl.glSamplePatternSGIS = missing_glSamplePatternSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSamplePatternSGIS == loader_glSamplePatternSGIS) {
      rCtx->dsp->emuTbl.glSamplePatternSGIS = driverTbl.glSamplePatternSGIS;
   }
   driverTbl.glSamplePatternSGIS(pattern);
}

// GL_SGIS_pixel_texture

static void REGAL_CALL missing_glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetPixelTexGenParameterfvSGIS not available." );
}

static void REGAL_CALL loader_glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPixelTexGenParameterfvSGIS, "glGetPixelTexGenParameterfvSGIS");
   if ( !driverTbl.glGetPixelTexGenParameterfvSGIS ) {
      driverTbl.glGetPixelTexGenParameterfvSGIS = missing_glGetPixelTexGenParameterfvSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPixelTexGenParameterfvSGIS == loader_glGetPixelTexGenParameterfvSGIS) {
      rCtx->dsp->emuTbl.glGetPixelTexGenParameterfvSGIS = driverTbl.glGetPixelTexGenParameterfvSGIS;
   }
   driverTbl.glGetPixelTexGenParameterfvSGIS(pname, params);
}

static void REGAL_CALL missing_glGetPixelTexGenParameterivSGIS(GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetPixelTexGenParameterivSGIS not available." );
}

static void REGAL_CALL loader_glGetPixelTexGenParameterivSGIS(GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetPixelTexGenParameterivSGIS, "glGetPixelTexGenParameterivSGIS");
   if ( !driverTbl.glGetPixelTexGenParameterivSGIS ) {
      driverTbl.glGetPixelTexGenParameterivSGIS = missing_glGetPixelTexGenParameterivSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetPixelTexGenParameterivSGIS == loader_glGetPixelTexGenParameterivSGIS) {
      rCtx->dsp->emuTbl.glGetPixelTexGenParameterivSGIS = driverTbl.glGetPixelTexGenParameterivSGIS;
   }
   driverTbl.glGetPixelTexGenParameterivSGIS(pname, params);
}

static void REGAL_CALL missing_glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPixelTexGenParameterfSGIS not available." );
}

static void REGAL_CALL loader_glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelTexGenParameterfSGIS, "glPixelTexGenParameterfSGIS");
   if ( !driverTbl.glPixelTexGenParameterfSGIS ) {
      driverTbl.glPixelTexGenParameterfSGIS = missing_glPixelTexGenParameterfSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelTexGenParameterfSGIS == loader_glPixelTexGenParameterfSGIS) {
      rCtx->dsp->emuTbl.glPixelTexGenParameterfSGIS = driverTbl.glPixelTexGenParameterfSGIS;
   }
   driverTbl.glPixelTexGenParameterfSGIS(pname, param);
}

static void REGAL_CALL missing_glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glPixelTexGenParameterfvSGIS not available." );
}

static void REGAL_CALL loader_glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelTexGenParameterfvSGIS, "glPixelTexGenParameterfvSGIS");
   if ( !driverTbl.glPixelTexGenParameterfvSGIS ) {
      driverTbl.glPixelTexGenParameterfvSGIS = missing_glPixelTexGenParameterfvSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelTexGenParameterfvSGIS == loader_glPixelTexGenParameterfvSGIS) {
      rCtx->dsp->emuTbl.glPixelTexGenParameterfvSGIS = driverTbl.glPixelTexGenParameterfvSGIS;
   }
   driverTbl.glPixelTexGenParameterfvSGIS(pname, params);
}

static void REGAL_CALL missing_glPixelTexGenParameteriSGIS(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPixelTexGenParameteriSGIS not available." );
}

static void REGAL_CALL loader_glPixelTexGenParameteriSGIS(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelTexGenParameteriSGIS, "glPixelTexGenParameteriSGIS");
   if ( !driverTbl.glPixelTexGenParameteriSGIS ) {
      driverTbl.glPixelTexGenParameteriSGIS = missing_glPixelTexGenParameteriSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelTexGenParameteriSGIS == loader_glPixelTexGenParameteriSGIS) {
      rCtx->dsp->emuTbl.glPixelTexGenParameteriSGIS = driverTbl.glPixelTexGenParameteriSGIS;
   }
   driverTbl.glPixelTexGenParameteriSGIS(pname, param);
}

static void REGAL_CALL missing_glPixelTexGenParameterivSGIS(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glPixelTexGenParameterivSGIS not available." );
}

static void REGAL_CALL loader_glPixelTexGenParameterivSGIS(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelTexGenParameterivSGIS, "glPixelTexGenParameterivSGIS");
   if ( !driverTbl.glPixelTexGenParameterivSGIS ) {
      driverTbl.glPixelTexGenParameterivSGIS = missing_glPixelTexGenParameterivSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelTexGenParameterivSGIS == loader_glPixelTexGenParameterivSGIS) {
      rCtx->dsp->emuTbl.glPixelTexGenParameterivSGIS = driverTbl.glPixelTexGenParameterivSGIS;
   }
   driverTbl.glPixelTexGenParameterivSGIS(pname, params);
}

// GL_SGIS_point_parameters

static void REGAL_CALL missing_glPointParameterfSGIS(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glPointParameterfSGIS not available." );
}

static void REGAL_CALL loader_glPointParameterfSGIS(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPointParameterfSGIS, "glPointParameterfSGIS");
   if ( !driverTbl.glPointParameterfSGIS ) {
      driverTbl.glPointParameterfSGIS = missing_glPointParameterfSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPointParameterfSGIS == loader_glPointParameterfSGIS) {
      rCtx->dsp->emuTbl.glPointParameterfSGIS = driverTbl.glPointParameterfSGIS;
   }
   driverTbl.glPointParameterfSGIS(pname, param);
}

static void REGAL_CALL missing_glPointParameterfvSGIS(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glPointParameterfvSGIS not available." );
}

static void REGAL_CALL loader_glPointParameterfvSGIS(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPointParameterfvSGIS, "glPointParameterfvSGIS");
   if ( !driverTbl.glPointParameterfvSGIS ) {
      driverTbl.glPointParameterfvSGIS = missing_glPointParameterfvSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPointParameterfvSGIS == loader_glPointParameterfvSGIS) {
      rCtx->dsp->emuTbl.glPointParameterfvSGIS = driverTbl.glPointParameterfvSGIS;
   }
   driverTbl.glPointParameterfvSGIS(pname, params);
}

// GL_SGIS_sharpen_texture

static void REGAL_CALL missing_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(points);
   Warning( "glGetSharpenTexFuncSGIS not available." );
}

static void REGAL_CALL loader_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetSharpenTexFuncSGIS, "glGetSharpenTexFuncSGIS");
   if ( !driverTbl.glGetSharpenTexFuncSGIS ) {
      driverTbl.glGetSharpenTexFuncSGIS = missing_glGetSharpenTexFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetSharpenTexFuncSGIS == loader_glGetSharpenTexFuncSGIS) {
      rCtx->dsp->emuTbl.glGetSharpenTexFuncSGIS = driverTbl.glGetSharpenTexFuncSGIS;
   }
   driverTbl.glGetSharpenTexFuncSGIS(target, points);
}

static void REGAL_CALL missing_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(points);
   Warning( "glSharpenTexFuncSGIS not available." );
}

static void REGAL_CALL loader_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSharpenTexFuncSGIS, "glSharpenTexFuncSGIS");
   if ( !driverTbl.glSharpenTexFuncSGIS ) {
      driverTbl.glSharpenTexFuncSGIS = missing_glSharpenTexFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSharpenTexFuncSGIS == loader_glSharpenTexFuncSGIS) {
      rCtx->dsp->emuTbl.glSharpenTexFuncSGIS = driverTbl.glSharpenTexFuncSGIS;
   }
   driverTbl.glSharpenTexFuncSGIS(target, n, points);
}

// GL_SGIS_texture4D

static void REGAL_CALL missing_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(size4d);
   UNUSED_PARAMETER(border);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTexImage4DSGIS not available." );
}

static void REGAL_CALL loader_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexImage4DSGIS, "glTexImage4DSGIS");
   if ( !driverTbl.glTexImage4DSGIS ) {
      driverTbl.glTexImage4DSGIS = missing_glTexImage4DSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexImage4DSGIS == loader_glTexImage4DSGIS) {
      rCtx->dsp->emuTbl.glTexImage4DSGIS = driverTbl.glTexImage4DSGIS;
   }
   driverTbl.glTexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
}

static void REGAL_CALL missing_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(level);
   UNUSED_PARAMETER(xoffset);
   UNUSED_PARAMETER(yoffset);
   UNUSED_PARAMETER(zoffset);
   UNUSED_PARAMETER(woffset);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(depth);
   UNUSED_PARAMETER(size4d);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glTexSubImage4DSGIS not available." );
}

static void REGAL_CALL loader_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexSubImage4DSGIS, "glTexSubImage4DSGIS");
   if ( !driverTbl.glTexSubImage4DSGIS ) {
      driverTbl.glTexSubImage4DSGIS = missing_glTexSubImage4DSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexSubImage4DSGIS == loader_glTexSubImage4DSGIS) {
      rCtx->dsp->emuTbl.glTexSubImage4DSGIS = driverTbl.glTexSubImage4DSGIS;
   }
   driverTbl.glTexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
}

// GL_SGIS_texture_color_mask

static void REGAL_CALL missing_glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
   UNUSED_PARAMETER(red);
   UNUSED_PARAMETER(green);
   UNUSED_PARAMETER(blue);
   UNUSED_PARAMETER(alpha);
   Warning( "glTextureColorMaskSGIS not available." );
}

static void REGAL_CALL loader_glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureColorMaskSGIS, "glTextureColorMaskSGIS");
   if ( !driverTbl.glTextureColorMaskSGIS ) {
      driverTbl.glTextureColorMaskSGIS = missing_glTextureColorMaskSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureColorMaskSGIS == loader_glTextureColorMaskSGIS) {
      rCtx->dsp->emuTbl.glTextureColorMaskSGIS = driverTbl.glTextureColorMaskSGIS;
   }
   driverTbl.glTextureColorMaskSGIS(red, green, blue, alpha);
}

// GL_SGIS_texture_filter4

static void REGAL_CALL missing_glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat *weights)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(filter);
   UNUSED_PARAMETER(weights);
   Warning( "glGetTexFilterFuncSGIS not available." );
}

static void REGAL_CALL loader_glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetTexFilterFuncSGIS, "glGetTexFilterFuncSGIS");
   if ( !driverTbl.glGetTexFilterFuncSGIS ) {
      driverTbl.glGetTexFilterFuncSGIS = missing_glGetTexFilterFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetTexFilterFuncSGIS == loader_glGetTexFilterFuncSGIS) {
      rCtx->dsp->emuTbl.glGetTexFilterFuncSGIS = driverTbl.glGetTexFilterFuncSGIS;
   }
   driverTbl.glGetTexFilterFuncSGIS(target, filter, weights);
}

static void REGAL_CALL missing_glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat *weights)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(filter);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(weights);
   Warning( "glTexFilterFuncSGIS not available." );
}

static void REGAL_CALL loader_glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat *weights)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexFilterFuncSGIS, "glTexFilterFuncSGIS");
   if ( !driverTbl.glTexFilterFuncSGIS ) {
      driverTbl.glTexFilterFuncSGIS = missing_glTexFilterFuncSGIS;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexFilterFuncSGIS == loader_glTexFilterFuncSGIS) {
      rCtx->dsp->emuTbl.glTexFilterFuncSGIS = driverTbl.glTexFilterFuncSGIS;
   }
   driverTbl.glTexFilterFuncSGIS(target, filter, n, weights);
}

// GL_SGIX_async

static void REGAL_CALL missing_glAsyncMarkerSGIX(GLuint marker)
{
   UNUSED_PARAMETER(marker);
   Warning( "glAsyncMarkerSGIX not available." );
}

static void REGAL_CALL loader_glAsyncMarkerSGIX(GLuint marker)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glAsyncMarkerSGIX, "glAsyncMarkerSGIX");
   if ( !driverTbl.glAsyncMarkerSGIX ) {
      driverTbl.glAsyncMarkerSGIX = missing_glAsyncMarkerSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glAsyncMarkerSGIX == loader_glAsyncMarkerSGIX) {
      rCtx->dsp->emuTbl.glAsyncMarkerSGIX = driverTbl.glAsyncMarkerSGIX;
   }
   driverTbl.glAsyncMarkerSGIX(marker);
}

static void REGAL_CALL missing_glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range)
{
   UNUSED_PARAMETER(marker);
   UNUSED_PARAMETER(range);
   Warning( "glDeleteAsyncMarkersSGIX not available." );
}

static void REGAL_CALL loader_glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeleteAsyncMarkersSGIX, "glDeleteAsyncMarkersSGIX");
   if ( !driverTbl.glDeleteAsyncMarkersSGIX ) {
      driverTbl.glDeleteAsyncMarkersSGIX = missing_glDeleteAsyncMarkersSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeleteAsyncMarkersSGIX == loader_glDeleteAsyncMarkersSGIX) {
      rCtx->dsp->emuTbl.glDeleteAsyncMarkersSGIX = driverTbl.glDeleteAsyncMarkersSGIX;
   }
   driverTbl.glDeleteAsyncMarkersSGIX(marker, range);
}

static GLint REGAL_CALL missing_glFinishAsyncSGIX(GLuint *markerp)
{
   UNUSED_PARAMETER(markerp);
   Warning( "glFinishAsyncSGIX not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glFinishAsyncSGIX(GLuint *markerp)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFinishAsyncSGIX, "glFinishAsyncSGIX");
   if ( !driverTbl.glFinishAsyncSGIX ) {
      driverTbl.glFinishAsyncSGIX = missing_glFinishAsyncSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFinishAsyncSGIX == loader_glFinishAsyncSGIX) {
      rCtx->dsp->emuTbl.glFinishAsyncSGIX = driverTbl.glFinishAsyncSGIX;
   }
   return driverTbl.glFinishAsyncSGIX(markerp);
}

static GLuint REGAL_CALL missing_glGenAsyncMarkersSGIX(GLsizei range)
{
   UNUSED_PARAMETER(range);
   Warning( "glGenAsyncMarkersSGIX not available." );
  GLuint  ret = (GLuint )0;
  return ret;
}

static GLuint REGAL_CALL loader_glGenAsyncMarkersSGIX(GLsizei range)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGenAsyncMarkersSGIX, "glGenAsyncMarkersSGIX");
   if ( !driverTbl.glGenAsyncMarkersSGIX ) {
      driverTbl.glGenAsyncMarkersSGIX = missing_glGenAsyncMarkersSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGenAsyncMarkersSGIX == loader_glGenAsyncMarkersSGIX) {
      rCtx->dsp->emuTbl.glGenAsyncMarkersSGIX = driverTbl.glGenAsyncMarkersSGIX;
   }
   return driverTbl.glGenAsyncMarkersSGIX(range);
}

static GLboolean REGAL_CALL missing_glIsAsyncMarkerSGIX(GLuint marker)
{
   UNUSED_PARAMETER(marker);
   Warning( "glIsAsyncMarkerSGIX not available." );
  GLboolean  ret = (GLboolean )0;
  return ret;
}

static GLboolean REGAL_CALL loader_glIsAsyncMarkerSGIX(GLuint marker)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIsAsyncMarkerSGIX, "glIsAsyncMarkerSGIX");
   if ( !driverTbl.glIsAsyncMarkerSGIX ) {
      driverTbl.glIsAsyncMarkerSGIX = missing_glIsAsyncMarkerSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIsAsyncMarkerSGIX == loader_glIsAsyncMarkerSGIX) {
      rCtx->dsp->emuTbl.glIsAsyncMarkerSGIX = driverTbl.glIsAsyncMarkerSGIX;
   }
   return driverTbl.glIsAsyncMarkerSGIX(marker);
}

static GLint REGAL_CALL missing_glPollAsyncSGIX(GLuint *markerp)
{
   UNUSED_PARAMETER(markerp);
   Warning( "glPollAsyncSGIX not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glPollAsyncSGIX(GLuint *markerp)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPollAsyncSGIX, "glPollAsyncSGIX");
   if ( !driverTbl.glPollAsyncSGIX ) {
      driverTbl.glPollAsyncSGIX = missing_glPollAsyncSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPollAsyncSGIX == loader_glPollAsyncSGIX) {
      rCtx->dsp->emuTbl.glPollAsyncSGIX = driverTbl.glPollAsyncSGIX;
   }
   return driverTbl.glPollAsyncSGIX(markerp);
}

// GL_SGIX_flush_raster

static void REGAL_CALL missing_glFlushRasterSGIX(void)
{
   Warning( "glFlushRasterSGIX not available." );
}

static void REGAL_CALL loader_glFlushRasterSGIX(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFlushRasterSGIX, "glFlushRasterSGIX");
   if ( !driverTbl.glFlushRasterSGIX ) {
      driverTbl.glFlushRasterSGIX = missing_glFlushRasterSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFlushRasterSGIX == loader_glFlushRasterSGIX) {
      rCtx->dsp->emuTbl.glFlushRasterSGIX = driverTbl.glFlushRasterSGIX;
   }
   driverTbl.glFlushRasterSGIX();
}

// GL_SGIX_fog_texture

static void REGAL_CALL missing_glTextureFogSGIX(GLenum pname)
{
   UNUSED_PARAMETER(pname);
   Warning( "glTextureFogSGIX not available." );
}

static void REGAL_CALL loader_glTextureFogSGIX(GLenum pname)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTextureFogSGIX, "glTextureFogSGIX");
   if ( !driverTbl.glTextureFogSGIX ) {
      driverTbl.glTextureFogSGIX = missing_glTextureFogSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTextureFogSGIX == loader_glTextureFogSGIX) {
      rCtx->dsp->emuTbl.glTextureFogSGIX = driverTbl.glTextureFogSGIX;
   }
   driverTbl.glTextureFogSGIX(pname);
}

// GL_SGIX_fragment_lighting

static void REGAL_CALL missing_glFragmentColorMaterialSGIX(GLenum face, GLenum mode)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(mode);
   Warning( "glFragmentColorMaterialSGIX not available." );
}

static void REGAL_CALL loader_glFragmentColorMaterialSGIX(GLenum face, GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentColorMaterialSGIX, "glFragmentColorMaterialSGIX");
   if ( !driverTbl.glFragmentColorMaterialSGIX ) {
      driverTbl.glFragmentColorMaterialSGIX = missing_glFragmentColorMaterialSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentColorMaterialSGIX == loader_glFragmentColorMaterialSGIX) {
      rCtx->dsp->emuTbl.glFragmentColorMaterialSGIX = driverTbl.glFragmentColorMaterialSGIX;
   }
   driverTbl.glFragmentColorMaterialSGIX(face, mode);
}

static void REGAL_CALL missing_glFragmentLightModelfSGIX(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFragmentLightModelfSGIX not available." );
}

static void REGAL_CALL loader_glFragmentLightModelfSGIX(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightModelfSGIX, "glFragmentLightModelfSGIX");
   if ( !driverTbl.glFragmentLightModelfSGIX ) {
      driverTbl.glFragmentLightModelfSGIX = missing_glFragmentLightModelfSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightModelfSGIX == loader_glFragmentLightModelfSGIX) {
      rCtx->dsp->emuTbl.glFragmentLightModelfSGIX = driverTbl.glFragmentLightModelfSGIX;
   }
   driverTbl.glFragmentLightModelfSGIX(pname, param);
}

static void REGAL_CALL missing_glFragmentLightModelfvSGIX(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glFragmentLightModelfvSGIX not available." );
}

static void REGAL_CALL loader_glFragmentLightModelfvSGIX(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightModelfvSGIX, "glFragmentLightModelfvSGIX");
   if ( !driverTbl.glFragmentLightModelfvSGIX ) {
      driverTbl.glFragmentLightModelfvSGIX = missing_glFragmentLightModelfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightModelfvSGIX == loader_glFragmentLightModelfvSGIX) {
      rCtx->dsp->emuTbl.glFragmentLightModelfvSGIX = driverTbl.glFragmentLightModelfvSGIX;
   }
   driverTbl.glFragmentLightModelfvSGIX(pname, params);
}

static void REGAL_CALL missing_glFragmentLightModeliSGIX(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFragmentLightModeliSGIX not available." );
}

static void REGAL_CALL loader_glFragmentLightModeliSGIX(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightModeliSGIX, "glFragmentLightModeliSGIX");
   if ( !driverTbl.glFragmentLightModeliSGIX ) {
      driverTbl.glFragmentLightModeliSGIX = missing_glFragmentLightModeliSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightModeliSGIX == loader_glFragmentLightModeliSGIX) {
      rCtx->dsp->emuTbl.glFragmentLightModeliSGIX = driverTbl.glFragmentLightModeliSGIX;
   }
   driverTbl.glFragmentLightModeliSGIX(pname, param);
}

static void REGAL_CALL missing_glFragmentLightModelivSGIX(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glFragmentLightModelivSGIX not available." );
}

static void REGAL_CALL loader_glFragmentLightModelivSGIX(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightModelivSGIX, "glFragmentLightModelivSGIX");
   if ( !driverTbl.glFragmentLightModelivSGIX ) {
      driverTbl.glFragmentLightModelivSGIX = missing_glFragmentLightModelivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightModelivSGIX == loader_glFragmentLightModelivSGIX) {
      rCtx->dsp->emuTbl.glFragmentLightModelivSGIX = driverTbl.glFragmentLightModelivSGIX;
   }
   driverTbl.glFragmentLightModelivSGIX(pname, params);
}

static void REGAL_CALL missing_glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFragmentLightfSGIX not available." );
}

static void REGAL_CALL loader_glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightfSGIX, "glFragmentLightfSGIX");
   if ( !driverTbl.glFragmentLightfSGIX ) {
      driverTbl.glFragmentLightfSGIX = missing_glFragmentLightfSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightfSGIX == loader_glFragmentLightfSGIX) {
      rCtx->dsp->emuTbl.glFragmentLightfSGIX = driverTbl.glFragmentLightfSGIX;
   }
   driverTbl.glFragmentLightfSGIX(light, pname, param);
}

static void REGAL_CALL missing_glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glFragmentLightfvSGIX not available." );
}

static void REGAL_CALL loader_glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightfvSGIX, "glFragmentLightfvSGIX");
   if ( !driverTbl.glFragmentLightfvSGIX ) {
      driverTbl.glFragmentLightfvSGIX = missing_glFragmentLightfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightfvSGIX == loader_glFragmentLightfvSGIX) {
      rCtx->dsp->emuTbl.glFragmentLightfvSGIX = driverTbl.glFragmentLightfvSGIX;
   }
   driverTbl.glFragmentLightfvSGIX(light, pname, params);
}

static void REGAL_CALL missing_glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFragmentLightiSGIX not available." );
}

static void REGAL_CALL loader_glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightiSGIX, "glFragmentLightiSGIX");
   if ( !driverTbl.glFragmentLightiSGIX ) {
      driverTbl.glFragmentLightiSGIX = missing_glFragmentLightiSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightiSGIX == loader_glFragmentLightiSGIX) {
      rCtx->dsp->emuTbl.glFragmentLightiSGIX = driverTbl.glFragmentLightiSGIX;
   }
   driverTbl.glFragmentLightiSGIX(light, pname, param);
}

static void REGAL_CALL missing_glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glFragmentLightivSGIX not available." );
}

static void REGAL_CALL loader_glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentLightivSGIX, "glFragmentLightivSGIX");
   if ( !driverTbl.glFragmentLightivSGIX ) {
      driverTbl.glFragmentLightivSGIX = missing_glFragmentLightivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentLightivSGIX == loader_glFragmentLightivSGIX) {
      rCtx->dsp->emuTbl.glFragmentLightivSGIX = driverTbl.glFragmentLightivSGIX;
   }
   driverTbl.glFragmentLightivSGIX(light, pname, params);
}

static void REGAL_CALL missing_glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFragmentMaterialfSGIX not available." );
}

static void REGAL_CALL loader_glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentMaterialfSGIX, "glFragmentMaterialfSGIX");
   if ( !driverTbl.glFragmentMaterialfSGIX ) {
      driverTbl.glFragmentMaterialfSGIX = missing_glFragmentMaterialfSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentMaterialfSGIX == loader_glFragmentMaterialfSGIX) {
      rCtx->dsp->emuTbl.glFragmentMaterialfSGIX = driverTbl.glFragmentMaterialfSGIX;
   }
   driverTbl.glFragmentMaterialfSGIX(face, pname, param);
}

static void REGAL_CALL missing_glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glFragmentMaterialfvSGIX not available." );
}

static void REGAL_CALL loader_glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentMaterialfvSGIX, "glFragmentMaterialfvSGIX");
   if ( !driverTbl.glFragmentMaterialfvSGIX ) {
      driverTbl.glFragmentMaterialfvSGIX = missing_glFragmentMaterialfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentMaterialfvSGIX == loader_glFragmentMaterialfvSGIX) {
      rCtx->dsp->emuTbl.glFragmentMaterialfvSGIX = driverTbl.glFragmentMaterialfvSGIX;
   }
   driverTbl.glFragmentMaterialfvSGIX(face, pname, params);
}

static void REGAL_CALL missing_glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glFragmentMaterialiSGIX not available." );
}

static void REGAL_CALL loader_glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentMaterialiSGIX, "glFragmentMaterialiSGIX");
   if ( !driverTbl.glFragmentMaterialiSGIX ) {
      driverTbl.glFragmentMaterialiSGIX = missing_glFragmentMaterialiSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentMaterialiSGIX == loader_glFragmentMaterialiSGIX) {
      rCtx->dsp->emuTbl.glFragmentMaterialiSGIX = driverTbl.glFragmentMaterialiSGIX;
   }
   driverTbl.glFragmentMaterialiSGIX(face, pname, param);
}

static void REGAL_CALL missing_glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glFragmentMaterialivSGIX not available." );
}

static void REGAL_CALL loader_glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFragmentMaterialivSGIX, "glFragmentMaterialivSGIX");
   if ( !driverTbl.glFragmentMaterialivSGIX ) {
      driverTbl.glFragmentMaterialivSGIX = missing_glFragmentMaterialivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFragmentMaterialivSGIX == loader_glFragmentMaterialivSGIX) {
      rCtx->dsp->emuTbl.glFragmentMaterialivSGIX = driverTbl.glFragmentMaterialivSGIX;
   }
   driverTbl.glFragmentMaterialivSGIX(face, pname, params);
}

static void REGAL_CALL missing_glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFragmentLightfvSGIX not available." );
}

static void REGAL_CALL loader_glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFragmentLightfvSGIX, "glGetFragmentLightfvSGIX");
   if ( !driverTbl.glGetFragmentLightfvSGIX ) {
      driverTbl.glGetFragmentLightfvSGIX = missing_glGetFragmentLightfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFragmentLightfvSGIX == loader_glGetFragmentLightfvSGIX) {
      rCtx->dsp->emuTbl.glGetFragmentLightfvSGIX = driverTbl.glGetFragmentLightfvSGIX;
   }
   driverTbl.glGetFragmentLightfvSGIX(light, pname, params);
}

static void REGAL_CALL missing_glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(light);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFragmentLightivSGIX not available." );
}

static void REGAL_CALL loader_glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFragmentLightivSGIX, "glGetFragmentLightivSGIX");
   if ( !driverTbl.glGetFragmentLightivSGIX ) {
      driverTbl.glGetFragmentLightivSGIX = missing_glGetFragmentLightivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFragmentLightivSGIX == loader_glGetFragmentLightivSGIX) {
      rCtx->dsp->emuTbl.glGetFragmentLightivSGIX = driverTbl.glGetFragmentLightivSGIX;
   }
   driverTbl.glGetFragmentLightivSGIX(light, pname, params);
}

static void REGAL_CALL missing_glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFragmentMaterialfvSGIX not available." );
}

static void REGAL_CALL loader_glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFragmentMaterialfvSGIX, "glGetFragmentMaterialfvSGIX");
   if ( !driverTbl.glGetFragmentMaterialfvSGIX ) {
      driverTbl.glGetFragmentMaterialfvSGIX = missing_glGetFragmentMaterialfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFragmentMaterialfvSGIX == loader_glGetFragmentMaterialfvSGIX) {
      rCtx->dsp->emuTbl.glGetFragmentMaterialfvSGIX = driverTbl.glGetFragmentMaterialfvSGIX;
   }
   driverTbl.glGetFragmentMaterialfvSGIX(face, pname, params);
}

static void REGAL_CALL missing_glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(face);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetFragmentMaterialivSGIX not available." );
}

static void REGAL_CALL loader_glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetFragmentMaterialivSGIX, "glGetFragmentMaterialivSGIX");
   if ( !driverTbl.glGetFragmentMaterialivSGIX ) {
      driverTbl.glGetFragmentMaterialivSGIX = missing_glGetFragmentMaterialivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetFragmentMaterialivSGIX == loader_glGetFragmentMaterialivSGIX) {
      rCtx->dsp->emuTbl.glGetFragmentMaterialivSGIX = driverTbl.glGetFragmentMaterialivSGIX;
   }
   driverTbl.glGetFragmentMaterialivSGIX(face, pname, params);
}

static void REGAL_CALL missing_glLightEnviSGIX(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glLightEnviSGIX not available." );
}

static void REGAL_CALL loader_glLightEnviSGIX(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLightEnviSGIX, "glLightEnviSGIX");
   if ( !driverTbl.glLightEnviSGIX ) {
      driverTbl.glLightEnviSGIX = missing_glLightEnviSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLightEnviSGIX == loader_glLightEnviSGIX) {
      rCtx->dsp->emuTbl.glLightEnviSGIX = driverTbl.glLightEnviSGIX;
   }
   driverTbl.glLightEnviSGIX(pname, param);
}

// GL_SGIX_framezoom

static void REGAL_CALL missing_glFrameZoomSGIX(GLint factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "glFrameZoomSGIX not available." );
}

static void REGAL_CALL loader_glFrameZoomSGIX(GLint factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFrameZoomSGIX, "glFrameZoomSGIX");
   if ( !driverTbl.glFrameZoomSGIX ) {
      driverTbl.glFrameZoomSGIX = missing_glFrameZoomSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFrameZoomSGIX == loader_glFrameZoomSGIX) {
      rCtx->dsp->emuTbl.glFrameZoomSGIX = driverTbl.glFrameZoomSGIX;
   }
   driverTbl.glFrameZoomSGIX(factor);
}

// GL_SGIX_igloo_interface

static void REGAL_CALL missing_glIglooInterfaceSGIX(GLenum pname, const GLvoid *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glIglooInterfaceSGIX not available." );
}

static void REGAL_CALL loader_glIglooInterfaceSGIX(GLenum pname, const GLvoid *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glIglooInterfaceSGIX, "glIglooInterfaceSGIX");
   if ( !driverTbl.glIglooInterfaceSGIX ) {
      driverTbl.glIglooInterfaceSGIX = missing_glIglooInterfaceSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glIglooInterfaceSGIX == loader_glIglooInterfaceSGIX) {
      rCtx->dsp->emuTbl.glIglooInterfaceSGIX = driverTbl.glIglooInterfaceSGIX;
   }
   driverTbl.glIglooInterfaceSGIX(pname, params);
}

// GL_SGIX_instruments

static GLint REGAL_CALL missing_glGetInstrumentsSGIX(void)
{
   Warning( "glGetInstrumentsSGIX not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glGetInstrumentsSGIX(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetInstrumentsSGIX, "glGetInstrumentsSGIX");
   if ( !driverTbl.glGetInstrumentsSGIX ) {
      driverTbl.glGetInstrumentsSGIX = missing_glGetInstrumentsSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetInstrumentsSGIX == loader_glGetInstrumentsSGIX) {
      rCtx->dsp->emuTbl.glGetInstrumentsSGIX = driverTbl.glGetInstrumentsSGIX;
   }
   return driverTbl.glGetInstrumentsSGIX();
}

static void REGAL_CALL missing_glInstrumentsBufferSGIX(GLsizei size, GLint *buffer)
{
   UNUSED_PARAMETER(size);
   UNUSED_PARAMETER(buffer);
   Warning( "glInstrumentsBufferSGIX not available." );
}

static void REGAL_CALL loader_glInstrumentsBufferSGIX(GLsizei size, GLint *buffer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glInstrumentsBufferSGIX, "glInstrumentsBufferSGIX");
   if ( !driverTbl.glInstrumentsBufferSGIX ) {
      driverTbl.glInstrumentsBufferSGIX = missing_glInstrumentsBufferSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glInstrumentsBufferSGIX == loader_glInstrumentsBufferSGIX) {
      rCtx->dsp->emuTbl.glInstrumentsBufferSGIX = driverTbl.glInstrumentsBufferSGIX;
   }
   driverTbl.glInstrumentsBufferSGIX(size, buffer);
}

static GLint REGAL_CALL missing_glPollInstrumentsSGIX(GLint *marker_p)
{
   UNUSED_PARAMETER(marker_p);
   Warning( "glPollInstrumentsSGIX not available." );
  GLint  ret = (GLint )0;
  return ret;
}

static GLint REGAL_CALL loader_glPollInstrumentsSGIX(GLint *marker_p)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPollInstrumentsSGIX, "glPollInstrumentsSGIX");
   if ( !driverTbl.glPollInstrumentsSGIX ) {
      driverTbl.glPollInstrumentsSGIX = missing_glPollInstrumentsSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPollInstrumentsSGIX == loader_glPollInstrumentsSGIX) {
      rCtx->dsp->emuTbl.glPollInstrumentsSGIX = driverTbl.glPollInstrumentsSGIX;
   }
   return driverTbl.glPollInstrumentsSGIX(marker_p);
}

static void REGAL_CALL missing_glReadInstrumentsSGIX(GLint marker)
{
   UNUSED_PARAMETER(marker);
   Warning( "glReadInstrumentsSGIX not available." );
}

static void REGAL_CALL loader_glReadInstrumentsSGIX(GLint marker)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReadInstrumentsSGIX, "glReadInstrumentsSGIX");
   if ( !driverTbl.glReadInstrumentsSGIX ) {
      driverTbl.glReadInstrumentsSGIX = missing_glReadInstrumentsSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReadInstrumentsSGIX == loader_glReadInstrumentsSGIX) {
      rCtx->dsp->emuTbl.glReadInstrumentsSGIX = driverTbl.glReadInstrumentsSGIX;
   }
   driverTbl.glReadInstrumentsSGIX(marker);
}

static void REGAL_CALL missing_glStartInstrumentsSGIX(void)
{
   Warning( "glStartInstrumentsSGIX not available." );
}

static void REGAL_CALL loader_glStartInstrumentsSGIX(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStartInstrumentsSGIX, "glStartInstrumentsSGIX");
   if ( !driverTbl.glStartInstrumentsSGIX ) {
      driverTbl.glStartInstrumentsSGIX = missing_glStartInstrumentsSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStartInstrumentsSGIX == loader_glStartInstrumentsSGIX) {
      rCtx->dsp->emuTbl.glStartInstrumentsSGIX = driverTbl.glStartInstrumentsSGIX;
   }
   driverTbl.glStartInstrumentsSGIX();
}

static void REGAL_CALL missing_glStopInstrumentsSGIX(GLint marker)
{
   UNUSED_PARAMETER(marker);
   Warning( "glStopInstrumentsSGIX not available." );
}

static void REGAL_CALL loader_glStopInstrumentsSGIX(GLint marker)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glStopInstrumentsSGIX, "glStopInstrumentsSGIX");
   if ( !driverTbl.glStopInstrumentsSGIX ) {
      driverTbl.glStopInstrumentsSGIX = missing_glStopInstrumentsSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glStopInstrumentsSGIX == loader_glStopInstrumentsSGIX) {
      rCtx->dsp->emuTbl.glStopInstrumentsSGIX = driverTbl.glStopInstrumentsSGIX;
   }
   driverTbl.glStopInstrumentsSGIX(marker);
}

// GL_SGIX_list_priority

static void REGAL_CALL missing_glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetListParameterfvSGIX not available." );
}

static void REGAL_CALL loader_glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetListParameterfvSGIX, "glGetListParameterfvSGIX");
   if ( !driverTbl.glGetListParameterfvSGIX ) {
      driverTbl.glGetListParameterfvSGIX = missing_glGetListParameterfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetListParameterfvSGIX == loader_glGetListParameterfvSGIX) {
      rCtx->dsp->emuTbl.glGetListParameterfvSGIX = driverTbl.glGetListParameterfvSGIX;
   }
   driverTbl.glGetListParameterfvSGIX(list, pname, params);
}

static void REGAL_CALL missing_glGetListParameterivSGIX(GLuint list, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetListParameterivSGIX not available." );
}

static void REGAL_CALL loader_glGetListParameterivSGIX(GLuint list, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetListParameterivSGIX, "glGetListParameterivSGIX");
   if ( !driverTbl.glGetListParameterivSGIX ) {
      driverTbl.glGetListParameterivSGIX = missing_glGetListParameterivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetListParameterivSGIX == loader_glGetListParameterivSGIX) {
      rCtx->dsp->emuTbl.glGetListParameterivSGIX = driverTbl.glGetListParameterivSGIX;
   }
   driverTbl.glGetListParameterivSGIX(list, pname, params);
}

static void REGAL_CALL missing_glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glListParameterfSGIX not available." );
}

static void REGAL_CALL loader_glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glListParameterfSGIX, "glListParameterfSGIX");
   if ( !driverTbl.glListParameterfSGIX ) {
      driverTbl.glListParameterfSGIX = missing_glListParameterfSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glListParameterfSGIX == loader_glListParameterfSGIX) {
      rCtx->dsp->emuTbl.glListParameterfSGIX = driverTbl.glListParameterfSGIX;
   }
   driverTbl.glListParameterfSGIX(list, pname, param);
}

static void REGAL_CALL missing_glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glListParameterfvSGIX not available." );
}

static void REGAL_CALL loader_glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glListParameterfvSGIX, "glListParameterfvSGIX");
   if ( !driverTbl.glListParameterfvSGIX ) {
      driverTbl.glListParameterfvSGIX = missing_glListParameterfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glListParameterfvSGIX == loader_glListParameterfvSGIX) {
      rCtx->dsp->emuTbl.glListParameterfvSGIX = driverTbl.glListParameterfvSGIX;
   }
   driverTbl.glListParameterfvSGIX(list, pname, params);
}

static void REGAL_CALL missing_glListParameteriSGIX(GLuint list, GLenum pname, GLint param)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glListParameteriSGIX not available." );
}

static void REGAL_CALL loader_glListParameteriSGIX(GLuint list, GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glListParameteriSGIX, "glListParameteriSGIX");
   if ( !driverTbl.glListParameteriSGIX ) {
      driverTbl.glListParameteriSGIX = missing_glListParameteriSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glListParameteriSGIX == loader_glListParameteriSGIX) {
      rCtx->dsp->emuTbl.glListParameteriSGIX = driverTbl.glListParameteriSGIX;
   }
   driverTbl.glListParameteriSGIX(list, pname, param);
}

static void REGAL_CALL missing_glListParameterivSGIX(GLuint list, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(list);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glListParameterivSGIX not available." );
}

static void REGAL_CALL loader_glListParameterivSGIX(GLuint list, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glListParameterivSGIX, "glListParameterivSGIX");
   if ( !driverTbl.glListParameterivSGIX ) {
      driverTbl.glListParameterivSGIX = missing_glListParameterivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glListParameterivSGIX == loader_glListParameterivSGIX) {
      rCtx->dsp->emuTbl.glListParameterivSGIX = driverTbl.glListParameterivSGIX;
   }
   driverTbl.glListParameterivSGIX(list, pname, params);
}

// GL_SGIX_pixel_texture

static void REGAL_CALL missing_glPixelTexGenSGIX(GLenum mode)
{
   UNUSED_PARAMETER(mode);
   Warning( "glPixelTexGenSGIX not available." );
}

static void REGAL_CALL loader_glPixelTexGenSGIX(GLenum mode)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glPixelTexGenSGIX, "glPixelTexGenSGIX");
   if ( !driverTbl.glPixelTexGenSGIX ) {
      driverTbl.glPixelTexGenSGIX = missing_glPixelTexGenSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glPixelTexGenSGIX == loader_glPixelTexGenSGIX) {
      rCtx->dsp->emuTbl.glPixelTexGenSGIX = driverTbl.glPixelTexGenSGIX;
   }
   driverTbl.glPixelTexGenSGIX(mode);
}

// GL_SGIX_polynomial_ffd

static void REGAL_CALL missing_glDeformSGIX(GLbitfield mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "glDeformSGIX not available." );
}

static void REGAL_CALL loader_glDeformSGIX(GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeformSGIX, "glDeformSGIX");
   if ( !driverTbl.glDeformSGIX ) {
      driverTbl.glDeformSGIX = missing_glDeformSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeformSGIX == loader_glDeformSGIX) {
      rCtx->dsp->emuTbl.glDeformSGIX = driverTbl.glDeformSGIX;
   }
   driverTbl.glDeformSGIX(mask);
}

static void REGAL_CALL missing_glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(uorder);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(vorder);
   UNUSED_PARAMETER(w1);
   UNUSED_PARAMETER(w2);
   UNUSED_PARAMETER(wstride);
   UNUSED_PARAMETER(worder);
   UNUSED_PARAMETER(points);
   Warning( "glDeformationMap3dSGIX not available." );
}

static void REGAL_CALL loader_glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeformationMap3dSGIX, "glDeformationMap3dSGIX");
   if ( !driverTbl.glDeformationMap3dSGIX ) {
      driverTbl.glDeformationMap3dSGIX = missing_glDeformationMap3dSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeformationMap3dSGIX == loader_glDeformationMap3dSGIX) {
      rCtx->dsp->emuTbl.glDeformationMap3dSGIX = driverTbl.glDeformationMap3dSGIX;
   }
   driverTbl.glDeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
}

static void REGAL_CALL missing_glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(u1);
   UNUSED_PARAMETER(u2);
   UNUSED_PARAMETER(ustride);
   UNUSED_PARAMETER(uorder);
   UNUSED_PARAMETER(v1);
   UNUSED_PARAMETER(v2);
   UNUSED_PARAMETER(vstride);
   UNUSED_PARAMETER(vorder);
   UNUSED_PARAMETER(w1);
   UNUSED_PARAMETER(w2);
   UNUSED_PARAMETER(wstride);
   UNUSED_PARAMETER(worder);
   UNUSED_PARAMETER(points);
   Warning( "glDeformationMap3fSGIX not available." );
}

static void REGAL_CALL loader_glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDeformationMap3fSGIX, "glDeformationMap3fSGIX");
   if ( !driverTbl.glDeformationMap3fSGIX ) {
      driverTbl.glDeformationMap3fSGIX = missing_glDeformationMap3fSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDeformationMap3fSGIX == loader_glDeformationMap3fSGIX) {
      rCtx->dsp->emuTbl.glDeformationMap3fSGIX = driverTbl.glDeformationMap3fSGIX;
   }
   driverTbl.glDeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
}

static void REGAL_CALL missing_glLoadIdentityDeformationMapSGIX(GLbitfield mask)
{
   UNUSED_PARAMETER(mask);
   Warning( "glLoadIdentityDeformationMapSGIX not available." );
}

static void REGAL_CALL loader_glLoadIdentityDeformationMapSGIX(GLbitfield mask)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glLoadIdentityDeformationMapSGIX, "glLoadIdentityDeformationMapSGIX");
   if ( !driverTbl.glLoadIdentityDeformationMapSGIX ) {
      driverTbl.glLoadIdentityDeformationMapSGIX = missing_glLoadIdentityDeformationMapSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glLoadIdentityDeformationMapSGIX == loader_glLoadIdentityDeformationMapSGIX) {
      rCtx->dsp->emuTbl.glLoadIdentityDeformationMapSGIX = driverTbl.glLoadIdentityDeformationMapSGIX;
   }
   driverTbl.glLoadIdentityDeformationMapSGIX(mask);
}

// GL_SGIX_reference_plane

static void REGAL_CALL missing_glReferencePlaneSGIX(const GLdouble *equation)
{
   UNUSED_PARAMETER(equation);
   Warning( "glReferencePlaneSGIX not available." );
}

static void REGAL_CALL loader_glReferencePlaneSGIX(const GLdouble *equation)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReferencePlaneSGIX, "glReferencePlaneSGIX");
   if ( !driverTbl.glReferencePlaneSGIX ) {
      driverTbl.glReferencePlaneSGIX = missing_glReferencePlaneSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReferencePlaneSGIX == loader_glReferencePlaneSGIX) {
      rCtx->dsp->emuTbl.glReferencePlaneSGIX = driverTbl.glReferencePlaneSGIX;
   }
   driverTbl.glReferencePlaneSGIX(equation);
}

// GL_SGIX_sprite

static void REGAL_CALL missing_glSpriteParameterfSGIX(GLenum pname, GLfloat param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glSpriteParameterfSGIX not available." );
}

static void REGAL_CALL loader_glSpriteParameterfSGIX(GLenum pname, GLfloat param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSpriteParameterfSGIX, "glSpriteParameterfSGIX");
   if ( !driverTbl.glSpriteParameterfSGIX ) {
      driverTbl.glSpriteParameterfSGIX = missing_glSpriteParameterfSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSpriteParameterfSGIX == loader_glSpriteParameterfSGIX) {
      rCtx->dsp->emuTbl.glSpriteParameterfSGIX = driverTbl.glSpriteParameterfSGIX;
   }
   driverTbl.glSpriteParameterfSGIX(pname, param);
}

static void REGAL_CALL missing_glSpriteParameterfvSGIX(GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glSpriteParameterfvSGIX not available." );
}

static void REGAL_CALL loader_glSpriteParameterfvSGIX(GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSpriteParameterfvSGIX, "glSpriteParameterfvSGIX");
   if ( !driverTbl.glSpriteParameterfvSGIX ) {
      driverTbl.glSpriteParameterfvSGIX = missing_glSpriteParameterfvSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSpriteParameterfvSGIX == loader_glSpriteParameterfvSGIX) {
      rCtx->dsp->emuTbl.glSpriteParameterfvSGIX = driverTbl.glSpriteParameterfvSGIX;
   }
   driverTbl.glSpriteParameterfvSGIX(pname, params);
}

static void REGAL_CALL missing_glSpriteParameteriSGIX(GLenum pname, GLint param)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(param);
   Warning( "glSpriteParameteriSGIX not available." );
}

static void REGAL_CALL loader_glSpriteParameteriSGIX(GLenum pname, GLint param)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSpriteParameteriSGIX, "glSpriteParameteriSGIX");
   if ( !driverTbl.glSpriteParameteriSGIX ) {
      driverTbl.glSpriteParameteriSGIX = missing_glSpriteParameteriSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSpriteParameteriSGIX == loader_glSpriteParameteriSGIX) {
      rCtx->dsp->emuTbl.glSpriteParameteriSGIX = driverTbl.glSpriteParameteriSGIX;
   }
   driverTbl.glSpriteParameteriSGIX(pname, param);
}

static void REGAL_CALL missing_glSpriteParameterivSGIX(GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glSpriteParameterivSGIX not available." );
}

static void REGAL_CALL loader_glSpriteParameterivSGIX(GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glSpriteParameterivSGIX, "glSpriteParameterivSGIX");
   if ( !driverTbl.glSpriteParameterivSGIX ) {
      driverTbl.glSpriteParameterivSGIX = missing_glSpriteParameterivSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glSpriteParameterivSGIX == loader_glSpriteParameterivSGIX) {
      rCtx->dsp->emuTbl.glSpriteParameterivSGIX = driverTbl.glSpriteParameterivSGIX;
   }
   driverTbl.glSpriteParameterivSGIX(pname, params);
}

// GL_SGIX_tag_sample_buffer

static void REGAL_CALL missing_glTagSampleBufferSGIX(void)
{
   Warning( "glTagSampleBufferSGIX not available." );
}

static void REGAL_CALL loader_glTagSampleBufferSGIX(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTagSampleBufferSGIX, "glTagSampleBufferSGIX");
   if ( !driverTbl.glTagSampleBufferSGIX ) {
      driverTbl.glTagSampleBufferSGIX = missing_glTagSampleBufferSGIX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTagSampleBufferSGIX == loader_glTagSampleBufferSGIX) {
      rCtx->dsp->emuTbl.glTagSampleBufferSGIX = driverTbl.glTagSampleBufferSGIX;
   }
   driverTbl.glTagSampleBufferSGIX();
}

// GL_SGI_color_table

static void REGAL_CALL missing_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glColorTableParameterfvSGI not available." );
}

static void REGAL_CALL loader_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorTableParameterfvSGI, "glColorTableParameterfvSGI");
   if ( !driverTbl.glColorTableParameterfvSGI ) {
      driverTbl.glColorTableParameterfvSGI = missing_glColorTableParameterfvSGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorTableParameterfvSGI == loader_glColorTableParameterfvSGI) {
      rCtx->dsp->emuTbl.glColorTableParameterfvSGI = driverTbl.glColorTableParameterfvSGI;
   }
   driverTbl.glColorTableParameterfvSGI(target, pname, params);
}

static void REGAL_CALL missing_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glColorTableParameterivSGI not available." );
}

static void REGAL_CALL loader_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorTableParameterivSGI, "glColorTableParameterivSGI");
   if ( !driverTbl.glColorTableParameterivSGI ) {
      driverTbl.glColorTableParameterivSGI = missing_glColorTableParameterivSGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorTableParameterivSGI == loader_glColorTableParameterivSGI) {
      rCtx->dsp->emuTbl.glColorTableParameterivSGI = driverTbl.glColorTableParameterivSGI;
   }
   driverTbl.glColorTableParameterivSGI(target, pname, params);
}

static void REGAL_CALL missing_glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(table);
   Warning( "glColorTableSGI not available." );
}

static void REGAL_CALL loader_glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColorTableSGI, "glColorTableSGI");
   if ( !driverTbl.glColorTableSGI ) {
      driverTbl.glColorTableSGI = missing_glColorTableSGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColorTableSGI == loader_glColorTableSGI) {
      rCtx->dsp->emuTbl.glColorTableSGI = driverTbl.glColorTableSGI;
   }
   driverTbl.glColorTableSGI(target, internalformat, width, format, type, table);
}

static void REGAL_CALL missing_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(internalformat);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   Warning( "glCopyColorTableSGI not available." );
}

static void REGAL_CALL loader_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glCopyColorTableSGI, "glCopyColorTableSGI");
   if ( !driverTbl.glCopyColorTableSGI ) {
      driverTbl.glCopyColorTableSGI = missing_glCopyColorTableSGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glCopyColorTableSGI == loader_glCopyColorTableSGI) {
      rCtx->dsp->emuTbl.glCopyColorTableSGI = driverTbl.glCopyColorTableSGI;
   }
   driverTbl.glCopyColorTableSGI(target, internalformat, x, y, width);
}

static void REGAL_CALL missing_glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetColorTableParameterfvSGI not available." );
}

static void REGAL_CALL loader_glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetColorTableParameterfvSGI, "glGetColorTableParameterfvSGI");
   if ( !driverTbl.glGetColorTableParameterfvSGI ) {
      driverTbl.glGetColorTableParameterfvSGI = missing_glGetColorTableParameterfvSGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetColorTableParameterfvSGI == loader_glGetColorTableParameterfvSGI) {
      rCtx->dsp->emuTbl.glGetColorTableParameterfvSGI = driverTbl.glGetColorTableParameterfvSGI;
   }
   driverTbl.glGetColorTableParameterfvSGI(target, pname, params);
}

static void REGAL_CALL missing_glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(pname);
   UNUSED_PARAMETER(params);
   Warning( "glGetColorTableParameterivSGI not available." );
}

static void REGAL_CALL loader_glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetColorTableParameterivSGI, "glGetColorTableParameterivSGI");
   if ( !driverTbl.glGetColorTableParameterivSGI ) {
      driverTbl.glGetColorTableParameterivSGI = missing_glGetColorTableParameterivSGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetColorTableParameterivSGI == loader_glGetColorTableParameterivSGI) {
      rCtx->dsp->emuTbl.glGetColorTableParameterivSGI = driverTbl.glGetColorTableParameterivSGI;
   }
   driverTbl.glGetColorTableParameterivSGI(target, pname, params);
}

static void REGAL_CALL missing_glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid *table)
{
   UNUSED_PARAMETER(target);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(table);
   Warning( "glGetColorTableSGI not available." );
}

static void REGAL_CALL loader_glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid *table)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGetColorTableSGI, "glGetColorTableSGI");
   if ( !driverTbl.glGetColorTableSGI ) {
      driverTbl.glGetColorTableSGI = missing_glGetColorTableSGI;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGetColorTableSGI == loader_glGetColorTableSGI) {
      rCtx->dsp->emuTbl.glGetColorTableSGI = driverTbl.glGetColorTableSGI;
   }
   driverTbl.glGetColorTableSGI(target, format, type, table);
}

// GL_SUNX_constant_data

static void REGAL_CALL missing_glFinishTextureSUNX(void)
{
   Warning( "glFinishTextureSUNX not available." );
}

static void REGAL_CALL loader_glFinishTextureSUNX(void)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glFinishTextureSUNX, "glFinishTextureSUNX");
   if ( !driverTbl.glFinishTextureSUNX ) {
      driverTbl.glFinishTextureSUNX = missing_glFinishTextureSUNX;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glFinishTextureSUNX == loader_glFinishTextureSUNX) {
      rCtx->dsp->emuTbl.glFinishTextureSUNX = driverTbl.glFinishTextureSUNX;
   }
   driverTbl.glFinishTextureSUNX();
}

// GL_SUN_global_alpha

static void REGAL_CALL missing_glGlobalAlphaFactorbSUN(GLbyte factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "glGlobalAlphaFactorbSUN not available." );
}

static void REGAL_CALL loader_glGlobalAlphaFactorbSUN(GLbyte factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGlobalAlphaFactorbSUN, "glGlobalAlphaFactorbSUN");
   if ( !driverTbl.glGlobalAlphaFactorbSUN ) {
      driverTbl.glGlobalAlphaFactorbSUN = missing_glGlobalAlphaFactorbSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGlobalAlphaFactorbSUN == loader_glGlobalAlphaFactorbSUN) {
      rCtx->dsp->emuTbl.glGlobalAlphaFactorbSUN = driverTbl.glGlobalAlphaFactorbSUN;
   }
   driverTbl.glGlobalAlphaFactorbSUN(factor);
}

static void REGAL_CALL missing_glGlobalAlphaFactordSUN(GLdouble factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "glGlobalAlphaFactordSUN not available." );
}

static void REGAL_CALL loader_glGlobalAlphaFactordSUN(GLdouble factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGlobalAlphaFactordSUN, "glGlobalAlphaFactordSUN");
   if ( !driverTbl.glGlobalAlphaFactordSUN ) {
      driverTbl.glGlobalAlphaFactordSUN = missing_glGlobalAlphaFactordSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGlobalAlphaFactordSUN == loader_glGlobalAlphaFactordSUN) {
      rCtx->dsp->emuTbl.glGlobalAlphaFactordSUN = driverTbl.glGlobalAlphaFactordSUN;
   }
   driverTbl.glGlobalAlphaFactordSUN(factor);
}

static void REGAL_CALL missing_glGlobalAlphaFactorfSUN(GLfloat factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "glGlobalAlphaFactorfSUN not available." );
}

static void REGAL_CALL loader_glGlobalAlphaFactorfSUN(GLfloat factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGlobalAlphaFactorfSUN, "glGlobalAlphaFactorfSUN");
   if ( !driverTbl.glGlobalAlphaFactorfSUN ) {
      driverTbl.glGlobalAlphaFactorfSUN = missing_glGlobalAlphaFactorfSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGlobalAlphaFactorfSUN == loader_glGlobalAlphaFactorfSUN) {
      rCtx->dsp->emuTbl.glGlobalAlphaFactorfSUN = driverTbl.glGlobalAlphaFactorfSUN;
   }
   driverTbl.glGlobalAlphaFactorfSUN(factor);
}

static void REGAL_CALL missing_glGlobalAlphaFactoriSUN(GLint factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "glGlobalAlphaFactoriSUN not available." );
}

static void REGAL_CALL loader_glGlobalAlphaFactoriSUN(GLint factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGlobalAlphaFactoriSUN, "glGlobalAlphaFactoriSUN");
   if ( !driverTbl.glGlobalAlphaFactoriSUN ) {
      driverTbl.glGlobalAlphaFactoriSUN = missing_glGlobalAlphaFactoriSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGlobalAlphaFactoriSUN == loader_glGlobalAlphaFactoriSUN) {
      rCtx->dsp->emuTbl.glGlobalAlphaFactoriSUN = driverTbl.glGlobalAlphaFactoriSUN;
   }
   driverTbl.glGlobalAlphaFactoriSUN(factor);
}

static void REGAL_CALL missing_glGlobalAlphaFactorsSUN(GLshort factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "glGlobalAlphaFactorsSUN not available." );
}

static void REGAL_CALL loader_glGlobalAlphaFactorsSUN(GLshort factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGlobalAlphaFactorsSUN, "glGlobalAlphaFactorsSUN");
   if ( !driverTbl.glGlobalAlphaFactorsSUN ) {
      driverTbl.glGlobalAlphaFactorsSUN = missing_glGlobalAlphaFactorsSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGlobalAlphaFactorsSUN == loader_glGlobalAlphaFactorsSUN) {
      rCtx->dsp->emuTbl.glGlobalAlphaFactorsSUN = driverTbl.glGlobalAlphaFactorsSUN;
   }
   driverTbl.glGlobalAlphaFactorsSUN(factor);
}

static void REGAL_CALL missing_glGlobalAlphaFactorubSUN(GLubyte factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "glGlobalAlphaFactorubSUN not available." );
}

static void REGAL_CALL loader_glGlobalAlphaFactorubSUN(GLubyte factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGlobalAlphaFactorubSUN, "glGlobalAlphaFactorubSUN");
   if ( !driverTbl.glGlobalAlphaFactorubSUN ) {
      driverTbl.glGlobalAlphaFactorubSUN = missing_glGlobalAlphaFactorubSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGlobalAlphaFactorubSUN == loader_glGlobalAlphaFactorubSUN) {
      rCtx->dsp->emuTbl.glGlobalAlphaFactorubSUN = driverTbl.glGlobalAlphaFactorubSUN;
   }
   driverTbl.glGlobalAlphaFactorubSUN(factor);
}

static void REGAL_CALL missing_glGlobalAlphaFactoruiSUN(GLuint factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "glGlobalAlphaFactoruiSUN not available." );
}

static void REGAL_CALL loader_glGlobalAlphaFactoruiSUN(GLuint factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGlobalAlphaFactoruiSUN, "glGlobalAlphaFactoruiSUN");
   if ( !driverTbl.glGlobalAlphaFactoruiSUN ) {
      driverTbl.glGlobalAlphaFactoruiSUN = missing_glGlobalAlphaFactoruiSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGlobalAlphaFactoruiSUN == loader_glGlobalAlphaFactoruiSUN) {
      rCtx->dsp->emuTbl.glGlobalAlphaFactoruiSUN = driverTbl.glGlobalAlphaFactoruiSUN;
   }
   driverTbl.glGlobalAlphaFactoruiSUN(factor);
}

static void REGAL_CALL missing_glGlobalAlphaFactorusSUN(GLushort factor)
{
   UNUSED_PARAMETER(factor);
   Warning( "glGlobalAlphaFactorusSUN not available." );
}

static void REGAL_CALL loader_glGlobalAlphaFactorusSUN(GLushort factor)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glGlobalAlphaFactorusSUN, "glGlobalAlphaFactorusSUN");
   if ( !driverTbl.glGlobalAlphaFactorusSUN ) {
      driverTbl.glGlobalAlphaFactorusSUN = missing_glGlobalAlphaFactorusSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glGlobalAlphaFactorusSUN == loader_glGlobalAlphaFactorusSUN) {
      rCtx->dsp->emuTbl.glGlobalAlphaFactorusSUN = driverTbl.glGlobalAlphaFactorusSUN;
   }
   driverTbl.glGlobalAlphaFactorusSUN(factor);
}

// GL_SUN_mesh_array

static void REGAL_CALL missing_glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width)
{
   UNUSED_PARAMETER(mode);
   UNUSED_PARAMETER(first);
   UNUSED_PARAMETER(count);
   UNUSED_PARAMETER(width);
   Warning( "glDrawMeshArraysSUN not available." );
}

static void REGAL_CALL loader_glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glDrawMeshArraysSUN, "glDrawMeshArraysSUN");
   if ( !driverTbl.glDrawMeshArraysSUN ) {
      driverTbl.glDrawMeshArraysSUN = missing_glDrawMeshArraysSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glDrawMeshArraysSUN == loader_glDrawMeshArraysSUN) {
      rCtx->dsp->emuTbl.glDrawMeshArraysSUN = driverTbl.glDrawMeshArraysSUN;
   }
   driverTbl.glDrawMeshArraysSUN(mode, first, count, width);
}

// GL_SUN_read_video_pixels

static void REGAL_CALL missing_glReadVideoPixelsSUN(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   UNUSED_PARAMETER(format);
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(pixels);
   Warning( "glReadVideoPixelsSUN not available." );
}

static void REGAL_CALL loader_glReadVideoPixelsSUN(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReadVideoPixelsSUN, "glReadVideoPixelsSUN");
   if ( !driverTbl.glReadVideoPixelsSUN ) {
      driverTbl.glReadVideoPixelsSUN = missing_glReadVideoPixelsSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReadVideoPixelsSUN == loader_glReadVideoPixelsSUN) {
      rCtx->dsp->emuTbl.glReadVideoPixelsSUN = driverTbl.glReadVideoPixelsSUN;
   }
   driverTbl.glReadVideoPixelsSUN(x, y, width, height, format, type, pixels);
}

// GL_SUN_triangle_list

static void REGAL_CALL missing_glReplacementCodePointerSUN(GLenum type, GLsizei stride, const GLvoid **pointer)
{
   UNUSED_PARAMETER(type);
   UNUSED_PARAMETER(stride);
   UNUSED_PARAMETER(pointer);
   Warning( "glReplacementCodePointerSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodePointerSUN(GLenum type, GLsizei stride, const GLvoid **pointer)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodePointerSUN, "glReplacementCodePointerSUN");
   if ( !driverTbl.glReplacementCodePointerSUN ) {
      driverTbl.glReplacementCodePointerSUN = missing_glReplacementCodePointerSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodePointerSUN == loader_glReplacementCodePointerSUN) {
      rCtx->dsp->emuTbl.glReplacementCodePointerSUN = driverTbl.glReplacementCodePointerSUN;
   }
   driverTbl.glReplacementCodePointerSUN(type, stride, pointer);
}

static void REGAL_CALL missing_glReplacementCodeubSUN(GLubyte code)
{
   UNUSED_PARAMETER(code);
   Warning( "glReplacementCodeubSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeubSUN(GLubyte code)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeubSUN, "glReplacementCodeubSUN");
   if ( !driverTbl.glReplacementCodeubSUN ) {
      driverTbl.glReplacementCodeubSUN = missing_glReplacementCodeubSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeubSUN == loader_glReplacementCodeubSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeubSUN = driverTbl.glReplacementCodeubSUN;
   }
   driverTbl.glReplacementCodeubSUN(code);
}

static void REGAL_CALL missing_glReplacementCodeubvSUN(const GLubyte *code)
{
   UNUSED_PARAMETER(code);
   Warning( "glReplacementCodeubvSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeubvSUN(const GLubyte *code)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeubvSUN, "glReplacementCodeubvSUN");
   if ( !driverTbl.glReplacementCodeubvSUN ) {
      driverTbl.glReplacementCodeubvSUN = missing_glReplacementCodeubvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeubvSUN == loader_glReplacementCodeubvSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeubvSUN = driverTbl.glReplacementCodeubvSUN;
   }
   driverTbl.glReplacementCodeubvSUN(code);
}

static void REGAL_CALL missing_glReplacementCodeuiSUN(GLuint code)
{
   UNUSED_PARAMETER(code);
   Warning( "glReplacementCodeuiSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiSUN(GLuint code)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiSUN, "glReplacementCodeuiSUN");
   if ( !driverTbl.glReplacementCodeuiSUN ) {
      driverTbl.glReplacementCodeuiSUN = missing_glReplacementCodeuiSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiSUN == loader_glReplacementCodeuiSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiSUN = driverTbl.glReplacementCodeuiSUN;
   }
   driverTbl.glReplacementCodeuiSUN(code);
}

static void REGAL_CALL missing_glReplacementCodeuivSUN(const GLuint *code)
{
   UNUSED_PARAMETER(code);
   Warning( "glReplacementCodeuivSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuivSUN(const GLuint *code)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuivSUN, "glReplacementCodeuivSUN");
   if ( !driverTbl.glReplacementCodeuivSUN ) {
      driverTbl.glReplacementCodeuivSUN = missing_glReplacementCodeuivSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuivSUN == loader_glReplacementCodeuivSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuivSUN = driverTbl.glReplacementCodeuivSUN;
   }
   driverTbl.glReplacementCodeuivSUN(code);
}

static void REGAL_CALL missing_glReplacementCodeusSUN(GLushort code)
{
   UNUSED_PARAMETER(code);
   Warning( "glReplacementCodeusSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeusSUN(GLushort code)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeusSUN, "glReplacementCodeusSUN");
   if ( !driverTbl.glReplacementCodeusSUN ) {
      driverTbl.glReplacementCodeusSUN = missing_glReplacementCodeusSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeusSUN == loader_glReplacementCodeusSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeusSUN = driverTbl.glReplacementCodeusSUN;
   }
   driverTbl.glReplacementCodeusSUN(code);
}

static void REGAL_CALL missing_glReplacementCodeusvSUN(const GLushort *code)
{
   UNUSED_PARAMETER(code);
   Warning( "glReplacementCodeusvSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeusvSUN(const GLushort *code)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeusvSUN, "glReplacementCodeusvSUN");
   if ( !driverTbl.glReplacementCodeusvSUN ) {
      driverTbl.glReplacementCodeusvSUN = missing_glReplacementCodeusvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeusvSUN == loader_glReplacementCodeusvSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeusvSUN = driverTbl.glReplacementCodeusvSUN;
   }
   driverTbl.glReplacementCodeusvSUN(code);
}

// GL_SUN_vertex

static void REGAL_CALL missing_glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glColor3fVertex3fSUN not available." );
}

static void REGAL_CALL loader_glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3fVertex3fSUN, "glColor3fVertex3fSUN");
   if ( !driverTbl.glColor3fVertex3fSUN ) {
      driverTbl.glColor3fVertex3fSUN = missing_glColor3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3fVertex3fSUN == loader_glColor3fVertex3fSUN) {
      rCtx->dsp->emuTbl.glColor3fVertex3fSUN = driverTbl.glColor3fVertex3fSUN;
   }
   driverTbl.glColor3fVertex3fSUN(r, g, b, x, y, z);
}

static void REGAL_CALL missing_glColor3fVertex3fvSUN(const GLfloat *c, const GLfloat *v)
{
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(v);
   Warning( "glColor3fVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glColor3fVertex3fvSUN(const GLfloat *c, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor3fVertex3fvSUN, "glColor3fVertex3fvSUN");
   if ( !driverTbl.glColor3fVertex3fvSUN ) {
      driverTbl.glColor3fVertex3fvSUN = missing_glColor3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor3fVertex3fvSUN == loader_glColor3fVertex3fvSUN) {
      rCtx->dsp->emuTbl.glColor3fVertex3fvSUN = driverTbl.glColor3fVertex3fvSUN;
   }
   driverTbl.glColor3fVertex3fvSUN(c, v);
}

static void REGAL_CALL missing_glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glColor4fNormal3fVertex3fSUN not available." );
}

static void REGAL_CALL loader_glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4fNormal3fVertex3fSUN, "glColor4fNormal3fVertex3fSUN");
   if ( !driverTbl.glColor4fNormal3fVertex3fSUN ) {
      driverTbl.glColor4fNormal3fVertex3fSUN = missing_glColor4fNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4fNormal3fVertex3fSUN == loader_glColor4fNormal3fVertex3fSUN) {
      rCtx->dsp->emuTbl.glColor4fNormal3fVertex3fSUN = driverTbl.glColor4fNormal3fVertex3fSUN;
   }
   driverTbl.glColor4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glColor4fNormal3fVertex3fvSUN(const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glColor4fNormal3fVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glColor4fNormal3fVertex3fvSUN(const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4fNormal3fVertex3fvSUN, "glColor4fNormal3fVertex3fvSUN");
   if ( !driverTbl.glColor4fNormal3fVertex3fvSUN ) {
      driverTbl.glColor4fNormal3fVertex3fvSUN = missing_glColor4fNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4fNormal3fVertex3fvSUN == loader_glColor4fNormal3fVertex3fvSUN) {
      rCtx->dsp->emuTbl.glColor4fNormal3fVertex3fvSUN = driverTbl.glColor4fNormal3fVertex3fvSUN;
   }
   driverTbl.glColor4fNormal3fVertex3fvSUN(c, n, v);
}

static void REGAL_CALL missing_glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y)
{
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   Warning( "glColor4ubVertex2fSUN not available." );
}

static void REGAL_CALL loader_glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4ubVertex2fSUN, "glColor4ubVertex2fSUN");
   if ( !driverTbl.glColor4ubVertex2fSUN ) {
      driverTbl.glColor4ubVertex2fSUN = missing_glColor4ubVertex2fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4ubVertex2fSUN == loader_glColor4ubVertex2fSUN) {
      rCtx->dsp->emuTbl.glColor4ubVertex2fSUN = driverTbl.glColor4ubVertex2fSUN;
   }
   driverTbl.glColor4ubVertex2fSUN(r, g, b, a, x, y);
}

static void REGAL_CALL missing_glColor4ubVertex2fvSUN(const GLubyte *c, const GLfloat *v)
{
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(v);
   Warning( "glColor4ubVertex2fvSUN not available." );
}

static void REGAL_CALL loader_glColor4ubVertex2fvSUN(const GLubyte *c, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4ubVertex2fvSUN, "glColor4ubVertex2fvSUN");
   if ( !driverTbl.glColor4ubVertex2fvSUN ) {
      driverTbl.glColor4ubVertex2fvSUN = missing_glColor4ubVertex2fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4ubVertex2fvSUN == loader_glColor4ubVertex2fvSUN) {
      rCtx->dsp->emuTbl.glColor4ubVertex2fvSUN = driverTbl.glColor4ubVertex2fvSUN;
   }
   driverTbl.glColor4ubVertex2fvSUN(c, v);
}

static void REGAL_CALL missing_glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glColor4ubVertex3fSUN not available." );
}

static void REGAL_CALL loader_glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4ubVertex3fSUN, "glColor4ubVertex3fSUN");
   if ( !driverTbl.glColor4ubVertex3fSUN ) {
      driverTbl.glColor4ubVertex3fSUN = missing_glColor4ubVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4ubVertex3fSUN == loader_glColor4ubVertex3fSUN) {
      rCtx->dsp->emuTbl.glColor4ubVertex3fSUN = driverTbl.glColor4ubVertex3fSUN;
   }
   driverTbl.glColor4ubVertex3fSUN(r, g, b, a, x, y, z);
}

static void REGAL_CALL missing_glColor4ubVertex3fvSUN(const GLubyte *c, const GLfloat *v)
{
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(v);
   Warning( "glColor4ubVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glColor4ubVertex3fvSUN(const GLubyte *c, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glColor4ubVertex3fvSUN, "glColor4ubVertex3fvSUN");
   if ( !driverTbl.glColor4ubVertex3fvSUN ) {
      driverTbl.glColor4ubVertex3fvSUN = missing_glColor4ubVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glColor4ubVertex3fvSUN == loader_glColor4ubVertex3fvSUN) {
      rCtx->dsp->emuTbl.glColor4ubVertex3fvSUN = driverTbl.glColor4ubVertex3fvSUN;
   }
   driverTbl.glColor4ubVertex3fvSUN(c, v);
}

static void REGAL_CALL missing_glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glNormal3fVertex3fSUN not available." );
}

static void REGAL_CALL loader_glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormal3fVertex3fSUN, "glNormal3fVertex3fSUN");
   if ( !driverTbl.glNormal3fVertex3fSUN ) {
      driverTbl.glNormal3fVertex3fSUN = missing_glNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormal3fVertex3fSUN == loader_glNormal3fVertex3fSUN) {
      rCtx->dsp->emuTbl.glNormal3fVertex3fSUN = driverTbl.glNormal3fVertex3fSUN;
   }
   driverTbl.glNormal3fVertex3fSUN(nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glNormal3fVertex3fvSUN(const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glNormal3fVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glNormal3fVertex3fvSUN(const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glNormal3fVertex3fvSUN, "glNormal3fVertex3fvSUN");
   if ( !driverTbl.glNormal3fVertex3fvSUN ) {
      driverTbl.glNormal3fVertex3fvSUN = missing_glNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glNormal3fVertex3fvSUN == loader_glNormal3fVertex3fvSUN) {
      rCtx->dsp->emuTbl.glNormal3fVertex3fvSUN = driverTbl.glNormal3fVertex3fvSUN;
   }
   driverTbl.glNormal3fVertex3fvSUN(n, v);
}

static void REGAL_CALL missing_glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glReplacementCodeuiColor3fVertex3fSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiColor3fVertex3fSUN, "glReplacementCodeuiColor3fVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiColor3fVertex3fSUN ) {
      driverTbl.glReplacementCodeuiColor3fVertex3fSUN = missing_glReplacementCodeuiColor3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiColor3fVertex3fSUN == loader_glReplacementCodeuiColor3fVertex3fSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiColor3fVertex3fSUN = driverTbl.glReplacementCodeuiColor3fVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiColor3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(v);
   Warning( "glReplacementCodeuiColor3fVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiColor3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiColor3fVertex3fvSUN, "glReplacementCodeuiColor3fVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiColor3fVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiColor3fVertex3fvSUN = missing_glReplacementCodeuiColor3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiColor3fVertex3fvSUN == loader_glReplacementCodeuiColor3fVertex3fvSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiColor3fVertex3fvSUN = driverTbl.glReplacementCodeuiColor3fVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiColor3fVertex3fvSUN(rc, c, v);
}

static void REGAL_CALL missing_glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glReplacementCodeuiColor4fNormal3fVertex3fSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN, "glReplacementCodeuiColor4fNormal3fVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN ) {
      driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN = missing_glReplacementCodeuiColor4fNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN == loader_glReplacementCodeuiColor4fNormal3fVertex3fSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN = driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glReplacementCodeuiColor4fNormal3fVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN, "glReplacementCodeuiColor4fNormal3fVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN = missing_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN == loader_glReplacementCodeuiColor4fNormal3fVertex3fvSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN = driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v);
}

static void REGAL_CALL missing_glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glReplacementCodeuiColor4ubVertex3fSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiColor4ubVertex3fSUN, "glReplacementCodeuiColor4ubVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiColor4ubVertex3fSUN ) {
      driverTbl.glReplacementCodeuiColor4ubVertex3fSUN = missing_glReplacementCodeuiColor4ubVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiColor4ubVertex3fSUN == loader_glReplacementCodeuiColor4ubVertex3fSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiColor4ubVertex3fSUN = driverTbl.glReplacementCodeuiColor4ubVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint *rc, const GLubyte *c, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(v);
   Warning( "glReplacementCodeuiColor4ubVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint *rc, const GLubyte *c, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiColor4ubVertex3fvSUN, "glReplacementCodeuiColor4ubVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiColor4ubVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiColor4ubVertex3fvSUN = missing_glReplacementCodeuiColor4ubVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiColor4ubVertex3fvSUN == loader_glReplacementCodeuiColor4ubVertex3fvSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiColor4ubVertex3fvSUN = driverTbl.glReplacementCodeuiColor4ubVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v);
}

static void REGAL_CALL missing_glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glReplacementCodeuiNormal3fVertex3fSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiNormal3fVertex3fSUN, "glReplacementCodeuiNormal3fVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiNormal3fVertex3fSUN ) {
      driverTbl.glReplacementCodeuiNormal3fVertex3fSUN = missing_glReplacementCodeuiNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiNormal3fVertex3fSUN == loader_glReplacementCodeuiNormal3fVertex3fSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiNormal3fVertex3fSUN = driverTbl.glReplacementCodeuiNormal3fVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glReplacementCodeuiNormal3fVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiNormal3fVertex3fvSUN, "glReplacementCodeuiNormal3fVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiNormal3fVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiNormal3fVertex3fvSUN = missing_glReplacementCodeuiNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiNormal3fVertex3fvSUN == loader_glReplacementCodeuiNormal3fVertex3fvSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiNormal3fVertex3fvSUN = driverTbl.glReplacementCodeuiNormal3fVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v);
}

static void REGAL_CALL missing_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN, "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN ) {
      driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = missing_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN == loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN, "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = missing_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN == loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v);
}

static void REGAL_CALL missing_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN, "glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN ) {
      driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = missing_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN == loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN, "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = missing_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN == loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v);
}

static void REGAL_CALL missing_glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glReplacementCodeuiTexCoord2fVertex3fSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiTexCoord2fVertex3fSUN, "glReplacementCodeuiTexCoord2fVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiTexCoord2fVertex3fSUN ) {
      driverTbl.glReplacementCodeuiTexCoord2fVertex3fSUN = missing_glReplacementCodeuiTexCoord2fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiTexCoord2fVertex3fSUN == loader_glReplacementCodeuiTexCoord2fVertex3fSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiTexCoord2fVertex3fSUN = driverTbl.glReplacementCodeuiTexCoord2fVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(v);
   Warning( "glReplacementCodeuiTexCoord2fVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiTexCoord2fVertex3fvSUN, "glReplacementCodeuiTexCoord2fVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiTexCoord2fVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiTexCoord2fVertex3fvSUN = missing_glReplacementCodeuiTexCoord2fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiTexCoord2fVertex3fvSUN == loader_glReplacementCodeuiTexCoord2fVertex3fvSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiTexCoord2fVertex3fvSUN = driverTbl.glReplacementCodeuiTexCoord2fVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v);
}

static void REGAL_CALL missing_glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glReplacementCodeuiVertex3fSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiVertex3fSUN, "glReplacementCodeuiVertex3fSUN");
   if ( !driverTbl.glReplacementCodeuiVertex3fSUN ) {
      driverTbl.glReplacementCodeuiVertex3fSUN = missing_glReplacementCodeuiVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiVertex3fSUN == loader_glReplacementCodeuiVertex3fSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiVertex3fSUN = driverTbl.glReplacementCodeuiVertex3fSUN;
   }
   driverTbl.glReplacementCodeuiVertex3fSUN(rc, x, y, z);
}

static void REGAL_CALL missing_glReplacementCodeuiVertex3fvSUN(const GLuint *rc, const GLfloat *v)
{
   UNUSED_PARAMETER(rc);
   UNUSED_PARAMETER(v);
   Warning( "glReplacementCodeuiVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glReplacementCodeuiVertex3fvSUN(const GLuint *rc, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glReplacementCodeuiVertex3fvSUN, "glReplacementCodeuiVertex3fvSUN");
   if ( !driverTbl.glReplacementCodeuiVertex3fvSUN ) {
      driverTbl.glReplacementCodeuiVertex3fvSUN = missing_glReplacementCodeuiVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glReplacementCodeuiVertex3fvSUN == loader_glReplacementCodeuiVertex3fvSUN) {
      rCtx->dsp->emuTbl.glReplacementCodeuiVertex3fvSUN = driverTbl.glReplacementCodeuiVertex3fvSUN;
   }
   driverTbl.glReplacementCodeuiVertex3fvSUN(rc, v);
}

static void REGAL_CALL missing_glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glTexCoord2fColor3fVertex3fSUN not available." );
}

static void REGAL_CALL loader_glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2fColor3fVertex3fSUN, "glTexCoord2fColor3fVertex3fSUN");
   if ( !driverTbl.glTexCoord2fColor3fVertex3fSUN ) {
      driverTbl.glTexCoord2fColor3fVertex3fSUN = missing_glTexCoord2fColor3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2fColor3fVertex3fSUN == loader_glTexCoord2fColor3fVertex3fSUN) {
      rCtx->dsp->emuTbl.glTexCoord2fColor3fVertex3fSUN = driverTbl.glTexCoord2fColor3fVertex3fSUN;
   }
   driverTbl.glTexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);
}

static void REGAL_CALL missing_glTexCoord2fColor3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *v)
{
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord2fColor3fVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glTexCoord2fColor3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2fColor3fVertex3fvSUN, "glTexCoord2fColor3fVertex3fvSUN");
   if ( !driverTbl.glTexCoord2fColor3fVertex3fvSUN ) {
      driverTbl.glTexCoord2fColor3fVertex3fvSUN = missing_glTexCoord2fColor3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2fColor3fVertex3fvSUN == loader_glTexCoord2fColor3fVertex3fvSUN) {
      rCtx->dsp->emuTbl.glTexCoord2fColor3fVertex3fvSUN = driverTbl.glTexCoord2fColor3fVertex3fvSUN;
   }
   driverTbl.glTexCoord2fColor3fVertex3fvSUN(tc, c, v);
}

static void REGAL_CALL missing_glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glTexCoord2fColor4fNormal3fVertex3fSUN not available." );
}

static void REGAL_CALL loader_glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2fColor4fNormal3fVertex3fSUN, "glTexCoord2fColor4fNormal3fVertex3fSUN");
   if ( !driverTbl.glTexCoord2fColor4fNormal3fVertex3fSUN ) {
      driverTbl.glTexCoord2fColor4fNormal3fVertex3fSUN = missing_glTexCoord2fColor4fNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2fColor4fNormal3fVertex3fSUN == loader_glTexCoord2fColor4fNormal3fVertex3fSUN) {
      rCtx->dsp->emuTbl.glTexCoord2fColor4fNormal3fVertex3fSUN = driverTbl.glTexCoord2fColor4fNormal3fVertex3fSUN;
   }
   driverTbl.glTexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord2fColor4fNormal3fVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2fColor4fNormal3fVertex3fvSUN, "glTexCoord2fColor4fNormal3fVertex3fvSUN");
   if ( !driverTbl.glTexCoord2fColor4fNormal3fVertex3fvSUN ) {
      driverTbl.glTexCoord2fColor4fNormal3fVertex3fvSUN = missing_glTexCoord2fColor4fNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2fColor4fNormal3fVertex3fvSUN == loader_glTexCoord2fColor4fNormal3fVertex3fvSUN) {
      rCtx->dsp->emuTbl.glTexCoord2fColor4fNormal3fVertex3fvSUN = driverTbl.glTexCoord2fColor4fNormal3fVertex3fvSUN;
   }
   driverTbl.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v);
}

static void REGAL_CALL missing_glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glTexCoord2fColor4ubVertex3fSUN not available." );
}

static void REGAL_CALL loader_glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2fColor4ubVertex3fSUN, "glTexCoord2fColor4ubVertex3fSUN");
   if ( !driverTbl.glTexCoord2fColor4ubVertex3fSUN ) {
      driverTbl.glTexCoord2fColor4ubVertex3fSUN = missing_glTexCoord2fColor4ubVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2fColor4ubVertex3fSUN == loader_glTexCoord2fColor4ubVertex3fSUN) {
      rCtx->dsp->emuTbl.glTexCoord2fColor4ubVertex3fSUN = driverTbl.glTexCoord2fColor4ubVertex3fSUN;
   }
   driverTbl.glTexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);
}

static void REGAL_CALL missing_glTexCoord2fColor4ubVertex3fvSUN(const GLfloat *tc, const GLubyte *c, const GLfloat *v)
{
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord2fColor4ubVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glTexCoord2fColor4ubVertex3fvSUN(const GLfloat *tc, const GLubyte *c, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2fColor4ubVertex3fvSUN, "glTexCoord2fColor4ubVertex3fvSUN");
   if ( !driverTbl.glTexCoord2fColor4ubVertex3fvSUN ) {
      driverTbl.glTexCoord2fColor4ubVertex3fvSUN = missing_glTexCoord2fColor4ubVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2fColor4ubVertex3fvSUN == loader_glTexCoord2fColor4ubVertex3fvSUN) {
      rCtx->dsp->emuTbl.glTexCoord2fColor4ubVertex3fvSUN = driverTbl.glTexCoord2fColor4ubVertex3fvSUN;
   }
   driverTbl.glTexCoord2fColor4ubVertex3fvSUN(tc, c, v);
}

static void REGAL_CALL missing_glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glTexCoord2fNormal3fVertex3fSUN not available." );
}

static void REGAL_CALL loader_glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2fNormal3fVertex3fSUN, "glTexCoord2fNormal3fVertex3fSUN");
   if ( !driverTbl.glTexCoord2fNormal3fVertex3fSUN ) {
      driverTbl.glTexCoord2fNormal3fVertex3fSUN = missing_glTexCoord2fNormal3fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2fNormal3fVertex3fSUN == loader_glTexCoord2fNormal3fVertex3fSUN) {
      rCtx->dsp->emuTbl.glTexCoord2fNormal3fVertex3fSUN = driverTbl.glTexCoord2fNormal3fVertex3fSUN;
   }
   driverTbl.glTexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);
}

static void REGAL_CALL missing_glTexCoord2fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord2fNormal3fVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glTexCoord2fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2fNormal3fVertex3fvSUN, "glTexCoord2fNormal3fVertex3fvSUN");
   if ( !driverTbl.glTexCoord2fNormal3fVertex3fvSUN ) {
      driverTbl.glTexCoord2fNormal3fVertex3fvSUN = missing_glTexCoord2fNormal3fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2fNormal3fVertex3fvSUN == loader_glTexCoord2fNormal3fVertex3fvSUN) {
      rCtx->dsp->emuTbl.glTexCoord2fNormal3fVertex3fvSUN = driverTbl.glTexCoord2fNormal3fVertex3fvSUN;
   }
   driverTbl.glTexCoord2fNormal3fVertex3fvSUN(tc, n, v);
}

static void REGAL_CALL missing_glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   Warning( "glTexCoord2fVertex3fSUN not available." );
}

static void REGAL_CALL loader_glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2fVertex3fSUN, "glTexCoord2fVertex3fSUN");
   if ( !driverTbl.glTexCoord2fVertex3fSUN ) {
      driverTbl.glTexCoord2fVertex3fSUN = missing_glTexCoord2fVertex3fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2fVertex3fSUN == loader_glTexCoord2fVertex3fSUN) {
      rCtx->dsp->emuTbl.glTexCoord2fVertex3fSUN = driverTbl.glTexCoord2fVertex3fSUN;
   }
   driverTbl.glTexCoord2fVertex3fSUN(s, t, x, y, z);
}

static void REGAL_CALL missing_glTexCoord2fVertex3fvSUN(const GLfloat *tc, const GLfloat *v)
{
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord2fVertex3fvSUN not available." );
}

static void REGAL_CALL loader_glTexCoord2fVertex3fvSUN(const GLfloat *tc, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord2fVertex3fvSUN, "glTexCoord2fVertex3fvSUN");
   if ( !driverTbl.glTexCoord2fVertex3fvSUN ) {
      driverTbl.glTexCoord2fVertex3fvSUN = missing_glTexCoord2fVertex3fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord2fVertex3fvSUN == loader_glTexCoord2fVertex3fvSUN) {
      rCtx->dsp->emuTbl.glTexCoord2fVertex3fvSUN = driverTbl.glTexCoord2fVertex3fvSUN;
   }
   driverTbl.glTexCoord2fVertex3fvSUN(tc, v);
}

static void REGAL_CALL missing_glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(p);
   UNUSED_PARAMETER(q);
   UNUSED_PARAMETER(r);
   UNUSED_PARAMETER(g);
   UNUSED_PARAMETER(b);
   UNUSED_PARAMETER(a);
   UNUSED_PARAMETER(nx);
   UNUSED_PARAMETER(ny);
   UNUSED_PARAMETER(nz);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glTexCoord4fColor4fNormal3fVertex4fSUN not available." );
}

static void REGAL_CALL loader_glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord4fColor4fNormal3fVertex4fSUN, "glTexCoord4fColor4fNormal3fVertex4fSUN");
   if ( !driverTbl.glTexCoord4fColor4fNormal3fVertex4fSUN ) {
      driverTbl.glTexCoord4fColor4fNormal3fVertex4fSUN = missing_glTexCoord4fColor4fNormal3fVertex4fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord4fColor4fNormal3fVertex4fSUN == loader_glTexCoord4fColor4fNormal3fVertex4fSUN) {
      rCtx->dsp->emuTbl.glTexCoord4fColor4fNormal3fVertex4fSUN = driverTbl.glTexCoord4fColor4fNormal3fVertex4fSUN;
   }
   driverTbl.glTexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
}

static void REGAL_CALL missing_glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(c);
   UNUSED_PARAMETER(n);
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord4fColor4fNormal3fVertex4fvSUN not available." );
}

static void REGAL_CALL loader_glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord4fColor4fNormal3fVertex4fvSUN, "glTexCoord4fColor4fNormal3fVertex4fvSUN");
   if ( !driverTbl.glTexCoord4fColor4fNormal3fVertex4fvSUN ) {
      driverTbl.glTexCoord4fColor4fNormal3fVertex4fvSUN = missing_glTexCoord4fColor4fNormal3fVertex4fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord4fColor4fNormal3fVertex4fvSUN == loader_glTexCoord4fColor4fNormal3fVertex4fvSUN) {
      rCtx->dsp->emuTbl.glTexCoord4fColor4fNormal3fVertex4fvSUN = driverTbl.glTexCoord4fColor4fNormal3fVertex4fvSUN;
   }
   driverTbl.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v);
}

static void REGAL_CALL missing_glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   UNUSED_PARAMETER(s);
   UNUSED_PARAMETER(t);
   UNUSED_PARAMETER(p);
   UNUSED_PARAMETER(q);
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(z);
   UNUSED_PARAMETER(w);
   Warning( "glTexCoord4fVertex4fSUN not available." );
}

static void REGAL_CALL loader_glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord4fVertex4fSUN, "glTexCoord4fVertex4fSUN");
   if ( !driverTbl.glTexCoord4fVertex4fSUN ) {
      driverTbl.glTexCoord4fVertex4fSUN = missing_glTexCoord4fVertex4fSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord4fVertex4fSUN == loader_glTexCoord4fVertex4fSUN) {
      rCtx->dsp->emuTbl.glTexCoord4fVertex4fSUN = driverTbl.glTexCoord4fVertex4fSUN;
   }
   driverTbl.glTexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);
}

static void REGAL_CALL missing_glTexCoord4fVertex4fvSUN(const GLfloat *tc, const GLfloat *v)
{
   UNUSED_PARAMETER(tc);
   UNUSED_PARAMETER(v);
   Warning( "glTexCoord4fVertex4fvSUN not available." );
}

static void REGAL_CALL loader_glTexCoord4fVertex4fvSUN(const GLfloat *tc, const GLfloat *v)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glTexCoord4fVertex4fvSUN, "glTexCoord4fVertex4fvSUN");
   if ( !driverTbl.glTexCoord4fVertex4fvSUN ) {
      driverTbl.glTexCoord4fVertex4fvSUN = missing_glTexCoord4fVertex4fvSUN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glTexCoord4fVertex4fvSUN == loader_glTexCoord4fVertex4fvSUN) {
      rCtx->dsp->emuTbl.glTexCoord4fVertex4fvSUN = driverTbl.glTexCoord4fVertex4fvSUN;
   }
   driverTbl.glTexCoord4fVertex4fvSUN(tc, v);
}

// GL_WIN_swap_hint

static void REGAL_CALL missing_glAddSwapHintRectWIN(GLint x, GLint y, GLsizei width, GLsizei height)
{
   UNUSED_PARAMETER(x);
   UNUSED_PARAMETER(y);
   UNUSED_PARAMETER(width);
   UNUSED_PARAMETER(height);
   Warning( "glAddSwapHintRectWIN not available." );
}

static void REGAL_CALL loader_glAddSwapHintRectWIN(GLint x, GLint y, GLsizei width, GLsizei height)
{
   RegalContext * rCtx = GET_REGAL_CONTEXT();
   RegalAssert(rCtx);
   RegalAssert(rCtx->dsp);
   DispatchTable & driverTbl = rCtx->dsp->driverTbl;
   GetProcAddress( driverTbl.glAddSwapHintRectWIN, "glAddSwapHintRectWIN");
   if ( !driverTbl.glAddSwapHintRectWIN ) {
      driverTbl.glAddSwapHintRectWIN = missing_glAddSwapHintRectWIN;
   }
   // If emu table is using the loader, update its entry too.
   if (rCtx->dsp->emuTbl.glAddSwapHintRectWIN == loader_glAddSwapHintRectWIN) {
      rCtx->dsp->emuTbl.glAddSwapHintRectWIN = driverTbl.glAddSwapHintRectWIN;
   }
   driverTbl.glAddSwapHintRectWIN(x, y, width, height);
}

void InitDispatchTableLoader(DispatchTable &tbl)
{

  // GL_VERSION_1_0

  tbl.glAccum = loader_glAccum;
  tbl.glAlphaFunc = loader_glAlphaFunc;
  tbl.glBegin = loader_glBegin;
  tbl.glBitmap = loader_glBitmap;
  tbl.glBlendFunc = loader_glBlendFunc;
  tbl.glCallList = loader_glCallList;
  tbl.glCallLists = loader_glCallLists;
  tbl.glClear = loader_glClear;
  tbl.glClearAccum = loader_glClearAccum;
  tbl.glClearColor = loader_glClearColor;
  tbl.glClearDepth = loader_glClearDepth;
  tbl.glClearIndex = loader_glClearIndex;
  tbl.glClearStencil = loader_glClearStencil;
  tbl.glClipPlane = loader_glClipPlane;
  tbl.glColor3b = loader_glColor3b;
  tbl.glColor3bv = loader_glColor3bv;
  tbl.glColor3d = loader_glColor3d;
  tbl.glColor3dv = loader_glColor3dv;
  tbl.glColor3f = loader_glColor3f;
  tbl.glColor3fv = loader_glColor3fv;
  tbl.glColor3i = loader_glColor3i;
  tbl.glColor3iv = loader_glColor3iv;
  tbl.glColor3s = loader_glColor3s;
  tbl.glColor3sv = loader_glColor3sv;
  tbl.glColor3ub = loader_glColor3ub;
  tbl.glColor3ubv = loader_glColor3ubv;
  tbl.glColor3ui = loader_glColor3ui;
  tbl.glColor3uiv = loader_glColor3uiv;
  tbl.glColor3us = loader_glColor3us;
  tbl.glColor3usv = loader_glColor3usv;
  tbl.glColor4b = loader_glColor4b;
  tbl.glColor4bv = loader_glColor4bv;
  tbl.glColor4d = loader_glColor4d;
  tbl.glColor4dv = loader_glColor4dv;
  tbl.glColor4f = loader_glColor4f;
  tbl.glColor4fv = loader_glColor4fv;
  tbl.glColor4i = loader_glColor4i;
  tbl.glColor4iv = loader_glColor4iv;
  tbl.glColor4s = loader_glColor4s;
  tbl.glColor4sv = loader_glColor4sv;
  tbl.glColor4ub = loader_glColor4ub;
  tbl.glColor4ubv = loader_glColor4ubv;
  tbl.glColor4ui = loader_glColor4ui;
  tbl.glColor4uiv = loader_glColor4uiv;
  tbl.glColor4us = loader_glColor4us;
  tbl.glColor4usv = loader_glColor4usv;
  tbl.glColorMask = loader_glColorMask;
  tbl.glColorMaterial = loader_glColorMaterial;
  tbl.glCopyPixels = loader_glCopyPixels;
  tbl.glCullFace = loader_glCullFace;
  tbl.glDeleteLists = loader_glDeleteLists;
  tbl.glDepthFunc = loader_glDepthFunc;
  tbl.glDepthMask = loader_glDepthMask;
  tbl.glDepthRange = loader_glDepthRange;
  tbl.glDisable = loader_glDisable;
  tbl.glDrawBuffer = loader_glDrawBuffer;
  tbl.glDrawPixels = loader_glDrawPixels;
  tbl.glEdgeFlag = loader_glEdgeFlag;
  tbl.glEdgeFlagv = loader_glEdgeFlagv;
  tbl.glEnable = loader_glEnable;
  tbl.glEnd = loader_glEnd;
  tbl.glEndList = loader_glEndList;
  tbl.glEvalCoord1d = loader_glEvalCoord1d;
  tbl.glEvalCoord1dv = loader_glEvalCoord1dv;
  tbl.glEvalCoord1f = loader_glEvalCoord1f;
  tbl.glEvalCoord1fv = loader_glEvalCoord1fv;
  tbl.glEvalCoord2d = loader_glEvalCoord2d;
  tbl.glEvalCoord2dv = loader_glEvalCoord2dv;
  tbl.glEvalCoord2f = loader_glEvalCoord2f;
  tbl.glEvalCoord2fv = loader_glEvalCoord2fv;
  tbl.glEvalMesh1 = loader_glEvalMesh1;
  tbl.glEvalMesh2 = loader_glEvalMesh2;
  tbl.glEvalPoint1 = loader_glEvalPoint1;
  tbl.glEvalPoint2 = loader_glEvalPoint2;
  tbl.glFeedbackBuffer = loader_glFeedbackBuffer;
  tbl.glFinish = loader_glFinish;
  tbl.glFlush = loader_glFlush;
  tbl.glFogf = loader_glFogf;
  tbl.glFogfv = loader_glFogfv;
  tbl.glFogi = loader_glFogi;
  tbl.glFogiv = loader_glFogiv;
  tbl.glFrontFace = loader_glFrontFace;
  tbl.glFrustum = loader_glFrustum;
  tbl.glGenLists = loader_glGenLists;
  tbl.glGetBooleanv = loader_glGetBooleanv;
  tbl.glGetClipPlane = loader_glGetClipPlane;
  tbl.glGetDoublev = loader_glGetDoublev;
  tbl.glGetError = loader_glGetError;
  tbl.glGetFloatv = loader_glGetFloatv;
  tbl.glGetIntegerv = loader_glGetIntegerv;
  tbl.glGetLightfv = loader_glGetLightfv;
  tbl.glGetLightiv = loader_glGetLightiv;
  tbl.glGetMapdv = loader_glGetMapdv;
  tbl.glGetMapfv = loader_glGetMapfv;
  tbl.glGetMapiv = loader_glGetMapiv;
  tbl.glGetMaterialfv = loader_glGetMaterialfv;
  tbl.glGetMaterialiv = loader_glGetMaterialiv;
  tbl.glGetPixelMapfv = loader_glGetPixelMapfv;
  tbl.glGetPixelMapuiv = loader_glGetPixelMapuiv;
  tbl.glGetPixelMapusv = loader_glGetPixelMapusv;
  tbl.glGetPolygonStipple = loader_glGetPolygonStipple;
  tbl.glGetString = loader_glGetString;
  tbl.glGetTexEnvfv = loader_glGetTexEnvfv;
  tbl.glGetTexEnviv = loader_glGetTexEnviv;
  tbl.glGetTexGendv = loader_glGetTexGendv;
  tbl.glGetTexGenfv = loader_glGetTexGenfv;
  tbl.glGetTexGeniv = loader_glGetTexGeniv;
  tbl.glGetTexImage = loader_glGetTexImage;
  tbl.glGetTexLevelParameterfv = loader_glGetTexLevelParameterfv;
  tbl.glGetTexLevelParameteriv = loader_glGetTexLevelParameteriv;
  tbl.glGetTexParameterfv = loader_glGetTexParameterfv;
  tbl.glGetTexParameteriv = loader_glGetTexParameteriv;
  tbl.glHint = loader_glHint;
  tbl.glIndexMask = loader_glIndexMask;
  tbl.glIndexd = loader_glIndexd;
  tbl.glIndexdv = loader_glIndexdv;
  tbl.glIndexf = loader_glIndexf;
  tbl.glIndexfv = loader_glIndexfv;
  tbl.glIndexi = loader_glIndexi;
  tbl.glIndexiv = loader_glIndexiv;
  tbl.glIndexs = loader_glIndexs;
  tbl.glIndexsv = loader_glIndexsv;
  tbl.glInitNames = loader_glInitNames;
  tbl.glIsEnabled = loader_glIsEnabled;
  tbl.glIsList = loader_glIsList;
  tbl.glLightModelf = loader_glLightModelf;
  tbl.glLightModelfv = loader_glLightModelfv;
  tbl.glLightModeli = loader_glLightModeli;
  tbl.glLightModeliv = loader_glLightModeliv;
  tbl.glLightf = loader_glLightf;
  tbl.glLightfv = loader_glLightfv;
  tbl.glLighti = loader_glLighti;
  tbl.glLightiv = loader_glLightiv;
  tbl.glLineStipple = loader_glLineStipple;
  tbl.glLineWidth = loader_glLineWidth;
  tbl.glListBase = loader_glListBase;
  tbl.glLoadIdentity = loader_glLoadIdentity;
  tbl.glLoadMatrixd = loader_glLoadMatrixd;
  tbl.glLoadMatrixf = loader_glLoadMatrixf;
  tbl.glLoadName = loader_glLoadName;
  tbl.glLogicOp = loader_glLogicOp;
  tbl.glMap1d = loader_glMap1d;
  tbl.glMap1f = loader_glMap1f;
  tbl.glMap2d = loader_glMap2d;
  tbl.glMap2f = loader_glMap2f;
  tbl.glMapGrid1d = loader_glMapGrid1d;
  tbl.glMapGrid1f = loader_glMapGrid1f;
  tbl.glMapGrid2d = loader_glMapGrid2d;
  tbl.glMapGrid2f = loader_glMapGrid2f;
  tbl.glMaterialf = loader_glMaterialf;
  tbl.glMaterialfv = loader_glMaterialfv;
  tbl.glMateriali = loader_glMateriali;
  tbl.glMaterialiv = loader_glMaterialiv;
  tbl.glMatrixMode = loader_glMatrixMode;
  tbl.glMultMatrixd = loader_glMultMatrixd;
  tbl.glMultMatrixf = loader_glMultMatrixf;
  tbl.glNewList = loader_glNewList;
  tbl.glNormal3b = loader_glNormal3b;
  tbl.glNormal3bv = loader_glNormal3bv;
  tbl.glNormal3d = loader_glNormal3d;
  tbl.glNormal3dv = loader_glNormal3dv;
  tbl.glNormal3f = loader_glNormal3f;
  tbl.glNormal3fv = loader_glNormal3fv;
  tbl.glNormal3i = loader_glNormal3i;
  tbl.glNormal3iv = loader_glNormal3iv;
  tbl.glNormal3s = loader_glNormal3s;
  tbl.glNormal3sv = loader_glNormal3sv;
  tbl.glOrtho = loader_glOrtho;
  tbl.glPassThrough = loader_glPassThrough;
  tbl.glPixelMapfv = loader_glPixelMapfv;
  tbl.glPixelMapuiv = loader_glPixelMapuiv;
  tbl.glPixelMapusv = loader_glPixelMapusv;
  tbl.glPixelStoref = loader_glPixelStoref;
  tbl.glPixelStorei = loader_glPixelStorei;
  tbl.glPixelTransferf = loader_glPixelTransferf;
  tbl.glPixelTransferi = loader_glPixelTransferi;
  tbl.glPixelZoom = loader_glPixelZoom;
  tbl.glPointSize = loader_glPointSize;
  tbl.glPolygonMode = loader_glPolygonMode;
  tbl.glPolygonStipple = loader_glPolygonStipple;
  tbl.glPopAttrib = loader_glPopAttrib;
  tbl.glPopMatrix = loader_glPopMatrix;
  tbl.glPopName = loader_glPopName;
  tbl.glPushAttrib = loader_glPushAttrib;
  tbl.glPushMatrix = loader_glPushMatrix;
  tbl.glPushName = loader_glPushName;
  tbl.glRasterPos2d = loader_glRasterPos2d;
  tbl.glRasterPos2dv = loader_glRasterPos2dv;
  tbl.glRasterPos2f = loader_glRasterPos2f;
  tbl.glRasterPos2fv = loader_glRasterPos2fv;
  tbl.glRasterPos2i = loader_glRasterPos2i;
  tbl.glRasterPos2iv = loader_glRasterPos2iv;
  tbl.glRasterPos2s = loader_glRasterPos2s;
  tbl.glRasterPos2sv = loader_glRasterPos2sv;
  tbl.glRasterPos3d = loader_glRasterPos3d;
  tbl.glRasterPos3dv = loader_glRasterPos3dv;
  tbl.glRasterPos3f = loader_glRasterPos3f;
  tbl.glRasterPos3fv = loader_glRasterPos3fv;
  tbl.glRasterPos3i = loader_glRasterPos3i;
  tbl.glRasterPos3iv = loader_glRasterPos3iv;
  tbl.glRasterPos3s = loader_glRasterPos3s;
  tbl.glRasterPos3sv = loader_glRasterPos3sv;
  tbl.glRasterPos4d = loader_glRasterPos4d;
  tbl.glRasterPos4dv = loader_glRasterPos4dv;
  tbl.glRasterPos4f = loader_glRasterPos4f;
  tbl.glRasterPos4fv = loader_glRasterPos4fv;
  tbl.glRasterPos4i = loader_glRasterPos4i;
  tbl.glRasterPos4iv = loader_glRasterPos4iv;
  tbl.glRasterPos4s = loader_glRasterPos4s;
  tbl.glRasterPos4sv = loader_glRasterPos4sv;
  tbl.glReadBuffer = loader_glReadBuffer;
  tbl.glReadPixels = loader_glReadPixels;
  tbl.glRectd = loader_glRectd;
  tbl.glRectdv = loader_glRectdv;
  tbl.glRectf = loader_glRectf;
  tbl.glRectfv = loader_glRectfv;
  tbl.glRecti = loader_glRecti;
  tbl.glRectiv = loader_glRectiv;
  tbl.glRects = loader_glRects;
  tbl.glRectsv = loader_glRectsv;
  tbl.glRenderMode = loader_glRenderMode;
  tbl.glRotated = loader_glRotated;
  tbl.glRotatef = loader_glRotatef;
  tbl.glScaled = loader_glScaled;
  tbl.glScalef = loader_glScalef;
  tbl.glScissor = loader_glScissor;
  tbl.glSelectBuffer = loader_glSelectBuffer;
  tbl.glShadeModel = loader_glShadeModel;
  tbl.glStencilFunc = loader_glStencilFunc;
  tbl.glStencilMask = loader_glStencilMask;
  tbl.glStencilOp = loader_glStencilOp;
  tbl.glTexCoord1d = loader_glTexCoord1d;
  tbl.glTexCoord1dv = loader_glTexCoord1dv;
  tbl.glTexCoord1f = loader_glTexCoord1f;
  tbl.glTexCoord1fv = loader_glTexCoord1fv;
  tbl.glTexCoord1i = loader_glTexCoord1i;
  tbl.glTexCoord1iv = loader_glTexCoord1iv;
  tbl.glTexCoord1s = loader_glTexCoord1s;
  tbl.glTexCoord1sv = loader_glTexCoord1sv;
  tbl.glTexCoord2d = loader_glTexCoord2d;
  tbl.glTexCoord2dv = loader_glTexCoord2dv;
  tbl.glTexCoord2f = loader_glTexCoord2f;
  tbl.glTexCoord2fv = loader_glTexCoord2fv;
  tbl.glTexCoord2i = loader_glTexCoord2i;
  tbl.glTexCoord2iv = loader_glTexCoord2iv;
  tbl.glTexCoord2s = loader_glTexCoord2s;
  tbl.glTexCoord2sv = loader_glTexCoord2sv;
  tbl.glTexCoord3d = loader_glTexCoord3d;
  tbl.glTexCoord3dv = loader_glTexCoord3dv;
  tbl.glTexCoord3f = loader_glTexCoord3f;
  tbl.glTexCoord3fv = loader_glTexCoord3fv;
  tbl.glTexCoord3i = loader_glTexCoord3i;
  tbl.glTexCoord3iv = loader_glTexCoord3iv;
  tbl.glTexCoord3s = loader_glTexCoord3s;
  tbl.glTexCoord3sv = loader_glTexCoord3sv;
  tbl.glTexCoord4d = loader_glTexCoord4d;
  tbl.glTexCoord4dv = loader_glTexCoord4dv;
  tbl.glTexCoord4f = loader_glTexCoord4f;
  tbl.glTexCoord4fv = loader_glTexCoord4fv;
  tbl.glTexCoord4i = loader_glTexCoord4i;
  tbl.glTexCoord4iv = loader_glTexCoord4iv;
  tbl.glTexCoord4s = loader_glTexCoord4s;
  tbl.glTexCoord4sv = loader_glTexCoord4sv;
  tbl.glTexEnvf = loader_glTexEnvf;
  tbl.glTexEnvfv = loader_glTexEnvfv;
  tbl.glTexEnvi = loader_glTexEnvi;
  tbl.glTexEnviv = loader_glTexEnviv;
  tbl.glTexGend = loader_glTexGend;
  tbl.glTexGendv = loader_glTexGendv;
  tbl.glTexGenf = loader_glTexGenf;
  tbl.glTexGenfv = loader_glTexGenfv;
  tbl.glTexGeni = loader_glTexGeni;
  tbl.glTexGeniv = loader_glTexGeniv;
  tbl.glTexImage1D = loader_glTexImage1D;
  tbl.glTexImage2D = loader_glTexImage2D;
  tbl.glTexParameterf = loader_glTexParameterf;
  tbl.glTexParameterfv = loader_glTexParameterfv;
  tbl.glTexParameteri = loader_glTexParameteri;
  tbl.glTexParameteriv = loader_glTexParameteriv;
  tbl.glTranslated = loader_glTranslated;
  tbl.glTranslatef = loader_glTranslatef;
  tbl.glVertex2d = loader_glVertex2d;
  tbl.glVertex2dv = loader_glVertex2dv;
  tbl.glVertex2f = loader_glVertex2f;
  tbl.glVertex2fv = loader_glVertex2fv;
  tbl.glVertex2i = loader_glVertex2i;
  tbl.glVertex2iv = loader_glVertex2iv;
  tbl.glVertex2s = loader_glVertex2s;
  tbl.glVertex2sv = loader_glVertex2sv;
  tbl.glVertex3d = loader_glVertex3d;
  tbl.glVertex3dv = loader_glVertex3dv;
  tbl.glVertex3f = loader_glVertex3f;
  tbl.glVertex3fv = loader_glVertex3fv;
  tbl.glVertex3i = loader_glVertex3i;
  tbl.glVertex3iv = loader_glVertex3iv;
  tbl.glVertex3s = loader_glVertex3s;
  tbl.glVertex3sv = loader_glVertex3sv;
  tbl.glVertex4d = loader_glVertex4d;
  tbl.glVertex4dv = loader_glVertex4dv;
  tbl.glVertex4f = loader_glVertex4f;
  tbl.glVertex4fv = loader_glVertex4fv;
  tbl.glVertex4i = loader_glVertex4i;
  tbl.glVertex4iv = loader_glVertex4iv;
  tbl.glVertex4s = loader_glVertex4s;
  tbl.glVertex4sv = loader_glVertex4sv;
  tbl.glViewport = loader_glViewport;

  // GL_VERSION_1_1

  tbl.glAreTexturesResident = loader_glAreTexturesResident;
  tbl.glArrayElement = loader_glArrayElement;
  tbl.glBindTexture = loader_glBindTexture;
  tbl.glColorPointer = loader_glColorPointer;
  tbl.glCopyTexImage1D = loader_glCopyTexImage1D;
  tbl.glCopyTexImage2D = loader_glCopyTexImage2D;
  tbl.glCopyTexSubImage1D = loader_glCopyTexSubImage1D;
  tbl.glCopyTexSubImage2D = loader_glCopyTexSubImage2D;
  tbl.glDeleteTextures = loader_glDeleteTextures;
  tbl.glDisableClientState = loader_glDisableClientState;
  tbl.glDrawArrays = loader_glDrawArrays;
  tbl.glDrawElements = loader_glDrawElements;
  tbl.glEdgeFlagPointer = loader_glEdgeFlagPointer;
  tbl.glEnableClientState = loader_glEnableClientState;
  tbl.glGenTextures = loader_glGenTextures;
  tbl.glGetPointerv = loader_glGetPointerv;
  tbl.glIndexPointer = loader_glIndexPointer;
  tbl.glIndexub = loader_glIndexub;
  tbl.glIndexubv = loader_glIndexubv;
  tbl.glInterleavedArrays = loader_glInterleavedArrays;
  tbl.glIsTexture = loader_glIsTexture;
  tbl.glNormalPointer = loader_glNormalPointer;
  tbl.glPolygonOffset = loader_glPolygonOffset;
  tbl.glPopClientAttrib = loader_glPopClientAttrib;
  tbl.glPrioritizeTextures = loader_glPrioritizeTextures;
  tbl.glPushClientAttrib = loader_glPushClientAttrib;
  tbl.glTexCoordPointer = loader_glTexCoordPointer;
  tbl.glTexSubImage1D = loader_glTexSubImage1D;
  tbl.glTexSubImage2D = loader_glTexSubImage2D;
  tbl.glVertexPointer = loader_glVertexPointer;

  // GL_VERSION_1_2

  tbl.glBlendColor = loader_glBlendColor;
  tbl.glBlendEquation = loader_glBlendEquation;
  tbl.glCopyTexSubImage3D = loader_glCopyTexSubImage3D;
  tbl.glDrawRangeElements = loader_glDrawRangeElements;
  tbl.glTexImage3D = loader_glTexImage3D;
  tbl.glTexSubImage3D = loader_glTexSubImage3D;

  // GL_VERSION_1_3

  tbl.glActiveTexture = loader_glActiveTexture;
  tbl.glClientActiveTexture = loader_glClientActiveTexture;
  tbl.glCompressedTexImage1D = loader_glCompressedTexImage1D;
  tbl.glCompressedTexImage2D = loader_glCompressedTexImage2D;
  tbl.glCompressedTexImage3D = loader_glCompressedTexImage3D;
  tbl.glCompressedTexSubImage1D = loader_glCompressedTexSubImage1D;
  tbl.glCompressedTexSubImage2D = loader_glCompressedTexSubImage2D;
  tbl.glCompressedTexSubImage3D = loader_glCompressedTexSubImage3D;
  tbl.glGetCompressedTexImage = loader_glGetCompressedTexImage;
  tbl.glLoadTransposeMatrixd = loader_glLoadTransposeMatrixd;
  tbl.glLoadTransposeMatrixf = loader_glLoadTransposeMatrixf;
  tbl.glMultTransposeMatrixd = loader_glMultTransposeMatrixd;
  tbl.glMultTransposeMatrixf = loader_glMultTransposeMatrixf;
  tbl.glMultiTexCoord1d = loader_glMultiTexCoord1d;
  tbl.glMultiTexCoord1dv = loader_glMultiTexCoord1dv;
  tbl.glMultiTexCoord1f = loader_glMultiTexCoord1f;
  tbl.glMultiTexCoord1fv = loader_glMultiTexCoord1fv;
  tbl.glMultiTexCoord1i = loader_glMultiTexCoord1i;
  tbl.glMultiTexCoord1iv = loader_glMultiTexCoord1iv;
  tbl.glMultiTexCoord1s = loader_glMultiTexCoord1s;
  tbl.glMultiTexCoord1sv = loader_glMultiTexCoord1sv;
  tbl.glMultiTexCoord2d = loader_glMultiTexCoord2d;
  tbl.glMultiTexCoord2dv = loader_glMultiTexCoord2dv;
  tbl.glMultiTexCoord2f = loader_glMultiTexCoord2f;
  tbl.glMultiTexCoord2fv = loader_glMultiTexCoord2fv;
  tbl.glMultiTexCoord2i = loader_glMultiTexCoord2i;
  tbl.glMultiTexCoord2iv = loader_glMultiTexCoord2iv;
  tbl.glMultiTexCoord2s = loader_glMultiTexCoord2s;
  tbl.glMultiTexCoord2sv = loader_glMultiTexCoord2sv;
  tbl.glMultiTexCoord3d = loader_glMultiTexCoord3d;
  tbl.glMultiTexCoord3dv = loader_glMultiTexCoord3dv;
  tbl.glMultiTexCoord3f = loader_glMultiTexCoord3f;
  tbl.glMultiTexCoord3fv = loader_glMultiTexCoord3fv;
  tbl.glMultiTexCoord3i = loader_glMultiTexCoord3i;
  tbl.glMultiTexCoord3iv = loader_glMultiTexCoord3iv;
  tbl.glMultiTexCoord3s = loader_glMultiTexCoord3s;
  tbl.glMultiTexCoord3sv = loader_glMultiTexCoord3sv;
  tbl.glMultiTexCoord4d = loader_glMultiTexCoord4d;
  tbl.glMultiTexCoord4dv = loader_glMultiTexCoord4dv;
  tbl.glMultiTexCoord4f = loader_glMultiTexCoord4f;
  tbl.glMultiTexCoord4fv = loader_glMultiTexCoord4fv;
  tbl.glMultiTexCoord4i = loader_glMultiTexCoord4i;
  tbl.glMultiTexCoord4iv = loader_glMultiTexCoord4iv;
  tbl.glMultiTexCoord4s = loader_glMultiTexCoord4s;
  tbl.glMultiTexCoord4sv = loader_glMultiTexCoord4sv;
  tbl.glSampleCoverage = loader_glSampleCoverage;

  // GL_VERSION_1_4

  tbl.glBlendFuncSeparate = loader_glBlendFuncSeparate;
  tbl.glFogCoordPointer = loader_glFogCoordPointer;
  tbl.glFogCoordd = loader_glFogCoordd;
  tbl.glFogCoorddv = loader_glFogCoorddv;
  tbl.glFogCoordf = loader_glFogCoordf;
  tbl.glFogCoordfv = loader_glFogCoordfv;
  tbl.glMultiDrawArrays = loader_glMultiDrawArrays;
  tbl.glMultiDrawElements = loader_glMultiDrawElements;
  tbl.glPointParameterf = loader_glPointParameterf;
  tbl.glPointParameterfv = loader_glPointParameterfv;
  tbl.glPointParameteri = loader_glPointParameteri;
  tbl.glPointParameteriv = loader_glPointParameteriv;
  tbl.glSecondaryColor3b = loader_glSecondaryColor3b;
  tbl.glSecondaryColor3bv = loader_glSecondaryColor3bv;
  tbl.glSecondaryColor3d = loader_glSecondaryColor3d;
  tbl.glSecondaryColor3dv = loader_glSecondaryColor3dv;
  tbl.glSecondaryColor3f = loader_glSecondaryColor3f;
  tbl.glSecondaryColor3fv = loader_glSecondaryColor3fv;
  tbl.glSecondaryColor3i = loader_glSecondaryColor3i;
  tbl.glSecondaryColor3iv = loader_glSecondaryColor3iv;
  tbl.glSecondaryColor3s = loader_glSecondaryColor3s;
  tbl.glSecondaryColor3sv = loader_glSecondaryColor3sv;
  tbl.glSecondaryColor3ub = loader_glSecondaryColor3ub;
  tbl.glSecondaryColor3ubv = loader_glSecondaryColor3ubv;
  tbl.glSecondaryColor3ui = loader_glSecondaryColor3ui;
  tbl.glSecondaryColor3uiv = loader_glSecondaryColor3uiv;
  tbl.glSecondaryColor3us = loader_glSecondaryColor3us;
  tbl.glSecondaryColor3usv = loader_glSecondaryColor3usv;
  tbl.glSecondaryColorPointer = loader_glSecondaryColorPointer;
  tbl.glWindowPos2d = loader_glWindowPos2d;
  tbl.glWindowPos2dv = loader_glWindowPos2dv;
  tbl.glWindowPos2f = loader_glWindowPos2f;
  tbl.glWindowPos2fv = loader_glWindowPos2fv;
  tbl.glWindowPos2i = loader_glWindowPos2i;
  tbl.glWindowPos2iv = loader_glWindowPos2iv;
  tbl.glWindowPos2s = loader_glWindowPos2s;
  tbl.glWindowPos2sv = loader_glWindowPos2sv;
  tbl.glWindowPos3d = loader_glWindowPos3d;
  tbl.glWindowPos3dv = loader_glWindowPos3dv;
  tbl.glWindowPos3f = loader_glWindowPos3f;
  tbl.glWindowPos3fv = loader_glWindowPos3fv;
  tbl.glWindowPos3i = loader_glWindowPos3i;
  tbl.glWindowPos3iv = loader_glWindowPos3iv;
  tbl.glWindowPos3s = loader_glWindowPos3s;
  tbl.glWindowPos3sv = loader_glWindowPos3sv;

  // GL_VERSION_1_5

  tbl.glBeginQuery = loader_glBeginQuery;
  tbl.glBindBuffer = loader_glBindBuffer;
  tbl.glBufferData = loader_glBufferData;
  tbl.glBufferSubData = loader_glBufferSubData;
  tbl.glDeleteBuffers = loader_glDeleteBuffers;
  tbl.glDeleteQueries = loader_glDeleteQueries;
  tbl.glEndQuery = loader_glEndQuery;
  tbl.glGenBuffers = loader_glGenBuffers;
  tbl.glGenQueries = loader_glGenQueries;
  tbl.glGetBufferParameteriv = loader_glGetBufferParameteriv;
  tbl.glGetBufferPointerv = loader_glGetBufferPointerv;
  tbl.glGetBufferSubData = loader_glGetBufferSubData;
  tbl.glGetQueryObjectiv = loader_glGetQueryObjectiv;
  tbl.glGetQueryObjectuiv = loader_glGetQueryObjectuiv;
  tbl.glGetQueryiv = loader_glGetQueryiv;
  tbl.glIsBuffer = loader_glIsBuffer;
  tbl.glIsQuery = loader_glIsQuery;
  tbl.glMapBuffer = loader_glMapBuffer;
  tbl.glUnmapBuffer = loader_glUnmapBuffer;

  // GL_VERSION_2_0

  tbl.glAttachShader = loader_glAttachShader;
  tbl.glBindAttribLocation = loader_glBindAttribLocation;
  tbl.glBlendEquationSeparate = loader_glBlendEquationSeparate;
  tbl.glCompileShader = loader_glCompileShader;
  tbl.glCreateProgram = loader_glCreateProgram;
  tbl.glCreateShader = loader_glCreateShader;
  tbl.glDeleteProgram = loader_glDeleteProgram;
  tbl.glDeleteShader = loader_glDeleteShader;
  tbl.glDetachShader = loader_glDetachShader;
  tbl.glDisableVertexAttribArray = loader_glDisableVertexAttribArray;
  tbl.glDrawBuffers = loader_glDrawBuffers;
  tbl.glEnableVertexAttribArray = loader_glEnableVertexAttribArray;
  tbl.glGetActiveAttrib = loader_glGetActiveAttrib;
  tbl.glGetActiveUniform = loader_glGetActiveUniform;
  tbl.glGetAttachedShaders = loader_glGetAttachedShaders;
  tbl.glGetAttribLocation = loader_glGetAttribLocation;
  tbl.glGetProgramInfoLog = loader_glGetProgramInfoLog;
  tbl.glGetProgramiv = loader_glGetProgramiv;
  tbl.glGetShaderInfoLog = loader_glGetShaderInfoLog;
  tbl.glGetShaderSource = loader_glGetShaderSource;
  tbl.glGetShaderiv = loader_glGetShaderiv;
  tbl.glGetUniformLocation = loader_glGetUniformLocation;
  tbl.glGetUniformfv = loader_glGetUniformfv;
  tbl.glGetUniformiv = loader_glGetUniformiv;
  tbl.glGetVertexAttribPointerv = loader_glGetVertexAttribPointerv;
  tbl.glGetVertexAttribdv = loader_glGetVertexAttribdv;
  tbl.glGetVertexAttribfv = loader_glGetVertexAttribfv;
  tbl.glGetVertexAttribiv = loader_glGetVertexAttribiv;
  tbl.glIsProgram = loader_glIsProgram;
  tbl.glIsShader = loader_glIsShader;
  tbl.glLinkProgram = loader_glLinkProgram;
  tbl.glShaderSource = loader_glShaderSource;
  tbl.glStencilFuncSeparate = loader_glStencilFuncSeparate;
  tbl.glStencilMaskSeparate = loader_glStencilMaskSeparate;
  tbl.glStencilOpSeparate = loader_glStencilOpSeparate;
  tbl.glUniform1f = loader_glUniform1f;
  tbl.glUniform1fv = loader_glUniform1fv;
  tbl.glUniform1i = loader_glUniform1i;
  tbl.glUniform1iv = loader_glUniform1iv;
  tbl.glUniform2f = loader_glUniform2f;
  tbl.glUniform2fv = loader_glUniform2fv;
  tbl.glUniform2i = loader_glUniform2i;
  tbl.glUniform2iv = loader_glUniform2iv;
  tbl.glUniform3f = loader_glUniform3f;
  tbl.glUniform3fv = loader_glUniform3fv;
  tbl.glUniform3i = loader_glUniform3i;
  tbl.glUniform3iv = loader_glUniform3iv;
  tbl.glUniform4f = loader_glUniform4f;
  tbl.glUniform4fv = loader_glUniform4fv;
  tbl.glUniform4i = loader_glUniform4i;
  tbl.glUniform4iv = loader_glUniform4iv;
  tbl.glUniformMatrix2fv = loader_glUniformMatrix2fv;
  tbl.glUniformMatrix3fv = loader_glUniformMatrix3fv;
  tbl.glUniformMatrix4fv = loader_glUniformMatrix4fv;
  tbl.glUseProgram = loader_glUseProgram;
  tbl.glValidateProgram = loader_glValidateProgram;
  tbl.glVertexAttrib1d = loader_glVertexAttrib1d;
  tbl.glVertexAttrib1dv = loader_glVertexAttrib1dv;
  tbl.glVertexAttrib1f = loader_glVertexAttrib1f;
  tbl.glVertexAttrib1fv = loader_glVertexAttrib1fv;
  tbl.glVertexAttrib1s = loader_glVertexAttrib1s;
  tbl.glVertexAttrib1sv = loader_glVertexAttrib1sv;
  tbl.glVertexAttrib2d = loader_glVertexAttrib2d;
  tbl.glVertexAttrib2dv = loader_glVertexAttrib2dv;
  tbl.glVertexAttrib2f = loader_glVertexAttrib2f;
  tbl.glVertexAttrib2fv = loader_glVertexAttrib2fv;
  tbl.glVertexAttrib2s = loader_glVertexAttrib2s;
  tbl.glVertexAttrib2sv = loader_glVertexAttrib2sv;
  tbl.glVertexAttrib3d = loader_glVertexAttrib3d;
  tbl.glVertexAttrib3dv = loader_glVertexAttrib3dv;
  tbl.glVertexAttrib3f = loader_glVertexAttrib3f;
  tbl.glVertexAttrib3fv = loader_glVertexAttrib3fv;
  tbl.glVertexAttrib3s = loader_glVertexAttrib3s;
  tbl.glVertexAttrib3sv = loader_glVertexAttrib3sv;
  tbl.glVertexAttrib4Nbv = loader_glVertexAttrib4Nbv;
  tbl.glVertexAttrib4Niv = loader_glVertexAttrib4Niv;
  tbl.glVertexAttrib4Nsv = loader_glVertexAttrib4Nsv;
  tbl.glVertexAttrib4Nub = loader_glVertexAttrib4Nub;
  tbl.glVertexAttrib4Nubv = loader_glVertexAttrib4Nubv;
  tbl.glVertexAttrib4Nuiv = loader_glVertexAttrib4Nuiv;
  tbl.glVertexAttrib4Nusv = loader_glVertexAttrib4Nusv;
  tbl.glVertexAttrib4bv = loader_glVertexAttrib4bv;
  tbl.glVertexAttrib4d = loader_glVertexAttrib4d;
  tbl.glVertexAttrib4dv = loader_glVertexAttrib4dv;
  tbl.glVertexAttrib4f = loader_glVertexAttrib4f;
  tbl.glVertexAttrib4fv = loader_glVertexAttrib4fv;
  tbl.glVertexAttrib4iv = loader_glVertexAttrib4iv;
  tbl.glVertexAttrib4s = loader_glVertexAttrib4s;
  tbl.glVertexAttrib4sv = loader_glVertexAttrib4sv;
  tbl.glVertexAttrib4ubv = loader_glVertexAttrib4ubv;
  tbl.glVertexAttrib4uiv = loader_glVertexAttrib4uiv;
  tbl.glVertexAttrib4usv = loader_glVertexAttrib4usv;
  tbl.glVertexAttribPointer = loader_glVertexAttribPointer;

  // GL_VERSION_2_1

  tbl.glUniformMatrix2x3fv = loader_glUniformMatrix2x3fv;
  tbl.glUniformMatrix2x4fv = loader_glUniformMatrix2x4fv;
  tbl.glUniformMatrix3x2fv = loader_glUniformMatrix3x2fv;
  tbl.glUniformMatrix3x4fv = loader_glUniformMatrix3x4fv;
  tbl.glUniformMatrix4x2fv = loader_glUniformMatrix4x2fv;
  tbl.glUniformMatrix4x3fv = loader_glUniformMatrix4x3fv;

  // GL_VERSION_3_0

  tbl.glBeginConditionalRender = loader_glBeginConditionalRender;
  tbl.glBeginTransformFeedback = loader_glBeginTransformFeedback;
  tbl.glBindFragDataLocation = loader_glBindFragDataLocation;
  tbl.glClampColor = loader_glClampColor;
  tbl.glClearBufferfi = loader_glClearBufferfi;
  tbl.glClearBufferfv = loader_glClearBufferfv;
  tbl.glClearBufferiv = loader_glClearBufferiv;
  tbl.glClearBufferuiv = loader_glClearBufferuiv;
  tbl.glColorMaski = loader_glColorMaski;
  tbl.glDisablei = loader_glDisablei;
  tbl.glEnablei = loader_glEnablei;
  tbl.glEndConditionalRender = loader_glEndConditionalRender;
  tbl.glEndTransformFeedback = loader_glEndTransformFeedback;
  tbl.glGetBooleani_v = loader_glGetBooleani_v;
  tbl.glGetFragDataLocation = loader_glGetFragDataLocation;
  tbl.glGetStringi = loader_glGetStringi;
  tbl.glGetTexParameterIiv = loader_glGetTexParameterIiv;
  tbl.glGetTexParameterIuiv = loader_glGetTexParameterIuiv;
  tbl.glGetTransformFeedbackVarying = loader_glGetTransformFeedbackVarying;
  tbl.glGetUniformuiv = loader_glGetUniformuiv;
  tbl.glGetVertexAttribIiv = loader_glGetVertexAttribIiv;
  tbl.glGetVertexAttribIuiv = loader_glGetVertexAttribIuiv;
  tbl.glIsEnabledi = loader_glIsEnabledi;
  tbl.glTexParameterIiv = loader_glTexParameterIiv;
  tbl.glTexParameterIuiv = loader_glTexParameterIuiv;
  tbl.glTransformFeedbackVaryings = loader_glTransformFeedbackVaryings;
  tbl.glUniform1ui = loader_glUniform1ui;
  tbl.glUniform1uiv = loader_glUniform1uiv;
  tbl.glUniform2ui = loader_glUniform2ui;
  tbl.glUniform2uiv = loader_glUniform2uiv;
  tbl.glUniform3ui = loader_glUniform3ui;
  tbl.glUniform3uiv = loader_glUniform3uiv;
  tbl.glUniform4ui = loader_glUniform4ui;
  tbl.glUniform4uiv = loader_glUniform4uiv;
  tbl.glVertexAttribI1i = loader_glVertexAttribI1i;
  tbl.glVertexAttribI1iv = loader_glVertexAttribI1iv;
  tbl.glVertexAttribI1ui = loader_glVertexAttribI1ui;
  tbl.glVertexAttribI1uiv = loader_glVertexAttribI1uiv;
  tbl.glVertexAttribI2i = loader_glVertexAttribI2i;
  tbl.glVertexAttribI2iv = loader_glVertexAttribI2iv;
  tbl.glVertexAttribI2ui = loader_glVertexAttribI2ui;
  tbl.glVertexAttribI2uiv = loader_glVertexAttribI2uiv;
  tbl.glVertexAttribI3i = loader_glVertexAttribI3i;
  tbl.glVertexAttribI3iv = loader_glVertexAttribI3iv;
  tbl.glVertexAttribI3ui = loader_glVertexAttribI3ui;
  tbl.glVertexAttribI3uiv = loader_glVertexAttribI3uiv;
  tbl.glVertexAttribI4bv = loader_glVertexAttribI4bv;
  tbl.glVertexAttribI4i = loader_glVertexAttribI4i;
  tbl.glVertexAttribI4iv = loader_glVertexAttribI4iv;
  tbl.glVertexAttribI4sv = loader_glVertexAttribI4sv;
  tbl.glVertexAttribI4ubv = loader_glVertexAttribI4ubv;
  tbl.glVertexAttribI4ui = loader_glVertexAttribI4ui;
  tbl.glVertexAttribI4uiv = loader_glVertexAttribI4uiv;
  tbl.glVertexAttribI4usv = loader_glVertexAttribI4usv;
  tbl.glVertexAttribIPointer = loader_glVertexAttribIPointer;

  // GL_VERSION_3_1

  tbl.glDrawArraysInstanced = loader_glDrawArraysInstanced;
  tbl.glDrawElementsInstanced = loader_glDrawElementsInstanced;
  tbl.glPrimitiveRestartIndex = loader_glPrimitiveRestartIndex;
  tbl.glTexBuffer = loader_glTexBuffer;

  // GL_VERSION_3_2

  tbl.glFramebufferTexture = loader_glFramebufferTexture;
  tbl.glFramebufferTextureFace = loader_glFramebufferTextureFace;
  tbl.glGetBufferParameteri64v = loader_glGetBufferParameteri64v;
  tbl.glGetInteger64i_v = loader_glGetInteger64i_v;

  // GL_VERSION_3_3

  tbl.glVertexAttribDivisor = loader_glVertexAttribDivisor;

  // GL_VERSION_4_0

  tbl.glBlendEquationSeparatei = loader_glBlendEquationSeparatei;
  tbl.glBlendEquationi = loader_glBlendEquationi;
  tbl.glBlendFuncSeparatei = loader_glBlendFuncSeparatei;
  tbl.glBlendFunci = loader_glBlendFunci;

  // GL_3DFX_tbuffer

  tbl.glTbufferMask3DFX = loader_glTbufferMask3DFX;

  // GL_AMD_debug_output

  tbl.glDebugMessageCallbackAMD = loader_glDebugMessageCallbackAMD;
  tbl.glDebugMessageEnableAMD = loader_glDebugMessageEnableAMD;
  tbl.glDebugMessageInsertAMD = loader_glDebugMessageInsertAMD;
  tbl.glGetDebugMessageLogAMD = loader_glGetDebugMessageLogAMD;

  // GL_AMD_draw_buffers_blend

  tbl.glBlendEquationIndexedAMD = loader_glBlendEquationIndexedAMD;
  tbl.glBlendEquationSeparateIndexedAMD = loader_glBlendEquationSeparateIndexedAMD;
  tbl.glBlendFuncIndexedAMD = loader_glBlendFuncIndexedAMD;
  tbl.glBlendFuncSeparateIndexedAMD = loader_glBlendFuncSeparateIndexedAMD;

  // GL_AMD_multi_draw_indirect

  tbl.glMultiDrawArraysIndirectAMD = loader_glMultiDrawArraysIndirectAMD;
  tbl.glMultiDrawElementsIndirectAMD = loader_glMultiDrawElementsIndirectAMD;

  // GL_AMD_name_gen_delete

  tbl.glDeleteNamesAMD = loader_glDeleteNamesAMD;
  tbl.glGenNamesAMD = loader_glGenNamesAMD;
  tbl.glIsNameAMD = loader_glIsNameAMD;

  // GL_AMD_performance_monitor

  tbl.glBeginPerfMonitorAMD = loader_glBeginPerfMonitorAMD;
  tbl.glDeletePerfMonitorsAMD = loader_glDeletePerfMonitorsAMD;
  tbl.glEndPerfMonitorAMD = loader_glEndPerfMonitorAMD;
  tbl.glGenPerfMonitorsAMD = loader_glGenPerfMonitorsAMD;
  tbl.glGetPerfMonitorCounterDataAMD = loader_glGetPerfMonitorCounterDataAMD;
  tbl.glGetPerfMonitorCounterInfoAMD = loader_glGetPerfMonitorCounterInfoAMD;
  tbl.glGetPerfMonitorCounterStringAMD = loader_glGetPerfMonitorCounterStringAMD;
  tbl.glGetPerfMonitorCountersAMD = loader_glGetPerfMonitorCountersAMD;
  tbl.glGetPerfMonitorGroupStringAMD = loader_glGetPerfMonitorGroupStringAMD;
  tbl.glGetPerfMonitorGroupsAMD = loader_glGetPerfMonitorGroupsAMD;
  tbl.glSelectPerfMonitorCountersAMD = loader_glSelectPerfMonitorCountersAMD;

  // GL_AMD_sample_positions

  tbl.glSetMultisamplefvAMD = loader_glSetMultisamplefvAMD;

  // GL_AMD_stencil_operation_extended

  tbl.glStencilOpValueAMD = loader_glStencilOpValueAMD;

  // GL_AMD_vertex_shader_tessellator

  tbl.glTessellationFactorAMD = loader_glTessellationFactorAMD;
  tbl.glTessellationModeAMD = loader_glTessellationModeAMD;

  // GL_APPLE_element_array

  tbl.glDrawElementArrayAPPLE = loader_glDrawElementArrayAPPLE;
  tbl.glDrawRangeElementArrayAPPLE = loader_glDrawRangeElementArrayAPPLE;
  tbl.glElementPointerAPPLE = loader_glElementPointerAPPLE;
  tbl.glMultiDrawElementArrayAPPLE = loader_glMultiDrawElementArrayAPPLE;
  tbl.glMultiDrawRangeElementArrayAPPLE = loader_glMultiDrawRangeElementArrayAPPLE;

  // GL_APPLE_fence

  tbl.glDeleteFencesAPPLE = loader_glDeleteFencesAPPLE;
  tbl.glFinishFenceAPPLE = loader_glFinishFenceAPPLE;
  tbl.glFinishObjectAPPLE = loader_glFinishObjectAPPLE;
  tbl.glGenFencesAPPLE = loader_glGenFencesAPPLE;
  tbl.glIsFenceAPPLE = loader_glIsFenceAPPLE;
  tbl.glSetFenceAPPLE = loader_glSetFenceAPPLE;
  tbl.glTestFenceAPPLE = loader_glTestFenceAPPLE;
  tbl.glTestObjectAPPLE = loader_glTestObjectAPPLE;

  // GL_APPLE_flush_buffer_range

  tbl.glBufferParameteriAPPLE = loader_glBufferParameteriAPPLE;
  tbl.glFlushMappedBufferRangeAPPLE = loader_glFlushMappedBufferRangeAPPLE;

  // GL_APPLE_flush_render

  tbl.glFinishRenderAPPLE = loader_glFinishRenderAPPLE;
  tbl.glFlushRenderAPPLE = loader_glFlushRenderAPPLE;
  tbl.glSwapAPPLE = loader_glSwapAPPLE;

  // GL_APPLE_object_purgeable

  tbl.glGetObjectParameterivAPPLE = loader_glGetObjectParameterivAPPLE;
  tbl.glObjectPurgeableAPPLE = loader_glObjectPurgeableAPPLE;
  tbl.glObjectUnpurgeableAPPLE = loader_glObjectUnpurgeableAPPLE;

  // GL_APPLE_texture_range

  tbl.glGetTexParameterPointervAPPLE = loader_glGetTexParameterPointervAPPLE;
  tbl.glTextureRangeAPPLE = loader_glTextureRangeAPPLE;

  // GL_APPLE_vertex_array_object

  tbl.glBindVertexArrayAPPLE = loader_glBindVertexArrayAPPLE;
  tbl.glDeleteVertexArraysAPPLE = loader_glDeleteVertexArraysAPPLE;
  tbl.glGenVertexArraysAPPLE = loader_glGenVertexArraysAPPLE;
  tbl.glIsVertexArrayAPPLE = loader_glIsVertexArrayAPPLE;

  // GL_APPLE_vertex_array_range

  tbl.glFlushVertexArrayRangeAPPLE = loader_glFlushVertexArrayRangeAPPLE;
  tbl.glVertexArrayParameteriAPPLE = loader_glVertexArrayParameteriAPPLE;
  tbl.glVertexArrayRangeAPPLE = loader_glVertexArrayRangeAPPLE;

  // GL_APPLE_vertex_program_evaluators

  tbl.glDisableVertexAttribAPPLE = loader_glDisableVertexAttribAPPLE;
  tbl.glEnableVertexAttribAPPLE = loader_glEnableVertexAttribAPPLE;
  tbl.glIsVertexAttribEnabledAPPLE = loader_glIsVertexAttribEnabledAPPLE;
  tbl.glMapVertexAttrib1dAPPLE = loader_glMapVertexAttrib1dAPPLE;
  tbl.glMapVertexAttrib1fAPPLE = loader_glMapVertexAttrib1fAPPLE;
  tbl.glMapVertexAttrib2dAPPLE = loader_glMapVertexAttrib2dAPPLE;
  tbl.glMapVertexAttrib2fAPPLE = loader_glMapVertexAttrib2fAPPLE;

  // GL_ARB_ES2_compatibility

  tbl.glClearDepthf = loader_glClearDepthf;
  tbl.glDepthRangef = loader_glDepthRangef;
  tbl.glGetShaderPrecisionFormat = loader_glGetShaderPrecisionFormat;
  tbl.glReleaseShaderCompiler = loader_glReleaseShaderCompiler;
  tbl.glShaderBinary = loader_glShaderBinary;

  // GL_ARB_base_instance

  tbl.glDrawArraysInstancedBaseInstance = loader_glDrawArraysInstancedBaseInstance;
  tbl.glDrawElementsInstancedBaseInstance = loader_glDrawElementsInstancedBaseInstance;
  tbl.glDrawElementsInstancedBaseVertexBaseInstance = loader_glDrawElementsInstancedBaseVertexBaseInstance;

  // GL_ARB_blend_func_extended

  tbl.glBindFragDataLocationIndexed = loader_glBindFragDataLocationIndexed;
  tbl.glGetFragDataIndex = loader_glGetFragDataIndex;

  // GL_ARB_cl_event

  tbl.glCreateSyncFromCLeventARB = loader_glCreateSyncFromCLeventARB;

  // GL_ARB_clear_buffer_object

  tbl.glClearBufferData = loader_glClearBufferData;
  tbl.glClearBufferSubData = loader_glClearBufferSubData;
  tbl.glClearNamedBufferDataEXT = loader_glClearNamedBufferDataEXT;
  tbl.glClearNamedBufferSubDataEXT = loader_glClearNamedBufferSubDataEXT;

  // GL_ARB_color_buffer_float

  tbl.glClampColorARB = loader_glClampColorARB;

  // GL_ARB_compute_shader

  tbl.glDispatchCompute = loader_glDispatchCompute;
  tbl.glDispatchComputeIndirect = loader_glDispatchComputeIndirect;

  // GL_ARB_copy_buffer

  tbl.glCopyBufferSubData = loader_glCopyBufferSubData;

  // GL_ARB_copy_image

  tbl.glCopyImageSubData = loader_glCopyImageSubData;

  // GL_ARB_debug_output

  tbl.glDebugMessageCallbackARB = loader_glDebugMessageCallbackARB;
  tbl.glDebugMessageControlARB = loader_glDebugMessageControlARB;
  tbl.glDebugMessageInsertARB = loader_glDebugMessageInsertARB;
  tbl.glGetDebugMessageLogARB = loader_glGetDebugMessageLogARB;

  // GL_ARB_draw_buffers

  tbl.glDrawBuffersARB = loader_glDrawBuffersARB;

  // GL_ARB_draw_buffers_blend

  tbl.glBlendEquationSeparateiARB = loader_glBlendEquationSeparateiARB;
  tbl.glBlendEquationiARB = loader_glBlendEquationiARB;
  tbl.glBlendFuncSeparateiARB = loader_glBlendFuncSeparateiARB;
  tbl.glBlendFunciARB = loader_glBlendFunciARB;

  // GL_ARB_draw_elements_base_vertex

  tbl.glDrawElementsBaseVertex = loader_glDrawElementsBaseVertex;
  tbl.glDrawElementsInstancedBaseVertex = loader_glDrawElementsInstancedBaseVertex;
  tbl.glDrawRangeElementsBaseVertex = loader_glDrawRangeElementsBaseVertex;
  tbl.glMultiDrawElementsBaseVertex = loader_glMultiDrawElementsBaseVertex;

  // GL_ARB_draw_indirect

  tbl.glDrawArraysIndirect = loader_glDrawArraysIndirect;
  tbl.glDrawElementsIndirect = loader_glDrawElementsIndirect;

  // GL_ARB_draw_instanced

  tbl.glDrawArraysInstancedARB = loader_glDrawArraysInstancedARB;
  tbl.glDrawElementsInstancedARB = loader_glDrawElementsInstancedARB;

  // GL_ARB_framebuffer_no_attachments

  tbl.glFramebufferParameteri = loader_glFramebufferParameteri;
  tbl.glGetFramebufferParameteriv = loader_glGetFramebufferParameteriv;
  tbl.glGetNamedFramebufferParameterivEXT = loader_glGetNamedFramebufferParameterivEXT;
  tbl.glNamedFramebufferParameteriEXT = loader_glNamedFramebufferParameteriEXT;

  // GL_ARB_framebuffer_object

  tbl.glBindFramebuffer = loader_glBindFramebuffer;
  tbl.glBindRenderbuffer = loader_glBindRenderbuffer;
  tbl.glBlitFramebuffer = loader_glBlitFramebuffer;
  tbl.glCheckFramebufferStatus = loader_glCheckFramebufferStatus;
  tbl.glDeleteFramebuffers = loader_glDeleteFramebuffers;
  tbl.glDeleteRenderbuffers = loader_glDeleteRenderbuffers;
  tbl.glFramebufferRenderbuffer = loader_glFramebufferRenderbuffer;
  tbl.glFramebufferTexture1D = loader_glFramebufferTexture1D;
  tbl.glFramebufferTexture2D = loader_glFramebufferTexture2D;
  tbl.glFramebufferTexture3D = loader_glFramebufferTexture3D;
  tbl.glFramebufferTextureLayer = loader_glFramebufferTextureLayer;
  tbl.glGenFramebuffers = loader_glGenFramebuffers;
  tbl.glGenRenderbuffers = loader_glGenRenderbuffers;
  tbl.glGenerateMipmap = loader_glGenerateMipmap;
  tbl.glGetFramebufferAttachmentParameteriv = loader_glGetFramebufferAttachmentParameteriv;
  tbl.glGetRenderbufferParameteriv = loader_glGetRenderbufferParameteriv;
  tbl.glIsFramebuffer = loader_glIsFramebuffer;
  tbl.glIsRenderbuffer = loader_glIsRenderbuffer;
  tbl.glRenderbufferStorage = loader_glRenderbufferStorage;
  tbl.glRenderbufferStorageMultisample = loader_glRenderbufferStorageMultisample;

  // GL_ARB_geometry_shader4

  tbl.glFramebufferTextureARB = loader_glFramebufferTextureARB;
  tbl.glFramebufferTextureFaceARB = loader_glFramebufferTextureFaceARB;
  tbl.glFramebufferTextureLayerARB = loader_glFramebufferTextureLayerARB;
  tbl.glProgramParameteriARB = loader_glProgramParameteriARB;

  // GL_ARB_get_program_binary

  tbl.glGetProgramBinary = loader_glGetProgramBinary;
  tbl.glProgramBinary = loader_glProgramBinary;
  tbl.glProgramParameteri = loader_glProgramParameteri;

  // GL_ARB_gpu_shader_fp64

  tbl.glGetUniformdv = loader_glGetUniformdv;
  tbl.glUniform1d = loader_glUniform1d;
  tbl.glUniform1dv = loader_glUniform1dv;
  tbl.glUniform2d = loader_glUniform2d;
  tbl.glUniform2dv = loader_glUniform2dv;
  tbl.glUniform3d = loader_glUniform3d;
  tbl.glUniform3dv = loader_glUniform3dv;
  tbl.glUniform4d = loader_glUniform4d;
  tbl.glUniform4dv = loader_glUniform4dv;
  tbl.glUniformMatrix2dv = loader_glUniformMatrix2dv;
  tbl.glUniformMatrix2x3dv = loader_glUniformMatrix2x3dv;
  tbl.glUniformMatrix2x4dv = loader_glUniformMatrix2x4dv;
  tbl.glUniformMatrix3dv = loader_glUniformMatrix3dv;
  tbl.glUniformMatrix3x2dv = loader_glUniformMatrix3x2dv;
  tbl.glUniformMatrix3x4dv = loader_glUniformMatrix3x4dv;
  tbl.glUniformMatrix4dv = loader_glUniformMatrix4dv;
  tbl.glUniformMatrix4x2dv = loader_glUniformMatrix4x2dv;
  tbl.glUniformMatrix4x3dv = loader_glUniformMatrix4x3dv;

  // GL_ARB_imaging

  tbl.glColorSubTable = loader_glColorSubTable;
  tbl.glColorTable = loader_glColorTable;
  tbl.glColorTableParameterfv = loader_glColorTableParameterfv;
  tbl.glColorTableParameteriv = loader_glColorTableParameteriv;
  tbl.glConvolutionFilter1D = loader_glConvolutionFilter1D;
  tbl.glConvolutionFilter2D = loader_glConvolutionFilter2D;
  tbl.glConvolutionParameterf = loader_glConvolutionParameterf;
  tbl.glConvolutionParameterfv = loader_glConvolutionParameterfv;
  tbl.glConvolutionParameteri = loader_glConvolutionParameteri;
  tbl.glConvolutionParameteriv = loader_glConvolutionParameteriv;
  tbl.glCopyColorSubTable = loader_glCopyColorSubTable;
  tbl.glCopyColorTable = loader_glCopyColorTable;
  tbl.glCopyConvolutionFilter1D = loader_glCopyConvolutionFilter1D;
  tbl.glCopyConvolutionFilter2D = loader_glCopyConvolutionFilter2D;
  tbl.glGetColorTable = loader_glGetColorTable;
  tbl.glGetColorTableParameterfv = loader_glGetColorTableParameterfv;
  tbl.glGetColorTableParameteriv = loader_glGetColorTableParameteriv;
  tbl.glGetConvolutionFilter = loader_glGetConvolutionFilter;
  tbl.glGetConvolutionParameterfv = loader_glGetConvolutionParameterfv;
  tbl.glGetConvolutionParameteriv = loader_glGetConvolutionParameteriv;
  tbl.glGetHistogram = loader_glGetHistogram;
  tbl.glGetHistogramParameterfv = loader_glGetHistogramParameterfv;
  tbl.glGetHistogramParameteriv = loader_glGetHistogramParameteriv;
  tbl.glGetMinmax = loader_glGetMinmax;
  tbl.glGetMinmaxParameterfv = loader_glGetMinmaxParameterfv;
  tbl.glGetMinmaxParameteriv = loader_glGetMinmaxParameteriv;
  tbl.glGetSeparableFilter = loader_glGetSeparableFilter;
  tbl.glHistogram = loader_glHistogram;
  tbl.glMinmax = loader_glMinmax;
  tbl.glResetHistogram = loader_glResetHistogram;
  tbl.glResetMinmax = loader_glResetMinmax;
  tbl.glSeparableFilter2D = loader_glSeparableFilter2D;

  // GL_ARB_instanced_arrays

  tbl.glVertexAttribDivisorARB = loader_glVertexAttribDivisorARB;

  // GL_ARB_internalformat_query

  tbl.glGetInternalformativ = loader_glGetInternalformativ;

  // GL_ARB_internalformat_query2

  tbl.glGetInternalformati64v = loader_glGetInternalformati64v;

  // GL_ARB_invalidate_subdata

  tbl.glInvalidateBufferData = loader_glInvalidateBufferData;
  tbl.glInvalidateBufferSubData = loader_glInvalidateBufferSubData;
  tbl.glInvalidateFramebuffer = loader_glInvalidateFramebuffer;
  tbl.glInvalidateSubFramebuffer = loader_glInvalidateSubFramebuffer;
  tbl.glInvalidateTexImage = loader_glInvalidateTexImage;
  tbl.glInvalidateTexSubImage = loader_glInvalidateTexSubImage;

  // GL_ARB_map_buffer_range

  tbl.glFlushMappedBufferRange = loader_glFlushMappedBufferRange;
  tbl.glMapBufferRange = loader_glMapBufferRange;

  // GL_ARB_matrix_palette

  tbl.glCurrentPaletteMatrixARB = loader_glCurrentPaletteMatrixARB;
  tbl.glMatrixIndexPointerARB = loader_glMatrixIndexPointerARB;
  tbl.glMatrixIndexubvARB = loader_glMatrixIndexubvARB;
  tbl.glMatrixIndexuivARB = loader_glMatrixIndexuivARB;
  tbl.glMatrixIndexusvARB = loader_glMatrixIndexusvARB;

  // GL_ARB_multi_draw_indirect

  tbl.glMultiDrawArraysIndirect = loader_glMultiDrawArraysIndirect;
  tbl.glMultiDrawElementsIndirect = loader_glMultiDrawElementsIndirect;

  // GL_ARB_multisample

  tbl.glSampleCoverageARB = loader_glSampleCoverageARB;

  // GL_ARB_multitexture

  tbl.glActiveTextureARB = loader_glActiveTextureARB;
  tbl.glClientActiveTextureARB = loader_glClientActiveTextureARB;
  tbl.glMultiTexCoord1dARB = loader_glMultiTexCoord1dARB;
  tbl.glMultiTexCoord1dvARB = loader_glMultiTexCoord1dvARB;
  tbl.glMultiTexCoord1fARB = loader_glMultiTexCoord1fARB;
  tbl.glMultiTexCoord1fvARB = loader_glMultiTexCoord1fvARB;
  tbl.glMultiTexCoord1iARB = loader_glMultiTexCoord1iARB;
  tbl.glMultiTexCoord1ivARB = loader_glMultiTexCoord1ivARB;
  tbl.glMultiTexCoord1sARB = loader_glMultiTexCoord1sARB;
  tbl.glMultiTexCoord1svARB = loader_glMultiTexCoord1svARB;
  tbl.glMultiTexCoord2dARB = loader_glMultiTexCoord2dARB;
  tbl.glMultiTexCoord2dvARB = loader_glMultiTexCoord2dvARB;
  tbl.glMultiTexCoord2fARB = loader_glMultiTexCoord2fARB;
  tbl.glMultiTexCoord2fvARB = loader_glMultiTexCoord2fvARB;
  tbl.glMultiTexCoord2iARB = loader_glMultiTexCoord2iARB;
  tbl.glMultiTexCoord2ivARB = loader_glMultiTexCoord2ivARB;
  tbl.glMultiTexCoord2sARB = loader_glMultiTexCoord2sARB;
  tbl.glMultiTexCoord2svARB = loader_glMultiTexCoord2svARB;
  tbl.glMultiTexCoord3dARB = loader_glMultiTexCoord3dARB;
  tbl.glMultiTexCoord3dvARB = loader_glMultiTexCoord3dvARB;
  tbl.glMultiTexCoord3fARB = loader_glMultiTexCoord3fARB;
  tbl.glMultiTexCoord3fvARB = loader_glMultiTexCoord3fvARB;
  tbl.glMultiTexCoord3iARB = loader_glMultiTexCoord3iARB;
  tbl.glMultiTexCoord3ivARB = loader_glMultiTexCoord3ivARB;
  tbl.glMultiTexCoord3sARB = loader_glMultiTexCoord3sARB;
  tbl.glMultiTexCoord3svARB = loader_glMultiTexCoord3svARB;
  tbl.glMultiTexCoord4dARB = loader_glMultiTexCoord4dARB;
  tbl.glMultiTexCoord4dvARB = loader_glMultiTexCoord4dvARB;
  tbl.glMultiTexCoord4fARB = loader_glMultiTexCoord4fARB;
  tbl.glMultiTexCoord4fvARB = loader_glMultiTexCoord4fvARB;
  tbl.glMultiTexCoord4iARB = loader_glMultiTexCoord4iARB;
  tbl.glMultiTexCoord4ivARB = loader_glMultiTexCoord4ivARB;
  tbl.glMultiTexCoord4sARB = loader_glMultiTexCoord4sARB;
  tbl.glMultiTexCoord4svARB = loader_glMultiTexCoord4svARB;

  // GL_ARB_occlusion_query

  tbl.glBeginQueryARB = loader_glBeginQueryARB;
  tbl.glDeleteQueriesARB = loader_glDeleteQueriesARB;
  tbl.glEndQueryARB = loader_glEndQueryARB;
  tbl.glGenQueriesARB = loader_glGenQueriesARB;
  tbl.glGetQueryObjectivARB = loader_glGetQueryObjectivARB;
  tbl.glGetQueryObjectuivARB = loader_glGetQueryObjectuivARB;
  tbl.glGetQueryivARB = loader_glGetQueryivARB;
  tbl.glIsQueryARB = loader_glIsQueryARB;

  // GL_ARB_point_parameters

  tbl.glPointParameterfARB = loader_glPointParameterfARB;
  tbl.glPointParameterfvARB = loader_glPointParameterfvARB;

  // GL_ARB_program_interface_query

  tbl.glGetProgramInterfaceiv = loader_glGetProgramInterfaceiv;
  tbl.glGetProgramResourceIndex = loader_glGetProgramResourceIndex;
  tbl.glGetProgramResourceLocation = loader_glGetProgramResourceLocation;
  tbl.glGetProgramResourceLocationIndex = loader_glGetProgramResourceLocationIndex;
  tbl.glGetProgramResourceName = loader_glGetProgramResourceName;
  tbl.glGetProgramResourceiv = loader_glGetProgramResourceiv;

  // GL_ARB_provoking_vertex

  tbl.glProvokingVertex = loader_glProvokingVertex;

  // GL_ARB_robustness

  tbl.glGetGraphicsResetStatusARB = loader_glGetGraphicsResetStatusARB;
  tbl.glGetnColorTableARB = loader_glGetnColorTableARB;
  tbl.glGetnCompressedTexImageARB = loader_glGetnCompressedTexImageARB;
  tbl.glGetnConvolutionFilterARB = loader_glGetnConvolutionFilterARB;
  tbl.glGetnHistogramARB = loader_glGetnHistogramARB;
  tbl.glGetnMapdvARB = loader_glGetnMapdvARB;
  tbl.glGetnMapfvARB = loader_glGetnMapfvARB;
  tbl.glGetnMapivARB = loader_glGetnMapivARB;
  tbl.glGetnMinmaxARB = loader_glGetnMinmaxARB;
  tbl.glGetnPixelMapfvARB = loader_glGetnPixelMapfvARB;
  tbl.glGetnPixelMapuivARB = loader_glGetnPixelMapuivARB;
  tbl.glGetnPixelMapusvARB = loader_glGetnPixelMapusvARB;
  tbl.glGetnPolygonStippleARB = loader_glGetnPolygonStippleARB;
  tbl.glGetnSeparableFilterARB = loader_glGetnSeparableFilterARB;
  tbl.glGetnTexImageARB = loader_glGetnTexImageARB;
  tbl.glGetnUniformdvARB = loader_glGetnUniformdvARB;
  tbl.glGetnUniformfvARB = loader_glGetnUniformfvARB;
  tbl.glGetnUniformivARB = loader_glGetnUniformivARB;
  tbl.glGetnUniformuivARB = loader_glGetnUniformuivARB;
  tbl.glReadnPixelsARB = loader_glReadnPixelsARB;

  // GL_ARB_sample_shading

  tbl.glMinSampleShading = loader_glMinSampleShading;
  tbl.glMinSampleShadingARB = loader_glMinSampleShadingARB;

  // GL_ARB_sampler_objects

  tbl.glBindSampler = loader_glBindSampler;
  tbl.glDeleteSamplers = loader_glDeleteSamplers;
  tbl.glGenSamplers = loader_glGenSamplers;
  tbl.glGetSamplerParameterIiv = loader_glGetSamplerParameterIiv;
  tbl.glGetSamplerParameterIuiv = loader_glGetSamplerParameterIuiv;
  tbl.glGetSamplerParameterfv = loader_glGetSamplerParameterfv;
  tbl.glGetSamplerParameteriv = loader_glGetSamplerParameteriv;
  tbl.glIsSampler = loader_glIsSampler;
  tbl.glSamplerParameterIiv = loader_glSamplerParameterIiv;
  tbl.glSamplerParameterIuiv = loader_glSamplerParameterIuiv;
  tbl.glSamplerParameterf = loader_glSamplerParameterf;
  tbl.glSamplerParameterfv = loader_glSamplerParameterfv;
  tbl.glSamplerParameteri = loader_glSamplerParameteri;
  tbl.glSamplerParameteriv = loader_glSamplerParameteriv;

  // GL_ARB_separate_shader_objects

  tbl.glActiveShaderProgram = loader_glActiveShaderProgram;
  tbl.glBindProgramPipeline = loader_glBindProgramPipeline;
  tbl.glCreateShaderProgramv = loader_glCreateShaderProgramv;
  tbl.glDeleteProgramPipelines = loader_glDeleteProgramPipelines;
  tbl.glGenProgramPipelines = loader_glGenProgramPipelines;
  tbl.glGetProgramPipelineInfoLog = loader_glGetProgramPipelineInfoLog;
  tbl.glGetProgramPipelineiv = loader_glGetProgramPipelineiv;
  tbl.glIsProgramPipeline = loader_glIsProgramPipeline;
  tbl.glProgramUniform1d = loader_glProgramUniform1d;
  tbl.glProgramUniform1dv = loader_glProgramUniform1dv;
  tbl.glProgramUniform1f = loader_glProgramUniform1f;
  tbl.glProgramUniform1fv = loader_glProgramUniform1fv;
  tbl.glProgramUniform1i = loader_glProgramUniform1i;
  tbl.glProgramUniform1iv = loader_glProgramUniform1iv;
  tbl.glProgramUniform1ui = loader_glProgramUniform1ui;
  tbl.glProgramUniform1uiv = loader_glProgramUniform1uiv;
  tbl.glProgramUniform2d = loader_glProgramUniform2d;
  tbl.glProgramUniform2dv = loader_glProgramUniform2dv;
  tbl.glProgramUniform2f = loader_glProgramUniform2f;
  tbl.glProgramUniform2fv = loader_glProgramUniform2fv;
  tbl.glProgramUniform2i = loader_glProgramUniform2i;
  tbl.glProgramUniform2iv = loader_glProgramUniform2iv;
  tbl.glProgramUniform2ui = loader_glProgramUniform2ui;
  tbl.glProgramUniform2uiv = loader_glProgramUniform2uiv;
  tbl.glProgramUniform3d = loader_glProgramUniform3d;
  tbl.glProgramUniform3dv = loader_glProgramUniform3dv;
  tbl.glProgramUniform3f = loader_glProgramUniform3f;
  tbl.glProgramUniform3fv = loader_glProgramUniform3fv;
  tbl.glProgramUniform3i = loader_glProgramUniform3i;
  tbl.glProgramUniform3iv = loader_glProgramUniform3iv;
  tbl.glProgramUniform3ui = loader_glProgramUniform3ui;
  tbl.glProgramUniform3uiv = loader_glProgramUniform3uiv;
  tbl.glProgramUniform4d = loader_glProgramUniform4d;
  tbl.glProgramUniform4dv = loader_glProgramUniform4dv;
  tbl.glProgramUniform4f = loader_glProgramUniform4f;
  tbl.glProgramUniform4fv = loader_glProgramUniform4fv;
  tbl.glProgramUniform4i = loader_glProgramUniform4i;
  tbl.glProgramUniform4iv = loader_glProgramUniform4iv;
  tbl.glProgramUniform4ui = loader_glProgramUniform4ui;
  tbl.glProgramUniform4uiv = loader_glProgramUniform4uiv;
  tbl.glProgramUniformMatrix2dv = loader_glProgramUniformMatrix2dv;
  tbl.glProgramUniformMatrix2fv = loader_glProgramUniformMatrix2fv;
  tbl.glProgramUniformMatrix2x3dv = loader_glProgramUniformMatrix2x3dv;
  tbl.glProgramUniformMatrix2x3fv = loader_glProgramUniformMatrix2x3fv;
  tbl.glProgramUniformMatrix2x4dv = loader_glProgramUniformMatrix2x4dv;
  tbl.glProgramUniformMatrix2x4fv = loader_glProgramUniformMatrix2x4fv;
  tbl.glProgramUniformMatrix3dv = loader_glProgramUniformMatrix3dv;
  tbl.glProgramUniformMatrix3fv = loader_glProgramUniformMatrix3fv;
  tbl.glProgramUniformMatrix3x2dv = loader_glProgramUniformMatrix3x2dv;
  tbl.glProgramUniformMatrix3x2fv = loader_glProgramUniformMatrix3x2fv;
  tbl.glProgramUniformMatrix3x4dv = loader_glProgramUniformMatrix3x4dv;
  tbl.glProgramUniformMatrix3x4fv = loader_glProgramUniformMatrix3x4fv;
  tbl.glProgramUniformMatrix4dv = loader_glProgramUniformMatrix4dv;
  tbl.glProgramUniformMatrix4fv = loader_glProgramUniformMatrix4fv;
  tbl.glProgramUniformMatrix4x2dv = loader_glProgramUniformMatrix4x2dv;
  tbl.glProgramUniformMatrix4x2fv = loader_glProgramUniformMatrix4x2fv;
  tbl.glProgramUniformMatrix4x3dv = loader_glProgramUniformMatrix4x3dv;
  tbl.glProgramUniformMatrix4x3fv = loader_glProgramUniformMatrix4x3fv;
  tbl.glUseProgramStages = loader_glUseProgramStages;
  tbl.glValidateProgramPipeline = loader_glValidateProgramPipeline;

  // GL_ARB_shader_atomic_counters

  tbl.glGetActiveAtomicCounterBufferiv = loader_glGetActiveAtomicCounterBufferiv;

  // GL_ARB_shader_image_load_store

  tbl.glBindImageTexture = loader_glBindImageTexture;
  tbl.glMemoryBarrier = loader_glMemoryBarrier;

  // GL_ARB_shader_objects

  tbl.glAttachObjectARB = loader_glAttachObjectARB;
  tbl.glCompileShaderARB = loader_glCompileShaderARB;
  tbl.glCreateProgramObjectARB = loader_glCreateProgramObjectARB;
  tbl.glCreateShaderObjectARB = loader_glCreateShaderObjectARB;
  tbl.glDeleteObjectARB = loader_glDeleteObjectARB;
  tbl.glDetachObjectARB = loader_glDetachObjectARB;
  tbl.glGetActiveUniformARB = loader_glGetActiveUniformARB;
  tbl.glGetAttachedObjectsARB = loader_glGetAttachedObjectsARB;
  tbl.glGetHandleARB = loader_glGetHandleARB;
  tbl.glGetInfoLogARB = loader_glGetInfoLogARB;
  tbl.glGetObjectParameterfvARB = loader_glGetObjectParameterfvARB;
  tbl.glGetObjectParameterivARB = loader_glGetObjectParameterivARB;
  tbl.glGetShaderSourceARB = loader_glGetShaderSourceARB;
  tbl.glGetUniformLocationARB = loader_glGetUniformLocationARB;
  tbl.glGetUniformfvARB = loader_glGetUniformfvARB;
  tbl.glGetUniformivARB = loader_glGetUniformivARB;
  tbl.glLinkProgramARB = loader_glLinkProgramARB;
  tbl.glShaderSourceARB = loader_glShaderSourceARB;
  tbl.glUniform1fARB = loader_glUniform1fARB;
  tbl.glUniform1fvARB = loader_glUniform1fvARB;
  tbl.glUniform1iARB = loader_glUniform1iARB;
  tbl.glUniform1ivARB = loader_glUniform1ivARB;
  tbl.glUniform2fARB = loader_glUniform2fARB;
  tbl.glUniform2fvARB = loader_glUniform2fvARB;
  tbl.glUniform2iARB = loader_glUniform2iARB;
  tbl.glUniform2ivARB = loader_glUniform2ivARB;
  tbl.glUniform3fARB = loader_glUniform3fARB;
  tbl.glUniform3fvARB = loader_glUniform3fvARB;
  tbl.glUniform3iARB = loader_glUniform3iARB;
  tbl.glUniform3ivARB = loader_glUniform3ivARB;
  tbl.glUniform4fARB = loader_glUniform4fARB;
  tbl.glUniform4fvARB = loader_glUniform4fvARB;
  tbl.glUniform4iARB = loader_glUniform4iARB;
  tbl.glUniform4ivARB = loader_glUniform4ivARB;
  tbl.glUniformMatrix2fvARB = loader_glUniformMatrix2fvARB;
  tbl.glUniformMatrix3fvARB = loader_glUniformMatrix3fvARB;
  tbl.glUniformMatrix4fvARB = loader_glUniformMatrix4fvARB;
  tbl.glUseProgramObjectARB = loader_glUseProgramObjectARB;
  tbl.glValidateProgramARB = loader_glValidateProgramARB;

  // GL_ARB_shader_storage_buffer_object

  tbl.glShaderStorageBlockBinding = loader_glShaderStorageBlockBinding;

  // GL_ARB_shader_subroutine

  tbl.glGetActiveSubroutineName = loader_glGetActiveSubroutineName;
  tbl.glGetActiveSubroutineUniformName = loader_glGetActiveSubroutineUniformName;
  tbl.glGetActiveSubroutineUniformiv = loader_glGetActiveSubroutineUniformiv;
  tbl.glGetProgramStageiv = loader_glGetProgramStageiv;
  tbl.glGetSubroutineIndex = loader_glGetSubroutineIndex;
  tbl.glGetSubroutineUniformLocation = loader_glGetSubroutineUniformLocation;
  tbl.glGetUniformSubroutineuiv = loader_glGetUniformSubroutineuiv;
  tbl.glUniformSubroutinesuiv = loader_glUniformSubroutinesuiv;

  // GL_ARB_shading_language_include

  tbl.glCompileShaderIncludeARB = loader_glCompileShaderIncludeARB;
  tbl.glDeleteNamedStringARB = loader_glDeleteNamedStringARB;
  tbl.glGetNamedStringARB = loader_glGetNamedStringARB;
  tbl.glGetNamedStringivARB = loader_glGetNamedStringivARB;
  tbl.glIsNamedStringARB = loader_glIsNamedStringARB;
  tbl.glNamedStringARB = loader_glNamedStringARB;

  // GL_ARB_sync

  tbl.glClientWaitSync = loader_glClientWaitSync;
  tbl.glDeleteSync = loader_glDeleteSync;
  tbl.glFenceSync = loader_glFenceSync;
  tbl.glGetInteger64v = loader_glGetInteger64v;
  tbl.glGetSynciv = loader_glGetSynciv;
  tbl.glIsSync = loader_glIsSync;
  tbl.glWaitSync = loader_glWaitSync;

  // GL_ARB_tessellation_shader

  tbl.glPatchParameterfv = loader_glPatchParameterfv;
  tbl.glPatchParameteri = loader_glPatchParameteri;

  // GL_ARB_texture_buffer_object

  tbl.glTexBufferARB = loader_glTexBufferARB;

  // GL_ARB_texture_buffer_range

  tbl.glTexBufferRange = loader_glTexBufferRange;
  tbl.glTextureBufferRangeEXT = loader_glTextureBufferRangeEXT;

  // GL_ARB_texture_compression

  tbl.glCompressedTexImage1DARB = loader_glCompressedTexImage1DARB;
  tbl.glCompressedTexImage2DARB = loader_glCompressedTexImage2DARB;
  tbl.glCompressedTexImage3DARB = loader_glCompressedTexImage3DARB;
  tbl.glCompressedTexSubImage1DARB = loader_glCompressedTexSubImage1DARB;
  tbl.glCompressedTexSubImage2DARB = loader_glCompressedTexSubImage2DARB;
  tbl.glCompressedTexSubImage3DARB = loader_glCompressedTexSubImage3DARB;
  tbl.glGetCompressedTexImageARB = loader_glGetCompressedTexImageARB;

  // GL_ARB_texture_multisample

  tbl.glGetMultisamplefv = loader_glGetMultisamplefv;
  tbl.glSampleMaski = loader_glSampleMaski;
  tbl.glTexImage2DMultisample = loader_glTexImage2DMultisample;
  tbl.glTexImage3DMultisample = loader_glTexImage3DMultisample;

  // GL_ARB_texture_storage

  tbl.glTexStorage1D = loader_glTexStorage1D;
  tbl.glTexStorage2D = loader_glTexStorage2D;
  tbl.glTexStorage3D = loader_glTexStorage3D;
  tbl.glTextureStorage1DEXT = loader_glTextureStorage1DEXT;
  tbl.glTextureStorage2DEXT = loader_glTextureStorage2DEXT;
  tbl.glTextureStorage3DEXT = loader_glTextureStorage3DEXT;

  // GL_ARB_texture_storage_multisample

  tbl.glTexStorage2DMultisample = loader_glTexStorage2DMultisample;
  tbl.glTexStorage3DMultisample = loader_glTexStorage3DMultisample;
  tbl.glTextureStorage2DMultisampleEXT = loader_glTextureStorage2DMultisampleEXT;
  tbl.glTextureStorage3DMultisampleEXT = loader_glTextureStorage3DMultisampleEXT;

  // GL_ARB_texture_view

  tbl.glTextureView = loader_glTextureView;

  // GL_ARB_timer_query

  tbl.glGetQueryObjecti64v = loader_glGetQueryObjecti64v;
  tbl.glGetQueryObjectui64v = loader_glGetQueryObjectui64v;
  tbl.glQueryCounter = loader_glQueryCounter;

  // GL_ARB_transform_feedback2

  tbl.glBindTransformFeedback = loader_glBindTransformFeedback;
  tbl.glDeleteTransformFeedbacks = loader_glDeleteTransformFeedbacks;
  tbl.glDrawTransformFeedback = loader_glDrawTransformFeedback;
  tbl.glGenTransformFeedbacks = loader_glGenTransformFeedbacks;
  tbl.glIsTransformFeedback = loader_glIsTransformFeedback;
  tbl.glPauseTransformFeedback = loader_glPauseTransformFeedback;
  tbl.glResumeTransformFeedback = loader_glResumeTransformFeedback;

  // GL_ARB_transform_feedback3

  tbl.glBeginQueryIndexed = loader_glBeginQueryIndexed;
  tbl.glDrawTransformFeedbackStream = loader_glDrawTransformFeedbackStream;
  tbl.glEndQueryIndexed = loader_glEndQueryIndexed;
  tbl.glGetQueryIndexediv = loader_glGetQueryIndexediv;

  // GL_ARB_transform_feedback_instanced

  tbl.glDrawTransformFeedbackInstanced = loader_glDrawTransformFeedbackInstanced;
  tbl.glDrawTransformFeedbackStreamInstanced = loader_glDrawTransformFeedbackStreamInstanced;

  // GL_ARB_transpose_matrix

  tbl.glLoadTransposeMatrixdARB = loader_glLoadTransposeMatrixdARB;
  tbl.glLoadTransposeMatrixfARB = loader_glLoadTransposeMatrixfARB;
  tbl.glMultTransposeMatrixdARB = loader_glMultTransposeMatrixdARB;
  tbl.glMultTransposeMatrixfARB = loader_glMultTransposeMatrixfARB;

  // GL_ARB_uniform_buffer_object

  tbl.glBindBufferBase = loader_glBindBufferBase;
  tbl.glBindBufferRange = loader_glBindBufferRange;
  tbl.glGetActiveUniformBlockName = loader_glGetActiveUniformBlockName;
  tbl.glGetActiveUniformBlockiv = loader_glGetActiveUniformBlockiv;
  tbl.glGetActiveUniformName = loader_glGetActiveUniformName;
  tbl.glGetActiveUniformsiv = loader_glGetActiveUniformsiv;
  tbl.glGetIntegeri_v = loader_glGetIntegeri_v;
  tbl.glGetUniformBlockIndex = loader_glGetUniformBlockIndex;
  tbl.glGetUniformIndices = loader_glGetUniformIndices;
  tbl.glUniformBlockBinding = loader_glUniformBlockBinding;

  // GL_ARB_vertex_array_object

  tbl.glBindVertexArray = loader_glBindVertexArray;
  tbl.glDeleteVertexArrays = loader_glDeleteVertexArrays;
  tbl.glGenVertexArrays = loader_glGenVertexArrays;
  tbl.glIsVertexArray = loader_glIsVertexArray;

  // GL_ARB_vertex_attrib_64bit

  tbl.glGetVertexAttribLdv = loader_glGetVertexAttribLdv;
  tbl.glVertexAttribL1d = loader_glVertexAttribL1d;
  tbl.glVertexAttribL1dv = loader_glVertexAttribL1dv;
  tbl.glVertexAttribL2d = loader_glVertexAttribL2d;
  tbl.glVertexAttribL2dv = loader_glVertexAttribL2dv;
  tbl.glVertexAttribL3d = loader_glVertexAttribL3d;
  tbl.glVertexAttribL3dv = loader_glVertexAttribL3dv;
  tbl.glVertexAttribL4d = loader_glVertexAttribL4d;
  tbl.glVertexAttribL4dv = loader_glVertexAttribL4dv;
  tbl.glVertexAttribLPointer = loader_glVertexAttribLPointer;

  // GL_ARB_vertex_attrib_binding

  tbl.glBindVertexBuffer = loader_glBindVertexBuffer;
  tbl.glVertexAttribBinding = loader_glVertexAttribBinding;
  tbl.glVertexAttribFormat = loader_glVertexAttribFormat;
  tbl.glVertexAttribIFormat = loader_glVertexAttribIFormat;
  tbl.glVertexAttribLFormat = loader_glVertexAttribLFormat;
  tbl.glVertexBindingDivisor = loader_glVertexBindingDivisor;

  // GL_ARB_vertex_blend

  tbl.glVertexBlendARB = loader_glVertexBlendARB;
  tbl.glWeightPointerARB = loader_glWeightPointerARB;
  tbl.glWeightbvARB = loader_glWeightbvARB;
  tbl.glWeightdvARB = loader_glWeightdvARB;
  tbl.glWeightfvARB = loader_glWeightfvARB;
  tbl.glWeightivARB = loader_glWeightivARB;
  tbl.glWeightsvARB = loader_glWeightsvARB;
  tbl.glWeightubvARB = loader_glWeightubvARB;
  tbl.glWeightuivARB = loader_glWeightuivARB;
  tbl.glWeightusvARB = loader_glWeightusvARB;

  // GL_ARB_vertex_buffer_object

  tbl.glBindBufferARB = loader_glBindBufferARB;
  tbl.glBufferDataARB = loader_glBufferDataARB;
  tbl.glBufferSubDataARB = loader_glBufferSubDataARB;
  tbl.glDeleteBuffersARB = loader_glDeleteBuffersARB;
  tbl.glGenBuffersARB = loader_glGenBuffersARB;
  tbl.glGetBufferParameterivARB = loader_glGetBufferParameterivARB;
  tbl.glGetBufferPointervARB = loader_glGetBufferPointervARB;
  tbl.glGetBufferSubDataARB = loader_glGetBufferSubDataARB;
  tbl.glIsBufferARB = loader_glIsBufferARB;
  tbl.glMapBufferARB = loader_glMapBufferARB;
  tbl.glUnmapBufferARB = loader_glUnmapBufferARB;

  // GL_ARB_vertex_program

  tbl.glBindProgramARB = loader_glBindProgramARB;
  tbl.glDeleteProgramsARB = loader_glDeleteProgramsARB;
  tbl.glDisableVertexAttribArrayARB = loader_glDisableVertexAttribArrayARB;
  tbl.glEnableVertexAttribArrayARB = loader_glEnableVertexAttribArrayARB;
  tbl.glGenProgramsARB = loader_glGenProgramsARB;
  tbl.glGetProgramEnvParameterdvARB = loader_glGetProgramEnvParameterdvARB;
  tbl.glGetProgramEnvParameterfvARB = loader_glGetProgramEnvParameterfvARB;
  tbl.glGetProgramLocalParameterdvARB = loader_glGetProgramLocalParameterdvARB;
  tbl.glGetProgramLocalParameterfvARB = loader_glGetProgramLocalParameterfvARB;
  tbl.glGetProgramStringARB = loader_glGetProgramStringARB;
  tbl.glGetProgramivARB = loader_glGetProgramivARB;
  tbl.glGetVertexAttribPointervARB = loader_glGetVertexAttribPointervARB;
  tbl.glGetVertexAttribdvARB = loader_glGetVertexAttribdvARB;
  tbl.glGetVertexAttribfvARB = loader_glGetVertexAttribfvARB;
  tbl.glGetVertexAttribivARB = loader_glGetVertexAttribivARB;
  tbl.glIsProgramARB = loader_glIsProgramARB;
  tbl.glProgramEnvParameter4dARB = loader_glProgramEnvParameter4dARB;
  tbl.glProgramEnvParameter4dvARB = loader_glProgramEnvParameter4dvARB;
  tbl.glProgramEnvParameter4fARB = loader_glProgramEnvParameter4fARB;
  tbl.glProgramEnvParameter4fvARB = loader_glProgramEnvParameter4fvARB;
  tbl.glProgramLocalParameter4dARB = loader_glProgramLocalParameter4dARB;
  tbl.glProgramLocalParameter4dvARB = loader_glProgramLocalParameter4dvARB;
  tbl.glProgramLocalParameter4fARB = loader_glProgramLocalParameter4fARB;
  tbl.glProgramLocalParameter4fvARB = loader_glProgramLocalParameter4fvARB;
  tbl.glProgramStringARB = loader_glProgramStringARB;
  tbl.glVertexAttrib1dARB = loader_glVertexAttrib1dARB;
  tbl.glVertexAttrib1dvARB = loader_glVertexAttrib1dvARB;
  tbl.glVertexAttrib1fARB = loader_glVertexAttrib1fARB;
  tbl.glVertexAttrib1fvARB = loader_glVertexAttrib1fvARB;
  tbl.glVertexAttrib1sARB = loader_glVertexAttrib1sARB;
  tbl.glVertexAttrib1svARB = loader_glVertexAttrib1svARB;
  tbl.glVertexAttrib2dARB = loader_glVertexAttrib2dARB;
  tbl.glVertexAttrib2dvARB = loader_glVertexAttrib2dvARB;
  tbl.glVertexAttrib2fARB = loader_glVertexAttrib2fARB;
  tbl.glVertexAttrib2fvARB = loader_glVertexAttrib2fvARB;
  tbl.glVertexAttrib2sARB = loader_glVertexAttrib2sARB;
  tbl.glVertexAttrib2svARB = loader_glVertexAttrib2svARB;
  tbl.glVertexAttrib3dARB = loader_glVertexAttrib3dARB;
  tbl.glVertexAttrib3dvARB = loader_glVertexAttrib3dvARB;
  tbl.glVertexAttrib3fARB = loader_glVertexAttrib3fARB;
  tbl.glVertexAttrib3fvARB = loader_glVertexAttrib3fvARB;
  tbl.glVertexAttrib3sARB = loader_glVertexAttrib3sARB;
  tbl.glVertexAttrib3svARB = loader_glVertexAttrib3svARB;
  tbl.glVertexAttrib4NbvARB = loader_glVertexAttrib4NbvARB;
  tbl.glVertexAttrib4NivARB = loader_glVertexAttrib4NivARB;
  tbl.glVertexAttrib4NsvARB = loader_glVertexAttrib4NsvARB;
  tbl.glVertexAttrib4NubARB = loader_glVertexAttrib4NubARB;
  tbl.glVertexAttrib4NubvARB = loader_glVertexAttrib4NubvARB;
  tbl.glVertexAttrib4NuivARB = loader_glVertexAttrib4NuivARB;
  tbl.glVertexAttrib4NusvARB = loader_glVertexAttrib4NusvARB;
  tbl.glVertexAttrib4bvARB = loader_glVertexAttrib4bvARB;
  tbl.glVertexAttrib4dARB = loader_glVertexAttrib4dARB;
  tbl.glVertexAttrib4dvARB = loader_glVertexAttrib4dvARB;
  tbl.glVertexAttrib4fARB = loader_glVertexAttrib4fARB;
  tbl.glVertexAttrib4fvARB = loader_glVertexAttrib4fvARB;
  tbl.glVertexAttrib4ivARB = loader_glVertexAttrib4ivARB;
  tbl.glVertexAttrib4sARB = loader_glVertexAttrib4sARB;
  tbl.glVertexAttrib4svARB = loader_glVertexAttrib4svARB;
  tbl.glVertexAttrib4ubvARB = loader_glVertexAttrib4ubvARB;
  tbl.glVertexAttrib4uivARB = loader_glVertexAttrib4uivARB;
  tbl.glVertexAttrib4usvARB = loader_glVertexAttrib4usvARB;
  tbl.glVertexAttribPointerARB = loader_glVertexAttribPointerARB;

  // GL_ARB_vertex_shader

  tbl.glBindAttribLocationARB = loader_glBindAttribLocationARB;
  tbl.glGetActiveAttribARB = loader_glGetActiveAttribARB;
  tbl.glGetAttribLocationARB = loader_glGetAttribLocationARB;

  // GL_ARB_vertex_type_2_10_10_10_rev

  tbl.glColorP3ui = loader_glColorP3ui;
  tbl.glColorP3uiv = loader_glColorP3uiv;
  tbl.glColorP4ui = loader_glColorP4ui;
  tbl.glColorP4uiv = loader_glColorP4uiv;
  tbl.glMultiTexCoordP1ui = loader_glMultiTexCoordP1ui;
  tbl.glMultiTexCoordP1uiv = loader_glMultiTexCoordP1uiv;
  tbl.glMultiTexCoordP2ui = loader_glMultiTexCoordP2ui;
  tbl.glMultiTexCoordP2uiv = loader_glMultiTexCoordP2uiv;
  tbl.glMultiTexCoordP3ui = loader_glMultiTexCoordP3ui;
  tbl.glMultiTexCoordP3uiv = loader_glMultiTexCoordP3uiv;
  tbl.glMultiTexCoordP4ui = loader_glMultiTexCoordP4ui;
  tbl.glMultiTexCoordP4uiv = loader_glMultiTexCoordP4uiv;
  tbl.glNormalP3ui = loader_glNormalP3ui;
  tbl.glNormalP3uiv = loader_glNormalP3uiv;
  tbl.glSecondaryColorP3ui = loader_glSecondaryColorP3ui;
  tbl.glSecondaryColorP3uiv = loader_glSecondaryColorP3uiv;
  tbl.glTexCoordP1ui = loader_glTexCoordP1ui;
  tbl.glTexCoordP1uiv = loader_glTexCoordP1uiv;
  tbl.glTexCoordP2ui = loader_glTexCoordP2ui;
  tbl.glTexCoordP2uiv = loader_glTexCoordP2uiv;
  tbl.glTexCoordP3ui = loader_glTexCoordP3ui;
  tbl.glTexCoordP3uiv = loader_glTexCoordP3uiv;
  tbl.glTexCoordP4ui = loader_glTexCoordP4ui;
  tbl.glTexCoordP4uiv = loader_glTexCoordP4uiv;
  tbl.glVertexAttribP1ui = loader_glVertexAttribP1ui;
  tbl.glVertexAttribP1uiv = loader_glVertexAttribP1uiv;
  tbl.glVertexAttribP2ui = loader_glVertexAttribP2ui;
  tbl.glVertexAttribP2uiv = loader_glVertexAttribP2uiv;
  tbl.glVertexAttribP3ui = loader_glVertexAttribP3ui;
  tbl.glVertexAttribP3uiv = loader_glVertexAttribP3uiv;
  tbl.glVertexAttribP4ui = loader_glVertexAttribP4ui;
  tbl.glVertexAttribP4uiv = loader_glVertexAttribP4uiv;
  tbl.glVertexP2ui = loader_glVertexP2ui;
  tbl.glVertexP2uiv = loader_glVertexP2uiv;
  tbl.glVertexP3ui = loader_glVertexP3ui;
  tbl.glVertexP3uiv = loader_glVertexP3uiv;
  tbl.glVertexP4ui = loader_glVertexP4ui;
  tbl.glVertexP4uiv = loader_glVertexP4uiv;

  // GL_ARB_viewport_array

  tbl.glDepthRangeArrayv = loader_glDepthRangeArrayv;
  tbl.glDepthRangeIndexed = loader_glDepthRangeIndexed;
  tbl.glGetDoublei_v = loader_glGetDoublei_v;
  tbl.glGetFloati_v = loader_glGetFloati_v;
  tbl.glScissorArrayv = loader_glScissorArrayv;
  tbl.glScissorIndexed = loader_glScissorIndexed;
  tbl.glScissorIndexedv = loader_glScissorIndexedv;
  tbl.glViewportArrayv = loader_glViewportArrayv;
  tbl.glViewportIndexedf = loader_glViewportIndexedf;
  tbl.glViewportIndexedfv = loader_glViewportIndexedfv;

  // GL_ARB_window_pos

  tbl.glWindowPos2dARB = loader_glWindowPos2dARB;
  tbl.glWindowPos2dvARB = loader_glWindowPos2dvARB;
  tbl.glWindowPos2fARB = loader_glWindowPos2fARB;
  tbl.glWindowPos2fvARB = loader_glWindowPos2fvARB;
  tbl.glWindowPos2iARB = loader_glWindowPos2iARB;
  tbl.glWindowPos2ivARB = loader_glWindowPos2ivARB;
  tbl.glWindowPos2sARB = loader_glWindowPos2sARB;
  tbl.glWindowPos2svARB = loader_glWindowPos2svARB;
  tbl.glWindowPos3dARB = loader_glWindowPos3dARB;
  tbl.glWindowPos3dvARB = loader_glWindowPos3dvARB;
  tbl.glWindowPos3fARB = loader_glWindowPos3fARB;
  tbl.glWindowPos3fvARB = loader_glWindowPos3fvARB;
  tbl.glWindowPos3iARB = loader_glWindowPos3iARB;
  tbl.glWindowPos3ivARB = loader_glWindowPos3ivARB;
  tbl.glWindowPos3sARB = loader_glWindowPos3sARB;
  tbl.glWindowPos3svARB = loader_glWindowPos3svARB;

  // GL_ATI_draw_buffers

  tbl.glDrawBuffersATI = loader_glDrawBuffersATI;

  // GL_ATI_element_array

  tbl.glDrawElementArrayATI = loader_glDrawElementArrayATI;
  tbl.glDrawRangeElementArrayATI = loader_glDrawRangeElementArrayATI;
  tbl.glElementPointerATI = loader_glElementPointerATI;

  // GL_ATI_envmap_bumpmap

  tbl.glGetTexBumpParameterfvATI = loader_glGetTexBumpParameterfvATI;
  tbl.glGetTexBumpParameterivATI = loader_glGetTexBumpParameterivATI;
  tbl.glTexBumpParameterfvATI = loader_glTexBumpParameterfvATI;
  tbl.glTexBumpParameterivATI = loader_glTexBumpParameterivATI;

  // GL_ATI_fragment_shader

  tbl.glAlphaFragmentOp1ATI = loader_glAlphaFragmentOp1ATI;
  tbl.glAlphaFragmentOp2ATI = loader_glAlphaFragmentOp2ATI;
  tbl.glAlphaFragmentOp3ATI = loader_glAlphaFragmentOp3ATI;
  tbl.glBeginFragmentShaderATI = loader_glBeginFragmentShaderATI;
  tbl.glBindFragmentShaderATI = loader_glBindFragmentShaderATI;
  tbl.glColorFragmentOp1ATI = loader_glColorFragmentOp1ATI;
  tbl.glColorFragmentOp2ATI = loader_glColorFragmentOp2ATI;
  tbl.glColorFragmentOp3ATI = loader_glColorFragmentOp3ATI;
  tbl.glDeleteFragmentShaderATI = loader_glDeleteFragmentShaderATI;
  tbl.glEndFragmentShaderATI = loader_glEndFragmentShaderATI;
  tbl.glGenFragmentShadersATI = loader_glGenFragmentShadersATI;
  tbl.glPassTexCoordATI = loader_glPassTexCoordATI;
  tbl.glSampleMapATI = loader_glSampleMapATI;
  tbl.glSetFragmentShaderConstantATI = loader_glSetFragmentShaderConstantATI;

  // GL_ATI_map_object_buffer

  tbl.glMapObjectBufferATI = loader_glMapObjectBufferATI;
  tbl.glUnmapObjectBufferATI = loader_glUnmapObjectBufferATI;

  // GL_ATI_pn_triangles

  tbl.glPNTrianglesfATI = loader_glPNTrianglesfATI;
  tbl.glPNTrianglesiATI = loader_glPNTrianglesiATI;

  // GL_ATI_separate_stencil

  tbl.glStencilFuncSeparateATI = loader_glStencilFuncSeparateATI;
  tbl.glStencilOpSeparateATI = loader_glStencilOpSeparateATI;

  // GL_ATI_vertex_array_object

  tbl.glArrayObjectATI = loader_glArrayObjectATI;
  tbl.glFreeObjectBufferATI = loader_glFreeObjectBufferATI;
  tbl.glGetArrayObjectfvATI = loader_glGetArrayObjectfvATI;
  tbl.glGetArrayObjectivATI = loader_glGetArrayObjectivATI;
  tbl.glGetObjectBufferfvATI = loader_glGetObjectBufferfvATI;
  tbl.glGetObjectBufferivATI = loader_glGetObjectBufferivATI;
  tbl.glGetVariantArrayObjectfvATI = loader_glGetVariantArrayObjectfvATI;
  tbl.glGetVariantArrayObjectivATI = loader_glGetVariantArrayObjectivATI;
  tbl.glIsObjectBufferATI = loader_glIsObjectBufferATI;
  tbl.glNewObjectBufferATI = loader_glNewObjectBufferATI;
  tbl.glUpdateObjectBufferATI = loader_glUpdateObjectBufferATI;
  tbl.glVariantArrayObjectATI = loader_glVariantArrayObjectATI;

  // GL_ATI_vertex_attrib_array_object

  tbl.glGetVertexAttribArrayObjectfvATI = loader_glGetVertexAttribArrayObjectfvATI;
  tbl.glGetVertexAttribArrayObjectivATI = loader_glGetVertexAttribArrayObjectivATI;
  tbl.glVertexAttribArrayObjectATI = loader_glVertexAttribArrayObjectATI;

  // GL_ATI_vertex_streams

  tbl.glClientActiveVertexStreamATI = loader_glClientActiveVertexStreamATI;
  tbl.glNormalStream3bATI = loader_glNormalStream3bATI;
  tbl.glNormalStream3bvATI = loader_glNormalStream3bvATI;
  tbl.glNormalStream3dATI = loader_glNormalStream3dATI;
  tbl.glNormalStream3dvATI = loader_glNormalStream3dvATI;
  tbl.glNormalStream3fATI = loader_glNormalStream3fATI;
  tbl.glNormalStream3fvATI = loader_glNormalStream3fvATI;
  tbl.glNormalStream3iATI = loader_glNormalStream3iATI;
  tbl.glNormalStream3ivATI = loader_glNormalStream3ivATI;
  tbl.glNormalStream3sATI = loader_glNormalStream3sATI;
  tbl.glNormalStream3svATI = loader_glNormalStream3svATI;
  tbl.glVertexBlendEnvfATI = loader_glVertexBlendEnvfATI;
  tbl.glVertexBlendEnviATI = loader_glVertexBlendEnviATI;
  tbl.glVertexStream1dATI = loader_glVertexStream1dATI;
  tbl.glVertexStream1dvATI = loader_glVertexStream1dvATI;
  tbl.glVertexStream1fATI = loader_glVertexStream1fATI;
  tbl.glVertexStream1fvATI = loader_glVertexStream1fvATI;
  tbl.glVertexStream1iATI = loader_glVertexStream1iATI;
  tbl.glVertexStream1ivATI = loader_glVertexStream1ivATI;
  tbl.glVertexStream1sATI = loader_glVertexStream1sATI;
  tbl.glVertexStream1svATI = loader_glVertexStream1svATI;
  tbl.glVertexStream2dATI = loader_glVertexStream2dATI;
  tbl.glVertexStream2dvATI = loader_glVertexStream2dvATI;
  tbl.glVertexStream2fATI = loader_glVertexStream2fATI;
  tbl.glVertexStream2fvATI = loader_glVertexStream2fvATI;
  tbl.glVertexStream2iATI = loader_glVertexStream2iATI;
  tbl.glVertexStream2ivATI = loader_glVertexStream2ivATI;
  tbl.glVertexStream2sATI = loader_glVertexStream2sATI;
  tbl.glVertexStream2svATI = loader_glVertexStream2svATI;
  tbl.glVertexStream3dATI = loader_glVertexStream3dATI;
  tbl.glVertexStream3dvATI = loader_glVertexStream3dvATI;
  tbl.glVertexStream3fATI = loader_glVertexStream3fATI;
  tbl.glVertexStream3fvATI = loader_glVertexStream3fvATI;
  tbl.glVertexStream3iATI = loader_glVertexStream3iATI;
  tbl.glVertexStream3ivATI = loader_glVertexStream3ivATI;
  tbl.glVertexStream3sATI = loader_glVertexStream3sATI;
  tbl.glVertexStream3svATI = loader_glVertexStream3svATI;
  tbl.glVertexStream4dATI = loader_glVertexStream4dATI;
  tbl.glVertexStream4dvATI = loader_glVertexStream4dvATI;
  tbl.glVertexStream4fATI = loader_glVertexStream4fATI;
  tbl.glVertexStream4fvATI = loader_glVertexStream4fvATI;
  tbl.glVertexStream4iATI = loader_glVertexStream4iATI;
  tbl.glVertexStream4ivATI = loader_glVertexStream4ivATI;
  tbl.glVertexStream4sATI = loader_glVertexStream4sATI;
  tbl.glVertexStream4svATI = loader_glVertexStream4svATI;

  // GL_EXT_bindable_uniform

  tbl.glGetUniformBufferSizeEXT = loader_glGetUniformBufferSizeEXT;
  tbl.glGetUniformOffsetEXT = loader_glGetUniformOffsetEXT;
  tbl.glUniformBufferEXT = loader_glUniformBufferEXT;

  // GL_EXT_blend_color

  tbl.glBlendColorEXT = loader_glBlendColorEXT;

  // GL_EXT_blend_equation_separate

  tbl.glBlendEquationSeparateEXT = loader_glBlendEquationSeparateEXT;

  // GL_EXT_blend_func_separate

  tbl.glBlendFuncSeparateEXT = loader_glBlendFuncSeparateEXT;

  // GL_EXT_blend_minmax

  tbl.glBlendEquationEXT = loader_glBlendEquationEXT;

  // GL_EXT_color_subtable

  tbl.glColorSubTableEXT = loader_glColorSubTableEXT;
  tbl.glCopyColorSubTableEXT = loader_glCopyColorSubTableEXT;

  // GL_EXT_compiled_vertex_array

  tbl.glLockArraysEXT = loader_glLockArraysEXT;
  tbl.glUnlockArraysEXT = loader_glUnlockArraysEXT;

  // GL_EXT_convolution

  tbl.glConvolutionFilter1DEXT = loader_glConvolutionFilter1DEXT;
  tbl.glConvolutionFilter2DEXT = loader_glConvolutionFilter2DEXT;
  tbl.glConvolutionParameterfEXT = loader_glConvolutionParameterfEXT;
  tbl.glConvolutionParameterfvEXT = loader_glConvolutionParameterfvEXT;
  tbl.glConvolutionParameteriEXT = loader_glConvolutionParameteriEXT;
  tbl.glConvolutionParameterivEXT = loader_glConvolutionParameterivEXT;
  tbl.glCopyConvolutionFilter1DEXT = loader_glCopyConvolutionFilter1DEXT;
  tbl.glCopyConvolutionFilter2DEXT = loader_glCopyConvolutionFilter2DEXT;
  tbl.glGetConvolutionFilterEXT = loader_glGetConvolutionFilterEXT;
  tbl.glGetConvolutionParameterfvEXT = loader_glGetConvolutionParameterfvEXT;
  tbl.glGetConvolutionParameterivEXT = loader_glGetConvolutionParameterivEXT;
  tbl.glGetSeparableFilterEXT = loader_glGetSeparableFilterEXT;
  tbl.glSeparableFilter2DEXT = loader_glSeparableFilter2DEXT;

  // GL_EXT_coordinate_frame

  tbl.glBinormal3bEXT = loader_glBinormal3bEXT;
  tbl.glBinormal3bvEXT = loader_glBinormal3bvEXT;
  tbl.glBinormal3dEXT = loader_glBinormal3dEXT;
  tbl.glBinormal3dvEXT = loader_glBinormal3dvEXT;
  tbl.glBinormal3fEXT = loader_glBinormal3fEXT;
  tbl.glBinormal3fvEXT = loader_glBinormal3fvEXT;
  tbl.glBinormal3iEXT = loader_glBinormal3iEXT;
  tbl.glBinormal3ivEXT = loader_glBinormal3ivEXT;
  tbl.glBinormal3sEXT = loader_glBinormal3sEXT;
  tbl.glBinormal3svEXT = loader_glBinormal3svEXT;
  tbl.glBinormalPointerEXT = loader_glBinormalPointerEXT;
  tbl.glTangent3bEXT = loader_glTangent3bEXT;
  tbl.glTangent3bvEXT = loader_glTangent3bvEXT;
  tbl.glTangent3dEXT = loader_glTangent3dEXT;
  tbl.glTangent3dvEXT = loader_glTangent3dvEXT;
  tbl.glTangent3fEXT = loader_glTangent3fEXT;
  tbl.glTangent3fvEXT = loader_glTangent3fvEXT;
  tbl.glTangent3iEXT = loader_glTangent3iEXT;
  tbl.glTangent3ivEXT = loader_glTangent3ivEXT;
  tbl.glTangent3sEXT = loader_glTangent3sEXT;
  tbl.glTangent3svEXT = loader_glTangent3svEXT;
  tbl.glTangentPointerEXT = loader_glTangentPointerEXT;

  // GL_EXT_copy_texture

  tbl.glCopyTexImage1DEXT = loader_glCopyTexImage1DEXT;
  tbl.glCopyTexImage2DEXT = loader_glCopyTexImage2DEXT;
  tbl.glCopyTexSubImage1DEXT = loader_glCopyTexSubImage1DEXT;
  tbl.glCopyTexSubImage2DEXT = loader_glCopyTexSubImage2DEXT;
  tbl.glCopyTexSubImage3DEXT = loader_glCopyTexSubImage3DEXT;

  // GL_EXT_cull_vertex

  tbl.glCullParameterdvEXT = loader_glCullParameterdvEXT;
  tbl.glCullParameterfvEXT = loader_glCullParameterfvEXT;

  // GL_EXT_debug_marker

  tbl.glInsertEventMarkerEXT = loader_glInsertEventMarkerEXT;
  tbl.glPopGroupMarkerEXT = loader_glPopGroupMarkerEXT;
  tbl.glPushGroupMarkerEXT = loader_glPushGroupMarkerEXT;

  // GL_EXT_depth_bounds_test

  tbl.glDepthBoundsEXT = loader_glDepthBoundsEXT;

  // GL_EXT_direct_state_access

  tbl.glBindMultiTextureEXT = loader_glBindMultiTextureEXT;
  tbl.glCheckNamedFramebufferStatusEXT = loader_glCheckNamedFramebufferStatusEXT;
  tbl.glClientAttribDefaultEXT = loader_glClientAttribDefaultEXT;
  tbl.glCompressedMultiTexImage1DEXT = loader_glCompressedMultiTexImage1DEXT;
  tbl.glCompressedMultiTexImage2DEXT = loader_glCompressedMultiTexImage2DEXT;
  tbl.glCompressedMultiTexImage3DEXT = loader_glCompressedMultiTexImage3DEXT;
  tbl.glCompressedMultiTexSubImage1DEXT = loader_glCompressedMultiTexSubImage1DEXT;
  tbl.glCompressedMultiTexSubImage2DEXT = loader_glCompressedMultiTexSubImage2DEXT;
  tbl.glCompressedMultiTexSubImage3DEXT = loader_glCompressedMultiTexSubImage3DEXT;
  tbl.glCompressedTextureImage1DEXT = loader_glCompressedTextureImage1DEXT;
  tbl.glCompressedTextureImage2DEXT = loader_glCompressedTextureImage2DEXT;
  tbl.glCompressedTextureImage3DEXT = loader_glCompressedTextureImage3DEXT;
  tbl.glCompressedTextureSubImage1DEXT = loader_glCompressedTextureSubImage1DEXT;
  tbl.glCompressedTextureSubImage2DEXT = loader_glCompressedTextureSubImage2DEXT;
  tbl.glCompressedTextureSubImage3DEXT = loader_glCompressedTextureSubImage3DEXT;
  tbl.glCopyMultiTexImage1DEXT = loader_glCopyMultiTexImage1DEXT;
  tbl.glCopyMultiTexImage2DEXT = loader_glCopyMultiTexImage2DEXT;
  tbl.glCopyMultiTexSubImage1DEXT = loader_glCopyMultiTexSubImage1DEXT;
  tbl.glCopyMultiTexSubImage2DEXT = loader_glCopyMultiTexSubImage2DEXT;
  tbl.glCopyMultiTexSubImage3DEXT = loader_glCopyMultiTexSubImage3DEXT;
  tbl.glCopyTextureImage1DEXT = loader_glCopyTextureImage1DEXT;
  tbl.glCopyTextureImage2DEXT = loader_glCopyTextureImage2DEXT;
  tbl.glCopyTextureSubImage1DEXT = loader_glCopyTextureSubImage1DEXT;
  tbl.glCopyTextureSubImage2DEXT = loader_glCopyTextureSubImage2DEXT;
  tbl.glCopyTextureSubImage3DEXT = loader_glCopyTextureSubImage3DEXT;
  tbl.glDisableClientStateIndexedEXT = loader_glDisableClientStateIndexedEXT;
  tbl.glDisableClientStateiEXT = loader_glDisableClientStateiEXT;
  tbl.glDisableVertexArrayAttribEXT = loader_glDisableVertexArrayAttribEXT;
  tbl.glDisableVertexArrayEXT = loader_glDisableVertexArrayEXT;
  tbl.glEnableClientStateIndexedEXT = loader_glEnableClientStateIndexedEXT;
  tbl.glEnableClientStateiEXT = loader_glEnableClientStateiEXT;
  tbl.glEnableVertexArrayAttribEXT = loader_glEnableVertexArrayAttribEXT;
  tbl.glEnableVertexArrayEXT = loader_glEnableVertexArrayEXT;
  tbl.glFlushMappedNamedBufferRangeEXT = loader_glFlushMappedNamedBufferRangeEXT;
  tbl.glFramebufferDrawBufferEXT = loader_glFramebufferDrawBufferEXT;
  tbl.glFramebufferDrawBuffersEXT = loader_glFramebufferDrawBuffersEXT;
  tbl.glFramebufferReadBufferEXT = loader_glFramebufferReadBufferEXT;
  tbl.glGenerateMultiTexMipmapEXT = loader_glGenerateMultiTexMipmapEXT;
  tbl.glGenerateTextureMipmapEXT = loader_glGenerateTextureMipmapEXT;
  tbl.glGetCompressedMultiTexImageEXT = loader_glGetCompressedMultiTexImageEXT;
  tbl.glGetCompressedTextureImageEXT = loader_glGetCompressedTextureImageEXT;
  tbl.glGetDoubleIndexedvEXT = loader_glGetDoubleIndexedvEXT;
  tbl.glGetDoublei_vEXT = loader_glGetDoublei_vEXT;
  tbl.glGetFloatIndexedvEXT = loader_glGetFloatIndexedvEXT;
  tbl.glGetFloati_vEXT = loader_glGetFloati_vEXT;
  tbl.glGetFramebufferParameterivEXT = loader_glGetFramebufferParameterivEXT;
  tbl.glGetMultiTexEnvfvEXT = loader_glGetMultiTexEnvfvEXT;
  tbl.glGetMultiTexEnvivEXT = loader_glGetMultiTexEnvivEXT;
  tbl.glGetMultiTexGendvEXT = loader_glGetMultiTexGendvEXT;
  tbl.glGetMultiTexGenfvEXT = loader_glGetMultiTexGenfvEXT;
  tbl.glGetMultiTexGenivEXT = loader_glGetMultiTexGenivEXT;
  tbl.glGetMultiTexImageEXT = loader_glGetMultiTexImageEXT;
  tbl.glGetMultiTexLevelParameterfvEXT = loader_glGetMultiTexLevelParameterfvEXT;
  tbl.glGetMultiTexLevelParameterivEXT = loader_glGetMultiTexLevelParameterivEXT;
  tbl.glGetMultiTexParameterIivEXT = loader_glGetMultiTexParameterIivEXT;
  tbl.glGetMultiTexParameterIuivEXT = loader_glGetMultiTexParameterIuivEXT;
  tbl.glGetMultiTexParameterfvEXT = loader_glGetMultiTexParameterfvEXT;
  tbl.glGetMultiTexParameterivEXT = loader_glGetMultiTexParameterivEXT;
  tbl.glGetNamedBufferParameterivEXT = loader_glGetNamedBufferParameterivEXT;
  tbl.glGetNamedBufferPointervEXT = loader_glGetNamedBufferPointervEXT;
  tbl.glGetNamedBufferSubDataEXT = loader_glGetNamedBufferSubDataEXT;
  tbl.glGetNamedFramebufferAttachmentParameterivEXT = loader_glGetNamedFramebufferAttachmentParameterivEXT;
  tbl.glGetNamedProgramLocalParameterIivEXT = loader_glGetNamedProgramLocalParameterIivEXT;
  tbl.glGetNamedProgramLocalParameterIuivEXT = loader_glGetNamedProgramLocalParameterIuivEXT;
  tbl.glGetNamedProgramLocalParameterdvEXT = loader_glGetNamedProgramLocalParameterdvEXT;
  tbl.glGetNamedProgramLocalParameterfvEXT = loader_glGetNamedProgramLocalParameterfvEXT;
  tbl.glGetNamedProgramStringEXT = loader_glGetNamedProgramStringEXT;
  tbl.glGetNamedProgramivEXT = loader_glGetNamedProgramivEXT;
  tbl.glGetNamedRenderbufferParameterivEXT = loader_glGetNamedRenderbufferParameterivEXT;
  tbl.glGetPointerIndexedvEXT = loader_glGetPointerIndexedvEXT;
  tbl.glGetTextureImageEXT = loader_glGetTextureImageEXT;
  tbl.glGetTextureLevelParameterfvEXT = loader_glGetTextureLevelParameterfvEXT;
  tbl.glGetTextureLevelParameterivEXT = loader_glGetTextureLevelParameterivEXT;
  tbl.glGetTextureParameterIivEXT = loader_glGetTextureParameterIivEXT;
  tbl.glGetTextureParameterIuivEXT = loader_glGetTextureParameterIuivEXT;
  tbl.glGetTextureParameterfvEXT = loader_glGetTextureParameterfvEXT;
  tbl.glGetTextureParameterivEXT = loader_glGetTextureParameterivEXT;
  tbl.glGetVertexArrayIntegeri_vEXT = loader_glGetVertexArrayIntegeri_vEXT;
  tbl.glGetVertexArrayIntegervEXT = loader_glGetVertexArrayIntegervEXT;
  tbl.glGetVertexArrayPointeri_vEXT = loader_glGetVertexArrayPointeri_vEXT;
  tbl.glGetVertexArrayPointervEXT = loader_glGetVertexArrayPointervEXT;
  tbl.glMapNamedBufferEXT = loader_glMapNamedBufferEXT;
  tbl.glMapNamedBufferRangeEXT = loader_glMapNamedBufferRangeEXT;
  tbl.glMatrixFrustumEXT = loader_glMatrixFrustumEXT;
  tbl.glMatrixLoadIdentityEXT = loader_glMatrixLoadIdentityEXT;
  tbl.glMatrixLoadTransposedEXT = loader_glMatrixLoadTransposedEXT;
  tbl.glMatrixLoadTransposefEXT = loader_glMatrixLoadTransposefEXT;
  tbl.glMatrixLoaddEXT = loader_glMatrixLoaddEXT;
  tbl.glMatrixLoadfEXT = loader_glMatrixLoadfEXT;
  tbl.glMatrixMultTransposedEXT = loader_glMatrixMultTransposedEXT;
  tbl.glMatrixMultTransposefEXT = loader_glMatrixMultTransposefEXT;
  tbl.glMatrixMultdEXT = loader_glMatrixMultdEXT;
  tbl.glMatrixMultfEXT = loader_glMatrixMultfEXT;
  tbl.glMatrixOrthoEXT = loader_glMatrixOrthoEXT;
  tbl.glMatrixPopEXT = loader_glMatrixPopEXT;
  tbl.glMatrixPushEXT = loader_glMatrixPushEXT;
  tbl.glMatrixRotatedEXT = loader_glMatrixRotatedEXT;
  tbl.glMatrixRotatefEXT = loader_glMatrixRotatefEXT;
  tbl.glMatrixScaledEXT = loader_glMatrixScaledEXT;
  tbl.glMatrixScalefEXT = loader_glMatrixScalefEXT;
  tbl.glMatrixTranslatedEXT = loader_glMatrixTranslatedEXT;
  tbl.glMatrixTranslatefEXT = loader_glMatrixTranslatefEXT;
  tbl.glMultiTexBufferEXT = loader_glMultiTexBufferEXT;
  tbl.glMultiTexCoordPointerEXT = loader_glMultiTexCoordPointerEXT;
  tbl.glMultiTexEnvfEXT = loader_glMultiTexEnvfEXT;
  tbl.glMultiTexEnvfvEXT = loader_glMultiTexEnvfvEXT;
  tbl.glMultiTexEnviEXT = loader_glMultiTexEnviEXT;
  tbl.glMultiTexEnvivEXT = loader_glMultiTexEnvivEXT;
  tbl.glMultiTexGendEXT = loader_glMultiTexGendEXT;
  tbl.glMultiTexGendvEXT = loader_glMultiTexGendvEXT;
  tbl.glMultiTexGenfEXT = loader_glMultiTexGenfEXT;
  tbl.glMultiTexGenfvEXT = loader_glMultiTexGenfvEXT;
  tbl.glMultiTexGeniEXT = loader_glMultiTexGeniEXT;
  tbl.glMultiTexGenivEXT = loader_glMultiTexGenivEXT;
  tbl.glMultiTexImage1DEXT = loader_glMultiTexImage1DEXT;
  tbl.glMultiTexImage2DEXT = loader_glMultiTexImage2DEXT;
  tbl.glMultiTexImage3DEXT = loader_glMultiTexImage3DEXT;
  tbl.glMultiTexParameterIivEXT = loader_glMultiTexParameterIivEXT;
  tbl.glMultiTexParameterIuivEXT = loader_glMultiTexParameterIuivEXT;
  tbl.glMultiTexParameterfEXT = loader_glMultiTexParameterfEXT;
  tbl.glMultiTexParameterfvEXT = loader_glMultiTexParameterfvEXT;
  tbl.glMultiTexParameteriEXT = loader_glMultiTexParameteriEXT;
  tbl.glMultiTexParameterivEXT = loader_glMultiTexParameterivEXT;
  tbl.glMultiTexRenderbufferEXT = loader_glMultiTexRenderbufferEXT;
  tbl.glMultiTexSubImage1DEXT = loader_glMultiTexSubImage1DEXT;
  tbl.glMultiTexSubImage2DEXT = loader_glMultiTexSubImage2DEXT;
  tbl.glMultiTexSubImage3DEXT = loader_glMultiTexSubImage3DEXT;
  tbl.glNamedBufferDataEXT = loader_glNamedBufferDataEXT;
  tbl.glNamedBufferSubDataEXT = loader_glNamedBufferSubDataEXT;
  tbl.glNamedCopyBufferSubDataEXT = loader_glNamedCopyBufferSubDataEXT;
  tbl.glNamedFramebufferRenderbufferEXT = loader_glNamedFramebufferRenderbufferEXT;
  tbl.glNamedFramebufferTexture1DEXT = loader_glNamedFramebufferTexture1DEXT;
  tbl.glNamedFramebufferTexture2DEXT = loader_glNamedFramebufferTexture2DEXT;
  tbl.glNamedFramebufferTexture3DEXT = loader_glNamedFramebufferTexture3DEXT;
  tbl.glNamedFramebufferTextureEXT = loader_glNamedFramebufferTextureEXT;
  tbl.glNamedFramebufferTextureFaceEXT = loader_glNamedFramebufferTextureFaceEXT;
  tbl.glNamedFramebufferTextureLayerEXT = loader_glNamedFramebufferTextureLayerEXT;
  tbl.glNamedProgramLocalParameter4dEXT = loader_glNamedProgramLocalParameter4dEXT;
  tbl.glNamedProgramLocalParameter4dvEXT = loader_glNamedProgramLocalParameter4dvEXT;
  tbl.glNamedProgramLocalParameter4fEXT = loader_glNamedProgramLocalParameter4fEXT;
  tbl.glNamedProgramLocalParameter4fvEXT = loader_glNamedProgramLocalParameter4fvEXT;
  tbl.glNamedProgramLocalParameterI4iEXT = loader_glNamedProgramLocalParameterI4iEXT;
  tbl.glNamedProgramLocalParameterI4ivEXT = loader_glNamedProgramLocalParameterI4ivEXT;
  tbl.glNamedProgramLocalParameterI4uiEXT = loader_glNamedProgramLocalParameterI4uiEXT;
  tbl.glNamedProgramLocalParameterI4uivEXT = loader_glNamedProgramLocalParameterI4uivEXT;
  tbl.glNamedProgramLocalParameters4fvEXT = loader_glNamedProgramLocalParameters4fvEXT;
  tbl.glNamedProgramLocalParametersI4ivEXT = loader_glNamedProgramLocalParametersI4ivEXT;
  tbl.glNamedProgramLocalParametersI4uivEXT = loader_glNamedProgramLocalParametersI4uivEXT;
  tbl.glNamedProgramStringEXT = loader_glNamedProgramStringEXT;
  tbl.glNamedRenderbufferStorageEXT = loader_glNamedRenderbufferStorageEXT;
  tbl.glNamedRenderbufferStorageMultisampleCoverageEXT = loader_glNamedRenderbufferStorageMultisampleCoverageEXT;
  tbl.glNamedRenderbufferStorageMultisampleEXT = loader_glNamedRenderbufferStorageMultisampleEXT;
  tbl.glProgramUniform1dEXT = loader_glProgramUniform1dEXT;
  tbl.glProgramUniform1dvEXT = loader_glProgramUniform1dvEXT;
  tbl.glProgramUniform1fEXT = loader_glProgramUniform1fEXT;
  tbl.glProgramUniform1fvEXT = loader_glProgramUniform1fvEXT;
  tbl.glProgramUniform1iEXT = loader_glProgramUniform1iEXT;
  tbl.glProgramUniform1ivEXT = loader_glProgramUniform1ivEXT;
  tbl.glProgramUniform1uiEXT = loader_glProgramUniform1uiEXT;
  tbl.glProgramUniform1uivEXT = loader_glProgramUniform1uivEXT;
  tbl.glProgramUniform2dEXT = loader_glProgramUniform2dEXT;
  tbl.glProgramUniform2dvEXT = loader_glProgramUniform2dvEXT;
  tbl.glProgramUniform2fEXT = loader_glProgramUniform2fEXT;
  tbl.glProgramUniform2fvEXT = loader_glProgramUniform2fvEXT;
  tbl.glProgramUniform2iEXT = loader_glProgramUniform2iEXT;
  tbl.glProgramUniform2ivEXT = loader_glProgramUniform2ivEXT;
  tbl.glProgramUniform2uiEXT = loader_glProgramUniform2uiEXT;
  tbl.glProgramUniform2uivEXT = loader_glProgramUniform2uivEXT;
  tbl.glProgramUniform3dEXT = loader_glProgramUniform3dEXT;
  tbl.glProgramUniform3dvEXT = loader_glProgramUniform3dvEXT;
  tbl.glProgramUniform3fEXT = loader_glProgramUniform3fEXT;
  tbl.glProgramUniform3fvEXT = loader_glProgramUniform3fvEXT;
  tbl.glProgramUniform3iEXT = loader_glProgramUniform3iEXT;
  tbl.glProgramUniform3ivEXT = loader_glProgramUniform3ivEXT;
  tbl.glProgramUniform3uiEXT = loader_glProgramUniform3uiEXT;
  tbl.glProgramUniform3uivEXT = loader_glProgramUniform3uivEXT;
  tbl.glProgramUniform4dEXT = loader_glProgramUniform4dEXT;
  tbl.glProgramUniform4dvEXT = loader_glProgramUniform4dvEXT;
  tbl.glProgramUniform4fEXT = loader_glProgramUniform4fEXT;
  tbl.glProgramUniform4fvEXT = loader_glProgramUniform4fvEXT;
  tbl.glProgramUniform4iEXT = loader_glProgramUniform4iEXT;
  tbl.glProgramUniform4ivEXT = loader_glProgramUniform4ivEXT;
  tbl.glProgramUniform4uiEXT = loader_glProgramUniform4uiEXT;
  tbl.glProgramUniform4uivEXT = loader_glProgramUniform4uivEXT;
  tbl.glProgramUniformMatrix2dvEXT = loader_glProgramUniformMatrix2dvEXT;
  tbl.glProgramUniformMatrix2fvEXT = loader_glProgramUniformMatrix2fvEXT;
  tbl.glProgramUniformMatrix2x3dvEXT = loader_glProgramUniformMatrix2x3dvEXT;
  tbl.glProgramUniformMatrix2x3fvEXT = loader_glProgramUniformMatrix2x3fvEXT;
  tbl.glProgramUniformMatrix2x4dvEXT = loader_glProgramUniformMatrix2x4dvEXT;
  tbl.glProgramUniformMatrix2x4fvEXT = loader_glProgramUniformMatrix2x4fvEXT;
  tbl.glProgramUniformMatrix3dvEXT = loader_glProgramUniformMatrix3dvEXT;
  tbl.glProgramUniformMatrix3fvEXT = loader_glProgramUniformMatrix3fvEXT;
  tbl.glProgramUniformMatrix3x2dvEXT = loader_glProgramUniformMatrix3x2dvEXT;
  tbl.glProgramUniformMatrix3x2fvEXT = loader_glProgramUniformMatrix3x2fvEXT;
  tbl.glProgramUniformMatrix3x4dvEXT = loader_glProgramUniformMatrix3x4dvEXT;
  tbl.glProgramUniformMatrix3x4fvEXT = loader_glProgramUniformMatrix3x4fvEXT;
  tbl.glProgramUniformMatrix4dvEXT = loader_glProgramUniformMatrix4dvEXT;
  tbl.glProgramUniformMatrix4fvEXT = loader_glProgramUniformMatrix4fvEXT;
  tbl.glProgramUniformMatrix4x2dvEXT = loader_glProgramUniformMatrix4x2dvEXT;
  tbl.glProgramUniformMatrix4x2fvEXT = loader_glProgramUniformMatrix4x2fvEXT;
  tbl.glProgramUniformMatrix4x3dvEXT = loader_glProgramUniformMatrix4x3dvEXT;
  tbl.glProgramUniformMatrix4x3fvEXT = loader_glProgramUniformMatrix4x3fvEXT;
  tbl.glPushClientAttribDefaultEXT = loader_glPushClientAttribDefaultEXT;
  tbl.glTextureBufferEXT = loader_glTextureBufferEXT;
  tbl.glTextureImage1DEXT = loader_glTextureImage1DEXT;
  tbl.glTextureImage2DEXT = loader_glTextureImage2DEXT;
  tbl.glTextureImage3DEXT = loader_glTextureImage3DEXT;
  tbl.glTextureParameterIivEXT = loader_glTextureParameterIivEXT;
  tbl.glTextureParameterIuivEXT = loader_glTextureParameterIuivEXT;
  tbl.glTextureParameterfEXT = loader_glTextureParameterfEXT;
  tbl.glTextureParameterfvEXT = loader_glTextureParameterfvEXT;
  tbl.glTextureParameteriEXT = loader_glTextureParameteriEXT;
  tbl.glTextureParameterivEXT = loader_glTextureParameterivEXT;
  tbl.glTextureRenderbufferEXT = loader_glTextureRenderbufferEXT;
  tbl.glTextureSubImage1DEXT = loader_glTextureSubImage1DEXT;
  tbl.glTextureSubImage2DEXT = loader_glTextureSubImage2DEXT;
  tbl.glTextureSubImage3DEXT = loader_glTextureSubImage3DEXT;
  tbl.glUnmapNamedBufferEXT = loader_glUnmapNamedBufferEXT;
  tbl.glVertexArrayColorOffsetEXT = loader_glVertexArrayColorOffsetEXT;
  tbl.glVertexArrayEdgeFlagOffsetEXT = loader_glVertexArrayEdgeFlagOffsetEXT;
  tbl.glVertexArrayFogCoordOffsetEXT = loader_glVertexArrayFogCoordOffsetEXT;
  tbl.glVertexArrayIndexOffsetEXT = loader_glVertexArrayIndexOffsetEXT;
  tbl.glVertexArrayMultiTexCoordOffsetEXT = loader_glVertexArrayMultiTexCoordOffsetEXT;
  tbl.glVertexArrayNormalOffsetEXT = loader_glVertexArrayNormalOffsetEXT;
  tbl.glVertexArraySecondaryColorOffsetEXT = loader_glVertexArraySecondaryColorOffsetEXT;
  tbl.glVertexArrayTexCoordOffsetEXT = loader_glVertexArrayTexCoordOffsetEXT;
  tbl.glVertexArrayVertexAttribIOffsetEXT = loader_glVertexArrayVertexAttribIOffsetEXT;
  tbl.glVertexArrayVertexAttribOffsetEXT = loader_glVertexArrayVertexAttribOffsetEXT;
  tbl.glVertexArrayVertexOffsetEXT = loader_glVertexArrayVertexOffsetEXT;

  // GL_EXT_draw_buffers2

  tbl.glColorMaskIndexedEXT = loader_glColorMaskIndexedEXT;
  tbl.glDisableIndexedEXT = loader_glDisableIndexedEXT;
  tbl.glEnableIndexedEXT = loader_glEnableIndexedEXT;
  tbl.glGetBooleanIndexedvEXT = loader_glGetBooleanIndexedvEXT;
  tbl.glGetIntegerIndexedvEXT = loader_glGetIntegerIndexedvEXT;
  tbl.glIsEnabledIndexedEXT = loader_glIsEnabledIndexedEXT;

  // GL_EXT_draw_instanced

  tbl.glDrawArraysInstancedEXT = loader_glDrawArraysInstancedEXT;
  tbl.glDrawElementsInstancedEXT = loader_glDrawElementsInstancedEXT;

  // GL_EXT_draw_range_elements

  tbl.glDrawRangeElementsEXT = loader_glDrawRangeElementsEXT;

  // GL_EXT_fog_coord

  tbl.glFogCoordPointerEXT = loader_glFogCoordPointerEXT;
  tbl.glFogCoorddEXT = loader_glFogCoorddEXT;
  tbl.glFogCoorddvEXT = loader_glFogCoorddvEXT;
  tbl.glFogCoordfEXT = loader_glFogCoordfEXT;
  tbl.glFogCoordfvEXT = loader_glFogCoordfvEXT;

  // GL_EXT_fragment_lighting

  tbl.glFragmentColorMaterialEXT = loader_glFragmentColorMaterialEXT;
  tbl.glFragmentLightModelfEXT = loader_glFragmentLightModelfEXT;
  tbl.glFragmentLightModelfvEXT = loader_glFragmentLightModelfvEXT;
  tbl.glFragmentLightModeliEXT = loader_glFragmentLightModeliEXT;
  tbl.glFragmentLightModelivEXT = loader_glFragmentLightModelivEXT;
  tbl.glFragmentLightfEXT = loader_glFragmentLightfEXT;
  tbl.glFragmentLightfvEXT = loader_glFragmentLightfvEXT;
  tbl.glFragmentLightiEXT = loader_glFragmentLightiEXT;
  tbl.glFragmentLightivEXT = loader_glFragmentLightivEXT;
  tbl.glFragmentMaterialfEXT = loader_glFragmentMaterialfEXT;
  tbl.glFragmentMaterialfvEXT = loader_glFragmentMaterialfvEXT;
  tbl.glFragmentMaterialiEXT = loader_glFragmentMaterialiEXT;
  tbl.glFragmentMaterialivEXT = loader_glFragmentMaterialivEXT;
  tbl.glGetFragmentLightfvEXT = loader_glGetFragmentLightfvEXT;
  tbl.glGetFragmentLightivEXT = loader_glGetFragmentLightivEXT;
  tbl.glGetFragmentMaterialfvEXT = loader_glGetFragmentMaterialfvEXT;
  tbl.glGetFragmentMaterialivEXT = loader_glGetFragmentMaterialivEXT;
  tbl.glLightEnviEXT = loader_glLightEnviEXT;

  // GL_EXT_framebuffer_blit

  tbl.glBlitFramebufferEXT = loader_glBlitFramebufferEXT;

  // GL_EXT_framebuffer_multisample

  tbl.glRenderbufferStorageMultisampleEXT = loader_glRenderbufferStorageMultisampleEXT;

  // GL_EXT_framebuffer_object

  tbl.glBindFramebufferEXT = loader_glBindFramebufferEXT;
  tbl.glBindRenderbufferEXT = loader_glBindRenderbufferEXT;
  tbl.glCheckFramebufferStatusEXT = loader_glCheckFramebufferStatusEXT;
  tbl.glDeleteFramebuffersEXT = loader_glDeleteFramebuffersEXT;
  tbl.glDeleteRenderbuffersEXT = loader_glDeleteRenderbuffersEXT;
  tbl.glFramebufferRenderbufferEXT = loader_glFramebufferRenderbufferEXT;
  tbl.glFramebufferTexture1DEXT = loader_glFramebufferTexture1DEXT;
  tbl.glFramebufferTexture2DEXT = loader_glFramebufferTexture2DEXT;
  tbl.glFramebufferTexture3DEXT = loader_glFramebufferTexture3DEXT;
  tbl.glGenFramebuffersEXT = loader_glGenFramebuffersEXT;
  tbl.glGenRenderbuffersEXT = loader_glGenRenderbuffersEXT;
  tbl.glGenerateMipmapEXT = loader_glGenerateMipmapEXT;
  tbl.glGetFramebufferAttachmentParameterivEXT = loader_glGetFramebufferAttachmentParameterivEXT;
  tbl.glGetRenderbufferParameterivEXT = loader_glGetRenderbufferParameterivEXT;
  tbl.glIsFramebufferEXT = loader_glIsFramebufferEXT;
  tbl.glIsRenderbufferEXT = loader_glIsRenderbufferEXT;
  tbl.glRenderbufferStorageEXT = loader_glRenderbufferStorageEXT;

  // GL_EXT_geometry_shader4

  tbl.glFramebufferTextureEXT = loader_glFramebufferTextureEXT;
  tbl.glFramebufferTextureFaceEXT = loader_glFramebufferTextureFaceEXT;
  tbl.glProgramParameteriEXT = loader_glProgramParameteriEXT;

  // GL_EXT_gpu_program_parameters

  tbl.glProgramEnvParameters4fvEXT = loader_glProgramEnvParameters4fvEXT;
  tbl.glProgramLocalParameters4fvEXT = loader_glProgramLocalParameters4fvEXT;

  // GL_EXT_gpu_shader4

  tbl.glBindFragDataLocationEXT = loader_glBindFragDataLocationEXT;
  tbl.glGetFragDataLocationEXT = loader_glGetFragDataLocationEXT;
  tbl.glGetUniformuivEXT = loader_glGetUniformuivEXT;
  tbl.glGetVertexAttribIivEXT = loader_glGetVertexAttribIivEXT;
  tbl.glGetVertexAttribIuivEXT = loader_glGetVertexAttribIuivEXT;
  tbl.glUniform1uiEXT = loader_glUniform1uiEXT;
  tbl.glUniform1uivEXT = loader_glUniform1uivEXT;
  tbl.glUniform2uiEXT = loader_glUniform2uiEXT;
  tbl.glUniform2uivEXT = loader_glUniform2uivEXT;
  tbl.glUniform3uiEXT = loader_glUniform3uiEXT;
  tbl.glUniform3uivEXT = loader_glUniform3uivEXT;
  tbl.glUniform4uiEXT = loader_glUniform4uiEXT;
  tbl.glUniform4uivEXT = loader_glUniform4uivEXT;
  tbl.glVertexAttribI1iEXT = loader_glVertexAttribI1iEXT;
  tbl.glVertexAttribI1ivEXT = loader_glVertexAttribI1ivEXT;
  tbl.glVertexAttribI1uiEXT = loader_glVertexAttribI1uiEXT;
  tbl.glVertexAttribI1uivEXT = loader_glVertexAttribI1uivEXT;
  tbl.glVertexAttribI2iEXT = loader_glVertexAttribI2iEXT;
  tbl.glVertexAttribI2ivEXT = loader_glVertexAttribI2ivEXT;
  tbl.glVertexAttribI2uiEXT = loader_glVertexAttribI2uiEXT;
  tbl.glVertexAttribI2uivEXT = loader_glVertexAttribI2uivEXT;
  tbl.glVertexAttribI3iEXT = loader_glVertexAttribI3iEXT;
  tbl.glVertexAttribI3ivEXT = loader_glVertexAttribI3ivEXT;
  tbl.glVertexAttribI3uiEXT = loader_glVertexAttribI3uiEXT;
  tbl.glVertexAttribI3uivEXT = loader_glVertexAttribI3uivEXT;
  tbl.glVertexAttribI4bvEXT = loader_glVertexAttribI4bvEXT;
  tbl.glVertexAttribI4iEXT = loader_glVertexAttribI4iEXT;
  tbl.glVertexAttribI4ivEXT = loader_glVertexAttribI4ivEXT;
  tbl.glVertexAttribI4svEXT = loader_glVertexAttribI4svEXT;
  tbl.glVertexAttribI4ubvEXT = loader_glVertexAttribI4ubvEXT;
  tbl.glVertexAttribI4uiEXT = loader_glVertexAttribI4uiEXT;
  tbl.glVertexAttribI4uivEXT = loader_glVertexAttribI4uivEXT;
  tbl.glVertexAttribI4usvEXT = loader_glVertexAttribI4usvEXT;
  tbl.glVertexAttribIPointerEXT = loader_glVertexAttribIPointerEXT;

  // GL_EXT_histogram

  tbl.glGetHistogramEXT = loader_glGetHistogramEXT;
  tbl.glGetHistogramParameterfvEXT = loader_glGetHistogramParameterfvEXT;
  tbl.glGetHistogramParameterivEXT = loader_glGetHistogramParameterivEXT;
  tbl.glGetMinmaxEXT = loader_glGetMinmaxEXT;
  tbl.glGetMinmaxParameterfvEXT = loader_glGetMinmaxParameterfvEXT;
  tbl.glGetMinmaxParameterivEXT = loader_glGetMinmaxParameterivEXT;
  tbl.glHistogramEXT = loader_glHistogramEXT;
  tbl.glMinmaxEXT = loader_glMinmaxEXT;
  tbl.glResetHistogramEXT = loader_glResetHistogramEXT;
  tbl.glResetMinmaxEXT = loader_glResetMinmaxEXT;

  // GL_EXT_index_func

  tbl.glIndexFuncEXT = loader_glIndexFuncEXT;

  // GL_EXT_index_material

  tbl.glIndexMaterialEXT = loader_glIndexMaterialEXT;

  // GL_EXT_light_texture

  tbl.glApplyTextureEXT = loader_glApplyTextureEXT;
  tbl.glTextureLightEXT = loader_glTextureLightEXT;
  tbl.glTextureMaterialEXT = loader_glTextureMaterialEXT;

  // GL_EXT_multi_draw_arrays

  tbl.glMultiDrawArraysEXT = loader_glMultiDrawArraysEXT;
  tbl.glMultiDrawElementsEXT = loader_glMultiDrawElementsEXT;

  // GL_EXT_multisample

  tbl.glSampleMaskEXT = loader_glSampleMaskEXT;
  tbl.glSamplePatternEXT = loader_glSamplePatternEXT;

  // GL_EXT_paletted_texture

  tbl.glColorTableEXT = loader_glColorTableEXT;
  tbl.glGetColorTableEXT = loader_glGetColorTableEXT;
  tbl.glGetColorTableParameterfvEXT = loader_glGetColorTableParameterfvEXT;
  tbl.glGetColorTableParameterivEXT = loader_glGetColorTableParameterivEXT;

  // GL_EXT_pixel_transform

  tbl.glGetPixelTransformParameterfvEXT = loader_glGetPixelTransformParameterfvEXT;
  tbl.glGetPixelTransformParameterivEXT = loader_glGetPixelTransformParameterivEXT;
  tbl.glPixelTransformParameterfEXT = loader_glPixelTransformParameterfEXT;
  tbl.glPixelTransformParameteriEXT = loader_glPixelTransformParameteriEXT;

  // GL_EXT_point_parameters

  tbl.glPointParameterfEXT = loader_glPointParameterfEXT;
  tbl.glPointParameterfvEXT = loader_glPointParameterfvEXT;

  // GL_EXT_polygon_offset

  tbl.glPolygonOffsetEXT = loader_glPolygonOffsetEXT;

  // GL_EXT_provoking_vertex

  tbl.glProvokingVertexEXT = loader_glProvokingVertexEXT;

  // GL_EXT_scene_marker

  tbl.glBeginSceneEXT = loader_glBeginSceneEXT;
  tbl.glEndSceneEXT = loader_glEndSceneEXT;

  // GL_EXT_secondary_color

  tbl.glSecondaryColor3bEXT = loader_glSecondaryColor3bEXT;
  tbl.glSecondaryColor3bvEXT = loader_glSecondaryColor3bvEXT;
  tbl.glSecondaryColor3dEXT = loader_glSecondaryColor3dEXT;
  tbl.glSecondaryColor3dvEXT = loader_glSecondaryColor3dvEXT;
  tbl.glSecondaryColor3fEXT = loader_glSecondaryColor3fEXT;
  tbl.glSecondaryColor3fvEXT = loader_glSecondaryColor3fvEXT;
  tbl.glSecondaryColor3iEXT = loader_glSecondaryColor3iEXT;
  tbl.glSecondaryColor3ivEXT = loader_glSecondaryColor3ivEXT;
  tbl.glSecondaryColor3sEXT = loader_glSecondaryColor3sEXT;
  tbl.glSecondaryColor3svEXT = loader_glSecondaryColor3svEXT;
  tbl.glSecondaryColor3ubEXT = loader_glSecondaryColor3ubEXT;
  tbl.glSecondaryColor3ubvEXT = loader_glSecondaryColor3ubvEXT;
  tbl.glSecondaryColor3uiEXT = loader_glSecondaryColor3uiEXT;
  tbl.glSecondaryColor3uivEXT = loader_glSecondaryColor3uivEXT;
  tbl.glSecondaryColor3usEXT = loader_glSecondaryColor3usEXT;
  tbl.glSecondaryColor3usvEXT = loader_glSecondaryColor3usvEXT;
  tbl.glSecondaryColorPointerEXT = loader_glSecondaryColorPointerEXT;

  // GL_EXT_separate_shader_objects

  tbl.glActiveProgramEXT = loader_glActiveProgramEXT;
  tbl.glCreateShaderProgramEXT = loader_glCreateShaderProgramEXT;
  tbl.glUseShaderProgramEXT = loader_glUseShaderProgramEXT;

  // GL_EXT_shader_image_load_store

  tbl.glBindImageTextureEXT = loader_glBindImageTextureEXT;
  tbl.glMemoryBarrierEXT = loader_glMemoryBarrierEXT;

  // GL_EXT_stencil_clear_tag

  tbl.glStencilClearTagEXT = loader_glStencilClearTagEXT;

  // GL_EXT_stencil_two_side

  tbl.glActiveStencilFaceEXT = loader_glActiveStencilFaceEXT;

  // GL_EXT_subtexture

  tbl.glTexSubImage1DEXT = loader_glTexSubImage1DEXT;
  tbl.glTexSubImage2DEXT = loader_glTexSubImage2DEXT;
  tbl.glTexSubImage3DEXT = loader_glTexSubImage3DEXT;

  // GL_EXT_texture3D

  tbl.glTexImage3DEXT = loader_glTexImage3DEXT;

  // GL_EXT_texture_array

  tbl.glFramebufferTextureLayerEXT = loader_glFramebufferTextureLayerEXT;

  // GL_EXT_texture_buffer_object

  tbl.glTexBufferEXT = loader_glTexBufferEXT;

  // GL_EXT_texture_integer

  tbl.glClearColorIiEXT = loader_glClearColorIiEXT;
  tbl.glClearColorIuiEXT = loader_glClearColorIuiEXT;
  tbl.glGetTexParameterIivEXT = loader_glGetTexParameterIivEXT;
  tbl.glGetTexParameterIuivEXT = loader_glGetTexParameterIuivEXT;
  tbl.glTexParameterIivEXT = loader_glTexParameterIivEXT;
  tbl.glTexParameterIuivEXT = loader_glTexParameterIuivEXT;

  // GL_EXT_texture_object

  tbl.glAreTexturesResidentEXT = loader_glAreTexturesResidentEXT;
  tbl.glBindTextureEXT = loader_glBindTextureEXT;
  tbl.glDeleteTexturesEXT = loader_glDeleteTexturesEXT;
  tbl.glGenTexturesEXT = loader_glGenTexturesEXT;
  tbl.glIsTextureEXT = loader_glIsTextureEXT;
  tbl.glPrioritizeTexturesEXT = loader_glPrioritizeTexturesEXT;

  // GL_EXT_texture_perturb_normal

  tbl.glTextureNormalEXT = loader_glTextureNormalEXT;

  // GL_EXT_timer_query

  tbl.glGetQueryObjecti64vEXT = loader_glGetQueryObjecti64vEXT;
  tbl.glGetQueryObjectui64vEXT = loader_glGetQueryObjectui64vEXT;

  // GL_EXT_transform_feedback

  tbl.glBeginTransformFeedbackEXT = loader_glBeginTransformFeedbackEXT;
  tbl.glBindBufferBaseEXT = loader_glBindBufferBaseEXT;
  tbl.glBindBufferOffsetEXT = loader_glBindBufferOffsetEXT;
  tbl.glBindBufferRangeEXT = loader_glBindBufferRangeEXT;
  tbl.glEndTransformFeedbackEXT = loader_glEndTransformFeedbackEXT;
  tbl.glGetTransformFeedbackVaryingEXT = loader_glGetTransformFeedbackVaryingEXT;
  tbl.glTransformFeedbackVaryingsEXT = loader_glTransformFeedbackVaryingsEXT;

  // GL_EXT_vertex_array

  tbl.glArrayElementEXT = loader_glArrayElementEXT;
  tbl.glColorPointerEXT = loader_glColorPointerEXT;
  tbl.glDrawArraysEXT = loader_glDrawArraysEXT;
  tbl.glEdgeFlagPointerEXT = loader_glEdgeFlagPointerEXT;
  tbl.glGetPointervEXT = loader_glGetPointervEXT;
  tbl.glIndexPointerEXT = loader_glIndexPointerEXT;
  tbl.glNormalPointerEXT = loader_glNormalPointerEXT;
  tbl.glTexCoordPointerEXT = loader_glTexCoordPointerEXT;
  tbl.glVertexPointerEXT = loader_glVertexPointerEXT;

  // GL_EXT_vertex_attrib_64bit

  tbl.glGetVertexAttribLdvEXT = loader_glGetVertexAttribLdvEXT;
  tbl.glVertexArrayVertexAttribLOffsetEXT = loader_glVertexArrayVertexAttribLOffsetEXT;
  tbl.glVertexAttribL1dEXT = loader_glVertexAttribL1dEXT;
  tbl.glVertexAttribL1dvEXT = loader_glVertexAttribL1dvEXT;
  tbl.glVertexAttribL2dEXT = loader_glVertexAttribL2dEXT;
  tbl.glVertexAttribL2dvEXT = loader_glVertexAttribL2dvEXT;
  tbl.glVertexAttribL3dEXT = loader_glVertexAttribL3dEXT;
  tbl.glVertexAttribL3dvEXT = loader_glVertexAttribL3dvEXT;
  tbl.glVertexAttribL4dEXT = loader_glVertexAttribL4dEXT;
  tbl.glVertexAttribL4dvEXT = loader_glVertexAttribL4dvEXT;
  tbl.glVertexAttribLPointerEXT = loader_glVertexAttribLPointerEXT;

  // GL_EXT_vertex_shader

  tbl.glBeginVertexShaderEXT = loader_glBeginVertexShaderEXT;
  tbl.glBindLightParameterEXT = loader_glBindLightParameterEXT;
  tbl.glBindMaterialParameterEXT = loader_glBindMaterialParameterEXT;
  tbl.glBindParameterEXT = loader_glBindParameterEXT;
  tbl.glBindTexGenParameterEXT = loader_glBindTexGenParameterEXT;
  tbl.glBindTextureUnitParameterEXT = loader_glBindTextureUnitParameterEXT;
  tbl.glBindVertexShaderEXT = loader_glBindVertexShaderEXT;
  tbl.glDeleteVertexShaderEXT = loader_glDeleteVertexShaderEXT;
  tbl.glDisableVariantClientStateEXT = loader_glDisableVariantClientStateEXT;
  tbl.glEnableVariantClientStateEXT = loader_glEnableVariantClientStateEXT;
  tbl.glEndVertexShaderEXT = loader_glEndVertexShaderEXT;
  tbl.glExtractComponentEXT = loader_glExtractComponentEXT;
  tbl.glGenSymbolsEXT = loader_glGenSymbolsEXT;
  tbl.glGenVertexShadersEXT = loader_glGenVertexShadersEXT;
  tbl.glGetInvariantBooleanvEXT = loader_glGetInvariantBooleanvEXT;
  tbl.glGetInvariantFloatvEXT = loader_glGetInvariantFloatvEXT;
  tbl.glGetInvariantIntegervEXT = loader_glGetInvariantIntegervEXT;
  tbl.glGetLocalConstantBooleanvEXT = loader_glGetLocalConstantBooleanvEXT;
  tbl.glGetLocalConstantFloatvEXT = loader_glGetLocalConstantFloatvEXT;
  tbl.glGetLocalConstantIntegervEXT = loader_glGetLocalConstantIntegervEXT;
  tbl.glGetVariantBooleanvEXT = loader_glGetVariantBooleanvEXT;
  tbl.glGetVariantFloatvEXT = loader_glGetVariantFloatvEXT;
  tbl.glGetVariantIntegervEXT = loader_glGetVariantIntegervEXT;
  tbl.glGetVariantPointervEXT = loader_glGetVariantPointervEXT;
  tbl.glInsertComponentEXT = loader_glInsertComponentEXT;
  tbl.glIsVariantEnabledEXT = loader_glIsVariantEnabledEXT;
  tbl.glSetInvariantEXT = loader_glSetInvariantEXT;
  tbl.glSetLocalConstantEXT = loader_glSetLocalConstantEXT;
  tbl.glShaderOp1EXT = loader_glShaderOp1EXT;
  tbl.glShaderOp2EXT = loader_glShaderOp2EXT;
  tbl.glShaderOp3EXT = loader_glShaderOp3EXT;
  tbl.glSwizzleEXT = loader_glSwizzleEXT;
  tbl.glVariantPointerEXT = loader_glVariantPointerEXT;
  tbl.glVariantbvEXT = loader_glVariantbvEXT;
  tbl.glVariantdvEXT = loader_glVariantdvEXT;
  tbl.glVariantfvEXT = loader_glVariantfvEXT;
  tbl.glVariantivEXT = loader_glVariantivEXT;
  tbl.glVariantsvEXT = loader_glVariantsvEXT;
  tbl.glVariantubvEXT = loader_glVariantubvEXT;
  tbl.glVariantuivEXT = loader_glVariantuivEXT;
  tbl.glVariantusvEXT = loader_glVariantusvEXT;
  tbl.glWriteMaskEXT = loader_glWriteMaskEXT;

  // GL_EXT_vertex_weighting

  tbl.glVertexWeightPointerEXT = loader_glVertexWeightPointerEXT;
  tbl.glVertexWeightfEXT = loader_glVertexWeightfEXT;
  tbl.glVertexWeightfvEXT = loader_glVertexWeightfvEXT;

  // GL_EXT_x11_sync_object

  tbl.glImportSyncEXT = loader_glImportSyncEXT;

  // GL_GREMEDY_frame_terminator

  tbl.glFrameTerminatorGREMEDY = loader_glFrameTerminatorGREMEDY;

  // GL_GREMEDY_string_marker

  tbl.glStringMarkerGREMEDY = loader_glStringMarkerGREMEDY;

  // GL_HP_image_transform

  tbl.glGetImageTransformParameterfvHP = loader_glGetImageTransformParameterfvHP;
  tbl.glGetImageTransformParameterivHP = loader_glGetImageTransformParameterivHP;
  tbl.glImageTransformParameterfHP = loader_glImageTransformParameterfHP;
  tbl.glImageTransformParameterfvHP = loader_glImageTransformParameterfvHP;
  tbl.glImageTransformParameteriHP = loader_glImageTransformParameteriHP;
  tbl.glImageTransformParameterivHP = loader_glImageTransformParameterivHP;

  // GL_IBM_multimode_draw_arrays

  tbl.glMultiModeDrawArraysIBM = loader_glMultiModeDrawArraysIBM;
  tbl.glMultiModeDrawElementsIBM = loader_glMultiModeDrawElementsIBM;

  // GL_IBM_vertex_array_lists

  tbl.glColorPointerListIBM = loader_glColorPointerListIBM;
  tbl.glEdgeFlagPointerListIBM = loader_glEdgeFlagPointerListIBM;
  tbl.glFogCoordPointerListIBM = loader_glFogCoordPointerListIBM;
  tbl.glIndexPointerListIBM = loader_glIndexPointerListIBM;
  tbl.glNormalPointerListIBM = loader_glNormalPointerListIBM;
  tbl.glSecondaryColorPointerListIBM = loader_glSecondaryColorPointerListIBM;
  tbl.glTexCoordPointerListIBM = loader_glTexCoordPointerListIBM;
  tbl.glVertexPointerListIBM = loader_glVertexPointerListIBM;

  // GL_INGR_blend_func_separate

  tbl.glBlendFuncSeparateINGR = loader_glBlendFuncSeparateINGR;

  // GL_INTEL_parallel_arrays

  tbl.glColorPointervINTEL = loader_glColorPointervINTEL;
  tbl.glNormalPointervINTEL = loader_glNormalPointervINTEL;
  tbl.glTexCoordPointervINTEL = loader_glTexCoordPointervINTEL;
  tbl.glVertexPointervINTEL = loader_glVertexPointervINTEL;

  // GL_INTEL_texture_scissor

  tbl.glTexScissorFuncINTEL = loader_glTexScissorFuncINTEL;
  tbl.glTexScissorINTEL = loader_glTexScissorINTEL;

  // GL_KHR_debug

  tbl.glDebugMessageCallback = loader_glDebugMessageCallback;
  tbl.glDebugMessageControl = loader_glDebugMessageControl;
  tbl.glDebugMessageInsert = loader_glDebugMessageInsert;
  tbl.glGetDebugMessageLog = loader_glGetDebugMessageLog;
  tbl.glGetObjectLabel = loader_glGetObjectLabel;
  tbl.glGetObjectPtrLabel = loader_glGetObjectPtrLabel;
  tbl.glObjectLabel = loader_glObjectLabel;
  tbl.glObjectPtrLabel = loader_glObjectPtrLabel;
  tbl.glPushDebugGroup = loader_glPushDebugGroup;

  // GL_KTX_buffer_region

  tbl.glBufferRegionEnabled = loader_glBufferRegionEnabled;
  tbl.glDeleteBufferRegion = loader_glDeleteBufferRegion;
  tbl.glDrawBufferRegion = loader_glDrawBufferRegion;
  tbl.glNewBufferRegion = loader_glNewBufferRegion;
  tbl.glReadBufferRegion = loader_glReadBufferRegion;

  // GL_MESA_resize_buffers

  tbl.glResizeBuffersMESA = loader_glResizeBuffersMESA;

  // GL_MESA_window_pos

  tbl.glWindowPos2dMESA = loader_glWindowPos2dMESA;
  tbl.glWindowPos2dvMESA = loader_glWindowPos2dvMESA;
  tbl.glWindowPos2fMESA = loader_glWindowPos2fMESA;
  tbl.glWindowPos2fvMESA = loader_glWindowPos2fvMESA;
  tbl.glWindowPos2iMESA = loader_glWindowPos2iMESA;
  tbl.glWindowPos2ivMESA = loader_glWindowPos2ivMESA;
  tbl.glWindowPos2sMESA = loader_glWindowPos2sMESA;
  tbl.glWindowPos2svMESA = loader_glWindowPos2svMESA;
  tbl.glWindowPos3dMESA = loader_glWindowPos3dMESA;
  tbl.glWindowPos3dvMESA = loader_glWindowPos3dvMESA;
  tbl.glWindowPos3fMESA = loader_glWindowPos3fMESA;
  tbl.glWindowPos3fvMESA = loader_glWindowPos3fvMESA;
  tbl.glWindowPos3iMESA = loader_glWindowPos3iMESA;
  tbl.glWindowPos3ivMESA = loader_glWindowPos3ivMESA;
  tbl.glWindowPos3sMESA = loader_glWindowPos3sMESA;
  tbl.glWindowPos3svMESA = loader_glWindowPos3svMESA;
  tbl.glWindowPos4dMESA = loader_glWindowPos4dMESA;
  tbl.glWindowPos4dvMESA = loader_glWindowPos4dvMESA;
  tbl.glWindowPos4fMESA = loader_glWindowPos4fMESA;
  tbl.glWindowPos4fvMESA = loader_glWindowPos4fvMESA;
  tbl.glWindowPos4iMESA = loader_glWindowPos4iMESA;
  tbl.glWindowPos4ivMESA = loader_glWindowPos4ivMESA;
  tbl.glWindowPos4sMESA = loader_glWindowPos4sMESA;
  tbl.glWindowPos4svMESA = loader_glWindowPos4svMESA;

  // GL_NV_bindless_texture

  tbl.glGetImageHandleNV = loader_glGetImageHandleNV;
  tbl.glGetTextureHandleNV = loader_glGetTextureHandleNV;
  tbl.glGetTextureSamplerHandleNV = loader_glGetTextureSamplerHandleNV;
  tbl.glIsImageHandleResidentNV = loader_glIsImageHandleResidentNV;
  tbl.glIsTextureHandleResidentNV = loader_glIsTextureHandleResidentNV;
  tbl.glMakeImageHandleNonResidentNV = loader_glMakeImageHandleNonResidentNV;
  tbl.glMakeImageHandleResidentNV = loader_glMakeImageHandleResidentNV;
  tbl.glMakeTextureHandleNonResidentNV = loader_glMakeTextureHandleNonResidentNV;
  tbl.glMakeTextureHandleResidentNV = loader_glMakeTextureHandleResidentNV;
  tbl.glProgramUniformHandleui64NV = loader_glProgramUniformHandleui64NV;
  tbl.glProgramUniformHandleui64vNV = loader_glProgramUniformHandleui64vNV;
  tbl.glUniformHandleui64NV = loader_glUniformHandleui64NV;
  tbl.glUniformHandleui64vNV = loader_glUniformHandleui64vNV;

  // GL_NV_conditional_render

  tbl.glBeginConditionalRenderNV = loader_glBeginConditionalRenderNV;
  tbl.glEndConditionalRenderNV = loader_glEndConditionalRenderNV;

  // GL_NV_copy_image

  tbl.glCopyImageSubDataNV = loader_glCopyImageSubDataNV;

  // GL_NV_depth_buffer_float

  tbl.glClearDepthdNV = loader_glClearDepthdNV;
  tbl.glDepthBoundsdNV = loader_glDepthBoundsdNV;
  tbl.glDepthRangedNV = loader_glDepthRangedNV;

  // GL_NV_evaluators

  tbl.glEvalMapsNV = loader_glEvalMapsNV;
  tbl.glGetMapAttribParameterfvNV = loader_glGetMapAttribParameterfvNV;
  tbl.glGetMapAttribParameterivNV = loader_glGetMapAttribParameterivNV;
  tbl.glGetMapControlPointsNV = loader_glGetMapControlPointsNV;
  tbl.glGetMapParameterfvNV = loader_glGetMapParameterfvNV;
  tbl.glGetMapParameterivNV = loader_glGetMapParameterivNV;
  tbl.glMapControlPointsNV = loader_glMapControlPointsNV;
  tbl.glMapParameterfvNV = loader_glMapParameterfvNV;
  tbl.glMapParameterivNV = loader_glMapParameterivNV;

  // GL_NV_explicit_multisample

  tbl.glGetMultisamplefvNV = loader_glGetMultisamplefvNV;
  tbl.glSampleMaskIndexedNV = loader_glSampleMaskIndexedNV;
  tbl.glTexRenderbufferNV = loader_glTexRenderbufferNV;

  // GL_NV_fence

  tbl.glDeleteFencesNV = loader_glDeleteFencesNV;
  tbl.glFinishFenceNV = loader_glFinishFenceNV;
  tbl.glGenFencesNV = loader_glGenFencesNV;
  tbl.glGetFenceivNV = loader_glGetFenceivNV;
  tbl.glIsFenceNV = loader_glIsFenceNV;
  tbl.glSetFenceNV = loader_glSetFenceNV;
  tbl.glTestFenceNV = loader_glTestFenceNV;

  // GL_NV_fragment_program

  tbl.glGetProgramNamedParameterdvNV = loader_glGetProgramNamedParameterdvNV;
  tbl.glGetProgramNamedParameterfvNV = loader_glGetProgramNamedParameterfvNV;
  tbl.glProgramNamedParameter4dNV = loader_glProgramNamedParameter4dNV;
  tbl.glProgramNamedParameter4dvNV = loader_glProgramNamedParameter4dvNV;
  tbl.glProgramNamedParameter4fNV = loader_glProgramNamedParameter4fNV;
  tbl.glProgramNamedParameter4fvNV = loader_glProgramNamedParameter4fvNV;

  // GL_NV_framebuffer_multisample_coverage

  tbl.glRenderbufferStorageMultisampleCoverageNV = loader_glRenderbufferStorageMultisampleCoverageNV;

  // GL_NV_geometry_program4

  tbl.glProgramVertexLimitNV = loader_glProgramVertexLimitNV;

  // GL_NV_gpu_program4

  tbl.glGetProgramEnvParameterIivNV = loader_glGetProgramEnvParameterIivNV;
  tbl.glGetProgramEnvParameterIuivNV = loader_glGetProgramEnvParameterIuivNV;
  tbl.glGetProgramLocalParameterIivNV = loader_glGetProgramLocalParameterIivNV;
  tbl.glGetProgramLocalParameterIuivNV = loader_glGetProgramLocalParameterIuivNV;
  tbl.glProgramEnvParameterI4iNV = loader_glProgramEnvParameterI4iNV;
  tbl.glProgramEnvParameterI4ivNV = loader_glProgramEnvParameterI4ivNV;
  tbl.glProgramEnvParameterI4uiNV = loader_glProgramEnvParameterI4uiNV;
  tbl.glProgramEnvParameterI4uivNV = loader_glProgramEnvParameterI4uivNV;
  tbl.glProgramEnvParametersI4ivNV = loader_glProgramEnvParametersI4ivNV;
  tbl.glProgramEnvParametersI4uivNV = loader_glProgramEnvParametersI4uivNV;
  tbl.glProgramLocalParameterI4iNV = loader_glProgramLocalParameterI4iNV;
  tbl.glProgramLocalParameterI4ivNV = loader_glProgramLocalParameterI4ivNV;
  tbl.glProgramLocalParameterI4uiNV = loader_glProgramLocalParameterI4uiNV;
  tbl.glProgramLocalParameterI4uivNV = loader_glProgramLocalParameterI4uivNV;
  tbl.glProgramLocalParametersI4ivNV = loader_glProgramLocalParametersI4ivNV;
  tbl.glProgramLocalParametersI4uivNV = loader_glProgramLocalParametersI4uivNV;

  // GL_NV_gpu_shader5

  tbl.glGetUniformi64vNV = loader_glGetUniformi64vNV;
  tbl.glProgramUniform1i64NV = loader_glProgramUniform1i64NV;
  tbl.glProgramUniform1i64vNV = loader_glProgramUniform1i64vNV;
  tbl.glProgramUniform1ui64NV = loader_glProgramUniform1ui64NV;
  tbl.glProgramUniform1ui64vNV = loader_glProgramUniform1ui64vNV;
  tbl.glProgramUniform2i64NV = loader_glProgramUniform2i64NV;
  tbl.glProgramUniform2i64vNV = loader_glProgramUniform2i64vNV;
  tbl.glProgramUniform2ui64NV = loader_glProgramUniform2ui64NV;
  tbl.glProgramUniform2ui64vNV = loader_glProgramUniform2ui64vNV;
  tbl.glProgramUniform3i64NV = loader_glProgramUniform3i64NV;
  tbl.glProgramUniform3i64vNV = loader_glProgramUniform3i64vNV;
  tbl.glProgramUniform3ui64NV = loader_glProgramUniform3ui64NV;
  tbl.glProgramUniform3ui64vNV = loader_glProgramUniform3ui64vNV;
  tbl.glProgramUniform4i64NV = loader_glProgramUniform4i64NV;
  tbl.glProgramUniform4i64vNV = loader_glProgramUniform4i64vNV;
  tbl.glProgramUniform4ui64NV = loader_glProgramUniform4ui64NV;
  tbl.glProgramUniform4ui64vNV = loader_glProgramUniform4ui64vNV;
  tbl.glUniform1i64NV = loader_glUniform1i64NV;
  tbl.glUniform1i64vNV = loader_glUniform1i64vNV;
  tbl.glUniform1ui64NV = loader_glUniform1ui64NV;
  tbl.glUniform1ui64vNV = loader_glUniform1ui64vNV;
  tbl.glUniform2i64NV = loader_glUniform2i64NV;
  tbl.glUniform2i64vNV = loader_glUniform2i64vNV;
  tbl.glUniform2ui64NV = loader_glUniform2ui64NV;
  tbl.glUniform2ui64vNV = loader_glUniform2ui64vNV;
  tbl.glUniform3i64NV = loader_glUniform3i64NV;
  tbl.glUniform3i64vNV = loader_glUniform3i64vNV;
  tbl.glUniform3ui64NV = loader_glUniform3ui64NV;
  tbl.glUniform3ui64vNV = loader_glUniform3ui64vNV;
  tbl.glUniform4i64NV = loader_glUniform4i64NV;
  tbl.glUniform4i64vNV = loader_glUniform4i64vNV;
  tbl.glUniform4ui64NV = loader_glUniform4ui64NV;
  tbl.glUniform4ui64vNV = loader_glUniform4ui64vNV;

  // GL_NV_half_float

  tbl.glColor3hNV = loader_glColor3hNV;
  tbl.glColor3hvNV = loader_glColor3hvNV;
  tbl.glColor4hNV = loader_glColor4hNV;
  tbl.glColor4hvNV = loader_glColor4hvNV;
  tbl.glFogCoordhNV = loader_glFogCoordhNV;
  tbl.glFogCoordhvNV = loader_glFogCoordhvNV;
  tbl.glMultiTexCoord1hNV = loader_glMultiTexCoord1hNV;
  tbl.glMultiTexCoord1hvNV = loader_glMultiTexCoord1hvNV;
  tbl.glMultiTexCoord2hNV = loader_glMultiTexCoord2hNV;
  tbl.glMultiTexCoord2hvNV = loader_glMultiTexCoord2hvNV;
  tbl.glMultiTexCoord3hNV = loader_glMultiTexCoord3hNV;
  tbl.glMultiTexCoord3hvNV = loader_glMultiTexCoord3hvNV;
  tbl.glMultiTexCoord4hNV = loader_glMultiTexCoord4hNV;
  tbl.glMultiTexCoord4hvNV = loader_glMultiTexCoord4hvNV;
  tbl.glNormal3hNV = loader_glNormal3hNV;
  tbl.glNormal3hvNV = loader_glNormal3hvNV;
  tbl.glSecondaryColor3hNV = loader_glSecondaryColor3hNV;
  tbl.glSecondaryColor3hvNV = loader_glSecondaryColor3hvNV;
  tbl.glTexCoord1hNV = loader_glTexCoord1hNV;
  tbl.glTexCoord1hvNV = loader_glTexCoord1hvNV;
  tbl.glTexCoord2hNV = loader_glTexCoord2hNV;
  tbl.glTexCoord2hvNV = loader_glTexCoord2hvNV;
  tbl.glTexCoord3hNV = loader_glTexCoord3hNV;
  tbl.glTexCoord3hvNV = loader_glTexCoord3hvNV;
  tbl.glTexCoord4hNV = loader_glTexCoord4hNV;
  tbl.glTexCoord4hvNV = loader_glTexCoord4hvNV;
  tbl.glVertex2hNV = loader_glVertex2hNV;
  tbl.glVertex2hvNV = loader_glVertex2hvNV;
  tbl.glVertex3hNV = loader_glVertex3hNV;
  tbl.glVertex3hvNV = loader_glVertex3hvNV;
  tbl.glVertex4hNV = loader_glVertex4hNV;
  tbl.glVertex4hvNV = loader_glVertex4hvNV;
  tbl.glVertexAttrib1hNV = loader_glVertexAttrib1hNV;
  tbl.glVertexAttrib1hvNV = loader_glVertexAttrib1hvNV;
  tbl.glVertexAttrib2hNV = loader_glVertexAttrib2hNV;
  tbl.glVertexAttrib2hvNV = loader_glVertexAttrib2hvNV;
  tbl.glVertexAttrib3hNV = loader_glVertexAttrib3hNV;
  tbl.glVertexAttrib3hvNV = loader_glVertexAttrib3hvNV;
  tbl.glVertexAttrib4hNV = loader_glVertexAttrib4hNV;
  tbl.glVertexAttrib4hvNV = loader_glVertexAttrib4hvNV;
  tbl.glVertexAttribs1hvNV = loader_glVertexAttribs1hvNV;
  tbl.glVertexAttribs2hvNV = loader_glVertexAttribs2hvNV;
  tbl.glVertexAttribs3hvNV = loader_glVertexAttribs3hvNV;
  tbl.glVertexAttribs4hvNV = loader_glVertexAttribs4hvNV;
  tbl.glVertexWeighthNV = loader_glVertexWeighthNV;
  tbl.glVertexWeighthvNV = loader_glVertexWeighthvNV;

  // GL_NV_occlusion_query

  tbl.glBeginOcclusionQueryNV = loader_glBeginOcclusionQueryNV;
  tbl.glDeleteOcclusionQueriesNV = loader_glDeleteOcclusionQueriesNV;
  tbl.glEndOcclusionQueryNV = loader_glEndOcclusionQueryNV;
  tbl.glGenOcclusionQueriesNV = loader_glGenOcclusionQueriesNV;
  tbl.glGetOcclusionQueryivNV = loader_glGetOcclusionQueryivNV;
  tbl.glGetOcclusionQueryuivNV = loader_glGetOcclusionQueryuivNV;
  tbl.glIsOcclusionQueryNV = loader_glIsOcclusionQueryNV;

  // GL_NV_parameter_buffer_object

  tbl.glProgramBufferParametersIivNV = loader_glProgramBufferParametersIivNV;
  tbl.glProgramBufferParametersIuivNV = loader_glProgramBufferParametersIuivNV;
  tbl.glProgramBufferParametersfvNV = loader_glProgramBufferParametersfvNV;

  // GL_NV_path_rendering

  tbl.glCopyPathNV = loader_glCopyPathNV;
  tbl.glCoverFillPathInstancedNV = loader_glCoverFillPathInstancedNV;
  tbl.glCoverFillPathNV = loader_glCoverFillPathNV;
  tbl.glCoverStrokePathInstancedNV = loader_glCoverStrokePathInstancedNV;
  tbl.glCoverStrokePathNV = loader_glCoverStrokePathNV;
  tbl.glDeletePathsNV = loader_glDeletePathsNV;
  tbl.glGenPathsNV = loader_glGenPathsNV;
  tbl.glGetPathColorGenfvNV = loader_glGetPathColorGenfvNV;
  tbl.glGetPathColorGenivNV = loader_glGetPathColorGenivNV;
  tbl.glGetPathCommandsNV = loader_glGetPathCommandsNV;
  tbl.glGetPathCoordsNV = loader_glGetPathCoordsNV;
  tbl.glGetPathDashArrayNV = loader_glGetPathDashArrayNV;
  tbl.glGetPathLengthNV = loader_glGetPathLengthNV;
  tbl.glGetPathMetricRangeNV = loader_glGetPathMetricRangeNV;
  tbl.glGetPathMetricsNV = loader_glGetPathMetricsNV;
  tbl.glGetPathParameterfvNV = loader_glGetPathParameterfvNV;
  tbl.glGetPathParameterivNV = loader_glGetPathParameterivNV;
  tbl.glGetPathSpacingNV = loader_glGetPathSpacingNV;
  tbl.glGetPathTexGenfvNV = loader_glGetPathTexGenfvNV;
  tbl.glGetPathTexGenivNV = loader_glGetPathTexGenivNV;
  tbl.glInterpolatePathsNV = loader_glInterpolatePathsNV;
  tbl.glIsPathNV = loader_glIsPathNV;
  tbl.glIsPointInFillPathNV = loader_glIsPointInFillPathNV;
  tbl.glIsPointInStrokePathNV = loader_glIsPointInStrokePathNV;
  tbl.glPathColorGenNV = loader_glPathColorGenNV;
  tbl.glPathCommandsNV = loader_glPathCommandsNV;
  tbl.glPathCoordsNV = loader_glPathCoordsNV;
  tbl.glPathCoverDepthFuncNV = loader_glPathCoverDepthFuncNV;
  tbl.glPathDashArrayNV = loader_glPathDashArrayNV;
  tbl.glPathFogGenNV = loader_glPathFogGenNV;
  tbl.glPathGlyphRangeNV = loader_glPathGlyphRangeNV;
  tbl.glPathGlyphsNV = loader_glPathGlyphsNV;
  tbl.glPathParameterfNV = loader_glPathParameterfNV;
  tbl.glPathParameterfvNV = loader_glPathParameterfvNV;
  tbl.glPathParameteriNV = loader_glPathParameteriNV;
  tbl.glPathParameterivNV = loader_glPathParameterivNV;
  tbl.glPathStencilDepthOffsetNV = loader_glPathStencilDepthOffsetNV;
  tbl.glPathStencilFuncNV = loader_glPathStencilFuncNV;
  tbl.glPathStringNV = loader_glPathStringNV;
  tbl.glPathSubCommandsNV = loader_glPathSubCommandsNV;
  tbl.glPathSubCoordsNV = loader_glPathSubCoordsNV;
  tbl.glPathTexGenNV = loader_glPathTexGenNV;
  tbl.glPointAlongPathNV = loader_glPointAlongPathNV;
  tbl.glStencilFillPathInstancedNV = loader_glStencilFillPathInstancedNV;
  tbl.glStencilFillPathNV = loader_glStencilFillPathNV;
  tbl.glStencilStrokePathInstancedNV = loader_glStencilStrokePathInstancedNV;
  tbl.glStencilStrokePathNV = loader_glStencilStrokePathNV;
  tbl.glTransformPathNV = loader_glTransformPathNV;
  tbl.glWeightPathsNV = loader_glWeightPathsNV;

  // GL_NV_pixel_data_range

  tbl.glFlushPixelDataRangeNV = loader_glFlushPixelDataRangeNV;
  tbl.glPixelDataRangeNV = loader_glPixelDataRangeNV;

  // GL_NV_point_sprite

  tbl.glPointParameteriNV = loader_glPointParameteriNV;
  tbl.glPointParameterivNV = loader_glPointParameterivNV;

  // GL_NV_present_video

  tbl.glGetVideoi64vNV = loader_glGetVideoi64vNV;
  tbl.glGetVideoivNV = loader_glGetVideoivNV;
  tbl.glGetVideoui64vNV = loader_glGetVideoui64vNV;
  tbl.glGetVideouivNV = loader_glGetVideouivNV;
  tbl.glPresentFrameDualFillNV = loader_glPresentFrameDualFillNV;
  tbl.glPresentFrameKeyedNV = loader_glPresentFrameKeyedNV;

  // GL_NV_primitive_restart

  tbl.glPrimitiveRestartIndexNV = loader_glPrimitiveRestartIndexNV;
  tbl.glPrimitiveRestartNV = loader_glPrimitiveRestartNV;

  // GL_NV_register_combiners

  tbl.glCombinerInputNV = loader_glCombinerInputNV;
  tbl.glCombinerOutputNV = loader_glCombinerOutputNV;
  tbl.glCombinerParameterfNV = loader_glCombinerParameterfNV;
  tbl.glCombinerParameterfvNV = loader_glCombinerParameterfvNV;
  tbl.glCombinerParameteriNV = loader_glCombinerParameteriNV;
  tbl.glCombinerParameterivNV = loader_glCombinerParameterivNV;
  tbl.glFinalCombinerInputNV = loader_glFinalCombinerInputNV;
  tbl.glGetCombinerInputParameterfvNV = loader_glGetCombinerInputParameterfvNV;
  tbl.glGetCombinerInputParameterivNV = loader_glGetCombinerInputParameterivNV;
  tbl.glGetCombinerOutputParameterfvNV = loader_glGetCombinerOutputParameterfvNV;
  tbl.glGetCombinerOutputParameterivNV = loader_glGetCombinerOutputParameterivNV;
  tbl.glGetFinalCombinerInputParameterfvNV = loader_glGetFinalCombinerInputParameterfvNV;
  tbl.glGetFinalCombinerInputParameterivNV = loader_glGetFinalCombinerInputParameterivNV;

  // GL_NV_register_combiners2

  tbl.glCombinerStageParameterfvNV = loader_glCombinerStageParameterfvNV;
  tbl.glGetCombinerStageParameterfvNV = loader_glGetCombinerStageParameterfvNV;

  // GL_NV_shader_buffer_load

  tbl.glGetBufferParameterui64vNV = loader_glGetBufferParameterui64vNV;
  tbl.glGetIntegerui64vNV = loader_glGetIntegerui64vNV;
  tbl.glGetNamedBufferParameterui64vNV = loader_glGetNamedBufferParameterui64vNV;
  tbl.glGetUniformui64vNV = loader_glGetUniformui64vNV;
  tbl.glIsBufferResidentNV = loader_glIsBufferResidentNV;
  tbl.glIsNamedBufferResidentNV = loader_glIsNamedBufferResidentNV;
  tbl.glMakeBufferNonResidentNV = loader_glMakeBufferNonResidentNV;
  tbl.glMakeBufferResidentNV = loader_glMakeBufferResidentNV;
  tbl.glMakeNamedBufferNonResidentNV = loader_glMakeNamedBufferNonResidentNV;
  tbl.glMakeNamedBufferResidentNV = loader_glMakeNamedBufferResidentNV;
  tbl.glProgramUniformui64NV = loader_glProgramUniformui64NV;
  tbl.glProgramUniformui64vNV = loader_glProgramUniformui64vNV;
  tbl.glUniformui64NV = loader_glUniformui64NV;
  tbl.glUniformui64vNV = loader_glUniformui64vNV;

  // GL_NV_texture_barrier

  tbl.glTextureBarrierNV = loader_glTextureBarrierNV;

  // GL_NV_texture_multisample

  tbl.glTexImage2DMultisampleCoverageNV = loader_glTexImage2DMultisampleCoverageNV;
  tbl.glTexImage3DMultisampleCoverageNV = loader_glTexImage3DMultisampleCoverageNV;
  tbl.glTextureImage2DMultisampleCoverageNV = loader_glTextureImage2DMultisampleCoverageNV;
  tbl.glTextureImage2DMultisampleNV = loader_glTextureImage2DMultisampleNV;
  tbl.glTextureImage3DMultisampleCoverageNV = loader_glTextureImage3DMultisampleCoverageNV;
  tbl.glTextureImage3DMultisampleNV = loader_glTextureImage3DMultisampleNV;

  // GL_NV_transform_feedback

  tbl.glActiveVaryingNV = loader_glActiveVaryingNV;
  tbl.glBeginTransformFeedbackNV = loader_glBeginTransformFeedbackNV;
  tbl.glBindBufferBaseNV = loader_glBindBufferBaseNV;
  tbl.glBindBufferOffsetNV = loader_glBindBufferOffsetNV;
  tbl.glBindBufferRangeNV = loader_glBindBufferRangeNV;
  tbl.glEndTransformFeedbackNV = loader_glEndTransformFeedbackNV;
  tbl.glGetActiveVaryingNV = loader_glGetActiveVaryingNV;
  tbl.glGetTransformFeedbackVaryingNV = loader_glGetTransformFeedbackVaryingNV;
  tbl.glGetVaryingLocationNV = loader_glGetVaryingLocationNV;
  tbl.glTransformFeedbackAttribsNV = loader_glTransformFeedbackAttribsNV;
  tbl.glTransformFeedbackVaryingsNV = loader_glTransformFeedbackVaryingsNV;

  // GL_NV_transform_feedback2

  tbl.glBindTransformFeedbackNV = loader_glBindTransformFeedbackNV;
  tbl.glDeleteTransformFeedbacksNV = loader_glDeleteTransformFeedbacksNV;
  tbl.glDrawTransformFeedbackNV = loader_glDrawTransformFeedbackNV;
  tbl.glGenTransformFeedbacksNV = loader_glGenTransformFeedbacksNV;
  tbl.glIsTransformFeedbackNV = loader_glIsTransformFeedbackNV;
  tbl.glPauseTransformFeedbackNV = loader_glPauseTransformFeedbackNV;
  tbl.glResumeTransformFeedbackNV = loader_glResumeTransformFeedbackNV;

  // GL_NV_vdpau_interop

  tbl.glVDPAUFiniNV = loader_glVDPAUFiniNV;
  tbl.glVDPAUGetSurfaceivNV = loader_glVDPAUGetSurfaceivNV;
  tbl.glVDPAUInitNV = loader_glVDPAUInitNV;
  tbl.glVDPAUIsSurfaceNV = loader_glVDPAUIsSurfaceNV;
  tbl.glVDPAUMapSurfacesNV = loader_glVDPAUMapSurfacesNV;
  tbl.glVDPAURegisterOutputSurfaceNV = loader_glVDPAURegisterOutputSurfaceNV;
  tbl.glVDPAURegisterVideoSurfaceNV = loader_glVDPAURegisterVideoSurfaceNV;
  tbl.glVDPAUSurfaceAccessNV = loader_glVDPAUSurfaceAccessNV;
  tbl.glVDPAUUnmapSurfacesNV = loader_glVDPAUUnmapSurfacesNV;
  tbl.glVDPAUUnregisterSurfaceNV = loader_glVDPAUUnregisterSurfaceNV;

  // GL_NV_vertex_array_range

  tbl.glFlushVertexArrayRangeNV = loader_glFlushVertexArrayRangeNV;
  tbl.glVertexArrayRangeNV = loader_glVertexArrayRangeNV;

  // GL_NV_vertex_attrib_integer_64bit

  tbl.glGetVertexAttribLi64vNV = loader_glGetVertexAttribLi64vNV;
  tbl.glGetVertexAttribLui64vNV = loader_glGetVertexAttribLui64vNV;
  tbl.glVertexAttribL1i64NV = loader_glVertexAttribL1i64NV;
  tbl.glVertexAttribL1i64vNV = loader_glVertexAttribL1i64vNV;
  tbl.glVertexAttribL1ui64NV = loader_glVertexAttribL1ui64NV;
  tbl.glVertexAttribL1ui64vNV = loader_glVertexAttribL1ui64vNV;
  tbl.glVertexAttribL2i64NV = loader_glVertexAttribL2i64NV;
  tbl.glVertexAttribL2i64vNV = loader_glVertexAttribL2i64vNV;
  tbl.glVertexAttribL2ui64NV = loader_glVertexAttribL2ui64NV;
  tbl.glVertexAttribL2ui64vNV = loader_glVertexAttribL2ui64vNV;
  tbl.glVertexAttribL3i64NV = loader_glVertexAttribL3i64NV;
  tbl.glVertexAttribL3i64vNV = loader_glVertexAttribL3i64vNV;
  tbl.glVertexAttribL3ui64NV = loader_glVertexAttribL3ui64NV;
  tbl.glVertexAttribL3ui64vNV = loader_glVertexAttribL3ui64vNV;
  tbl.glVertexAttribL4i64NV = loader_glVertexAttribL4i64NV;
  tbl.glVertexAttribL4i64vNV = loader_glVertexAttribL4i64vNV;
  tbl.glVertexAttribL4ui64NV = loader_glVertexAttribL4ui64NV;
  tbl.glVertexAttribL4ui64vNV = loader_glVertexAttribL4ui64vNV;
  tbl.glVertexAttribLFormatNV = loader_glVertexAttribLFormatNV;

  // GL_NV_vertex_buffer_unified_memory

  tbl.glBufferAddressRangeNV = loader_glBufferAddressRangeNV;
  tbl.glColorFormatNV = loader_glColorFormatNV;
  tbl.glEdgeFlagFormatNV = loader_glEdgeFlagFormatNV;
  tbl.glFogCoordFormatNV = loader_glFogCoordFormatNV;
  tbl.glGetIntegerui64i_vNV = loader_glGetIntegerui64i_vNV;
  tbl.glIndexFormatNV = loader_glIndexFormatNV;
  tbl.glNormalFormatNV = loader_glNormalFormatNV;
  tbl.glSecondaryColorFormatNV = loader_glSecondaryColorFormatNV;
  tbl.glTexCoordFormatNV = loader_glTexCoordFormatNV;
  tbl.glVertexAttribFormatNV = loader_glVertexAttribFormatNV;
  tbl.glVertexAttribIFormatNV = loader_glVertexAttribIFormatNV;
  tbl.glVertexFormatNV = loader_glVertexFormatNV;

  // GL_NV_vertex_program

  tbl.glAreProgramsResidentNV = loader_glAreProgramsResidentNV;
  tbl.glBindProgramNV = loader_glBindProgramNV;
  tbl.glDeleteProgramsNV = loader_glDeleteProgramsNV;
  tbl.glExecuteProgramNV = loader_glExecuteProgramNV;
  tbl.glGenProgramsNV = loader_glGenProgramsNV;
  tbl.glGetProgramParameterdvNV = loader_glGetProgramParameterdvNV;
  tbl.glGetProgramParameterfvNV = loader_glGetProgramParameterfvNV;
  tbl.glGetProgramStringNV = loader_glGetProgramStringNV;
  tbl.glGetProgramivNV = loader_glGetProgramivNV;
  tbl.glGetTrackMatrixivNV = loader_glGetTrackMatrixivNV;
  tbl.glGetVertexAttribPointervNV = loader_glGetVertexAttribPointervNV;
  tbl.glGetVertexAttribdvNV = loader_glGetVertexAttribdvNV;
  tbl.glGetVertexAttribfvNV = loader_glGetVertexAttribfvNV;
  tbl.glGetVertexAttribivNV = loader_glGetVertexAttribivNV;
  tbl.glIsProgramNV = loader_glIsProgramNV;
  tbl.glLoadProgramNV = loader_glLoadProgramNV;
  tbl.glProgramParameter4dNV = loader_glProgramParameter4dNV;
  tbl.glProgramParameter4dvNV = loader_glProgramParameter4dvNV;
  tbl.glProgramParameter4fNV = loader_glProgramParameter4fNV;
  tbl.glProgramParameter4fvNV = loader_glProgramParameter4fvNV;
  tbl.glProgramParameters4dvNV = loader_glProgramParameters4dvNV;
  tbl.glProgramParameters4fvNV = loader_glProgramParameters4fvNV;
  tbl.glRequestResidentProgramsNV = loader_glRequestResidentProgramsNV;
  tbl.glTrackMatrixNV = loader_glTrackMatrixNV;
  tbl.glVertexAttrib1dNV = loader_glVertexAttrib1dNV;
  tbl.glVertexAttrib1dvNV = loader_glVertexAttrib1dvNV;
  tbl.glVertexAttrib1fNV = loader_glVertexAttrib1fNV;
  tbl.glVertexAttrib1fvNV = loader_glVertexAttrib1fvNV;
  tbl.glVertexAttrib1sNV = loader_glVertexAttrib1sNV;
  tbl.glVertexAttrib1svNV = loader_glVertexAttrib1svNV;
  tbl.glVertexAttrib2dNV = loader_glVertexAttrib2dNV;
  tbl.glVertexAttrib2dvNV = loader_glVertexAttrib2dvNV;
  tbl.glVertexAttrib2fNV = loader_glVertexAttrib2fNV;
  tbl.glVertexAttrib2fvNV = loader_glVertexAttrib2fvNV;
  tbl.glVertexAttrib2sNV = loader_glVertexAttrib2sNV;
  tbl.glVertexAttrib2svNV = loader_glVertexAttrib2svNV;
  tbl.glVertexAttrib3dNV = loader_glVertexAttrib3dNV;
  tbl.glVertexAttrib3dvNV = loader_glVertexAttrib3dvNV;
  tbl.glVertexAttrib3fNV = loader_glVertexAttrib3fNV;
  tbl.glVertexAttrib3fvNV = loader_glVertexAttrib3fvNV;
  tbl.glVertexAttrib3sNV = loader_glVertexAttrib3sNV;
  tbl.glVertexAttrib3svNV = loader_glVertexAttrib3svNV;
  tbl.glVertexAttrib4dNV = loader_glVertexAttrib4dNV;
  tbl.glVertexAttrib4dvNV = loader_glVertexAttrib4dvNV;
  tbl.glVertexAttrib4fNV = loader_glVertexAttrib4fNV;
  tbl.glVertexAttrib4fvNV = loader_glVertexAttrib4fvNV;
  tbl.glVertexAttrib4sNV = loader_glVertexAttrib4sNV;
  tbl.glVertexAttrib4svNV = loader_glVertexAttrib4svNV;
  tbl.glVertexAttrib4ubNV = loader_glVertexAttrib4ubNV;
  tbl.glVertexAttrib4ubvNV = loader_glVertexAttrib4ubvNV;
  tbl.glVertexAttribPointerNV = loader_glVertexAttribPointerNV;
  tbl.glVertexAttribs1dvNV = loader_glVertexAttribs1dvNV;
  tbl.glVertexAttribs1fvNV = loader_glVertexAttribs1fvNV;
  tbl.glVertexAttribs1svNV = loader_glVertexAttribs1svNV;
  tbl.glVertexAttribs2dvNV = loader_glVertexAttribs2dvNV;
  tbl.glVertexAttribs2fvNV = loader_glVertexAttribs2fvNV;
  tbl.glVertexAttribs2svNV = loader_glVertexAttribs2svNV;
  tbl.glVertexAttribs3dvNV = loader_glVertexAttribs3dvNV;
  tbl.glVertexAttribs3fvNV = loader_glVertexAttribs3fvNV;
  tbl.glVertexAttribs3svNV = loader_glVertexAttribs3svNV;
  tbl.glVertexAttribs4dvNV = loader_glVertexAttribs4dvNV;
  tbl.glVertexAttribs4fvNV = loader_glVertexAttribs4fvNV;
  tbl.glVertexAttribs4svNV = loader_glVertexAttribs4svNV;
  tbl.glVertexAttribs4ubvNV = loader_glVertexAttribs4ubvNV;

  // GL_NV_video_capture

  tbl.glBeginVideoCaptureNV = loader_glBeginVideoCaptureNV;
  tbl.glBindVideoCaptureStreamBufferNV = loader_glBindVideoCaptureStreamBufferNV;
  tbl.glBindVideoCaptureStreamTextureNV = loader_glBindVideoCaptureStreamTextureNV;
  tbl.glEndVideoCaptureNV = loader_glEndVideoCaptureNV;
  tbl.glGetVideoCaptureStreamdvNV = loader_glGetVideoCaptureStreamdvNV;
  tbl.glGetVideoCaptureStreamfvNV = loader_glGetVideoCaptureStreamfvNV;
  tbl.glGetVideoCaptureStreamivNV = loader_glGetVideoCaptureStreamivNV;
  tbl.glGetVideoCaptureivNV = loader_glGetVideoCaptureivNV;
  tbl.glVideoCaptureNV = loader_glVideoCaptureNV;
  tbl.glVideoCaptureStreamParameterdvNV = loader_glVideoCaptureStreamParameterdvNV;
  tbl.glVideoCaptureStreamParameterfvNV = loader_glVideoCaptureStreamParameterfvNV;
  tbl.glVideoCaptureStreamParameterivNV = loader_glVideoCaptureStreamParameterivNV;

  // GL_PGI_misc_hints

  tbl.glHintPGI = loader_glHintPGI;

  // GL_REGAL_error_string

  tbl.glErrorStringREGAL = loader_glErrorStringREGAL;

  // GL_REGAL_extension_query

  tbl.glGetExtensionREGAL = loader_glGetExtensionREGAL;
  tbl.glIsSupportedREGAL = loader_glIsSupportedREGAL;

  // GL_SGIS_detail_texture

  tbl.glDetailTexFuncSGIS = loader_glDetailTexFuncSGIS;
  tbl.glGetDetailTexFuncSGIS = loader_glGetDetailTexFuncSGIS;

  // GL_SGIS_fog_function

  tbl.glFogFuncSGIS = loader_glFogFuncSGIS;
  tbl.glGetFogFuncSGIS = loader_glGetFogFuncSGIS;

  // GL_SGIS_multisample

  tbl.glSampleMaskSGIS = loader_glSampleMaskSGIS;
  tbl.glSamplePatternSGIS = loader_glSamplePatternSGIS;

  // GL_SGIS_pixel_texture

  tbl.glGetPixelTexGenParameterfvSGIS = loader_glGetPixelTexGenParameterfvSGIS;
  tbl.glGetPixelTexGenParameterivSGIS = loader_glGetPixelTexGenParameterivSGIS;
  tbl.glPixelTexGenParameterfSGIS = loader_glPixelTexGenParameterfSGIS;
  tbl.glPixelTexGenParameterfvSGIS = loader_glPixelTexGenParameterfvSGIS;
  tbl.glPixelTexGenParameteriSGIS = loader_glPixelTexGenParameteriSGIS;
  tbl.glPixelTexGenParameterivSGIS = loader_glPixelTexGenParameterivSGIS;

  // GL_SGIS_point_parameters

  tbl.glPointParameterfSGIS = loader_glPointParameterfSGIS;
  tbl.glPointParameterfvSGIS = loader_glPointParameterfvSGIS;

  // GL_SGIS_sharpen_texture

  tbl.glGetSharpenTexFuncSGIS = loader_glGetSharpenTexFuncSGIS;
  tbl.glSharpenTexFuncSGIS = loader_glSharpenTexFuncSGIS;

  // GL_SGIS_texture4D

  tbl.glTexImage4DSGIS = loader_glTexImage4DSGIS;
  tbl.glTexSubImage4DSGIS = loader_glTexSubImage4DSGIS;

  // GL_SGIS_texture_color_mask

  tbl.glTextureColorMaskSGIS = loader_glTextureColorMaskSGIS;

  // GL_SGIS_texture_filter4

  tbl.glGetTexFilterFuncSGIS = loader_glGetTexFilterFuncSGIS;
  tbl.glTexFilterFuncSGIS = loader_glTexFilterFuncSGIS;

  // GL_SGIX_async

  tbl.glAsyncMarkerSGIX = loader_glAsyncMarkerSGIX;
  tbl.glDeleteAsyncMarkersSGIX = loader_glDeleteAsyncMarkersSGIX;
  tbl.glFinishAsyncSGIX = loader_glFinishAsyncSGIX;
  tbl.glGenAsyncMarkersSGIX = loader_glGenAsyncMarkersSGIX;
  tbl.glIsAsyncMarkerSGIX = loader_glIsAsyncMarkerSGIX;
  tbl.glPollAsyncSGIX = loader_glPollAsyncSGIX;

  // GL_SGIX_flush_raster

  tbl.glFlushRasterSGIX = loader_glFlushRasterSGIX;

  // GL_SGIX_fog_texture

  tbl.glTextureFogSGIX = loader_glTextureFogSGIX;

  // GL_SGIX_fragment_lighting

  tbl.glFragmentColorMaterialSGIX = loader_glFragmentColorMaterialSGIX;
  tbl.glFragmentLightModelfSGIX = loader_glFragmentLightModelfSGIX;
  tbl.glFragmentLightModelfvSGIX = loader_glFragmentLightModelfvSGIX;
  tbl.glFragmentLightModeliSGIX = loader_glFragmentLightModeliSGIX;
  tbl.glFragmentLightModelivSGIX = loader_glFragmentLightModelivSGIX;
  tbl.glFragmentLightfSGIX = loader_glFragmentLightfSGIX;
  tbl.glFragmentLightfvSGIX = loader_glFragmentLightfvSGIX;
  tbl.glFragmentLightiSGIX = loader_glFragmentLightiSGIX;
  tbl.glFragmentLightivSGIX = loader_glFragmentLightivSGIX;
  tbl.glFragmentMaterialfSGIX = loader_glFragmentMaterialfSGIX;
  tbl.glFragmentMaterialfvSGIX = loader_glFragmentMaterialfvSGIX;
  tbl.glFragmentMaterialiSGIX = loader_glFragmentMaterialiSGIX;
  tbl.glFragmentMaterialivSGIX = loader_glFragmentMaterialivSGIX;
  tbl.glGetFragmentLightfvSGIX = loader_glGetFragmentLightfvSGIX;
  tbl.glGetFragmentLightivSGIX = loader_glGetFragmentLightivSGIX;
  tbl.glGetFragmentMaterialfvSGIX = loader_glGetFragmentMaterialfvSGIX;
  tbl.glGetFragmentMaterialivSGIX = loader_glGetFragmentMaterialivSGIX;
  tbl.glLightEnviSGIX = loader_glLightEnviSGIX;

  // GL_SGIX_framezoom

  tbl.glFrameZoomSGIX = loader_glFrameZoomSGIX;

  // GL_SGIX_igloo_interface

  tbl.glIglooInterfaceSGIX = loader_glIglooInterfaceSGIX;

  // GL_SGIX_instruments

  tbl.glGetInstrumentsSGIX = loader_glGetInstrumentsSGIX;
  tbl.glInstrumentsBufferSGIX = loader_glInstrumentsBufferSGIX;
  tbl.glPollInstrumentsSGIX = loader_glPollInstrumentsSGIX;
  tbl.glReadInstrumentsSGIX = loader_glReadInstrumentsSGIX;
  tbl.glStartInstrumentsSGIX = loader_glStartInstrumentsSGIX;
  tbl.glStopInstrumentsSGIX = loader_glStopInstrumentsSGIX;

  // GL_SGIX_list_priority

  tbl.glGetListParameterfvSGIX = loader_glGetListParameterfvSGIX;
  tbl.glGetListParameterivSGIX = loader_glGetListParameterivSGIX;
  tbl.glListParameterfSGIX = loader_glListParameterfSGIX;
  tbl.glListParameterfvSGIX = loader_glListParameterfvSGIX;
  tbl.glListParameteriSGIX = loader_glListParameteriSGIX;
  tbl.glListParameterivSGIX = loader_glListParameterivSGIX;

  // GL_SGIX_pixel_texture

  tbl.glPixelTexGenSGIX = loader_glPixelTexGenSGIX;

  // GL_SGIX_polynomial_ffd

  tbl.glDeformSGIX = loader_glDeformSGIX;
  tbl.glDeformationMap3dSGIX = loader_glDeformationMap3dSGIX;
  tbl.glDeformationMap3fSGIX = loader_glDeformationMap3fSGIX;
  tbl.glLoadIdentityDeformationMapSGIX = loader_glLoadIdentityDeformationMapSGIX;

  // GL_SGIX_reference_plane

  tbl.glReferencePlaneSGIX = loader_glReferencePlaneSGIX;

  // GL_SGIX_sprite

  tbl.glSpriteParameterfSGIX = loader_glSpriteParameterfSGIX;
  tbl.glSpriteParameterfvSGIX = loader_glSpriteParameterfvSGIX;
  tbl.glSpriteParameteriSGIX = loader_glSpriteParameteriSGIX;
  tbl.glSpriteParameterivSGIX = loader_glSpriteParameterivSGIX;

  // GL_SGIX_tag_sample_buffer

  tbl.glTagSampleBufferSGIX = loader_glTagSampleBufferSGIX;

  // GL_SGI_color_table

  tbl.glColorTableParameterfvSGI = loader_glColorTableParameterfvSGI;
  tbl.glColorTableParameterivSGI = loader_glColorTableParameterivSGI;
  tbl.glColorTableSGI = loader_glColorTableSGI;
  tbl.glCopyColorTableSGI = loader_glCopyColorTableSGI;
  tbl.glGetColorTableParameterfvSGI = loader_glGetColorTableParameterfvSGI;
  tbl.glGetColorTableParameterivSGI = loader_glGetColorTableParameterivSGI;
  tbl.glGetColorTableSGI = loader_glGetColorTableSGI;

  // GL_SUNX_constant_data

  tbl.glFinishTextureSUNX = loader_glFinishTextureSUNX;

  // GL_SUN_global_alpha

  tbl.glGlobalAlphaFactorbSUN = loader_glGlobalAlphaFactorbSUN;
  tbl.glGlobalAlphaFactordSUN = loader_glGlobalAlphaFactordSUN;
  tbl.glGlobalAlphaFactorfSUN = loader_glGlobalAlphaFactorfSUN;
  tbl.glGlobalAlphaFactoriSUN = loader_glGlobalAlphaFactoriSUN;
  tbl.glGlobalAlphaFactorsSUN = loader_glGlobalAlphaFactorsSUN;
  tbl.glGlobalAlphaFactorubSUN = loader_glGlobalAlphaFactorubSUN;
  tbl.glGlobalAlphaFactoruiSUN = loader_glGlobalAlphaFactoruiSUN;
  tbl.glGlobalAlphaFactorusSUN = loader_glGlobalAlphaFactorusSUN;

  // GL_SUN_mesh_array

  tbl.glDrawMeshArraysSUN = loader_glDrawMeshArraysSUN;

  // GL_SUN_read_video_pixels

  tbl.glReadVideoPixelsSUN = loader_glReadVideoPixelsSUN;

  // GL_SUN_triangle_list

  tbl.glReplacementCodePointerSUN = loader_glReplacementCodePointerSUN;
  tbl.glReplacementCodeubSUN = loader_glReplacementCodeubSUN;
  tbl.glReplacementCodeubvSUN = loader_glReplacementCodeubvSUN;
  tbl.glReplacementCodeuiSUN = loader_glReplacementCodeuiSUN;
  tbl.glReplacementCodeuivSUN = loader_glReplacementCodeuivSUN;
  tbl.glReplacementCodeusSUN = loader_glReplacementCodeusSUN;
  tbl.glReplacementCodeusvSUN = loader_glReplacementCodeusvSUN;

  // GL_SUN_vertex

  tbl.glColor3fVertex3fSUN = loader_glColor3fVertex3fSUN;
  tbl.glColor3fVertex3fvSUN = loader_glColor3fVertex3fvSUN;
  tbl.glColor4fNormal3fVertex3fSUN = loader_glColor4fNormal3fVertex3fSUN;
  tbl.glColor4fNormal3fVertex3fvSUN = loader_glColor4fNormal3fVertex3fvSUN;
  tbl.glColor4ubVertex2fSUN = loader_glColor4ubVertex2fSUN;
  tbl.glColor4ubVertex2fvSUN = loader_glColor4ubVertex2fvSUN;
  tbl.glColor4ubVertex3fSUN = loader_glColor4ubVertex3fSUN;
  tbl.glColor4ubVertex3fvSUN = loader_glColor4ubVertex3fvSUN;
  tbl.glNormal3fVertex3fSUN = loader_glNormal3fVertex3fSUN;
  tbl.glNormal3fVertex3fvSUN = loader_glNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiColor3fVertex3fSUN = loader_glReplacementCodeuiColor3fVertex3fSUN;
  tbl.glReplacementCodeuiColor3fVertex3fvSUN = loader_glReplacementCodeuiColor3fVertex3fvSUN;
  tbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN = loader_glReplacementCodeuiColor4fNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN = loader_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiColor4ubVertex3fSUN = loader_glReplacementCodeuiColor4ubVertex3fSUN;
  tbl.glReplacementCodeuiColor4ubVertex3fvSUN = loader_glReplacementCodeuiColor4ubVertex3fvSUN;
  tbl.glReplacementCodeuiNormal3fVertex3fSUN = loader_glReplacementCodeuiNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiNormal3fVertex3fvSUN = loader_glReplacementCodeuiNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = loader_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = loader_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiTexCoord2fVertex3fSUN = loader_glReplacementCodeuiTexCoord2fVertex3fSUN;
  tbl.glReplacementCodeuiTexCoord2fVertex3fvSUN = loader_glReplacementCodeuiTexCoord2fVertex3fvSUN;
  tbl.glReplacementCodeuiVertex3fSUN = loader_glReplacementCodeuiVertex3fSUN;
  tbl.glReplacementCodeuiVertex3fvSUN = loader_glReplacementCodeuiVertex3fvSUN;
  tbl.glTexCoord2fColor3fVertex3fSUN = loader_glTexCoord2fColor3fVertex3fSUN;
  tbl.glTexCoord2fColor3fVertex3fvSUN = loader_glTexCoord2fColor3fVertex3fvSUN;
  tbl.glTexCoord2fColor4fNormal3fVertex3fSUN = loader_glTexCoord2fColor4fNormal3fVertex3fSUN;
  tbl.glTexCoord2fColor4fNormal3fVertex3fvSUN = loader_glTexCoord2fColor4fNormal3fVertex3fvSUN;
  tbl.glTexCoord2fColor4ubVertex3fSUN = loader_glTexCoord2fColor4ubVertex3fSUN;
  tbl.glTexCoord2fColor4ubVertex3fvSUN = loader_glTexCoord2fColor4ubVertex3fvSUN;
  tbl.glTexCoord2fNormal3fVertex3fSUN = loader_glTexCoord2fNormal3fVertex3fSUN;
  tbl.glTexCoord2fNormal3fVertex3fvSUN = loader_glTexCoord2fNormal3fVertex3fvSUN;
  tbl.glTexCoord2fVertex3fSUN = loader_glTexCoord2fVertex3fSUN;
  tbl.glTexCoord2fVertex3fvSUN = loader_glTexCoord2fVertex3fvSUN;
  tbl.glTexCoord4fColor4fNormal3fVertex4fSUN = loader_glTexCoord4fColor4fNormal3fVertex4fSUN;
  tbl.glTexCoord4fColor4fNormal3fVertex4fvSUN = loader_glTexCoord4fColor4fNormal3fVertex4fvSUN;
  tbl.glTexCoord4fVertex4fSUN = loader_glTexCoord4fVertex4fSUN;
  tbl.glTexCoord4fVertex4fvSUN = loader_glTexCoord4fVertex4fvSUN;

  // GL_WIN_swap_hint

  tbl.glAddSwapHintRectWIN = loader_glAddSwapHintRectWIN;

}

REGAL_NAMESPACE_END
