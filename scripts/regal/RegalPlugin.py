#!/usr/bin/python -B

#
# Plugin interface for Regal
#
# RegalPlugin.cpp provides the functions for
# plugin layers to call back into the Regal
# emulation or dispatch stack.
#

from string import Template, upper, replace

from ApiUtil import outputCode
from ApiUtil import typeIsVoid

from ApiCodeGen   import *

from RegalContextInfo import cond

# Code generation for RegalPlugin.cpp

pluginHeaderTemplate = Template('''${AUTOGENERATED}
${LICENSE}

#include "pch.h" /* For MS precompiled header support */

#define REGAL_PLUGIN_MODE 1

#include "RegalUtil.h"

REGAL_GLOBAL_BEGIN

#if REGAL_PLUGIN

#include "RegalContext.h"
#include "RegalDispatcher.h"

extern "C" {

${PLUGIN_SOURCE}

}

#endif // REGAL_PLUGIN

REGAL_GLOBAL_END
''')


def generatePluginHeader(apis, args):

  code = ''
  for api in apis:

    tmp = []
    for function in api.functions:

      if getattr(function,'regalOnly',False):
        continue

      name       = function.name
      params     = paramsDefaultCode(function.parameters, True)
      callParams = paramsNameCode(function.parameters)
      rType      = typeCode(function.ret.type)
      rTypes     = rType.strip()
      category   = getattr(function, 'category', None)
      version    = getattr(function, 'version', None)

      if category:
        category = category.replace('_DEPRECATED', '')
      elif version:
        category = version.replace('.', '_')
        category = 'GL_VERSION_' + category

      c = ''
      c += '%sREGAL_CALL plugin_%s(%s) \n{\n' % (rType, name, params)

      c += '  ::REGAL_NAMESPACE_INTERNAL::Thread::ThreadLocal &_instance = ::REGAL_NAMESPACE_INTERNAL::Thread::ThreadLocal::instance();\n'
      if function.needsContext:
        c += '  ::REGAL_NAMESPACE_INTERNAL::DispatchTableGL *_next = _instance.nextDispatchTable;\n'
      else:
        c += '  ::REGAL_NAMESPACE_INTERNAL::DispatchTableGlobal *_next = _instance.nextDispatchTableGlobal;\n'
      c += '  RegalAssert(_next);\n'
      if not typeIsVoid(rType):
        c += '  return '
      else:
        c += '  '
      c += '_next->call(&_next->%s)(%s);\n}\n' % ( name, callParams )

      tmp.append( (category, indent(c,'  ') ) )

    tmp = listToString(unfoldCategory(tmp,'  /* %s */'))

    if api.name in cond:
      tmp = wrapIf(cond[api.name], tmp)

    code += tmp

  # Output

  substitute = {}

  substitute['LICENSE']         = args.license
  substitute['AUTOGENERATED']   = args.generated
  substitute['PLUGIN_SOURCE']   = code

  outputCode( '%s/RegalPlugin.cpp' % args.srcdir, pluginHeaderTemplate.substitute(substitute))

