#!/usr/bin/python -B

from string import Template, upper, replace, capwords

from ApiUtil import outputCode
from ApiCodeGen import *

from EmuInit           import formulae       as initFormulae
from EmuInit           import formulaeGlobal as initFormulaeGlobal
from EmuContextShare   import formulae       as contextShareFormulae
from EmuContextState   import formulae       as contextStateFormulae
from EmuGetString      import formulae       as getStringFormulae
from EmuForceCore      import formulae       as forceCoreFormulae
from EmuExtensionQuery import formulae       as extensionQueryFormulae
from EmuErrorString    import formulae       as errorStringFormulae
from EmuEnable         import formulae       as enableFormulae

from EmuLog    import logFormulae

from Emu       import emuFindEntry, emuCodeGen
from EmuDsa    import dsaFormulae
from EmuVao    import vaoFormulae
from EmuSo     import soFormulae
from EmuPpca   import ppcaFormulae
from EmuPpa    import ppaFormulae
from EmuIff    import iffFormulae
from EmuQuads  import quadsFormulae
from EmuBin    import binFormulae
from EmuObj    import objFormulae
from EmuFilt   import formulae as filtFormulae
from EmuTexC   import texCFormulae
from EmuTextureStorage import texstoFormulae
from EmuBaseVertex import baseVertexFormulae
from EmuRect   import rectFormulae
from EmuHint   import hintFormulae

from EmuPixelTransfer import xferFormulae

# Regal.cpp emulation

emuRegal = [
    { 'name' : None,     'type' : None, 'formulae' : initFormulae           },
    { 'name' : None,     'type' : None, 'formulae' : initFormulaeGlobal     },
    { 'name' : None,     'type' : None, 'formulae' : contextShareFormulae   },
    { 'name' : None,     'type' : None, 'formulae' : contextStateFormulae   },
    { 'name' : None,     'type' : None, 'formulae' : getStringFormulae      },
    { 'name' : None,     'type' : None, 'formulae' : forceCoreFormulae      },
    { 'name' : None,     'type' : None, 'formulae' : extensionQueryFormulae },
    { 'name' : None,     'type' : None, 'formulae' : errorStringFormulae    },
    { 'name' : None,     'type' : None, 'formulae' : logFormulae            },
    { 'name' : None,     'type' : None, 'formulae' : enableFormulae         },
]


# src/regal/layer/... regal interception layers

emu = [
    { 'name' : 'obj',    'type' : 'Obj',        'formulae' : objFormulae        },
    { 'name' : 'hint',   'type' : 'Hint',       'formulae' : hintFormulae       },
    { 'name' : 'ppa',    'type' : 'Ppa',        'formulae' : ppaFormulae        },
    { 'name' : 'ppca',   'type' : 'Ppca',       'formulae' : ppcaFormulae       },
    { 'name' : 'bin',    'type' : 'Bin',        'formulae' : binFormulae        },
    { 'name' : 'xfer',   'type' : 'Xfer',       'formulae' : xferFormulae       },
    { 'name' : 'texsto', 'type' : 'TexSto',     'formulae' : texstoFormulae     },
    { 'name' : 'bv',     'type' : 'BaseVertex', 'formulae' : baseVertexFormulae },
    { 'name' : 'rect',   'type' : 'Rect',       'formulae' : rectFormulae       },
    { 'name' : 'iff',    'type' : 'Iff',        'formulae' : iffFormulae        },
    { 'name' : 'quads',  'type' : 'Quads',      'formulae' : quadsFormulae      },
    { 'name' : 'so',     'type' : 'So',         'formulae' : soFormulae         },
    { 'name' : 'dsa',    'type' : 'Dsa',        'formulae' : dsaFormulae        },
    { 'name' : 'vao',    'type' : 'Vao',        'formulae' : vaoFormulae        },
    { 'name' : 'texc',   'type' : 'TexC',       'formulae' : texCFormulae       },
    { 'name' : 'filt',   'type' : 'Filt',       'formulae' : filtFormulae       },
]

contextHeaderTemplate = Template( '''${AUTOGENERATED}
${LICENSE}

#ifndef __${HEADER_NAME}_H__
#define __${HEADER_NAME}_H__

#include "RegalUtil.h"

REGAL_GLOBAL_BEGIN

#include "RegalThread.h"
#include "RegalPrivate.h"
#include "RegalContextInfo.h"
#include "RegalDispatch.h"
#include "RegalScopedPtr.h"
#include "RegalSharedList.h"

#if REGAL_SYS_PPAPI
#define __gl2_h_  // HACK - revisit
#include <ppapi/c/pp_resource.h>
#include <ppapi/c/ppb_opengles2.h>
#endif

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

struct EmuInfo;

struct RegalContext
{
  RegalContext();
  ~RegalContext();

  void Init();
  void Cleanup();

  // If profile is forced at build-time, no need to check runtime flag

  inline bool isES1()    const { RegalAssert(info); return REGAL_SYS_ES1 && ( REGAL_FORCE_ES1_PROFILE  || info->es1  ); }
  inline bool isES2()    const { RegalAssert(info); return REGAL_SYS_ES2 && ( REGAL_FORCE_ES2_PROFILE  || info->es2  ); }
  inline bool isCore()   const { RegalAssert(info); return REGAL_SYS_GL  && ( REGAL_FORCE_CORE_PROFILE || info->core ); }
  inline bool isCompat() const { RegalAssert(info); return REGAL_SYS_GL  &&                               info->compat; }

  bool                    initialized;
  Dispatch::GL            dispatchGL;
  scoped_ptr<ContextInfo> info;
  scoped_ptr<EmuInfo>     emuInfo;

  std::vector<Layer *>    layer;

  #if REGAL_SYS_PPAPI
  PPB_OpenGLES2      *ppapiES2;
  PP_Resource         ppapiResource;
  #endif

  RegalSystemContext  sysCtx;
  Thread::Thread      thread;

  #if REGAL_SYS_X11
  Display            *x11Display;
  #endif

  #if REGAL_SYS_GLX
  GLXDrawable         x11Drawable;
  #endif

  #if REGAL_SYS_WGL
  HDC                 hdc;
  HGLRC               hglrc;
  #endif

  GLLOGPROCREGAL      logCallback;

  //
  // Regal context sharing
  //

  shared_list<RegalContext *> shareGroup;

  // Query that any of the contexts in the share
  // group are already initialized

  bool groupInitialized() const;

  // The http and perhaps other threads need to be able brief, temporary access the context.
  // parkContext() makes the calling thread release the context
  // unparkContext() makes it current to the calling thread
          
  struct ParkProcs {
    template <typename T>
    void init( T & dt ) {
      #if REGAL_SYS_OSX
        CGLSetCurrentContext       = dispatchGlobal.CGLSetCurrentContext;
      #elif REGAL_SYS_EGL
        eglMakeCurrent       = dispatchGlobal.eglMakeCurrent;
        eglMakeCurrent_layer = dispatchGlobal.eglMakeCurrent_layer;
      #elif REGAL_SYS_GLX
        glXMakeCurrent       = dispatchGlobal.glXMakeCurrent;
        glXMakeCurrent_layer = dispatchGlobal.glXMakeCurrent_layer;
      #elif REGAL_SYS_WGL
        wglMakeCurrent       = dispatchGlobal.wglMakeCurrent;
        wglMakeCurrent_layer = dispatchGlobal.wglMakeCurrent_layer;
      #else
        # error "Implement me!"
      #endif
    }
    #if REGAL_SYS_OSX
      REGALCGLSETCURRENTCONTEXTPROC CGLSetCurrentContext;
    #elif REGAL_SYS_EGL
      REGALEGLMAKECURRENTPROC eglMakeCurrent;
      Layer * eglMakeCurrent_layer;
    #elif REGAL_SYS_GLX
      REGALGLXMAKECURRENTPROC glXMakeCurrent;
      Layer * glXMakeCurrent_layer;
    #elif REGAL_SYS_WGL
      REGALWGLMAKECURRENTPROC wglMakeCurrent;
       wglMakeCurrent;
    #else
      # error "Implement me!"
    #endif
  };
  void parkContext( ParkProcs & pp );
  void unparkContext( ParkProcs & pp );


  // State tracked via EmuContextState.py / Regal.cpp

  size_t              depthBeginEnd;   // Normally zero or one
  size_t              depthPushMatrix; //
  size_t              depthPushAttrib; //
  size_t              depthNewList;    //
};

REGAL_NAMESPACE_END

#endif // __${HEADER_NAME}_H__
''')

contextSourceTemplate = Template( '''${AUTOGENERATED}
${LICENSE}

#include "pch.h" /* For MS precompiled header support */

#include "RegalUtil.h"

REGAL_GLOBAL_BEGIN

#include "RegalConfig.h"
#include "RegalContext.h"
#include "RegalEmuInfo.h"
#include "RegalContextInfo.h"


${INCLUDES}#if REGAL_EMULATION
${EMU_INCLUDES}#endif

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

using namespace Logging;

RegalContext::RegalContext()
: initialized(false),
  dispatchGL(),
  info(NULL),
${MEMBER_CONSTRUCT}#if REGAL_EMULATION
${EMU_MEMBER_CONSTRUCT}#endif
#if REGAL_SYS_PPAPI
  ppapiES2(NULL),
  ppapiResource(0),
  sysCtx(0),
#else
  sysCtx(NULL),
#endif
  thread(0),
#if REGAL_SYS_X11
  x11Display(NULL),
#endif
#if REGAL_SYS_GLX
  x11Drawable(0),
#endif
#if REGAL_SYS_WGL
  hdc(0),
  hglrc(0),
#endif
  logCallback(NULL),
  depthBeginEnd(0),
  depthPushMatrix(0),
  depthPushAttrib(0),
  depthNewList(0)
{
  Internal("RegalContext::RegalContext","()");

  shareGroup.push_back(this);
}

void
RegalContext::Init()
{
  Internal("RegalContext::Init","()");

  RegalAssert(!initialized);

  memset( &dispatchGL, 0, sizeof( Dispatch::GL ) );
            
  RegalAssert(this);
  if (!info)
  {
    info = new ContextInfo();
    RegalAssert(info);
    info->init(*this);
  }

  if (!emuInfo)
  {
    emuInfo = new EmuInfo();
    RegalAssert(emuInfo);
    emuInfo->init(*info);
  }

${MEMBER_INIT}

  initialized = true;
}

// Note that Cleanup() may or may not have been called prior to destruction
RegalContext::~RegalContext()
{
  Internal("RegalContext::~RegalContext","()");

  // Remove this context from the share group.

  shareGroup->remove(this);
}

// Called prior to deletion, if this context is still set for this thread.
// Need to:
// 1) clean up GL state we've modified
// 2) leave the RegalContext in a state where Init() could be called again
void
RegalContext::Cleanup()
{
  Internal("RegalContext::Cleanup","()");

#if REGAL_EMULATION
${EMU_MEMBER_CLEANUP}#endif

  initialized = false;
}

bool
RegalContext::groupInitialized() const
{
  Internal("RegalContext::groupInitialized","()");

  // The first context is always the first initialized context in the group.
  return shareGroup->front()->initialized;
}

void RegalContext::parkContext( RegalContext::ParkProcs & pp )
{
  #if REGAL_SYS_OSX
  RCGLSetCurrentContext( pp, NULL );
  #elif REGAL_SYS_WGL
  RwglMakeCurrent( pp, NULL, NULL );
  #elif REGAL_SYS_GLX
  RglXMakeCurrent( pp, x11Display, None, NULL );
  #else
  # error "Implement me!"
  #endif
  RegalMakeCurrent(NULL);
}

void RegalContext::unparkContext( RegalContext::ParkProcs & pp )
{
  #if REGAL_SYS_OSX
  RCGLSetCurrentContext( pp, reinterpret_cast<CGLContextObj>(sysCtx) );
  #elif REGAL_SYS_WGL
  RwglMakeCurrent( pp, hdc, hglrc );
  #elif REGAL_SYS_GLX
  RglXMakeCurrent( pp, x11Display, x11Drawable, reinterpret_cast<GLXContext>(sysCtx) );
  #else
  # error "Implement me!"
  #endif
  RegalMakeCurrent(sysCtx);
}


REGAL_NAMESPACE_END
''')

def generateContextHeader(apis, args):

    emuForwardDeclare = ''
    emuMemberDeclare  = ''

    for i in emuRegal:
      if i.get('name')!=None:
        emuForwardDeclare += 'struct %s;\n' % i['type']
        emuMemberDeclare  += '  scoped_ptr<%-18s> %s;\n' % ( i['type'], i['name'] )

    emuForwardDeclare += '#if REGAL_EMULATION\n'
    emuMemberDeclare  += '#if REGAL_EMULATION\n'

    emuMemberDeclare += '  // Fixed function emulation\n'
    emuMemberDeclare += '  int emuLevel;\n'

    for i in emu:
      if i.get('name')!=None:
        if i['type'].startswith('Emu::'):
          emuForwardDeclare += 'namespace Emu { struct %s; };\n' % i['type'][5:]
        else:
          emuForwardDeclare += 'struct %s;\n' % i['type']
        emuMemberDeclare  += '  scoped_ptr<%-18s> %s;\n' % ( i['type'], i['name'] )

    emuForwardDeclare += '#endif\n'
    emuMemberDeclare  += '#endif\n'

    # Output

    substitute = {}

    substitute['LICENSE']       = args.license
    substitute['AUTOGENERATED'] = args.generated
    substitute['COPYRIGHT']     = args.copyright

    substitute['HEADER_NAME'] = "REGAL_CONTEXT"

    outputCode( '%s/RegalContext.h' % args.srcdir, contextHeaderTemplate.substitute(substitute))

def addEmulatedExtensions(extensions, emuLayer):
    str = ''

    for extension in extensions:
      if extension.emulatedBy == emuLayer:
        emuStr = ''

        # Strip 'GL_' prefix
        name = extension.name[3:]

        emuStr += 'Info("Activating %s emulation.");\n' % name
        emuStr += 'emuInfo->gl_%s = true;\n' % name.lower()
        emuStr += 'emuInfo->extensionsSet.insert("GL_%s");\n' % name

        supportStr = '!info->gl_%s' % name.lower()
        if (len(extension.emulatedIf)):
          supportStr += ' && (%s)' % extension.emulatedIf

        str += wrapCIf(supportStr, emuStr)

    if str != '':
      str += 'emuInfo->extensions = ::print_detail::join(emuInfo->extensionsSet,std::string(" "));\n'

    return str

def generateContextSource(apis, args):

    includes           = ''
    memberConstruct    = ''
    memberInit         = ''
    memberCleanup      = ''
    emuIncludes        = ''
    emuMemberConstruct = ''
    emuMemberInit      = ''
    emuMemberCleanup   = ''
    emulatedExtensions = []
    emuEmulationEnabled = ''

    # Output

    substitute = {}

    substitute['LICENSE']       = args.license
    substitute['AUTOGENERATED'] = args.generated
    substitute['COPYRIGHT']     = args.copyright

    substitute['INCLUDES']             = includes
    substitute['MEMBER_CONSTRUCT']     = memberConstruct
    substitute['MEMBER_INIT']          = memberInit
    substitute['EMU_INCLUDES']         = emuIncludes
    substitute['EMU_MEMBER_CONSTRUCT'] = emuMemberConstruct
    substitute['EMU_MEMBER_INIT']      = emuMemberInit
    substitute['EMU_MEMBER_CLEANUP']   = emuMemberCleanup
    substitute['EMULATION_ENABLED']    = emuEmulationEnabled

    outputCode( '%s/RegalContext.cpp' % args.srcdir, contextSourceTemplate.substitute(substitute))
